const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":1539,\"nextId\":1539,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-4a54ddc6\",\"2\":\"v-4a54ddc6#背景\",\"3\":\"v-4a54ddc6#jmh-的意义\",\"4\":\"v-4a54ddc6#jmh-如何工作\",\"5\":\"v-4a54ddc6#快速开始\",\"6\":\"v-4a54ddc6#安装插件\",\"7\":\"v-4a54ddc6#使用-maven-archtype\",\"8\":\"v-4a54ddc6#引入依赖\",\"9\":\"v-4a54ddc6#编写测试代码\",\"10\":\"v-4a54ddc6#运行测试\",\"11\":\"v-4a54ddc6#查看结果\",\"12\":\"v-4a54ddc6#注释详解\",\"13\":\"v-4a54ddc6#高级用法\",\"14\":\"v-4a54ddc6#将结果图形化\",\"15\":\"v-4a54ddc6#参考资料\",\"16\":\"v-6d713d47\",\"17\":\"v-6d713d47#_2-面向对象编程\",\"18\":\"v-6d713d47#_2-1-面向对象基础\",\"19\":\"v-6d713d47#包\",\"20\":\"v-6d713d47#编译器查找类的步骤\",\"21\":\"v-6d713d47#编译和运行\",\"22\":\"v-6d713d47#内部类\",\"23\":\"v-6d713d47#classpath-和-jar\",\"24\":\"v-6d713d47#jar-包\",\"25\":\"v-6d713d47#class-版本\",\"26\":\"v-6d713d47#_2-2-java-核心类\",\"27\":\"v-6d713d47#字符串和编码\",\"28\":\"v-6d713d47#stringbuilder\",\"29\":\"v-6d713d47#stringjoiner\",\"30\":\"v-6d713d47#包装类型\",\"31\":\"v-6d713d47#枚举类\",\"32\":\"v-6d713d47#_3-异常处理\",\"33\":\"v-6d713d47#java-的异常\",\"34\":\"v-6d713d47#抛出异常\",\"35\":\"v-6d713d47#_4-反射\",\"36\":\"v-6d713d47#class-类\",\"37\":\"v-6d713d47#动态加载\",\"38\":\"v-6d713d47#访问字段\",\"39\":\"v-6d713d47#调用方法\",\"40\":\"v-6d713d47#获取继承关系\",\"41\":\"v-6d713d47#动态代理\",\"42\":\"v-6d713d47#_5-注解\",\"43\":\"v-6d713d47#定义注解\",\"44\":\"v-6d713d47#处理注解\",\"45\":\"v-6d713d47#_6-泛型\",\"46\":\"v-6d713d47#java-类型系统\",\"47\":\"v-6d713d47#编写泛型\",\"48\":\"v-6d713d47#擦拭法\",\"49\":\"v-6d713d47#extends-通配符-上界通配符\",\"50\":\"v-6d713d47#_7-集合\",\"51\":\"v-6d713d47#_8-io\",\"52\":\"v-6d713d47#file\",\"53\":\"v-6d713d47#inputstream\",\"54\":\"v-6d713d47#outputstream\",\"55\":\"v-6d713d47#filter-模式\",\"56\":\"v-6d713d47#读取-classpath-资源\",\"57\":\"v-6d713d47#reader\",\"58\":\"v-6d713d47#writer\",\"59\":\"v-6d713d47#_14-maven-基础\",\"60\":\"v-6d713d47#依赖管理\",\"61\":\"v-6d713d47#构建流程\",\"62\":\"v-6d713d47#phase\",\"63\":\"v-6d713d47#goal\",\"64\":\"v-6d713d47#使用插件\",\"65\":\"v-6d713d47#maven-wrapper\",\"66\":\"v-6d713d47#_15-网络编程\",\"67\":\"v-6d713d47#网络编程基础\",\"68\":\"v-6d713d47#tcp-编程\",\"69\":\"v-6d713d47#服务器端\",\"70\":\"v-6d713d47#客户端\",\"71\":\"v-6d713d47#udp-编程\",\"72\":\"v-6d713d47#服务器端-1\",\"73\":\"v-6d713d47#客户端-1\",\"74\":\"v-6d713d47#_18-函数式编程\",\"75\":\"v-6d713d47#lambda-基础\",\"76\":\"v-6d713d47#方法引用\",\"77\":\"v-6d713d47#_20-web-开发\",\"78\":\"v-6d713d47#servlet-入门\",\"79\":\"v-6d713d47#_21-spring-开发\",\"80\":\"v-6d713d47#_21-1-ioc-容器\",\"81\":\"v-6d713d47#ioc-原理\",\"82\":\"v-6d713d47#定制-bean\",\"83\":\"v-6d713d47#使用-resource\",\"84\":\"v-6d713d47#使用条件装配\",\"85\":\"v-6d713d47#_21-2-使用-aop\",\"86\":\"v-6d713d47#_21-3-访问数据库\",\"87\":\"v-6d713d47#使用声明式事务\",\"88\":\"v-6d713d47#集成-hibernate\",\"89\":\"v-6d713d47#初始化\",\"90\":\"v-6d713d47#设置映射关系\",\"91\":\"v-6d713d47#基本操作\",\"92\":\"v-6d713d47#使用高级查询-hql\",\"93\":\"v-6d713d47#_21-4-开发-web-应用\",\"94\":\"v-6d713d47#_22-spring-boot-开发\",\"95\":\"v-6d713d47#使用开发者工具\",\"96\":\"v-e6ca9d74\",\"97\":\"v-e6ca9d74#difference-between-doreturn-and-when\",\"98\":\"v-e6ca9d74#difference-between-mock-and-injectmocks\",\"99\":\"v-e6ca9d74#mock-singleton\",\"100\":\"v-e6ca9d74#mocking-exception-throwing\",\"101\":\"v-e6ca9d74#non-void-return-type\",\"102\":\"v-e6ca9d74#void-return-type\",\"103\":\"v-e6ca9d74#checked-exception\",\"104\":\"v-e6ca9d74#mocking-static-methods\",\"105\":\"v-e6ca9d74#no-argument-static-method\",\"106\":\"v-e6ca9d74#static-method-with-arguments\",\"107\":\"v-d3ab1200\",\"108\":\"v-d3ab1200#_1-背景\",\"109\":\"v-d3ab1200#_1-1-reactor-模式是什么\",\"110\":\"v-d3ab1200#_1-2-本文内容\",\"111\":\"v-d3ab1200#_2-传统服务端设计模式-bio\",\"112\":\"v-d3ab1200#_2-1-bio-服务端\",\"113\":\"v-d3ab1200#_2-2-bio-handler\",\"114\":\"v-d3ab1200#_2-3-缺陷\",\"115\":\"v-d3ab1200#_3-优化思路\",\"116\":\"v-d3ab1200#_3-1-分而治之\",\"117\":\"v-d3ab1200#_3-2-事件驱动\",\"118\":\"v-d3ab1200#_4-前置知识-java-nio-包\",\"119\":\"v-d3ab1200#_5-单线程-reactor\",\"120\":\"v-d3ab1200#_5-1-设计\",\"121\":\"v-d3ab1200#_5-2-reactor-线程初始化\",\"122\":\"v-d3ab1200#_5-3-reactor-线程主循环\",\"123\":\"v-d3ab1200#_5-4-acceptor-请求分发\",\"124\":\"v-d3ab1200#_5-5-handler-初始化\",\"125\":\"v-d3ab1200#_5-6-handler-执行-i-o-操作和业务处理\",\"126\":\"v-d3ab1200#_5-7-单线程-reactor-启动\",\"127\":\"v-d3ab1200#_6-单-reactor-多线程\",\"128\":\"v-d3ab1200#_6-1-handler-使用线程池\",\"129\":\"v-d3ab1200#_6-2-多线程-reactor-启动\",\"130\":\"v-d3ab1200#_7-主从-reactor-多线程\",\"131\":\"v-d3ab1200#_7-1-引入-reactorgroup\",\"132\":\"v-d3ab1200#_7-1-reactor-类实现\",\"133\":\"v-d3ab1200#_7-2-主从-reactor-启动类\",\"134\":\"v-d3ab1200#_7-3-主从-reactor-启动\",\"135\":\"v-d3ab1200#_8-netty-中的-reactor-模式\",\"136\":\"v-d3ab1200#参考资料\",\"137\":\"v-4b50507b\",\"138\":\"v-14c69af4\",\"139\":\"v-4c82ca0d\",\"140\":\"v-4c82ca0d#vim模式\",\"141\":\"v-4c82ca0d#normal普通模式\",\"142\":\"v-4c82ca0d#insert插入模式\",\"143\":\"v-4c82ca0d#command命令模式\",\"144\":\"v-4c82ca0d#visual可视模式\",\"145\":\"v-4c82ca0d#快速移动\",\"146\":\"v-4c82ca0d#快速增删改查\",\"147\":\"v-4c82ca0d#快速删除\",\"148\":\"v-4c82ca0d#快速修改\",\"149\":\"v-4c82ca0d#快速查询\",\"150\":\"v-4c82ca0d#正则搜索替换\",\"151\":\"v-4c82ca0d#多文件操作\",\"152\":\"v-4c82ca0d#buffer缓冲区\",\"153\":\"v-4c82ca0d#window窗口\",\"154\":\"v-4c82ca0d#tab标签页-将窗口分组\",\"155\":\"v-4c82ca0d#vim的text-object\",\"156\":\"v-4c82ca0d#vim复制粘贴与寄存器\",\"157\":\"v-4c82ca0d#vim寄存器\",\"158\":\"v-4c82ca0d#常见寄存器\",\"159\":\"v-4c82ca0d#vim宏-macro\",\"160\":\"v-4c82ca0d#录制和回放宏\",\"161\":\"v-4c82ca0d#将宏应用到多行-在command模式下执行normal模式命令\",\"162\":\"v-4c82ca0d#vim补全\",\"163\":\"v-4c82ca0d#更换配色\",\"164\":\"v-4c82ca0d#插件\",\"165\":\"v-4c82ca0d#安装插件管理器\",\"166\":\"v-4c82ca0d#插件网站\",\"167\":\"v-4c82ca0d#快速跳转插件\",\"168\":\"v-7d9c1103\",\"169\":\"v-7d9c1103#顺序编程\",\"170\":\"v-7d9c1103#基本概念\",\"171\":\"v-7d9c1103#erlang-shell\",\"172\":\"v-7d9c1103#整数运算\",\"173\":\"v-7d9c1103#变量\",\"174\":\"v-7d9c1103#浮点数\",\"175\":\"v-7d9c1103#原子\",\"176\":\"v-7d9c1103#元组\",\"177\":\"v-7d9c1103#列表\",\"178\":\"v-7d9c1103#字符串\",\"179\":\"v-7d9c1103#模块与函数\",\"180\":\"v-7d9c1103#模块-module\",\"181\":\"v-7d9c1103#高阶函数-fun\",\"182\":\"v-7d9c1103#实现-for\",\"183\":\"v-7d9c1103#列表处理-sum、map\",\"184\":\"v-7d9c1103#列表推导-f-x-x-l\",\"185\":\"v-7d9c1103#内置函数\",\"186\":\"v-7d9c1103#关卡-when\",\"187\":\"v-7d9c1103#case-表达式\",\"188\":\"v-7d9c1103#if-表达式\",\"189\":\"v-7d9c1103#归集器\",\"190\":\"v-7d9c1103#记录-record-与映射组-map\",\"191\":\"v-7d9c1103#record\",\"192\":\"v-7d9c1103#map\",\"193\":\"v-7d9c1103#顺序程序的错误处理\",\"194\":\"v-7d9c1103#用-try-catch-捕获异常\",\"195\":\"v-7d9c1103#用-catch-捕捉异常错误\",\"196\":\"v-7d9c1103#针对异常的编程样式\",\"197\":\"v-7d9c1103#栈跟踪-erlang-get-stacktrace\",\"198\":\"v-7d9c1103#二进制型与位语法\",\"199\":\"v-7d9c1103#顺序编程补遗\",\"200\":\"v-7d9c1103#apply\",\"201\":\"v-7d9c1103#算数表达式\",\"202\":\"v-7d9c1103#属性\",\"203\":\"v-7d9c1103#预定义模块属性\",\"204\":\"v-7d9c1103#用户定义的模块属性\",\"205\":\"v-7d9c1103#块表达式\",\"206\":\"v-7d9c1103#布尔值-布尔表达式\",\"207\":\"v-7d9c1103#动态代码载入\",\"208\":\"v-7d9c1103#预处理器\",\"209\":\"v-7d9c1103#转义序列\",\"210\":\"v-7d9c1103#函数引用\",\"211\":\"v-7d9c1103#包含文件\",\"212\":\"v-7d9c1103#列表操作-、\",\"213\":\"v-7d9c1103#宏-define\",\"214\":\"v-7d9c1103#宏控制流\",\"215\":\"v-7d9c1103#数字\",\"216\":\"v-7d9c1103#操作符优先级\",\"217\":\"v-7d9c1103#进程字典\",\"218\":\"v-7d9c1103#引用\",\"219\":\"v-7d9c1103#短路布尔表达式\",\"220\":\"v-7d9c1103#比较数据类型\",\"221\":\"v-7d9c1103#类型\",\"222\":\"v-7d9c1103#编译和运行程序\",\"223\":\"v-7d9c1103#改变开发环境\",\"224\":\"v-7d9c1103#运行程序的不同方式\",\"225\":\"v-7d9c1103#makefile-使编译自动化\",\"226\":\"v-7d9c1103#并发和分布式程序\",\"227\":\"v-7d9c1103#现实世界中的并发\",\"228\":\"v-7d9c1103#并发编程\",\"229\":\"v-7d9c1103#基本并发函数\",\"230\":\"v-7d9c1103#客户端-服务器\",\"231\":\"v-7d9c1103#进程很轻巧\",\"232\":\"v-7d9c1103#带超时的接收\",\"233\":\"v-7d9c1103#选择性接收\",\"234\":\"v-7d9c1103#注册进程\",\"235\":\"v-7d9c1103#尾递归的说明\",\"236\":\"v-7d9c1103#分布式编程\",\"237\":\"v-7d9c1103#两种分布式模型\",\"238\":\"v-7d9c1103#编写一个分布式程序\",\"239\":\"v-7d9c1103#编程库与框架\",\"240\":\"v-7d9c1103#接口技术\",\"241\":\"v-7d9c1103#erlang-如何与外部程序通信\",\"242\":\"v-7d9c1103#用端口建立外部-c-程序接口\",\"243\":\"v-7d9c1103#在-erlang-里调用-shell-脚本\",\"244\":\"v-7d9c1103#文件编程\",\"245\":\"v-7d9c1103#套接字编程\",\"246\":\"v-7d9c1103#用-websocket-和-erlang-进行浏览\",\"247\":\"v-7d9c1103#用-ets-和-dets-存储数据\",\"248\":\"v-7d9c1103#表的类型\",\"249\":\"v-7d9c1103#影响-ets-表效率的因素\",\"250\":\"v-7d9c1103#保存元组到磁盘\",\"251\":\"v-7d9c1103#mnesia-erlang-数据库\",\"252\":\"v-7d9c1103#创建初始数据库\",\"253\":\"v-7d9c1103#数据库查询\",\"254\":\"v-7d9c1103#性能分析、调试与跟踪\",\"255\":\"v-7d9c1103#erlang-代码的性能分析工具\",\"256\":\"v-7d9c1103#运行时诊断\",\"257\":\"v-7d9c1103#调试方法\",\"258\":\"v-7d9c1103#io-format-调试\",\"259\":\"v-7d9c1103#转储至文件\",\"260\":\"v-7d9c1103#erlang-调试器\",\"261\":\"v-7d9c1103#跟踪消息与进程执行\",\"262\":\"v-7d9c1103#otp-介绍\",\"263\":\"v-a4b6ad84\",\"264\":\"v-a4b6ad84#arthas-idea-plugin-文档\",\"265\":\"v-a4b6ad84#执行静态方法和-spring-对象方法\",\"266\":\"v-a4b6ad84#spring\",\"267\":\"v-a4b6ad84#直接执行静态方法\",\"268\":\"v-a4b6ad84#使用arthas显式执行代码-避免重启应用-10倍提升本地研发效率\",\"269\":\"v-a4b6ad84#前提\",\"270\":\"v-a4b6ad84#谁拖垮了效率\",\"271\":\"v-a4b6ad84#探索\",\"272\":\"v-a4b6ad84#准备工作\",\"273\":\"v-a4b6ad84#开始起飞\",\"274\":\"v-a4b6ad84#ognl-使用姿势\",\"275\":\"v-85577f20\",\"276\":\"v-85577f20#背景\",\"277\":\"v-85577f20#良药虽好-但也有局限\",\"278\":\"v-85577f20#openchaos-需要解决的本质问题\",\"279\":\"v-85577f20#架构与案例分析\",\"280\":\"v-85577f20#整体架构\",\"281\":\"v-85577f20#检测模型与度量模型\",\"282\":\"v-85577f20#检测模型\",\"283\":\"v-85577f20#度量模型\",\"284\":\"v-85577f20#可靠性案例分析\",\"285\":\"v-85577f20#弹性案例分析\",\"286\":\"v-85577f20#未来规划\",\"287\":\"v-2ccceafc\",\"288\":\"v-2ccceafc#背景\",\"289\":\"v-2ccceafc#显示换行符\",\"290\":\"v-2ccceafc#去除-cr\",\"291\":\"v-7316e482\",\"292\":\"v-7316e482#_1-快速入门\",\"293\":\"v-7316e482#_1-2-数据类型和变量\",\"294\":\"v-7316e482#_1-2-1-数据类型\",\"295\":\"v-7316e482#_1-2-2-比较运算符\",\"296\":\"v-7316e482#_1-2-3-strict-模式\",\"297\":\"v-7316e482#_1-3-字符串\",\"298\":\"v-7316e482#_1-4-数组\",\"299\":\"v-7316e482#_1-5-对象\",\"300\":\"v-7316e482#_1-8-map-和-set\",\"301\":\"v-7316e482#_1-8-1-map\",\"302\":\"v-7316e482#_1-8-2-set\",\"303\":\"v-7316e482#_1-9-iterable\",\"304\":\"v-7316e482#_2-函数\",\"305\":\"v-7316e482#_2-1-函数定义和调用\",\"306\":\"v-7316e482#_2-1-1-函数定义\",\"307\":\"v-7316e482#_2-1-2-调用函数\",\"308\":\"v-7316e482#arguments\",\"309\":\"v-7316e482#rest\",\"310\":\"v-7316e482#_2-2-变量作用域与解构赋值\",\"311\":\"v-7316e482#_2-2-1-变量提升\",\"312\":\"v-7316e482#_2-2-2-全局作用域\",\"313\":\"v-7316e482#_2-2-3-名字空间\",\"314\":\"v-7316e482#_2-2-4-局部作用域\",\"315\":\"v-7316e482#_2-2-5-常量\",\"316\":\"v-7316e482#_2-2-6-解构赋值\",\"317\":\"v-7316e482#_2-3-方法\",\"318\":\"v-7316e482#_2-3-1-apply\",\"319\":\"v-7316e482#call\",\"320\":\"v-7316e482#_2-3-2-装饰器\",\"321\":\"v-7316e482#_2-4-高阶函数\",\"322\":\"v-7316e482#_2-4-1-map-reduce\",\"323\":\"v-7316e482#map\",\"324\":\"v-7316e482#reduce\",\"325\":\"v-7316e482#_2-4-2-filter\",\"326\":\"v-7316e482#_2-4-3-sort\",\"327\":\"v-7316e482#_2-4-4-array\",\"328\":\"v-7316e482#_2-5-闭包\",\"329\":\"v-7316e482#_2-5-1-函数作为返回值\",\"330\":\"v-7316e482#_2-5-2-闭包\",\"331\":\"v-7316e482#_2-6-箭头函数\",\"332\":\"v-7316e482#_2-7-generator\",\"333\":\"v-7316e482#_3-标准对象\",\"334\":\"v-7316e482#_3-1-date\",\"335\":\"v-7316e482#_3-2-regexp\",\"336\":\"v-7316e482#_3-3-json\",\"337\":\"v-7316e482#_3-3-1-序列化\",\"338\":\"v-7316e482#_3-3-2-反序列化\",\"339\":\"v-7316e482#_4-面向对象编程\",\"340\":\"v-7316e482#_4-1-创建对象\",\"341\":\"v-7316e482#_4-1-2-构造函数\",\"342\":\"v-7316e482#_4-2-原型继承\",\"343\":\"v-7316e482#_4-3-class-继承\",\"344\":\"v-7316e482#_4-3-1-class-定义\",\"345\":\"v-7316e482#_4-3-2-class-继承\",\"346\":\"v-7316e482#_5-浏览器\",\"347\":\"v-7316e482#_5-5-ajax\",\"348\":\"v-7316e482#_5-5-1-xmlhttprequest-对象\",\"349\":\"v-7316e482#_5-5-2-fetch-api\",\"350\":\"v-7316e482#_5-5-3-安全限制\",\"351\":\"v-7316e482#_5-6-promise\",\"352\":\"v-7316e482#_5-6-1-并行执行多个任务-promise-all\",\"353\":\"v-7316e482#_5-6-2-并行执行并只获得先返回的结果-promise-race\",\"354\":\"v-7316e482#_5-7-async-函数\",\"355\":\"v-7316e482#_6-错误处理\",\"356\":\"v-7316e482#_6-1-错误类型\",\"357\":\"v-7316e482#_6-2-抛出错误\",\"358\":\"v-7316e482#_6-3-错误传播\",\"359\":\"v-7316e482#_6-4-异步错误处理\",\"360\":\"v-7316e482#_9-node-js\",\"361\":\"v-7316e482#_9-1-模块\",\"362\":\"v-7316e482#_9-1-1-commonjs-规范\",\"363\":\"v-7316e482#模块路径搜索\",\"364\":\"v-7316e482#_9-1-2-模块的实现原理\",\"365\":\"v-7316e482#_9-1-3-module-exports-vs-exports\",\"366\":\"v-7316e482#_9-2-基本模块\",\"367\":\"v-7316e482#_9-3-web-开发\",\"368\":\"v-7316e482#_9-3-4-websocket\",\"369\":\"v-7316e482#使用-ws\",\"370\":\"v-6cfe8891\",\"371\":\"v-6cfe8891#_1-为什么选择powerjob\",\"372\":\"v-6cfe8891#_2-架构解析\",\"373\":\"v-6cfe8891#_3-关键流程解析\",\"374\":\"v-6cfe8891#_3-1-server初始化流程\",\"375\":\"v-6cfe8891#_3-2-worker初始化流程\",\"376\":\"v-6cfe8891#_3-3-创建job\",\"377\":\"v-6cfe8891#_4-源码解析\",\"378\":\"v-6cfe8891#_4-1-mapreduce动态分片\",\"379\":\"v-6cfe8891#_4-2-时间轮\",\"380\":\"v-6cfe8891#_4-3-无锁化设计和高可用的关键-分组隔离机制\",\"381\":\"v-6cfe8891#参考文献\",\"382\":\"v-78f525a3\",\"383\":\"v-78f525a3#_1-背景\",\"384\":\"v-78f525a3#_1-1-使用场景\",\"385\":\"v-78f525a3#_1-1-什么是一致性哈希算法\",\"386\":\"v-78f525a3#_2-概要设计\",\"387\":\"v-78f525a3#_2-1-哈希环\",\"388\":\"v-78f525a3#_2-2-不均衡问题和虚拟节点\",\"389\":\"v-78f525a3#_3-详细设计\",\"390\":\"v-78f525a3#_3-1-哈希算法\",\"391\":\"v-78f525a3#_3-2-哈希环\",\"392\":\"v-78f525a3#_3-3-添加和删除节点\",\"393\":\"v-78f525a3#_3-3-1-添加节点\",\"394\":\"v-78f525a3#_3-3-2-删除节点\",\"395\":\"v-78f525a3#_3-4-路由\",\"396\":\"v-78f525a3#_4-java-实现\",\"397\":\"v-78f525a3#参考资料\",\"398\":\"v-4a014bf9\",\"399\":\"v-4a014bf9#译者序\",\"400\":\"v-4a014bf9#_1-概述\",\"401\":\"v-4a014bf9#_2-英雄天赋\",\"402\":\"v-4a014bf9#_3-天赋\",\"403\":\"v-4a014bf9#_3-1-什么时候用这套天赋\",\"404\":\"v-4a014bf9#_3-2-了解会影响手法的天赋\",\"405\":\"v-4a014bf9#_3-2-1-专精天赋\",\"406\":\"v-4a014bf9#_3-2-2-职业天赋\",\"407\":\"v-4a014bf9#_3-2-3-英雄天赋\",\"408\":\"v-4a014bf9#_4-技能循环\",\"409\":\"v-4a014bf9#_4-1-套装效果\",\"410\":\"v-4a014bf9#_4-2-技能优先级\",\"411\":\"v-4a014bf9#_4-2-1-治疗\",\"412\":\"v-4a014bf9#_4-2-2-输出\",\"413\":\"v-4a014bf9#_4-3-手牌\",\"414\":\"v-4a014bf9#_5-深入理解\",\"415\":\"v-4a014bf9#_5-1-最大化生命绽放的效果\",\"416\":\"v-4a014bf9#_5-2-最大化百花齐放的效果\",\"417\":\"v-4a014bf9#_5-3-最大化野性之心效果\",\"418\":\"v-4a014bf9#_5-4-理解游戏机制\",\"419\":\"v-4a014bf9#_5-4-1-无损补-hot-dot\",\"420\":\"v-4a014bf9#_5-4-2-施法排队窗口\",\"421\":\"v-4a014bf9#_5-4-3-次要属性收益递减\",\"422\":\"v-4a014bf9#_6-副本\",\"423\":\"v-4a014bf9#_6-1-艾拉-卡拉-回响之城\",\"424\":\"v-4a014bf9#_6-1-1-boss\",\"425\":\"v-4a014bf9#阿瓦诺克斯\",\"426\":\"v-4a014bf9#阿奴布泽克特\",\"427\":\"v-4a014bf9#收割者卡吉尔\",\"428\":\"v-4a014bf9#_6-1-2-小怪\",\"429\":\"v-4a014bf9#_6-2-千丝之城\",\"430\":\"v-4a014bf9#_6-2-1-boss\",\"431\":\"v-4a014bf9#演说者基克斯威兹克\",\"432\":\"v-4a014bf9#女王之牙\",\"433\":\"v-4a014bf9#凝结聚合体\",\"434\":\"v-4a014bf9#大捻接师艾佐\",\"435\":\"v-4a014bf9#_6-2-2-小怪\",\"436\":\"v-4a014bf9#_6-3-矶石宝库\",\"437\":\"v-4a014bf9#_6-3-1-boss\",\"438\":\"v-4a014bf9#e-d-n-a\",\"439\":\"v-4a014bf9#斯卡莫拉克\",\"440\":\"v-4a014bf9#代言人布洛克-多利塔\",\"441\":\"v-4a014bf9#虚空代言人艾里克\",\"442\":\"v-4a014bf9#_6-3-2-小怪\",\"443\":\"v-4a014bf9#_6-4-破晨号\",\"444\":\"v-4a014bf9#_6-4-1-boss\",\"445\":\"v-4a014bf9#代言人夏多克朗\",\"446\":\"v-4a014bf9#阿努布伊卡基\",\"447\":\"v-4a014bf9#拉夏南\",\"448\":\"v-4a014bf9#_6-4-2-小怪\",\"449\":\"v-4a014bf9#_6-5-仙林\",\"450\":\"v-4a014bf9#_6-5-1-boss\",\"451\":\"v-4a014bf9#英格拉·马洛克\",\"452\":\"v-4a014bf9#唤雾者\",\"453\":\"v-4a014bf9#特雷德奥瓦\",\"454\":\"v-4a014bf9#_6-5-2-小怪\",\"455\":\"v-4a014bf9#_6-6-通灵战潮\",\"456\":\"v-4a014bf9#_6-6-1-boss\",\"457\":\"v-4a014bf9#凋骨\",\"458\":\"v-4a014bf9#阿玛厄斯\",\"459\":\"v-4a014bf9#外科医生缝肉\",\"460\":\"v-4a014bf9#缚霜者纳尔佐\",\"461\":\"v-4a014bf9#_6-6-2-小怪\",\"462\":\"v-4a014bf9#_6-7-围攻伯拉勒斯\",\"463\":\"v-4a014bf9#_6-7-1-boss\",\"464\":\"v-4a014bf9#屠夫-血钩\",\"465\":\"v-4a014bf9#恐怖船长洛克伍德\",\"466\":\"v-4a014bf9#哈达尔·黑渊\",\"467\":\"v-4a014bf9#维克戈斯\",\"468\":\"v-4a014bf9#_6-7-2-小怪\",\"469\":\"v-4a014bf9#_6-8-格瑞姆巴托\",\"470\":\"v-4a014bf9#_6-8-1-boss\",\"471\":\"v-4a014bf9#乌比斯将军\",\"472\":\"v-4a014bf9#铸炉之主索朗格斯\",\"473\":\"v-4a014bf9#达加·燃影者\",\"474\":\"v-4a014bf9#埃鲁达克\",\"475\":\"v-4a014bf9#_6-8-2-小怪\",\"476\":\"v-4a014bf9#_7-属性优先级\",\"477\":\"v-4a014bf9#_7-1-三级属性\",\"478\":\"v-4a014bf9#_8-装备\",\"479\":\"v-4a014bf9#_8-1-毕业装备\",\"480\":\"v-4a014bf9#_8-2-大米获取的替代品-无制造业、团本\",\"481\":\"v-4a014bf9#_8-3-饰品\",\"482\":\"v-4a014bf9#_8-3-1-主动饰品备选\",\"483\":\"v-4a014bf9#_8-3-2-被动饰品备选\",\"484\":\"v-4a014bf9#_8-4-美化\",\"485\":\"v-4a014bf9#_9-消耗品\",\"486\":\"v-4a014bf9#_9-1-附魔\",\"487\":\"v-4a014bf9#_10-种族\",\"488\":\"v-4a014bf9#_11-宏\",\"489\":\"v-4a014bf9#_11-1-鼠标指向宏\",\"490\":\"v-4a014bf9#_11-2-其他推荐的宏\",\"491\":\"v-4a014bf9#_12-插件\",\"492\":\"v-4a014bf9#_13-常见问题\",\"493\":\"v-87aad0c6\",\"494\":\"v-87aad0c6#_1-简介\",\"495\":\"v-87aad0c6#_1-3-动态类型与静态类型\",\"496\":\"v-87aad0c6#_2-基本用法\",\"497\":\"v-87aad0c6#_2-3-typescript-的编译\",\"498\":\"v-87aad0c6#_2-6-tsc-编译器\",\"499\":\"v-87aad0c6#_2-6-5-tsconfig-json\",\"500\":\"v-87aad0c6#_2-7-ts-node-模块\",\"501\":\"v-87aad0c6#_3-any-类型-unknown-类型-never-类型\",\"502\":\"v-87aad0c6#_3-1-any-类型\",\"503\":\"v-87aad0c6#_3-2-unknown-类型\",\"504\":\"v-87aad0c6#_3-3-never-类型\",\"505\":\"v-87aad0c6#_4-类型系统\",\"506\":\"v-87aad0c6#_4-1-基本类型\",\"507\":\"v-87aad0c6#_4-2-包装对象类型\",\"508\":\"v-87aad0c6#_4-2-1-包装对象的概念\",\"509\":\"v-87aad0c6#_4-2-2-包装对象类型与字面量类型\",\"510\":\"v-87aad0c6#_4-3-object-类型与-object-类型\",\"511\":\"v-87aad0c6#_4-3-1-object-类型\",\"512\":\"v-87aad0c6#_4-3-2-object-类型\",\"513\":\"v-87aad0c6#_4-4-undefined-和-null-的特殊性\",\"514\":\"v-87aad0c6#_4-5-值类型\",\"515\":\"v-87aad0c6#_4-6-联合类型\",\"516\":\"v-87aad0c6#_4-7-交叉类型\",\"517\":\"v-87aad0c6#_4-8-type-命令\",\"518\":\"v-87aad0c6#_4-9-typeof-运算符\",\"519\":\"v-87aad0c6#_4-10-块级类型声明\",\"520\":\"v-87aad0c6#_4-11-类型的兼容\",\"521\":\"v-87aad0c6#_5-数组\",\"522\":\"v-87aad0c6#_5-1-简介\",\"523\":\"v-87aad0c6#_5-2-数组的类型推断\",\"524\":\"v-87aad0c6#_5-3-只读数组-const-断言\",\"525\":\"v-87aad0c6#_5-4-多维数组\",\"526\":\"v-87aad0c6#_6-元组\",\"527\":\"v-87aad0c6#_6-1-简介\",\"528\":\"v-87aad0c6#_6-2-只读元组\",\"529\":\"v-87aad0c6#_6-4-扩展运算符\",\"530\":\"v-87aad0c6#_7-symbol-类型\",\"531\":\"v-87aad0c6#_7-1-简介\",\"532\":\"v-87aad0c6#_8-函数\",\"533\":\"v-87aad0c6#_8-1-简介\",\"534\":\"v-87aad0c6#_8-2-function-类型\",\"535\":\"v-87aad0c6#_8-3-箭头函数\",\"536\":\"v-87aad0c6#_8-4-可选参数\",\"537\":\"v-87aad0c6#_8-5-参数默认值\",\"538\":\"v-87aad0c6#_8-6-参数解构\",\"539\":\"v-87aad0c6#_8-7-rest-参数\",\"540\":\"v-87aad0c6#_8-8-readonly-只读参数\",\"541\":\"v-87aad0c6#_8-9-void-类型\",\"542\":\"v-87aad0c6#_8-10-never-类型\",\"543\":\"v-87aad0c6#抛出错误的函数\",\"544\":\"v-87aad0c6#无限执行的函数\",\"545\":\"v-87aad0c6#_8-11-局部类型\",\"546\":\"v-87aad0c6#_8-12-高阶函数\",\"547\":\"v-87aad0c6#_8-13-函数重载\",\"548\":\"v-87aad0c6#_8-14-构造函数\",\"549\":\"v-87aad0c6#_9-对象\",\"550\":\"v-87aad0c6#_9-1-简介\",\"551\":\"v-87aad0c6#_9-2-可选属性\",\"552\":\"v-87aad0c6#_9-3-只读属性\",\"553\":\"v-87aad0c6#_9-4-属性名的索引类型\",\"554\":\"v-87aad0c6#_9-5-解构赋值\",\"555\":\"v-87aad0c6#_9-7-严格字面量检查\",\"556\":\"v-87aad0c6#_9-9-空对象\",\"557\":\"v-87aad0c6#_10-interface\",\"558\":\"v-87aad0c6#_10-1-简介\",\"559\":\"v-87aad0c6#_10-2-interface-的继承\",\"560\":\"v-87aad0c6#_10-2-1-interface-继承-interface\",\"561\":\"v-87aad0c6#_10-2-2-interface-继承-type\",\"562\":\"v-87aad0c6#_10-2-3-interface-继承-class\",\"563\":\"v-87aad0c6#_10-3-接口合并\",\"564\":\"v-87aad0c6#_10-4-interface-与-type-的异同\",\"565\":\"v-87aad0c6#_11-类\",\"566\":\"v-87aad0c6#_11-1-简介\",\"567\":\"v-87aad0c6#_11-1-4-存取器方法\",\"568\":\"v-87aad0c6#_11-1-5-属性索引\",\"569\":\"v-87aad0c6#_11-2-类的-interface-接口\",\"570\":\"v-87aad0c6#_11-2-1-implements-关键字\",\"571\":\"v-87aad0c6#_11-2-2-实现多个接口\",\"572\":\"v-87aad0c6#_11-3-class-类型\",\"573\":\"v-87aad0c6#_11-3-1-实例类型\",\"574\":\"v-87aad0c6#_11-3-2-类的自身类型\",\"575\":\"v-87aad0c6#_11-5-可访问性修饰符\",\"576\":\"v-87aad0c6#_11-5-4-实例属性的简写形式\",\"577\":\"v-87aad0c6#_11-6-静态成员\",\"578\":\"v-87aad0c6#_11-7-泛型类\",\"579\":\"v-87aad0c6#_11-8-抽象类-抽象成员\",\"580\":\"v-87aad0c6#_11-9-this-问题\",\"581\":\"v-87aad0c6#_13-enum-类型\",\"582\":\"v-87aad0c6#_13-1-简介\",\"583\":\"v-87aad0c6#_13-2-enum-成员的值\",\"584\":\"v-87aad0c6#_13-3-同名-enum-的合并\",\"585\":\"v-87aad0c6#_13-4-字符串-enum\",\"586\":\"v-87aad0c6#_13-5-keyof-运算符\",\"587\":\"v-87aad0c6#_13-6-反向映射\",\"588\":\"v-87aad0c6#_14-类型断言\",\"589\":\"v-87aad0c6#_14-1-简介\",\"590\":\"v-87aad0c6#_15-模块\",\"591\":\"v-87aad0c6#_15-1-简介\",\"592\":\"v-87aad0c6#_15-2-import-type-语句\",\"593\":\"v-87aad0c6#_15-3-importsnotusedasvalues-编译设置\",\"594\":\"v-87aad0c6#_15-4-commonjs-模块\",\"595\":\"v-87aad0c6#_15-4-1-import-语句\",\"596\":\"v-87aad0c6#_15-4-2-export-语句\",\"597\":\"v-87aad0c6#_15-5-模块定位\",\"598\":\"v-87aad0c6#_15-5-1-相对模块-非相对模块\",\"599\":\"v-87aad0c6#_15-5-2-classic-方法\",\"600\":\"v-87aad0c6#_15-5-3-node-方法\",\"601\":\"v-87aad0c6#_15-5-4-路径映射\",\"602\":\"v-87aad0c6#_15-5-5-tsc-的-traceresolution-参数\",\"603\":\"v-87aad0c6#_15-5-6-tsc-的-noresolve-参数\",\"604\":\"v-87aad0c6#_17-装饰器\",\"605\":\"v-87aad0c6#_17-1-简介\",\"606\":\"v-87aad0c6#_17-3-装饰器的结构\",\"607\":\"v-87aad0c6#_17-4-类装饰器\",\"608\":\"v-e4cb1150\",\"609\":\"v-9b222838\",\"610\":\"v-9b222838#_1-概述\",\"611\":\"v-9b222838#_1-1-为什么要流控\",\"612\":\"v-9b222838#_1-2-rabbitmq-的多种流控机制\",\"613\":\"v-9b222838#_1-2-1-全局流控-内存高水位、磁盘低水位\",\"614\":\"v-9b222838#_1-2-2-进程内流控\",\"615\":\"v-9b222838#_1-2-3-发送方确认\",\"616\":\"v-9b222838#_1-2-4-消费者预取\",\"617\":\"v-9b222838#_2-概要流程\",\"618\":\"v-9b222838#_2-1-信用证配置\",\"619\":\"v-9b222838#_2-2-基于信用证的流控\",\"620\":\"v-9b222838#_3-详细流程\",\"621\":\"v-9b222838#_3-1-流控详细流程\",\"622\":\"v-9b222838#_3-2-如何识别性能瓶颈\",\"623\":\"v-9b222838#_4-源码解析\",\"624\":\"v-9b222838#_4-1-处理消息-减少信用\",\"625\":\"v-9b222838#_4-2-进程阻塞-停止接收信息\",\"626\":\"v-9b222838#_4-3-增加信用值\",\"627\":\"v-9b222838#_4-4-进程解除阻塞\",\"628\":\"v-9b222838#_5-参考资料\",\"629\":\"v-ecdc3a4e\",\"630\":\"v-ecdc3a4e#概述\",\"631\":\"v-ecdc3a4e#使用场景\",\"632\":\"v-ecdc3a4e#federation-种类\",\"633\":\"v-ecdc3a4e#exchange-federation\",\"634\":\"v-ecdc3a4e#queue-federation\",\"635\":\"v-ecdc3a4e#使用前提\",\"636\":\"v-ecdc3a4e#federation-exchange-使用\",\"637\":\"v-ecdc3a4e#upstream-上游集群配置\",\"638\":\"v-ecdc3a4e#downstream-下游集群配置\",\"639\":\"v-ecdc3a4e#测试\",\"640\":\"v-ecdc3a4e#参考资料\",\"641\":\"v-52d766da\",\"642\":\"v-52d766da#_1-erlang-22-x-安装\",\"643\":\"v-52d766da#_1-1-deb-安装包安装\",\"644\":\"v-52d766da#_1-2-apt-安装\",\"645\":\"v-52d766da#_2-安装-rabbitmq\",\"646\":\"v-52d766da#_3-rabbitmq-卸载\",\"647\":\"v-44cd04de\",\"648\":\"v-44cd04de#_1-背景\",\"649\":\"v-44cd04de#_2-镜像队列概述\",\"650\":\"v-44cd04de#_3-使用方法和注意事项\",\"651\":\"v-44cd04de#_3-1-配置方法\",\"652\":\"v-44cd04de#_3-1-1-管理界面配置\",\"653\":\"v-44cd04de#_3-1-2-命令行\",\"654\":\"v-44cd04de#_3-1-3-http-api\",\"655\":\"v-44cd04de#_3-2-镜像队列配置观测\",\"656\":\"v-44cd04de#_3-3-配置参数\",\"657\":\"v-44cd04de#_3-3-1-镜像策略\",\"658\":\"v-44cd04de#_3-3-2-新镜像同步策略\",\"659\":\"v-44cd04de#_3-3-3-从节点晋升策略\",\"660\":\"v-44cd04de#_3-3-4-主队列选择策略\",\"661\":\"v-44cd04de#_3-4-注意事项\",\"662\":\"v-44cd04de#_3-4-1-多少个镜像才是最优的\",\"663\":\"v-44cd04de#_3-4-2-生产者确认和事务\",\"664\":\"v-44cd04de#_3-4-3-流控\",\"665\":\"v-44cd04de#_3-4-4-主节点失效和消费者取消\",\"666\":\"v-44cd04de#_4-镜像队列原理\",\"667\":\"v-44cd04de#_4-1-镜像队列的数据流\",\"668\":\"v-44cd04de#_4-1-1-客户端连接主节点\",\"669\":\"v-44cd04de#_4-1-2-客户端连接从节点\",\"670\":\"v-44cd04de#_4-2-镜像队列的实现原理\",\"671\":\"v-44cd04de#_4-2-1-普通队列结构\",\"672\":\"v-44cd04de#_4-2-2-镜像队列结构\",\"673\":\"v-44cd04de#_4-2-3-gm-guaranteed-multicast\",\"674\":\"v-44cd04de#_4-2-4-消息的广播\",\"675\":\"v-44cd04de#_5-镜像队列实践\",\"676\":\"v-44cd04de#_5-1-镜像队列的缺点\",\"677\":\"v-44cd04de#_5-1-1-设计缺陷-1-broker-离线后重新上线\",\"678\":\"v-44cd04de#_5-1-2-设计缺陷-2-同步阻塞\",\"679\":\"v-44cd04de#参考资料\",\"680\":\"v-e79bef96\",\"681\":\"v-e79bef96#_1-背景\",\"682\":\"v-e79bef96#_2-概述\",\"683\":\"v-e79bef96#_2-1-持久化\",\"684\":\"v-e79bef96#_2-1-1-队列持久化\",\"685\":\"v-e79bef96#_2-1-2-消息的持久化\",\"686\":\"v-e79bef96#_2-2-存储机制\",\"687\":\"v-e79bef96#_2-2-1-存储结构\",\"688\":\"v-e79bef96#_2-2-2-合并机制\",\"689\":\"v-e79bef96#_2-3-队列结构\",\"690\":\"v-e79bef96#rabbitmq中队列的存储状态\",\"691\":\"v-e79bef96#参考资料\",\"692\":\"v-0123c557\",\"693\":\"v-0123c557#镜像队列的设计缺陷\",\"694\":\"v-0123c557#仲裁队列——下一代高可用队列\",\"695\":\"v-0123c557#raft-协议下的消息复制\",\"696\":\"v-0123c557#仲裁队列的优势\",\"697\":\"v-0123c557#仲裁队列的劣势\",\"698\":\"v-0123c557#特性更少\",\"699\":\"v-0123c557#磁盘使用——写入放大\",\"700\":\"v-0123c557#普通队列\",\"701\":\"v-0123c557#仲裁队列\",\"702\":\"v-0123c557#内存使用——所有消息一直保存在内存中\",\"703\":\"v-0123c557#失去多数节点时意味着队列不可用\",\"704\":\"v-0123c557#延迟\",\"705\":\"v-26e78d15\",\"706\":\"v-26e78d15#_1-背景\",\"707\":\"v-26e78d15#_1-1-使用场景\",\"708\":\"v-26e78d15#_1-2-一致性哈希\",\"709\":\"v-26e78d15#_2-使用\",\"710\":\"v-26e78d15#_2-1-开启插件\",\"711\":\"v-26e78d15#_2-2-管理页面使用\",\"712\":\"v-26e78d15#_2-3-java-sdk-使用\",\"713\":\"v-26e78d15#_2-4-高级用法\",\"714\":\"v-26e78d15#_2-4-1-使用-header-作为路由键\",\"715\":\"v-26e78d15#_2-4-2-使用消息属性作为路由键\",\"716\":\"v-26e78d15#_3-原理\",\"717\":\"v-26e78d15#参考资料\",\"718\":\"v-4e9b65d8\",\"719\":\"v-4489d564\",\"720\":\"v-4489d564#概述\",\"721\":\"v-4489d564#优化分析\",\"722\":\"v-4489d564#事务消息日志优化-1\",\"723\":\"v-4489d564#主从复制和同步刷流程中锁的优化-移除-2-4\",\"724\":\"v-4489d564#前置知识-主从复制和同步刷盘中的生产消费模式\",\"725\":\"v-4489d564#优化1-主从复制和同步刷盘中重量级锁synchronized改为自旋锁\",\"726\":\"v-4489d564#优化2-waitnotifyobject-类\",\"727\":\"v-4489d564#消除主从复制中不必要的数组拷贝-5\",\"728\":\"v-4489d564#内存映射文件mmap\",\"729\":\"v-4489d564#主从复制流程概要\",\"730\":\"v-4489d564#优化-减少字节数组拷贝\",\"731\":\"v-4489d564#移除-commitlog-中包含重复代码的-putmessage-putmessages-方法-6\",\"732\":\"v-4489d564#调整消息发送几个参数的默认值-7\",\"733\":\"v-4489d564#消息保存-发送参数优化\",\"734\":\"v-4489d564#事务消息二阶段处理线程大小\",\"735\":\"v-4489d564#开启定时刷盘\",\"736\":\"v-4489d564#优化-putmessage-锁内操作-8-12\",\"737\":\"v-4489d564#优化-asyncputmessage-性能-将准备工作放到锁外\",\"738\":\"v-4489d564#messageid-懒加载\",\"739\":\"v-4489d564#优化消息-header-解析的性能-13-15\",\"740\":\"v-4489d564#去除字符串末尾占位符-节省消息传输大小\",\"741\":\"v-4489d564#优化-string-和-map-互相解析的性能\",\"742\":\"v-4489d564#优化-broker-请求消息头解码性能-15\",\"743\":\"v-4489d564#参考资料\",\"744\":\"v-56a2f3c8\",\"745\":\"v-56a2f3c8#_1-概述\",\"746\":\"v-56a2f3c8#_1-1-consumequeue-是什么\",\"747\":\"v-56a2f3c8#_1-2-consumequeue-的作用\",\"748\":\"v-56a2f3c8#_2-概要设计\",\"749\":\"v-56a2f3c8#_2-1-文件结构\",\"750\":\"v-56a2f3c8#_2-2-构建\",\"751\":\"v-56a2f3c8#_2-3-查询消息\",\"752\":\"v-56a2f3c8#_2-4-刷盘\",\"753\":\"v-56a2f3c8#_2-5-恢复\",\"754\":\"v-56a2f3c8#_3-详细设计\",\"755\":\"v-56a2f3c8#_3-1-文件结构\",\"756\":\"v-56a2f3c8#_3-2-构建\",\"757\":\"v-56a2f3c8#_3-3-查询消息\",\"758\":\"v-56a2f3c8#_3-4-刷盘\",\"759\":\"v-56a2f3c8#_3-5-恢复\",\"760\":\"v-56a2f3c8#_4-源码解析\",\"761\":\"v-56a2f3c8#_4-1-构建\",\"762\":\"v-56a2f3c8#_4-1-1-reputmessageservice-doreput\",\"763\":\"v-56a2f3c8#_4-1-2-defaultmessagestore-dodispatch\",\"764\":\"v-56a2f3c8#_4-1-3-commitlogdispatcherbuildconsumequeue-dispatch\",\"765\":\"v-56a2f3c8#_4-1-4-consumequeue-putmessageposiitoninfo\",\"766\":\"v-56a2f3c8#_4-2-查询消息\",\"767\":\"v-56a2f3c8#_4-2-1-defaultmessagestore-getmessage\",\"768\":\"v-56a2f3c8#_4-3-刷盘\",\"769\":\"v-56a2f3c8#_4-3-1-flushconsumequeueservice-doflush\",\"770\":\"v-56a2f3c8#_4-4-恢复\",\"771\":\"v-56a2f3c8#_4-4-1-consumequeue-recover\",\"772\":\"v-56a2f3c8#_5-更多思考\",\"773\":\"v-56a2f3c8#_5-1-rocketmq-5-x-版本中新的-batch-consume-queue-index\",\"774\":\"v-56a2f3c8#参考资料\",\"775\":\"v-5f598c93\",\"776\":\"v-5f598c93#_1-概述\",\"777\":\"v-5f598c93#_1-1-索引文件是什么\",\"778\":\"v-5f598c93#_1-2-索引文件作用\",\"779\":\"v-5f598c93#_2-概要设计\",\"780\":\"v-5f598c93#_2-1-索引文件结构\",\"781\":\"v-5f598c93#_2-2-如何构建\",\"782\":\"v-5f598c93#_2-3-如何查询消息\",\"783\":\"v-5f598c93#_2-4-刷盘机制\",\"784\":\"v-5f598c93#_3-详细设计\",\"785\":\"v-5f598c93#_3-1-索引文件结构\",\"786\":\"v-5f598c93#_3-1-1-逻辑结构\",\"787\":\"v-5f598c93#_3-1-2-存储结构\",\"788\":\"v-5f598c93#_3-2-索引文件涉及到的类\",\"789\":\"v-5f598c93#indexservice\",\"790\":\"v-5f598c93#indexfile\",\"791\":\"v-5f598c93#_4-源码解析\",\"792\":\"v-5f598c93#_4-1-indexservice\",\"793\":\"v-5f598c93#_4-1-1-创建\",\"794\":\"v-5f598c93#_4-1-2-插入和查询\",\"795\":\"v-5f598c93#_4-1-3-过期删除\",\"796\":\"v-5f598c93#_4-1-4-刷盘\",\"797\":\"v-5f598c93#_4-2-indexfile\",\"798\":\"v-5f598c93#参考资料\",\"799\":\"v-285e1fdf\",\"800\":\"v-285e1fdf#_1-概述\",\"801\":\"v-285e1fdf#_1-1-消息消费方式\",\"802\":\"v-285e1fdf#_1-2-push-消费模式\",\"803\":\"v-285e1fdf#_1-2-1-push-模式原理\",\"804\":\"v-285e1fdf#_1-3-如何进行轮询\",\"805\":\"v-285e1fdf#_1-4-长轮询和短轮询\",\"806\":\"v-285e1fdf#_2-概要流程\",\"807\":\"v-285e1fdf#_3-详细流程\",\"808\":\"v-285e1fdf#_3-1-涉及到的类\",\"809\":\"v-285e1fdf#_3-1-1-pullmessageprocessor\",\"810\":\"v-285e1fdf#_3-1-2-pullrequestholdservice\",\"811\":\"v-285e1fdf#_3-1-3-defaultmessagestore-reputmessageservice\",\"812\":\"v-285e1fdf#_3-2-时序图\",\"813\":\"v-285e1fdf#_3-3-每个类的具体逻辑\",\"814\":\"v-285e1fdf#_3-3-1-pullmessageprocessor\",\"815\":\"v-285e1fdf#_3-3-2-pullrequestholdservice\",\"816\":\"v-285e1fdf#_3-3-3-defaultmessagestore-reputmessageservice\",\"817\":\"v-285e1fdf#_4-源码解析\",\"818\":\"v-285e1fdf#_4-1-pullmessageprocessor\",\"819\":\"v-285e1fdf#_4-1-1-processrequest\",\"820\":\"v-285e1fdf#_4-1-2-executerequestwhenwakeup\",\"821\":\"v-285e1fdf#_4-2-pullrequestholdservice\",\"822\":\"v-285e1fdf#_4-2-1-suspendpullrequest\",\"823\":\"v-285e1fdf#_4-2-2-checkholdrequest\",\"824\":\"v-285e1fdf#_4-2-3-run\",\"825\":\"v-285e1fdf#_4-2-4-notifymessagearriving\",\"826\":\"v-285e1fdf#_4-3-defaultmessagestore-reputmessageservice\",\"827\":\"v-285e1fdf#_4-3-1-doreput\",\"828\":\"v-285e1fdf#_4-3-2-notifymessagearrivinglistener-arriving\",\"829\":\"v-285e1fdf#参考资料\",\"830\":\"v-5ae9d6bb\",\"831\":\"v-5ae9d6bb#_1-概述\",\"832\":\"v-5ae9d6bb#_1-1-定时消息概念\",\"833\":\"v-5ae9d6bb#_1-2-rocketmq中的定时消息支持\",\"834\":\"v-5ae9d6bb#_2-概要流程\",\"835\":\"v-5ae9d6bb#_3-详细流程\",\"836\":\"v-5ae9d6bb#_3-1-定时消息涉及到的类\",\"837\":\"v-5ae9d6bb#_3-2-定时消息时序图\",\"838\":\"v-5ae9d6bb#_3-3-每个类关于定时消息的具体逻辑\",\"839\":\"v-5ae9d6bb#_3-3-1-commitlog\",\"840\":\"v-5ae9d6bb#_3-3-2-schedulemessageservice\",\"841\":\"v-5ae9d6bb#_3-3-3-deliverdelayedmessagetimertask\",\"842\":\"v-5ae9d6bb#_4-源码解析\",\"843\":\"v-5ae9d6bb#_4-1-commitlog\",\"844\":\"v-5ae9d6bb#_4-2-schedulemessageservice\",\"845\":\"v-5ae9d6bb#_4-2-1-deliverdelayedmessagetimertask\",\"846\":\"v-5ae9d6bb#_5-更多思考\",\"847\":\"v-5ae9d6bb#_5-1-为什么不实现任意时间的定时消息\",\"848\":\"v-5ae9d6bb#_5-2-任意时间定时消息实现\",\"849\":\"v-d8040e16\",\"850\":\"v-d8040e16#_1-概述\",\"851\":\"v-d8040e16#_2-改动解析\",\"852\":\"v-d8040e16#_2-1-将多延迟等级延迟消息扫描和投递的任务从单线程执行改为多线程\",\"853\":\"v-d8040e16#_2-2-支持延迟消息异步投递-提升-dledger-模式下的投递性能\",\"854\":\"v-d8040e16#_2-2-1-异步投递的注意点\",\"855\":\"v-d8040e16#_2-2-2-异步投递逻辑\",\"856\":\"v-d8040e16#_3-异步投递详解\",\"857\":\"v-d8040e16#_3-1-定时消息投递线程\",\"858\":\"v-d8040e16#_3-2-投递过程状态更新线程\",\"859\":\"v-d8040e16#_4-源码解析\",\"860\":\"v-d8040e16#_4-1-定时消息投递任务\",\"861\":\"v-d8040e16#_4-2-异步投递过程状态更新任务\",\"862\":\"v-8afca39c\",\"863\":\"v-8afca39c#_1-背景\",\"864\":\"v-8afca39c#_2-概述\",\"865\":\"v-8afca39c#_3-详解\",\"866\":\"v-8afca39c#_3-1-commitlog\",\"867\":\"v-8afca39c#_3-2-consumequeue\",\"868\":\"v-8afca39c#_3-3-indexfile\",\"869\":\"v-8afca39c#_4-源码解析\",\"870\":\"v-8afca39c#_4-1-commitlog\",\"871\":\"v-8afca39c#_4-2-consumequeue\",\"872\":\"v-8afca39c#_4-3-indexfile\",\"873\":\"v-37eec892\",\"874\":\"v-37eec892#背景\",\"875\":\"v-37eec892#实现现高性能-io-的手段\",\"876\":\"v-37eec892#_1-顺序读写\",\"877\":\"v-37eec892#_1-1-顺序写\",\"878\":\"v-37eec892#_1-2-读取消息\",\"879\":\"v-37eec892#_2-页缓存-page-cache\",\"880\":\"v-37eec892#_3-mmap\",\"881\":\"v-37eec892#_4-预分配文件\",\"882\":\"v-37eec892#_5-文件预热\",\"883\":\"v-37eec892#_6-内存级读写分离-transientstorepool\",\"884\":\"v-37eec892#参考资料\",\"885\":\"v-67348692\",\"886\":\"v-67348692#概述\",\"887\":\"v-67348692#性能优化\",\"888\":\"v-67348692#a-移除-messageext-中的反向-dns-查找\",\"889\":\"v-67348692#b-1-优化-rocketmq-通信协议-header-解码性能\",\"890\":\"v-67348692#寻找优化点\",\"891\":\"v-67348692#优化方案\",\"892\":\"v-67348692#b-2-提高编解码性能\",\"893\":\"v-67348692#改动背景\",\"894\":\"v-67348692#优化方法\",\"895\":\"v-67348692#c-缓存-parsechannelremoteaddr-方法的结果\",\"896\":\"v-67348692#寻找优化点-1\",\"897\":\"v-67348692#具体优化方法\",\"898\":\"v-67348692#d-提升-createuniqid-的性能\",\"899\":\"v-67348692#寻找优化点-2\",\"900\":\"v-67348692#优化方法-1\",\"901\":\"v-67348692#e-当没有用到-namespace-时-避免其被多次调用\",\"902\":\"v-67348692#寻找优化点-3\",\"903\":\"v-67348692#优化方法-2\",\"904\":\"v-67348692#f-去除-topic-group-名称的正则匹配检查\",\"905\":\"v-67348692#g-支持发送-batch-消息时支持不同的-topic-queue\",\"906\":\"v-67348692#h-避免无谓的-stringbuilder-扩容\",\"907\":\"v-67348692#i-避免无谓的-stringbuffer-扩容和-string-格式化\",\"908\":\"v-67348692#寻找优化点-4\",\"909\":\"v-67348692#优化方法-3\",\"910\":\"v-67348692#j-在写-consumequeue-和-从节点的-commitlog-时-使用-mmap-而不是-filechannel-提升消息消费-tps\",\"911\":\"v-67348692#寻找优化点-5\",\"912\":\"v-67348692#优化方法-4\",\"913\":\"v-67348692#k-将-notifymessagearriving-的调用从-reputmessageservice-线程移到-pullrequestholdservice-线程\",\"914\":\"v-67348692#寻找优化点-6\",\"915\":\"v-67348692#优化方案-1\",\"916\":\"v-67348692#优化方案-2\",\"917\":\"v-67348692#小结\",\"918\":\"v-6624aa83\",\"919\":\"v-6624aa83#背景\",\"920\":\"v-6624aa83#定时消息和延迟消息是什么\",\"921\":\"v-6624aa83#定时消息的需求和应用场景\",\"922\":\"v-6624aa83#各大消息队列对定时消息支持的现状\",\"923\":\"v-6624aa83#设计和实现\",\"924\":\"v-6624aa83#难点和取舍\",\"925\":\"v-6624aa83#站在巨人的肩膀上\",\"926\":\"v-6624aa83#存储设计\",\"927\":\"v-6624aa83#使用索引文件解决定时消息顺序问题\",\"928\":\"v-6624aa83#消息存储的方案取舍\",\"929\":\"v-6624aa83#存储最终方案\",\"930\":\"v-6624aa83#定时消息投递\",\"931\":\"v-6624aa83#预加载到时间轮\",\"932\":\"v-6624aa83#周期性启动定时任务\",\"933\":\"v-6624aa83#流控\",\"934\":\"v-6624aa83#重投\",\"935\":\"v-6624aa83#定时消息取消\",\"936\":\"v-6624aa83#小结\",\"937\":\"v-6624aa83#华为云-rocketmq-定时消息已经上线\",\"938\":\"v-6624aa83#参考资料\",\"939\":\"v-178be2c0\",\"940\":\"v-178be2c0#_1-概述\",\"941\":\"v-178be2c0#_1-1-nameserver-是什么\",\"942\":\"v-178be2c0#_1-2-nameserver-与-zookeeper\",\"943\":\"v-178be2c0#_2-概要设计\",\"944\":\"v-178be2c0#_2-1-模块\",\"945\":\"v-178be2c0#_2-2-交互\",\"946\":\"v-178be2c0#_3-详细设计\",\"947\":\"v-178be2c0#_3-1-nameserver-启动\",\"948\":\"v-178be2c0#_3-2-路由信息\",\"949\":\"v-178be2c0#_3-2-1-nameserver-端保存的路由信息\",\"950\":\"v-178be2c0#_3-2-2-客户端保存的路由信息\",\"951\":\"v-178be2c0#_3-3-路由注册\",\"952\":\"v-178be2c0#_3-3-1-broker-上报心跳和路由信息\",\"953\":\"v-178be2c0#_3-3-2-nameserver-保存上报的路由信息\",\"954\":\"v-178be2c0#_3-4-路由删除\",\"955\":\"v-178be2c0#_3-5-路由发现-客户端拉取路由信息\",\"956\":\"v-178be2c0#_3-5-1-客户端请求路由信息\",\"957\":\"v-178be2c0#_3-5-2-nameserver-返回路由信息\",\"958\":\"v-178be2c0#_4-源码剖析\",\"959\":\"v-178be2c0#_4-1-nameserver-启动\",\"960\":\"v-178be2c0#_4-1-1-nemesrvstartup\",\"961\":\"v-178be2c0#_4-1-2-namesrvcontroller-启动\",\"962\":\"v-178be2c0#_4-2-路由信息\",\"963\":\"v-178be2c0#_4-2-1-nameserver-路由信息\",\"964\":\"v-178be2c0#topicqueuetable\",\"965\":\"v-178be2c0#brokeraddrtable\",\"966\":\"v-178be2c0#clusteraddrtable\",\"967\":\"v-178be2c0#brokerlivetable\",\"968\":\"v-178be2c0#_4-2-2-客户端路由信息\",\"969\":\"v-178be2c0#_4-3-路由注册\",\"970\":\"v-178be2c0#_4-3-1-broker-上报心跳和路由信息\",\"971\":\"v-178be2c0#_4-3-2-nameserver-保存上报的路由信息\",\"972\":\"v-178be2c0#_4-4-路由删除\",\"973\":\"v-178be2c0#_4-5-路由发现\",\"974\":\"v-178be2c0#参考资料\",\"975\":\"v-0c763d3c\",\"976\":\"v-0c763d3c#_1-背景\",\"977\":\"v-0c763d3c#_2-概述\",\"978\":\"v-0c763d3c#_2-1-基本概念\",\"979\":\"v-0c763d3c#_2-2-基本流程\",\"980\":\"v-0c763d3c#_2-2-1-初始化\",\"981\":\"v-0c763d3c#_2-2-2-发送-处理请求\",\"982\":\"v-0c763d3c#_2-3-使用方法\",\"983\":\"v-0c763d3c#_2-3-1-broker-端配置\",\"984\":\"v-0c763d3c#_2-3-2-生产者使用\",\"985\":\"v-0c763d3c#_2-3-3-消费者使用\",\"986\":\"v-0c763d3c#_3-实现原理\",\"987\":\"v-0c763d3c#_3-1-客户端-aclclientrpchook\",\"988\":\"v-0c763d3c#_3-1-1-注册-aclclientrpchook\",\"989\":\"v-0c763d3c#_3-1-2-aclclientrpchook-的逻辑\",\"990\":\"v-0c763d3c#_3-2-broker-初始化-acl-配置\",\"991\":\"v-0c763d3c#_3-3-broker-权限验证\",\"992\":\"v-0c763d3c#_4-源码解析\",\"993\":\"v-0c763d3c#_4-1-客户端-aclclientrpchook\",\"994\":\"v-0c763d3c#_4-1-1-注册-aclclientrpchook\",\"995\":\"v-0c763d3c#_4-1-2-aclclientrpchook-的逻辑\",\"996\":\"v-0c763d3c#_4-2-broker-初始化-acl-配置\",\"997\":\"v-0c763d3c#_4-2-1-plainpermissonmanager-的字段含义\",\"998\":\"v-0c763d3c#_4-2-2-plainpermissonmanager-load\",\"999\":\"v-0c763d3c#_4-2-3-plainpermissonmanager-watch\",\"1000\":\"v-0c763d3c#_4-3-broker-权限验证\",\"1001\":\"v-0c763d3c#参考资料\",\"1002\":\"v-6175eebc\",\"1003\":\"v-6175eebc#_1-背景\",\"1004\":\"v-6175eebc#_2-使用示例\",\"1005\":\"v-6175eebc#_2-1-broker-端配置\",\"1006\":\"v-6175eebc#_2-2-生产者开启消息轨迹\",\"1007\":\"v-6175eebc#_2-3-消费者开启消息轨迹\",\"1008\":\"v-6175eebc#_2-4-使用-mqadmin-查看消息轨迹\",\"1009\":\"v-6175eebc#_2-5-使用-rocketmq-dashboard-查看消息轨迹\",\"1010\":\"v-6175eebc#_3-概要设计\",\"1011\":\"v-6175eebc#_3-1-主要流程\",\"1012\":\"v-6175eebc#_3-2-存储设计\",\"1013\":\"v-6175eebc#_4-详细设计\",\"1014\":\"v-6175eebc#_4-1-轨迹数据采集\",\"1015\":\"v-6175eebc#_4-2-轨迹数据发送\",\"1016\":\"v-6175eebc#_5-源码解析\",\"1017\":\"v-6175eebc#_5-1-消息轨迹数据模型\",\"1018\":\"v-6175eebc#_5-2-消息轨迹数据采集\",\"1019\":\"v-6175eebc#_5-2-1-注册消息轨迹采集钩子\",\"1020\":\"v-6175eebc#_5-2-2-钩子方法中采集消息轨迹数据\",\"1021\":\"v-6175eebc#_5-3-消息轨迹数据发送\",\"1022\":\"v-6175eebc#参考资料\",\"1023\":\"v-9e6b5c72\",\"1024\":\"v-9e6b5c72#_1-背景\",\"1025\":\"v-9e6b5c72#_2-概述\",\"1026\":\"v-9e6b5c72#_2-1-消息发送方式和特殊消息\",\"1027\":\"v-9e6b5c72#_2-1-1-三种消息发送方式\",\"1028\":\"v-9e6b5c72#_2-1-2-特殊消息类型\",\"1029\":\"v-9e6b5c72#_2-2-路由机制\",\"1030\":\"v-9e6b5c72#_2-3-消息发送流程\",\"1031\":\"v-9e6b5c72#_2-4-高可用设计\",\"1032\":\"v-9e6b5c72#_2-4-1-生产者高可用\",\"1033\":\"v-9e6b5c72#_2-4-2-broker-端高可用\",\"1034\":\"v-9e6b5c72#_3-详细设计\",\"1035\":\"v-9e6b5c72#_3-1-消息\",\"1036\":\"v-9e6b5c72#_3-2-生产者类图\",\"1037\":\"v-9e6b5c72#_3-3-生产者启动\",\"1038\":\"v-9e6b5c72#_3-4-消息发送\",\"1039\":\"v-9e6b5c72#_3-4-1-查找-topic-路由信息\",\"1040\":\"v-9e6b5c72#_3-4-2-重试机制\",\"1041\":\"v-9e6b5c72#_3-4-3-选择消息队列-故障延迟机制\",\"1042\":\"v-9e6b5c72#_3-4-4-发送消息\",\"1043\":\"v-9e6b5c72#_3-5-broker-处理发送请求\",\"1044\":\"v-9e6b5c72#_3-6-batch-消息-批量消息\",\"1045\":\"v-9e6b5c72#_4-源码解析\",\"1046\":\"v-9e6b5c72#_4-1-生产者启动\",\"1047\":\"v-9e6b5c72#_4-1-1-defaultmqproducerimpl-start\",\"1048\":\"v-9e6b5c72#_4-1-2-mqclientexception\",\"1049\":\"v-9e6b5c72#_4-2-消息发送\",\"1050\":\"v-9e6b5c72#_4-2-1-消息发送实现\",\"1051\":\"v-9e6b5c72#_4-2-2-查找路由信息\",\"1052\":\"v-9e6b5c72#_4-2-3-选择消息队列\",\"1053\":\"v-9e6b5c72#_4-2-4-发送消息-api-核心入口\",\"1054\":\"v-9e6b5c72#_4-3-broker-处理发送请求\",\"1055\":\"v-9e6b5c72#_4-3-1-broker-注册发送消息处理器\",\"1056\":\"v-9e6b5c72#_4-3-2-发送消息处理器处理\",\"1057\":\"v-9e6b5c72#参考资料\",\"1058\":\"v-62f7b2da\",\"1059\":\"v-62f7b2da#背景\",\"1060\":\"v-62f7b2da#概要设计\",\"1061\":\"v-62f7b2da#整体流程\",\"1062\":\"v-62f7b2da#详细设计\",\"1063\":\"v-62f7b2da#整体流程顺序图\",\"1064\":\"v-62f7b2da#类设计\",\"1065\":\"v-62f7b2da#memorymessagestore\",\"1066\":\"v-62f7b2da#topicconfig\",\"1067\":\"v-62f7b2da#brokercontroller\",\"1068\":\"v-977ad6b2\",\"1069\":\"v-977ad6b2#背景\",\"1070\":\"v-977ad6b2#环境准备\",\"1071\":\"v-977ad6b2#镜像准备\",\"1072\":\"v-977ad6b2#本地构建-rocketmq-docker-镜像\",\"1073\":\"v-977ad6b2#拉取远程\",\"1074\":\"v-977ad6b2#docker-启动-rocketmq\",\"1075\":\"v-977ad6b2#用-docker-compose-以集群模式启动-rocketmq\",\"1076\":\"v-977ad6b2#使用-docker-启动-rocketmq-dashboard\",\"1077\":\"v-977ad6b2#用-docker-单独启动-rocketmq-dashboard\",\"1078\":\"v-977ad6b2#与集群一起用-docker-compose-启动-docker-dashboard\",\"1079\":\"v-977ad6b2#docker-启动-dledger-模式的-rocketmq\",\"1080\":\"v-977ad6b2#修改内存配置\",\"1081\":\"v-977ad6b2#dledger-与-dashboard-同时启动\",\"1082\":\"v-977ad6b2#以其他部署形式启动-rocketmq\",\"1083\":\"v-977ad6b2#docker-启动单节点-rocketmq\",\"1084\":\"v-977ad6b2#docker-启动带-tls-的-rocketmq\",\"1085\":\"v-fe397c88\",\"1086\":\"v-fe397c88#_1-背景\",\"1087\":\"v-fe397c88#_2-概念简述\",\"1088\":\"v-fe397c88#_2-1-消费组概念与消费模式\",\"1089\":\"v-fe397c88#_2-1-1-消费组\",\"1090\":\"v-fe397c88#_2-1-2-广播消费模式-broadcasting\",\"1091\":\"v-fe397c88#_2-1-3-集群消费模式-clustering\",\"1092\":\"v-fe397c88#_2-2-消费者拉取消息模式\",\"1093\":\"v-fe397c88#_2-2-1-pull\",\"1094\":\"v-fe397c88#_2-2-2-push\",\"1095\":\"v-fe397c88#_2-2-3-pop\",\"1096\":\"v-fe397c88#_2-3-队列负载机制与重平衡\",\"1097\":\"v-fe397c88#_2-3-1-队列负载机制\",\"1098\":\"v-fe397c88#_2-3-2-重平衡-rebalance\",\"1099\":\"v-fe397c88#_2-4-消费端高可靠\",\"1100\":\"v-fe397c88#_2-4-1-重试-死信机制\",\"1101\":\"v-fe397c88#_2-4-2-队列负载机制与重平衡\",\"1102\":\"v-fe397c88#_2-5-并发消费与顺序消费\",\"1103\":\"v-fe397c88#_2-6-消费进度保存和提交\",\"1104\":\"v-fe397c88#_3-消费流程\",\"1105\":\"v-fe397c88#参考资料\",\"1106\":\"v-d66de8c8\",\"1107\":\"v-d66de8c8#_1-背景\",\"1108\":\"v-d66de8c8#_2-概要设计\",\"1109\":\"v-d66de8c8#_2-1-消费者客户端设计\",\"1110\":\"v-d66de8c8#_2-2-消费者客户端启动\",\"1111\":\"v-d66de8c8#_2-2-1-新建消费者\",\"1112\":\"v-d66de8c8#_2-2-2-消费者启动\",\"1113\":\"v-d66de8c8#_3-详细设计\",\"1114\":\"v-d66de8c8#_3-1-消费者客户端类设计\",\"1115\":\"v-d66de8c8#_3-1-1-整体类图\",\"1116\":\"v-d66de8c8#_3-1-2-消费者接口\",\"1117\":\"v-d66de8c8#_3-1-3-拉-推模式消费者接口\",\"1118\":\"v-d66de8c8#_3-1-4-消费者实现\",\"1119\":\"v-d66de8c8#_3-1-5-推模式消费者实现\",\"1120\":\"v-d66de8c8#_3-2-消费者启动\",\"1121\":\"v-d66de8c8#_4-源码解析\",\"1122\":\"v-d66de8c8#_4-1-defaultmqproducerimpl-启动\",\"1123\":\"v-d66de8c8#_4-2-mqclientinstance-启动\",\"1124\":\"v-a5c93210\",\"1125\":\"v-a5c93210#_1-背景\",\"1126\":\"v-a5c93210#_1-1-重平衡的含义\",\"1127\":\"v-a5c93210#_2-概要设计\",\"1128\":\"v-a5c93210#_2-1-重平衡的触发\",\"1129\":\"v-a5c93210#_2-2-重平衡类设计\",\"1130\":\"v-a5c93210#_2-3-重平衡流程\",\"1131\":\"v-a5c93210#_3-详细设计\",\"1132\":\"v-a5c93210#_3-1-重平衡实现类-rebalanceimpl\",\"1133\":\"v-a5c93210#_3-1-1-域\",\"1134\":\"v-a5c93210#_3-1-2-方法\",\"1135\":\"v-a5c93210#_3-2-重平衡流程\",\"1136\":\"v-a5c93210#_3-2-1-重平衡触发\",\"1137\":\"v-a5c93210#_3-2-2-重平衡流程\",\"1138\":\"v-a5c93210#_3-3-重平衡队列分配策略\",\"1139\":\"v-a5c93210#_4-源码解析\",\"1140\":\"v-a5c93210#_4-1-rebalanceservice-重平衡线程\",\"1141\":\"v-a5c93210#_4-2-rebalanceimpl-重平衡实现\",\"1142\":\"v-a5c93210#_4-2-1-dorebalance-重平衡入口\",\"1143\":\"v-a5c93210#_4-2-2-rebalancebytopic-对-topic-进行重平衡\",\"1144\":\"v-a5c93210#_4-2-3-updateprocessqueuetableinrebalance-重平衡后更新订阅的队列和处理队列表\",\"1145\":\"v-a5c93210#_4-2-4-messagequeuechanged\",\"1146\":\"v-041d67ca\",\"1147\":\"v-041d67ca#_1-背景\",\"1148\":\"v-041d67ca#_2-概要设计\",\"1149\":\"v-041d67ca#_2-1-交互流程\",\"1150\":\"v-041d67ca#_2-2-客户端拉取流程设计\",\"1151\":\"v-041d67ca#_2-2-1-拉模式消费者拉取\",\"1152\":\"v-041d67ca#_2-2-2-推模式消费者拉取\",\"1153\":\"v-041d67ca#_2-3-broker-端拉取流程设计\",\"1154\":\"v-041d67ca#_3-详细设计\",\"1155\":\"v-041d67ca#_3-1-相关类设计\",\"1156\":\"v-041d67ca#_3-2-整体流程\",\"1157\":\"v-041d67ca#_3-2-1-消费者拉取消息\",\"1158\":\"v-041d67ca#_3-2-1-1-pullmessageservice\",\"1159\":\"v-041d67ca#_3-2-1-2-defaultmqpushconsumerimpl\",\"1160\":\"v-041d67ca#_3-2-1-3-pullapiwrapper\",\"1161\":\"v-041d67ca#_3-2-1-4-mqclientapiimpl\",\"1162\":\"v-041d67ca#_3-2-2-broker-端处理拉取请求\",\"1163\":\"v-041d67ca#_3-2-2-1-pullmessageprocessor\",\"1164\":\"v-041d67ca#_3-2-2-2-defaultmessagestore\",\"1165\":\"v-041d67ca#_3-2-3-消费者拉取成功结果处理\",\"1166\":\"v-041d67ca#_4-源码解析\",\"1167\":\"v-041d67ca#_4-1-消费者拉取消息\",\"1168\":\"v-041d67ca#_4-1-1-pullmessageservice-消息拉取线程\",\"1169\":\"v-041d67ca#_4-1-2-pullrequest-消息拉取请求\",\"1170\":\"v-041d67ca#_4-1-3-defaultmqpushconsumerimpl\",\"1171\":\"v-041d67ca#_4-1-4-pullapiwrapper\",\"1172\":\"v-041d67ca#_4-1-5-mqclientinstance\",\"1173\":\"v-041d67ca#_4-1-6-pullmessageprocessor\",\"1174\":\"v-041d67ca#_4-1-7-defaultmessagestore\",\"1175\":\"v-041d67ca#_4-1-8-pullcallback\",\"1176\":\"v-c0655cf8\",\"1177\":\"v-c0655cf8#_1-背景\",\"1178\":\"v-c0655cf8#_2-概要设计\",\"1179\":\"v-c0655cf8#_2-1-推模式并发消费交互流程\",\"1180\":\"v-c0655cf8#_2-2-重试消费设计\",\"1181\":\"v-c0655cf8#_2-3-消费进度管理设计\",\"1182\":\"v-c0655cf8#_2-3-1-广播模式消费进度管理\",\"1183\":\"v-c0655cf8#_2-3-2-集群模式消费进度管理\",\"1184\":\"v-c0655cf8#_2-3-3-消费者更新消费进度\",\"1185\":\"v-c0655cf8#_3-详细设计\",\"1186\":\"v-c0655cf8#_3-1-推模式并发消费\",\"1187\":\"v-c0655cf8#_3-1-1-消息消费类设计\",\"1188\":\"v-c0655cf8#_3-1-2-推模式并发消费流程\",\"1189\":\"v-c0655cf8#_3-2-消费进度管理\",\"1190\":\"v-c0655cf8#_3-2-1-消费进度管理类设计\",\"1191\":\"v-c0655cf8#_3-2-2-消费进度更新流程\",\"1192\":\"v-c0655cf8#_4-源码解析\",\"1193\":\"v-c0655cf8#_4-1-推模式并发消费\",\"1194\":\"v-c0655cf8#_4-1-1-并发消费服务提交消费请求\",\"1195\":\"v-c0655cf8#_4-1-2-消费请求运行、处理结果\",\"1196\":\"v-c0655cf8#_4-2-重试消费\",\"1197\":\"v-c0655cf8#_4-2-1-消费者消费失败-将消息发回-broker\",\"1198\":\"v-c0655cf8#_4-2-2-broker-端处理客户端发回的消息\",\"1199\":\"v-c0655cf8#_4-3-消费进度管理\",\"1200\":\"v-c0655cf8#_4-3-1-客户端消费进度管理器持久化消费进度\",\"1201\":\"v-c0655cf8#_4-3-2-broker-端消费进度管理器\",\"1202\":\"v-495b4ee9\",\"1203\":\"v-495b4ee9#_1-背景\",\"1204\":\"v-495b4ee9#_2-概要设计\",\"1205\":\"v-495b4ee9#_2-1-消费线程池逻辑\",\"1206\":\"v-495b4ee9#_2-1-1-消费线程池顺序消费\",\"1207\":\"v-495b4ee9#_2-1-2-保证一个队列同时仅被一个消费线程消费\",\"1208\":\"v-495b4ee9#_2-2-重平衡时顺序消费\",\"1209\":\"v-495b4ee9#_2-2-1-broker-管理的分布式锁\",\"1210\":\"v-495b4ee9#_3-详细设计\",\"1211\":\"v-495b4ee9#_3-1-broker锁\",\"1212\":\"v-495b4ee9#_3-1-1-设计\",\"1213\":\"v-495b4ee9#_3-1-2-加解锁时机\",\"1214\":\"v-495b4ee9#_3-1-3-加解锁流程\",\"1215\":\"v-495b4ee9#_3-1-4-边界条件-消费消息时重平衡\",\"1216\":\"v-495b4ee9#_3-2-消费线程池顺序消费逻辑\",\"1217\":\"v-495b4ee9#_3-2-1-消费线程池顺序消费设计\",\"1218\":\"v-495b4ee9#_3-2-2-消费线程池顺序消费任务流程\",\"1219\":\"v-495b4ee9#_3-3-顺序消费流程\",\"1220\":\"v-495b4ee9#_4-源码解析\",\"1221\":\"v-495b4ee9#_4-1-broker锁\",\"1222\":\"v-495b4ee9#_4-1-1-broker锁-管理器\",\"1223\":\"v-495b4ee9#_4-1-2-消费者解锁-加锁\",\"1224\":\"v-495b4ee9#_4-1-2-1-重平衡后更新处理队列\",\"1225\":\"v-495b4ee9#_4-1-2-2-消息队列解锁\",\"1226\":\"v-495b4ee9#_4-1-2-3-消息队列加锁\",\"1227\":\"v-495b4ee9#_4-2-消息拉取\",\"1228\":\"v-495b4ee9#_4-2-1-消息拉取\",\"1229\":\"v-495b4ee9#_4-2-2-消息拉取成功\",\"1230\":\"v-495b4ee9#_4-3-顺序消费任务\",\"1231\":\"v-61f53d7d\",\"1232\":\"v-61f53d7d#生产者\",\"1233\":\"v-61f53d7d#发送重试\",\"1234\":\"v-61f53d7d#延迟故障规避\",\"1235\":\"v-61f53d7d#同一进程中多个生产者发送消息到多个集群\",\"1236\":\"v-61f53d7d#消费者\",\"1237\":\"v-61f53d7d#消费幂等\",\"1238\":\"v-61f53d7d#消费组线程数\",\"1239\":\"v-61f53d7d#避免订阅关系不一致导致消息丢失\",\"1240\":\"v-61f53d7d#避免-clientid-相同\",\"1241\":\"v-61f53d7d#消费重试次数\",\"1242\":\"v-61f53d7d#broker\",\"1243\":\"v-461d8dc0\",\"1244\":\"v-461d8dc0#_1-背景\",\"1245\":\"v-461d8dc0#_1-1-什么是-pop-消费\",\"1246\":\"v-461d8dc0#_1-2-如何使用-pop-消费\",\"1247\":\"v-461d8dc0#_1-2-1-使用命令行方式切换\",\"1248\":\"v-461d8dc0#_1-2-2-代码切换\",\"1249\":\"v-461d8dc0#_1-3-引入-pop-消费模式的原因\",\"1250\":\"v-461d8dc0#_2-概要设计\",\"1251\":\"v-461d8dc0#_2-1-pop-消费流程\",\"1252\":\"v-461d8dc0#_2-2-客户端-服务端交互\",\"1253\":\"v-461d8dc0#_2-3-服务端实现\",\"1254\":\"v-461d8dc0#_3-详细设计\",\"1255\":\"v-461d8dc0#_3-1-broker-端重平衡\",\"1256\":\"v-461d8dc0#_3-2-broker-端-pop-消息\",\"1257\":\"v-461d8dc0#_3-2-1-请求处理入口\",\"1258\":\"v-461d8dc0#_3-2-2-pop-消息方法\",\"1259\":\"v-461d8dc0#_3-2-3-保存-checkpoint-用于匹配\",\"1260\":\"v-461d8dc0#_3-3-broker-端-ack-消息\",\"1261\":\"v-461d8dc0#_3-4-broker-端-checkpoint-与-ackmsg-匹配\",\"1262\":\"v-461d8dc0#_3-4-1-内存匹配\",\"1263\":\"v-461d8dc0#_3-4-2-store-匹配和消息重试\",\"1264\":\"v-461d8dc0#_4-源码解析\",\"1265\":\"v-461d8dc0#_4-1-broker-端重平衡\",\"1266\":\"v-461d8dc0#_4-1-1-queryassignmentprocessor-doloadbalance\",\"1267\":\"v-461d8dc0#_4-1-2-queryassignmentprocessor-allocate4pop\",\"1268\":\"v-461d8dc0#_4-2-broker-端-pop-消息\",\"1269\":\"v-461d8dc0#_4-2-1-popmessageprocessor-processrequest\",\"1270\":\"v-461d8dc0#_4-2-2-popmessageprocessor-popmsgfromqueue\",\"1271\":\"v-461d8dc0#_4-2-3-popmessageprocessor-appendcheckpoint\",\"1272\":\"v-461d8dc0#_4-3-broker-端-ack-消息\",\"1273\":\"v-461d8dc0#_4-3-1-ackmessageprocessor-processrequest\",\"1274\":\"v-461d8dc0#_4-4-broker-端-checkpoint-与-ackmsg-匹配\",\"1275\":\"v-461d8dc0#_4-4-1-popbuffermergeservice-addck\",\"1276\":\"v-461d8dc0#_4-4-2-popbuffermergeservice-addak\",\"1277\":\"v-461d8dc0#_4-4-3-popbuffermergeservice-scan\",\"1278\":\"v-461d8dc0#_4-4-4-popreviveservice-consumerevivemessage\",\"1279\":\"v-461d8dc0#_4-4-5-popreviveservice-mergeandrevive\",\"1280\":\"v-461d8dc0#_4-4-6-popreviveservice-重试消息\",\"1281\":\"v-461d8dc0#参考资料\",\"1282\":\"v-589d225e\",\"1283\":\"v-589d225e#_1-背景\",\"1284\":\"v-589d225e#_1-1-引入原因\",\"1285\":\"v-589d225e#_1-2-使用方法\",\"1286\":\"v-589d225e#_1-2-1-broker-启动配置\",\"1287\":\"v-589d225e#_1-2-2-生产消息\",\"1288\":\"v-589d225e#_1-2-3-消费消息\",\"1289\":\"v-589d225e#_2-概要设计\",\"1290\":\"v-589d225e#_2-1-当前痛点\",\"1291\":\"v-589d225e#_2-1-实现思想\",\"1292\":\"v-589d225e#_3-详细设计\",\"1293\":\"v-589d225e#_3-1-消息生产和消费\",\"1294\":\"v-589d225e#_3-2-commitlog-分发到-lmq\",\"1295\":\"v-589d225e#_4-源码解析\",\"1296\":\"v-589d225e#_4-1-查询-lmq-偏移量\",\"1297\":\"v-589d225e#_4-2-分发-lmq\",\"1298\":\"v-589d225e#参考资料\",\"1299\":\"v-bdb85802\",\"1300\":\"v-bdb85802#write-buffer-water-mark\",\"1301\":\"v-18304210\",\"1302\":\"v-18304210#_1-背景\",\"1303\":\"v-18304210#_1-1-rocketmq-支持的过滤方式\",\"1304\":\"v-18304210#_1-2-使用方法\",\"1305\":\"v-18304210#_1-2-1-tag-过滤\",\"1306\":\"v-18304210#生产者\",\"1307\":\"v-18304210#消费者\",\"1308\":\"v-18304210#_1-2-2-sql92\",\"1309\":\"v-18304210#生产者-1\",\"1310\":\"v-18304210#消费者-1\",\"1311\":\"v-18304210#_2-概要设计\",\"1312\":\"v-18304210#_2-1-过滤信息的注册\",\"1313\":\"v-18304210#_2-2-表达式过滤\",\"1314\":\"v-18304210#_2-2-1-tag-过滤\",\"1315\":\"v-18304210#_2-2-2-sql92-过滤\",\"1316\":\"v-18304210#_3-详细设计\",\"1317\":\"v-18304210#_3-1-过滤信息注册\",\"1318\":\"v-18304210#_3-2-过滤器接口\",\"1319\":\"v-18304210#_3-3-tag-过滤\",\"1320\":\"v-18304210#_3-4-sql92-过滤\",\"1321\":\"v-18304210#_3-4-1-编译-sql-语句\",\"1322\":\"v-18304210#_3-4-2-布隆过滤器-bloomfilter\",\"1323\":\"v-18304210#_3-4-3-生成布隆过滤器位数组\",\"1324\":\"v-18304210#_3-4-4-消息过滤\",\"1325\":\"v-18304210#_3-4-5-是否启用布隆过滤器-第一层过滤\",\"1326\":\"v-18304210#_4-源码解析\",\"1327\":\"v-18304210#_4-1-tag-过滤\",\"1328\":\"v-18304210#_4-1-1-broker-端过滤\",\"1329\":\"v-18304210#_4-1-2-客户端过滤\",\"1330\":\"v-18304210#_4-2-sql92-过滤\",\"1331\":\"v-18304210#_4-2-1-注册过滤信息\",\"1332\":\"v-18304210#_4-2-2-消息生产时构建布隆过滤器数据\",\"1333\":\"v-18304210#_4-2-3-消息拉取时过滤\",\"1334\":\"v-18304210#参考资料\",\"1335\":\"v-377ff2c9\",\"1336\":\"v-377ff2c9#_1-背景\",\"1337\":\"v-377ff2c9#_1-1-概念和应用场景\",\"1338\":\"v-377ff2c9#_1-2-延迟消息与定时消息\",\"1339\":\"v-377ff2c9#_1-2-任意时间定时消息的使用\",\"1340\":\"v-377ff2c9#_2-概要设计\",\"1341\":\"v-377ff2c9#_2-1-任意时间定时消息的难点\",\"1342\":\"v-377ff2c9#_2-1-1-难点1-任意的定时时间\",\"1343\":\"v-377ff2c9#_2-1-2-难点2-定时消息的存储和老化\",\"1344\":\"v-377ff2c9#_2-1-3-难点3-大量定时消息的极端情况\",\"1345\":\"v-377ff2c9#_2-2-设计思路\",\"1346\":\"v-377ff2c9#_2-2-1-任意时间定时\",\"1347\":\"v-377ff2c9#_2-2-2-定时消息轮转-避免定时消息被老化删除\",\"1348\":\"v-377ff2c9#_2-2-3-定时任务划分和解耦\",\"1349\":\"v-377ff2c9#_3-详细设计\",\"1350\":\"v-377ff2c9#_3-1-定时消息文件设计\",\"1351\":\"v-377ff2c9#_3-1-1-timerwheel-时间轮\",\"1352\":\"v-377ff2c9#_3-1-2-timerlog-定时消息索引文件\",\"1353\":\"v-377ff2c9#_3-2-定时消息投递步骤\",\"1354\":\"v-377ff2c9#_3-2-1-定时消息保存\",\"1355\":\"v-377ff2c9#timerenqueuegetservice-扫描定时消息\",\"1356\":\"v-377ff2c9#timerenqueueputservice-将定时消息放入时间轮和-timerlog\",\"1357\":\"v-377ff2c9#_3-2-2-定时消息投递\",\"1358\":\"v-377ff2c9#timerdequeuegetservice-扫描时间轮中到期的消息\",\"1359\":\"v-377ff2c9#timerdequeuegetmessageservice-查询原始消息\",\"1360\":\"v-377ff2c9#timerdequeueputmessageservice-投递定时消息\",\"1361\":\"v-377ff2c9#_3-3-其他设计\",\"1362\":\"v-377ff2c9#_3-3-1-定时消息文件的恢复\",\"1363\":\"v-377ff2c9#_3-3-2-随机读-pagecache-污染问题\",\"1364\":\"v-377ff2c9#_3-3-3-另一种实现方案-rocksdb\",\"1365\":\"v-377ff2c9#_4-源码解析\",\"1366\":\"v-377ff2c9#_4-1-定时消息文件\",\"1367\":\"v-377ff2c9#_4-1-1-timerwheel\",\"1368\":\"v-377ff2c9#_4-1-2-timerlog\",\"1369\":\"v-377ff2c9#_4-2-定时消息投递步骤\",\"1370\":\"v-377ff2c9#_4-2-1-timerenqueuegetservice-保存——扫描定时消息\",\"1371\":\"v-377ff2c9#_4-2-2-timerenqueueputservice-保存——定时消息放入时间轮\",\"1372\":\"v-377ff2c9#_4-2-3-timerdequeuegetservice-投递——扫描时间轮中到期的消息\",\"1373\":\"v-377ff2c9#_4-2-4-timerdequeuegetmessageservice-投递——查询原始消息\",\"1374\":\"v-377ff2c9#_4-2-5-timerdequeueputmessageservice-投递——投递定时消息\",\"1375\":\"v-377ff2c9#参考资料\",\"1376\":\"v-60f6f56a\",\"1377\":\"v-60f6f56a#_1-背景\",\"1378\":\"v-60f6f56a#_1-1-需求\",\"1379\":\"v-60f6f56a#_1-2-解决的问题\",\"1380\":\"v-60f6f56a#_1-3-演进过程\",\"1381\":\"v-60f6f56a#_2-使用\",\"1382\":\"v-60f6f56a#_2-1-broker-配置\",\"1383\":\"v-60f6f56a#_2-2-数据组织结构\",\"1384\":\"v-60f6f56a#_3-概要设计\",\"1385\":\"v-60f6f56a#_3-1-技术架构选型\",\"1386\":\"v-60f6f56a#_3-2-存储模型与抽象\",\"1387\":\"v-60f6f56a#_3-3-分层设计\",\"1388\":\"v-60f6f56a#_3-4-写消息\",\"1389\":\"v-60f6f56a#_3-5-读消息\",\"1390\":\"v-60f6f56a#_3-5-1-读取策略\",\"1391\":\"v-60f6f56a#_3-5-2-读取流程\",\"1392\":\"v-60f6f56a#_3-6-索引设计\",\"1393\":\"v-60f6f56a#_3-6-1-索引重排\",\"1394\":\"v-60f6f56a#_3-6-2-索引构建流程\",\"1395\":\"v-60f6f56a#_3-7-重启恢复和元数据\",\"1396\":\"v-60f6f56a#_4-详细设计\",\"1397\":\"v-60f6f56a#_4-1-接入方式\",\"1398\":\"v-60f6f56a#_4-1-1-分级存储初始化\",\"1399\":\"v-60f6f56a#_4-1-2-分级存储调用\",\"1400\":\"v-60f6f56a#写消息\",\"1401\":\"v-60f6f56a#读消息\",\"1402\":\"v-60f6f56a#_4-2-存储模型\",\"1403\":\"v-60f6f56a#_4-3-写消息\",\"1404\":\"v-60f6f56a#_4-4-读消息\",\"1405\":\"v-60f6f56a#_4-4-1-tieredmessagestore-读消息\",\"1406\":\"v-60f6f56a#_4-4-2-预读缓存设计\",\"1407\":\"v-60f6f56a#_4-4-3-messagestorefetcher-读消息\",\"1408\":\"v-60f6f56a#从分级存储读取\",\"1409\":\"v-60f6f56a#从预读缓存读取\",\"1410\":\"v-60f6f56a#_4-4-4-flatappendfile-读消息\",\"1411\":\"v-60f6f56a#_4-5-索引文件\",\"1412\":\"v-60f6f56a#_4-5-1-索引文件类设计\",\"1413\":\"v-60f6f56a#_4-5-2-索引文件读写\",\"1414\":\"v-60f6f56a#写分级存储索引\",\"1415\":\"v-60f6f56a#读分级存储索引\",\"1416\":\"v-60f6f56a#_4-5-3-索引文件重排\",\"1417\":\"v-60f6f56a#_4-5-3-1-重排流程\",\"1418\":\"v-60f6f56a#_4-5-3-2-重排细节\",\"1419\":\"v-60f6f56a#_4-6-重启恢复和元数据\",\"1420\":\"v-60f6f56a#_4-6-1-元数据\",\"1421\":\"v-60f6f56a#_4-6-2-重启恢复\",\"1422\":\"v-60f6f56a#_5-源码解析\",\"1423\":\"v-60f6f56a#_5-1-分级存储接入\",\"1424\":\"v-60f6f56a#_5-1-1-brokercontroller-initializemessagestore-初始化分级存储实现\",\"1425\":\"v-60f6f56a#_5-1-2-messagestorefactory-build-构造分级存储插件\",\"1426\":\"v-60f6f56a#_5-2-写消息\",\"1427\":\"v-60f6f56a#_5-2-1-messagestoredispatcherimpl-doscheduledispatch-定时上传消息到分级存储\",\"1428\":\"v-60f6f56a#_5-2-2-filesegment-commitasync-异步上传\",\"1429\":\"v-60f6f56a#_5-3-读消息\",\"1430\":\"v-60f6f56a#_5-3-1-messagestorefetcherimpl-getmessageasync-分级存储消息读取入口\",\"1431\":\"v-60f6f56a#_5-3-2-messagestorefetcherimpl-getmessagefromcacheasync-从缓存中读取消息\",\"1432\":\"v-60f6f56a#_5-3-3-messagestorefetcherimpl-getmessagefromtieredstoreasync-从二级存储中读取消息\",\"1433\":\"v-60f6f56a#_5-4-索引文件\",\"1434\":\"v-60f6f56a#_5-4-1-indexstoreservice-indexstorefile-putkey-写入索引项\",\"1435\":\"v-60f6f56a#_5-4-2-indexstoreservice-indexstorefile-docompaction-索引文件压缩重排\",\"1436\":\"v-60f6f56a#_5-4-3-indexstoreservice-indexstorefile-queryasync-根据消息-key-查询索引项\",\"1437\":\"v-60f6f56a#参考资料\",\"1438\":\"v-2b49c59c\",\"1439\":\"v-2b49c59c#_1-背景\",\"1440\":\"v-2b49c59c#_2-使用示例\",\"1441\":\"v-2b49c59c#_2-1-创建事务-topic\",\"1442\":\"v-2b49c59c#_2-2-实现事务消息本地执行和回查逻辑\",\"1443\":\"v-2b49c59c#_2-3-事务消息生产者\",\"1444\":\"v-2b49c59c#_2-4-消费者\",\"1445\":\"v-2b49c59c#_2-5-运行结果\",\"1446\":\"v-2b49c59c#_3-概要设计\",\"1447\":\"v-2b49c59c#_4-原理详解\",\"1448\":\"v-2b49c59c#_4-1-事务消息发送\",\"1449\":\"v-2b49c59c#_4-1-1-生产者发送事务消息\",\"1450\":\"v-2b49c59c#_4-1-2-broker-接收事务半消息\",\"1451\":\"v-2b49c59c#_4-1-3-broker-接收事务执行结果请求\",\"1452\":\"v-2b49c59c#_4-2-事务状态回查\",\"1453\":\"v-2b49c59c#_4-2-1-broker-回查事务状态\",\"1454\":\"v-2b49c59c#_4-2-2-生产者处理事务状态回查请求\",\"1455\":\"v-2b49c59c#_5-源码解析\",\"1456\":\"v-2b49c59c#_5-1-事务消息发送\",\"1457\":\"v-2b49c59c#_5-1-1-生产者发送事务消息\",\"1458\":\"v-2b49c59c#transactionmqproducer-sendmessageintransaction\",\"1459\":\"v-2b49c59c#defaultmqproducerimpl-sendmessageintransaction\",\"1460\":\"v-2b49c59c#transactionmqproducer-endtransaction\",\"1461\":\"v-2b49c59c#_5-1-2-broker-接收事务消息\",\"1462\":\"v-2b49c59c#sendmessageprocessor-processrequest-接收事务半消息\",\"1463\":\"v-2b49c59c#transactionmessagebridge-parsehalfmessageinner-事务消息转换成事务半消息保存\",\"1464\":\"v-2b49c59c#endtransactionprocessor-processrequest-处理-endtransaction-请求\",\"1465\":\"v-2b49c59c#_5-2-事务状态回查\",\"1466\":\"v-2b49c59c#_5-2-1-broker-回查事务状态\",\"1467\":\"v-2b49c59c#transactionalmessagecheckservice-onwaitend\",\"1468\":\"v-2b49c59c#transactionalmessageserviceimpl-check\",\"1469\":\"v-2b49c59c#abstracttransactionalmessagechecklistener-resolvehalfmsg\",\"1470\":\"v-2b49c59c#_5-2-2-producer-处理回查请求\",\"1471\":\"v-2b49c59c#clientremotingprocessor-checktransactionstate\",\"1472\":\"v-2b49c59c#defaultmqproducerimpl-checktransactionstate\",\"1473\":\"v-2b49c59c#参考资料\",\"1474\":\"v-091cf22e\",\"1475\":\"v-091cf22e#_1-背景\",\"1476\":\"v-091cf22e#_2-概要设计\",\"1477\":\"v-091cf22e#_2-1-节点状态流转\",\"1478\":\"v-091cf22e#_2-2-follower\",\"1479\":\"v-091cf22e#_2-3-leader\",\"1480\":\"v-091cf22e#_2-4-candidate\",\"1481\":\"v-091cf22e#_3-详细设计\",\"1482\":\"v-091cf22e#_3-1-类设计\",\"1483\":\"v-091cf22e#_3-2-dledgerleaderelector-逻辑\",\"1484\":\"v-091cf22e#_3-2-1-follower\",\"1485\":\"v-091cf22e#_3-2-2-leader\",\"1486\":\"v-091cf22e#_3-2-3-candidate\",\"1487\":\"v-091cf22e#_3-2-4-心跳请求\",\"1488\":\"v-091cf22e#心跳请求发送、响应处理\",\"1489\":\"v-091cf22e#心跳请求处理\",\"1490\":\"v-091cf22e#_3-2-5-拉票请求\",\"1491\":\"v-091cf22e#拉票请求发送、响应处理\",\"1492\":\"v-091cf22e#拉票请求处理\",\"1493\":\"v-091cf22e#_4-源码解析\",\"1494\":\"v-091cf22e#_4-1-状态维护\",\"1495\":\"v-091cf22e#_4-2-maintainasfollower\",\"1496\":\"v-091cf22e#_4-3-maintainasleader\",\"1497\":\"v-091cf22e#_4-3-maintainascandidate\",\"1498\":\"v-091cf22e#_4-4-心跳请求\",\"1499\":\"v-091cf22e#_4-4-1-sendheartbeats\",\"1500\":\"v-091cf22e#_4-4-2-handleheartbeat\",\"1501\":\"v-091cf22e#_4-5-拉票请求\",\"1502\":\"v-091cf22e#_4-5-1-voteforquorumresponses\",\"1503\":\"v-091cf22e#_4-5-2-handlevote\",\"1504\":\"v-091cf22e#参考资料\",\"1505\":\"v-55389f64\",\"1506\":\"v-55389f64#_1-背景\",\"1507\":\"v-55389f64#_2-概要设计\",\"1508\":\"v-55389f64#_3-详细设计\",\"1509\":\"v-55389f64#_3-1-leader-日志存储\",\"1510\":\"v-55389f64#_3-2-leader-转发日志到-follower\",\"1511\":\"v-55389f64#_3-3-follower-存储日志\",\"1512\":\"v-55389f64#_3-4-leader-仲裁日志复制结果\",\"1513\":\"v-55389f64#_4-源码解析\",\"1514\":\"v-55389f64#_4-1-dledgerentrypusher-类字段设计\",\"1515\":\"v-55389f64#_4-2-leader-日志存储\",\"1516\":\"v-55389f64#_4-2-1-dledgerserver-处理客户端-append-请求\",\"1517\":\"v-55389f64#_4-2-2-dledgerstore-保存日志到本地存储\",\"1518\":\"v-55389f64#_4-2-3-dledgerentrypusher-推送写入的日志到-follower-等待-follower-节点-ack\",\"1519\":\"v-55389f64#_4-3-entrydispatcher-将日志从-leader-转发到-follower\",\"1520\":\"v-55389f64#_4-4-entryhandler-在-follower-接收-leader-推送的请求-存储日志\",\"1521\":\"v-55389f64#_4-5-leader-的-quorumackchecker-检查日志推送到-follower-的结果\",\"1522\":\"v-55389f64#参考资料\",\"1523\":\"v-a7ffda38\",\"1524\":\"v-30f669eb\",\"1525\":\"v-30f669eb#背景\",\"1526\":\"v-30f669eb#用户态和内核态\",\"1527\":\"v-30f669eb#参考资料\",\"1528\":\"v-d2480bb6\",\"1529\":\"v-d2480bb6#_1-背景\",\"1530\":\"v-d2480bb6#_2-概述\",\"1531\":\"v-d2480bb6#_2-1-mappedfile-的创建\",\"1532\":\"v-d2480bb6#_2-2-mappedfile-的写入\",\"1533\":\"v-d2480bb6#_2-3-mappedfile-刷盘\",\"1534\":\"v-d2480bb6#_2-4\",\"1535\":\"v-d2480bb6#_3-详解\",\"1536\":\"v-d2480bb6#_4-代码\",\"1537\":\"v-d2480bb6#_5-参考资料\",\"1538\":\"v-40f554de\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,6],\"1\":[4,9],\"2\":[1,48],\"3\":[2,15],\"4\":[3,33],\"5\":[1],\"6\":[1,8],\"7\":[3,37],\"8\":[1,28],\"9\":[1,76],\"10\":[1,17],\"11\":[1,162],\"12\":[1,5],\"13\":[1,3],\"14\":[1],\"15\":[1,29],\"16\":[4,16],\"17\":[2],\"18\":[3],\"19\":[1],\"20\":[1,16],\"21\":[1,52],\"22\":[1,26],\"23\":[3,38],\"24\":[2,21],\"25\":[2,34],\"26\":[3],\"27\":[1,31],\"28\":[1,11],\"29\":[1,14],\"30\":[1,14],\"31\":[1,9],\"32\":[2],\"33\":[2,37],\"34\":[1,47],\"35\":[2],\"36\":[2,26],\"37\":[1,11],\"38\":[1,13],\"39\":[1,14],\"40\":[1,8],\"41\":[1,51],\"42\":[2],\"43\":[1,43],\"44\":[1,28],\"45\":[2],\"46\":[2,27],\"47\":[1,7],\"48\":[1,43],\"49\":[4,8],\"50\":[2],\"51\":[2],\"52\":[1,35],\"53\":[1,39],\"54\":[1,33],\"55\":[2,6],\"56\":[3,6],\"57\":[1,15],\"58\":[1,12],\"59\":[3],\"60\":[1,20],\"61\":[1,9],\"62\":[1,41],\"63\":[1,12],\"64\":[1,78],\"65\":[2,18],\"66\":[2],\"67\":[1,20],\"68\":[2,15],\"69\":[1,84],\"70\":[1,64],\"71\":[2,14],\"72\":[1,37],\"73\":[1,43],\"74\":[2,3],\"75\":[2,14],\"76\":[1,19],\"77\":[3],\"78\":[2,21],\"79\":[3],\"80\":[4],\"81\":[2,48],\"82\":[2,23],\"83\":[2,6],\"84\":[1,9],\"85\":[4,41],\"86\":[3],\"87\":[1,70],\"88\":[2],\"89\":[1,46],\"90\":[1,30],\"91\":[1,21],\"92\":[3,50],\"93\":[5,6],\"94\":[4],\"95\":[1,30],\"96\":[2,24],\"97\":[6,67],\"98\":[5,42],\"99\":[2,30],\"100\":[3],\"101\":[4,30],\"102\":[3,27],\"103\":[2,44],\"104\":[3,66],\"105\":[4,21],\"106\":[4,35],\"107\":[11,9],\"108\":[2,19],\"109\":[3,16],\"110\":[3,17],\"111\":[4,19],\"112\":[4,54],\"113\":[3,81],\"114\":[3,24],\"115\":[2,10],\"116\":[3,53],\"117\":[3,17],\"118\":[5,168],\"119\":[3,38],\"120\":[3,33],\"121\":[4,76],\"122\":[4,91],\"123\":[4,55],\"124\":[3,116],\"125\":[7,166],\"126\":[5,29],\"127\":[4,36],\"128\":[4,97],\"129\":[5,24],\"130\":[4,37],\"131\":[4,55],\"132\":[4,60],\"133\":[5,98],\"134\":[5,30],\"135\":[5,96],\"136\":[1,25],\"137\":[3,38],\"138\":[1,19],\"139\":[1,10],\"140\":[1],\"141\":[1,4],\"142\":[1,30],\"143\":[1,41],\"144\":[1,16],\"145\":[1,66],\"146\":[1],\"147\":[1,37],\"148\":[1,23],\"149\":[1,10],\"150\":[1,27],\"151\":[1,12],\"152\":[1,16],\"153\":[1,47],\"154\":[2,43],\"155\":[2,44],\"156\":[1,25],\"157\":[1,14],\"158\":[1,14],\"159\":[3,4],\"160\":[1,5],\"161\":[2,7],\"162\":[1,24],\"163\":[1,10],\"164\":[1],\"165\":[1,67],\"166\":[1,4],\"167\":[1,45],\"168\":[2,10],\"169\":[1],\"170\":[1],\"171\":[2,188],\"172\":[1,14],\"173\":[1,38],\"174\":[1,25],\"175\":[1,13],\"176\":[1,31],\"177\":[1,62],\"178\":[1,63],\"179\":[1],\"180\":[2,86],\"181\":[2,84],\"182\":[2,37],\"183\":[4,20],\"184\":[7,85],\"185\":[1,22],\"186\":[3,61],\"187\":[2,50],\"188\":[2,36],\"189\":[1,25],\"190\":[5,9],\"191\":[1,64],\"192\":[1,61],\"193\":[1,61],\"194\":[4,66],\"195\":[3,50],\"196\":[1,36],\"197\":[5],\"198\":[1],\"199\":[1],\"200\":[1,21],\"201\":[1],\"202\":[1,5],\"203\":[1,18],\"204\":[1,12],\"205\":[1,8],\"206\":[2,9],\"207\":[1,12],\"208\":[1,11],\"209\":[1,2],\"210\":[1,9],\"211\":[1,18],\"212\":[3,13],\"213\":[3,28],\"214\":[1,7],\"215\":[1,25],\"216\":[1],\"217\":[1,32],\"218\":[1,11],\"219\":[1,6],\"220\":[1],\"221\":[1],\"222\":[1],\"223\":[1,11],\"224\":[1,36],\"225\":[2],\"226\":[1],\"227\":[1,6],\"228\":[1,2],\"229\":[1,36],\"230\":[2,78],\"231\":[1,8],\"232\":[1,17],\"233\":[1,6],\"234\":[1,24],\"235\":[1,28],\"236\":[1],\"237\":[1,20],\"238\":[1,8],\"239\":[1],\"240\":[1],\"241\":[2,26],\"242\":[3],\"243\":[5,5],\"244\":[1],\"245\":[1],\"246\":[5],\"247\":[5,29],\"248\":[1,62],\"249\":[3,6],\"250\":[1],\"251\":[3,11],\"252\":[1,36],\"253\":[1,176],\"254\":[2],\"255\":[2,43],\"256\":[1,34],\"257\":[1],\"258\":[3,9],\"259\":[1,22],\"260\":[2],\"261\":[1,59],\"262\":[2,25],\"263\":[2,10],\"264\":[4,8],\"265\":[3,9],\"266\":[1,60],\"267\":[1,16],\"268\":[3,7],\"269\":[1,5],\"270\":[2,12],\"271\":[1,26],\"272\":[1,58],\"273\":[1,47],\"274\":[2,17],\"275\":[1,20],\"276\":[1,70],\"277\":[2,41],\"278\":[2,24],\"279\":[1,1],\"280\":[1,43],\"281\":[1],\"282\":[1,13],\"283\":[1,29],\"284\":[1,42],\"285\":[1,74],\"286\":[1,56],\"287\":[3,10],\"288\":[1,22],\"289\":[1,17],\"290\":[2,9],\"291\":[4,17],\"292\":[2],\"293\":[3],\"294\":[3,64],\"295\":[3,18],\"296\":[5,7],\"297\":[3,37],\"298\":[3,81],\"299\":[3,29],\"300\":[5,9],\"301\":[3,26],\"302\":[4,14],\"303\":[3,52],\"304\":[2],\"305\":[3],\"306\":[3,11],\"307\":[3,4],\"308\":[1,6],\"309\":[1,22],\"310\":[2,9],\"311\":[3,24],\"312\":[2,6],\"313\":[3,16],\"314\":[3,20],\"315\":[3,4],\"316\":[3,84],\"317\":[3,8],\"318\":[4,9],\"319\":[1,16],\"320\":[3,18],\"321\":[3,2],\"322\":[5],\"323\":[1,26],\"324\":[1,19],\"325\":[3,30],\"326\":[4,4],\"327\":[3,19],\"328\":[3],\"329\":[4,22],\"330\":[3,45],\"331\":[3,28],\"332\":[3,44],\"333\":[2,42],\"334\":[3],\"335\":[3],\"336\":[2,2],\"337\":[3,12],\"338\":[3,31],\"339\":[2,44],\"340\":[3,12],\"341\":[4,36],\"342\":[3,40],\"343\":[4,4],\"344\":[5,11],\"345\":[5,18],\"346\":[2],\"347\":[2,17],\"348\":[4,49],\"349\":[4,31],\"350\":[3,16],\"351\":[3,48],\"352\":[6,23],\"353\":[6,20],\"354\":[4,31],\"355\":[2,5],\"356\":[3,18],\"357\":[3,5],\"358\":[3,9],\"359\":[3,9],\"360\":[3,20],\"361\":[3,25],\"362\":[4],\"363\":[1,4],\"364\":[4,27],\"365\":[6,23],\"366\":[3],\"367\":[4],\"368\":[4,80],\"369\":[2,56],\"370\":[3,20],\"371\":[2,95],\"372\":[2,123],\"373\":[2,3],\"374\":[3,73],\"375\":[3,26],\"376\":[2,2],\"377\":[2],\"378\":[3,35],\"379\":[3,83],\"380\":[4,52],\"381\":[1,33],\"382\":[2,10],\"383\":[2],\"384\":[2,23],\"385\":[2,42],\"386\":[2,7],\"387\":[3,26],\"388\":[2,21],\"389\":[2],\"390\":[3,27],\"391\":[3,23],\"392\":[2,5],\"393\":[3,14],\"394\":[3,4],\"395\":[3,13],\"396\":[3,188],\"397\":[1,8],\"398\":[5,44],\"399\":[1,175],\"400\":[2,17],\"401\":[2,117],\"402\":[2,4],\"403\":[3,124],\"404\":[3],\"405\":[4,75],\"406\":[3,20],\"407\":[3,23],\"408\":[2],\"409\":[3,13],\"410\":[3],\"411\":[4,70],\"412\":[3,52],\"413\":[3,29],\"414\":[2],\"415\":[3,19],\"416\":[3,18],\"417\":[3,25],\"418\":[3],\"419\":[6,30],\"420\":[4,21],\"421\":[4,101],\"422\":[2,49],\"423\":[5,34],\"424\":[3],\"425\":[1,42],\"426\":[1,22],\"427\":[1,17],\"428\":[4,48],\"429\":[3,39],\"430\":[4],\"431\":[1,31],\"432\":[1,21],\"433\":[1,40],\"434\":[1,27],\"435\":[3,24],\"436\":[3,32],\"437\":[4],\"438\":[4,36],\"439\":[1,22],\"440\":[2,14],\"441\":[1,27],\"442\":[4,31],\"443\":[3,62],\"444\":[4],\"445\":[1,25],\"446\":[1,50],\"447\":[1,19],\"448\":[4,50],\"449\":[3,20],\"450\":[4],\"451\":[2,15],\"452\":[1,10],\"453\":[1,24],\"454\":[4,36],\"455\":[2,76],\"456\":[3],\"457\":[1,17],\"458\":[1,19],\"459\":[1,21],\"460\":[1,12],\"461\":[3,43],\"462\":[3,9],\"463\":[4],\"464\":[3,16],\"465\":[1,14],\"466\":[2,14],\"467\":[1,10],\"468\":[4,44],\"469\":[3,49],\"470\":[4],\"471\":[1,13],\"472\":[1,9],\"473\":[2,14],\"474\":[1,4],\"475\":[4,40],\"476\":[2,25],\"477\":[3,11],\"478\":[2],\"479\":[3,48],\"480\":[6,59],\"481\":[3,3],\"482\":[4,22],\"483\":[4,14],\"484\":[3,20],\"485\":[2,70],\"486\":[3,20],\"487\":[2,14],\"488\":[2,10],\"489\":[3,32],\"490\":[3,64],\"491\":[2,37],\"492\":[2,52],\"493\":[4,16],\"494\":[2],\"495\":[3,6],\"496\":[2],\"497\":[4,11],\"498\":[4,34],\"499\":[5,17],\"500\":[5,23],\"501\":[5,8],\"502\":[4,25],\"503\":[4,48],\"504\":[3,32],\"505\":[2],\"506\":[3,35],\"507\":[3],\"508\":[4,35],\"509\":[3,28],\"510\":[6],\"511\":[5,21],\"512\":[5,30],\"513\":[5,2],\"514\":[3,24],\"515\":[3,56],\"516\":[3,19],\"517\":[4,10],\"518\":[4,40],\"519\":[3,17],\"520\":[3,18],\"521\":[2,9],\"522\":[3,18],\"523\":[3,16],\"524\":[5,29],\"525\":[3,11],\"526\":[2],\"527\":[3,33],\"528\":[3,10],\"529\":[3,20],\"530\":[3],\"531\":[3,16],\"532\":[2],\"533\":[3,24],\"534\":[4,2],\"535\":[3,16],\"536\":[3,7],\"537\":[3,9],\"538\":[3,14],\"539\":[4,14],\"540\":[3,9],\"541\":[4,8],\"542\":[4,5],\"543\":[1,9],\"544\":[1,10],\"545\":[3,17],\"546\":[3,10],\"547\":[3,28],\"548\":[3,22],\"549\":[2],\"550\":[3,13],\"551\":[3,22],\"552\":[3,18],\"553\":[3,18],\"554\":[3,12],\"555\":[3,14],\"556\":[2,20],\"557\":[2],\"558\":[3,52],\"559\":[4],\"560\":[5,13],\"561\":[5,12],\"562\":[6,15],\"563\":[3,20],\"564\":[6,49],\"565\":[2],\"566\":[3,18],\"567\":[4,21],\"568\":[4,15],\"569\":[5],\"570\":[5,25],\"571\":[3,9],\"572\":[4],\"573\":[4,18],\"574\":[4,4],\"575\":[3,25],\"576\":[4,28],\"577\":[3,19],\"578\":[3,19],\"579\":[4,23],\"580\":[4,22],\"581\":[3],\"582\":[3,42],\"583\":[4,19],\"584\":[5,10],\"585\":[4,25],\"586\":[4,17],\"587\":[3,16],\"588\":[2],\"589\":[3,34],\"590\":[2],\"591\":[3,44],\"592\":[5,21],\"593\":[4,25],\"594\":[4,9],\"595\":[6,23],\"596\":[6,19],\"597\":[3,32],\"598\":[5,22],\"599\":[5,7],\"600\":[5,10],\"601\":[4,20],\"602\":[6,5],\"603\":[7,4],\"604\":[2],\"605\":[3,28],\"606\":[3,63],\"607\":[3,6],\"608\":[1,22],\"609\":[5,10],\"610\":[2],\"611\":[3,17],\"612\":[4],\"613\":[6,39],\"614\":[3,52],\"615\":[4,9],\"616\":[4,7],\"617\":[2,7],\"618\":[3,20],\"619\":[2,29],\"620\":[2],\"621\":[3,85],\"622\":[3,73],\"623\":[2,19],\"624\":[4,157],\"625\":[4,88],\"626\":[3,77],\"627\":[2,62],\"628\":[2,32],\"629\":[3,10],\"630\":[1,19],\"631\":[1,4],\"632\":[2,7],\"633\":[2,17],\"634\":[2,8],\"635\":[1,14],\"636\":[3,11],\"637\":[2,8],\"638\":[2,11],\"639\":[1,4],\"640\":[1,16],\"641\":[6,17],\"642\":[5,27],\"643\":[3,127],\"644\":[4,46],\"645\":[3,64],\"646\":[3,25],\"647\":[3,10],\"648\":[2,41],\"649\":[2,15],\"650\":[2],\"651\":[3],\"652\":[3,49],\"653\":[4,29],\"654\":[4,22],\"655\":[3,28],\"656\":[2,3],\"657\":[3,61],\"658\":[3,25],\"659\":[2,55],\"660\":[3,26],\"661\":[3],\"662\":[4,24],\"663\":[4,12],\"664\":[3,17],\"665\":[3,39],\"666\":[2],\"667\":[3],\"668\":[3,72],\"669\":[4,10],\"670\":[3],\"671\":[4,16],\"672\":[3,30],\"673\":[7,33],\"674\":[3,51],\"675\":[2,12],\"676\":[3,2],\"677\":[5,16],\"678\":[5,25],\"679\":[1,18],\"680\":[2,9],\"681\":[2,25],\"682\":[2],\"683\":[3,5],\"684\":[3,11],\"685\":[3,7],\"686\":[2],\"687\":[3,53],\"688\":[2,18],\"689\":[3,11],\"690\":[1,88],\"691\":[1,9],\"692\":[8,46],\"693\":[1,63],\"694\":[2,12],\"695\":[2,42],\"696\":[1,24],\"697\":[1],\"698\":[1,17],\"699\":[2,2],\"700\":[1,33],\"701\":[1,24],\"702\":[2,22],\"703\":[1,14],\"704\":[1,15],\"705\":[3,11],\"706\":[2],\"707\":[2,26],\"708\":[3,9],\"709\":[2],\"710\":[3,8],\"711\":[2,59],\"712\":[5,122],\"713\":[3],\"714\":[6,56],\"715\":[3,52],\"716\":[2,36],\"717\":[1,19],\"718\":[1,22],\"719\":[6,13],\"720\":[1,112],\"721\":[1],\"722\":[3,56],\"723\":[5,19],\"724\":[2,34],\"725\":[2,21],\"726\":[3,31],\"727\":[3,13],\"728\":[1,16],\"729\":[1,34],\"730\":[2,12],\"731\":[8,32],\"732\":[3,10],\"733\":[2,54],\"734\":[1,12],\"735\":[1,22],\"736\":[6,81],\"737\":[4,172],\"738\":[2,88],\"739\":[7],\"740\":[2,17],\"741\":[5,82],\"742\":[5,200],\"743\":[1,17],\"744\":[3,9],\"745\":[2],\"746\":[3,21],\"747\":[4,31],\"748\":[2],\"749\":[3,47],\"750\":[2,14],\"751\":[3,24],\"752\":[3,9],\"753\":[3,8],\"754\":[2],\"755\":[3,31],\"756\":[3,48],\"757\":[2,30],\"758\":[3,13],\"759\":[3,14],\"760\":[2,7],\"761\":[3,9],\"762\":[4,73],\"763\":[5,15],\"764\":[5,45],\"765\":[4,153],\"766\":[3,13],\"767\":[5,117],\"768\":[3,10],\"769\":[5,81],\"770\":[2,3],\"771\":[4,87],\"772\":[2],\"773\":[9,23],\"774\":[1,18],\"775\":[3,9],\"776\":[2],\"777\":[2,13],\"778\":[3,12],\"779\":[2],\"780\":[3,28],\"781\":[2,14],\"782\":[3,10],\"783\":[3,4],\"784\":[2],\"785\":[3,5],\"786\":[3,51],\"787\":[4,102],\"788\":[3],\"789\":[1,92],\"790\":[1,28],\"791\":[2],\"792\":[3],\"793\":[3,126],\"794\":[4,140],\"795\":[4,4],\"796\":[3,30],\"797\":[3,175],\"798\":[1,11],\"799\":[4,10],\"800\":[2,5],\"801\":[2,10],\"802\":[4,10],\"803\":[4,15],\"804\":[4,27],\"805\":[3,24],\"806\":[2,64],\"807\":[2],\"808\":[3],\"809\":[3,11],\"810\":[4,7],\"811\":[4,13],\"812\":[3,66],\"813\":[2],\"814\":[3,45],\"815\":[3,69],\"816\":[3,20],\"817\":[2],\"818\":[3],\"819\":[3,83],\"820\":[4,76],\"821\":[3],\"822\":[4,39],\"823\":[3,54],\"824\":[4,52],\"825\":[3,127],\"826\":[4],\"827\":[4,52],\"828\":[5,28],\"829\":[1,13],\"830\":[4,10],\"831\":[2],\"832\":[2,9],\"833\":[3,38],\"834\":[2,45],\"835\":[2,29],\"836\":[3,59],\"837\":[3,13],\"838\":[2],\"839\":[3,29],\"840\":[3,43],\"841\":[2,32],\"842\":[2],\"843\":[3,77],\"844\":[3,66],\"845\":[4,206],\"846\":[2],\"847\":[4,14],\"848\":[4,17],\"849\":[8,14],\"850\":[2,43],\"851\":[2],\"852\":[3,35],\"853\":[5,18],\"854\":[3,19],\"855\":[2,36],\"856\":[2,8],\"857\":[3,47],\"858\":[3,27],\"859\":[2],\"860\":[3,200],\"861\":[3,126],\"862\":[3,11],\"863\":[2,12],\"864\":[2,27],\"865\":[2],\"866\":[3,81],\"867\":[3,17],\"868\":[2,20],\"869\":[2,46],\"870\":[3,207],\"871\":[3,52],\"872\":[3,88],\"873\":[3,10],\"874\":[1,25],\"875\":[3],\"876\":[2,20],\"877\":[2,22],\"878\":[3,26],\"879\":[5,70],\"880\":[2,70],\"881\":[2,22],\"882\":[2,127],\"883\":[3,57],\"884\":[1,18],\"885\":[7,13],\"886\":[1,147],\"887\":[1,16],\"888\":[6,22],\"889\":[7,20],\"890\":[1,73],\"891\":[1,34],\"892\":[3,17],\"893\":[1,35],\"894\":[1,151],\"895\":[4,6],\"896\":[1,31],\"897\":[1,41],\"898\":[4,5],\"899\":[1,29],\"900\":[1,49],\"901\":[5,10],\"902\":[1,24],\"903\":[1,19],\"904\":[5,77],\"905\":[6,13],\"906\":[4,67],\"907\":[6,8],\"908\":[1,13],\"909\":[1,12],\"910\":[13,35],\"911\":[1,11],\"912\":[1,30],\"913\":[8,44],\"914\":[1,20],\"915\":[2,77],\"916\":[2,32],\"917\":[1,51],\"918\":[2,11],\"919\":[1,28],\"920\":[2,26],\"921\":[1,34],\"922\":[1,61],\"923\":[1,17],\"924\":[1,35],\"925\":[1,98],\"926\":[1,10],\"927\":[1,62],\"928\":[1,50],\"929\":[1,6],\"930\":[1,45],\"931\":[1,67],\"932\":[1,46],\"933\":[1,19],\"934\":[1,15],\"935\":[1,31],\"936\":[1,11],\"937\":[3,12],\"938\":[1,12],\"939\":[4,9],\"940\":[2],\"941\":[3,60],\"942\":[5,72],\"943\":[2,8],\"944\":[3,74],\"945\":[2,59],\"946\":[2],\"947\":[4,50],\"948\":[3],\"949\":[5,54],\"950\":[3,52],\"951\":[2,10],\"952\":[4,54],\"953\":[4,32],\"954\":[3,52],\"955\":[5,10],\"956\":[4,17],\"957\":[5,29],\"958\":[2],\"959\":[4],\"960\":[3,188],\"961\":[5,126],\"962\":[3],\"963\":[5,6],\"964\":[1,48],\"965\":[1,22],\"966\":[1,10],\"967\":[1,44],\"968\":[3,58],\"969\":[3],\"970\":[5,111],\"971\":[5,174],\"972\":[2,134],\"973\":[3,95],\"974\":[1,16],\"975\":[5,9],\"976\":[2,37],\"977\":[2],\"978\":[3,76],\"979\":[2,20],\"980\":[3,21],\"981\":[3,16],\"982\":[3],\"983\":[5,88],\"984\":[3,75],\"985\":[3,72],\"986\":[2,13],\"987\":[4,15],\"988\":[4,24],\"989\":[5,16],\"990\":[6,58],\"991\":[3,24],\"992\":[2],\"993\":[4],\"994\":[4,65],\"995\":[5,105],\"996\":[6,109],\"997\":[5,76],\"998\":[4,158],\"999\":[5,131],\"1000\":[4,129],\"1001\":[1,17],\"1002\":[2,9],\"1003\":[2,26],\"1004\":[2,19],\"1005\":[4,20],\"1006\":[2,46],\"1007\":[3,51],\"1008\":[5,49],\"1009\":[6,4],\"1010\":[2,33],\"1011\":[3,7],\"1012\":[3,25],\"1013\":[2],\"1014\":[3,22],\"1015\":[3,10],\"1016\":[2],\"1017\":[3,101],\"1018\":[3,1],\"1019\":[4,51],\"1020\":[3,138],\"1021\":[3,223],\"1022\":[1,11],\"1023\":[3,10],\"1024\":[2,20],\"1025\":[2,33],\"1026\":[3],\"1027\":[3,51],\"1028\":[3,37],\"1029\":[2,27],\"1030\":[3,31],\"1031\":[3],\"1032\":[4,12],\"1033\":[4,9],\"1034\":[2],\"1035\":[3,24],\"1036\":[3,44],\"1037\":[2,31],\"1038\":[3,12],\"1039\":[6,49],\"1040\":[4,26],\"1041\":[4,39],\"1042\":[3,35],\"1043\":[4,26],\"1044\":[6,20],\"1045\":[2],\"1046\":[3],\"1047\":[4,114],\"1048\":[4,115],\"1049\":[3],\"1050\":[4,135],\"1051\":[3,33],\"1052\":[4,94],\"1053\":[5,283],\"1054\":[4],\"1055\":[5,37],\"1056\":[4,169],\"1057\":[1,14],\"1058\":[3,10],\"1059\":[1],\"1060\":[1],\"1061\":[1,24],\"1062\":[1],\"1063\":[1],\"1064\":[1],\"1065\":[1,29],\"1066\":[1,4],\"1067\":[1,12],\"1068\":[10,10],\"1069\":[1,18],\"1070\":[1,18],\"1071\":[1,7],\"1072\":[4,54],\"1073\":[1,37],\"1074\":[3,59],\"1075\":[5,152],\"1076\":[5,13],\"1077\":[5,62],\"1078\":[5,43],\"1079\":[5,143],\"1080\":[1,110],\"1081\":[4,41],\"1082\":[2],\"1083\":[3,11],\"1084\":[5,16],\"1085\":[4,11],\"1086\":[2,23],\"1087\":[2],\"1088\":[3,10],\"1089\":[3,15],\"1090\":[5,38],\"1091\":[6,18],\"1092\":[2],\"1093\":[3,6],\"1094\":[2,28],\"1095\":[3,46],\"1096\":[3,7],\"1097\":[4,22],\"1098\":[5,16],\"1099\":[3],\"1100\":[5,37],\"1101\":[3,6],\"1102\":[3,43],\"1103\":[3,42],\"1104\":[2,70],\"1105\":[1,31],\"1106\":[5,13],\"1107\":[2,7],\"1108\":[2],\"1109\":[3,28],\"1110\":[2,7],\"1111\":[3,14],\"1112\":[2,16],\"1113\":[2],\"1114\":[3],\"1115\":[3],\"1116\":[4,27],\"1117\":[4,76],\"1118\":[4,31],\"1119\":[4,64],\"1120\":[3,76],\"1121\":[2],\"1122\":[4,146],\"1123\":[4,81],\"1124\":[6,11],\"1125\":[2,13],\"1126\":[2,14],\"1127\":[2,7],\"1128\":[3,38],\"1129\":[2,20],\"1130\":[3,19],\"1131\":[2,14],\"1132\":[4,3],\"1133\":[3,19],\"1134\":[4,21],\"1135\":[3],\"1136\":[4,87],\"1137\":[3,65],\"1138\":[2,23],\"1139\":[2],\"1140\":[4,30],\"1141\":[4],\"1142\":[5,49],\"1143\":[6,116],\"1144\":[5,149],\"1145\":[3,92],\"1146\":[6,12],\"1147\":[2,24],\"1148\":[2],\"1149\":[3,17],\"1150\":[2],\"1151\":[3,6],\"1152\":[2,23],\"1153\":[4,8],\"1154\":[2],\"1155\":[3,60],\"1156\":[3,14],\"1157\":[4],\"1158\":[4,15],\"1159\":[4,25],\"1160\":[4,11],\"1161\":[5,6],\"1162\":[4],\"1163\":[4,23],\"1164\":[3,17],\"1165\":[3,15],\"1166\":[2],\"1167\":[3],\"1168\":[4,63],\"1169\":[5,29],\"1170\":[4,246],\"1171\":[3,136],\"1172\":[4,40],\"1173\":[4,438],\"1174\":[4,250],\"1175\":[4,163],\"1176\":[7,12],\"1177\":[2,16],\"1178\":[2],\"1179\":[3,36],\"1180\":[2,30],\"1181\":[3,15],\"1182\":[4,8],\"1183\":[3,18],\"1184\":[3,4],\"1185\":[2],\"1186\":[3],\"1187\":[3,49],\"1188\":[4,129],\"1189\":[3],\"1190\":[4,35],\"1191\":[3,48],\"1192\":[2],\"1193\":[3],\"1194\":[3,73],\"1195\":[5,244],\"1196\":[3],\"1197\":[6,130],\"1198\":[4,265],\"1199\":[3],\"1200\":[4,126],\"1201\":[5,86],\"1202\":[6,12],\"1203\":[2,58],\"1204\":[2,8],\"1205\":[3],\"1206\":[3,18],\"1207\":[3,19],\"1208\":[2,10],\"1209\":[4,32],\"1210\":[2],\"1211\":[3],\"1212\":[3,37],\"1213\":[4,9],\"1214\":[3,31],\"1215\":[5,31],\"1216\":[3],\"1217\":[4,18],\"1218\":[3,33],\"1219\":[2,18],\"1220\":[2],\"1221\":[3],\"1222\":[4,81],\"1223\":[5],\"1224\":[4,157],\"1225\":[4,80],\"1226\":[5,81],\"1227\":[3],\"1228\":[4,95],\"1229\":[3,77],\"1230\":[3,201],\"1231\":[2,10],\"1232\":[1],\"1233\":[1,20],\"1234\":[1,29],\"1235\":[1,58],\"1236\":[1],\"1237\":[1,16],\"1238\":[1,10],\"1239\":[1,9],\"1240\":[3,27],\"1241\":[1,42],\"1242\":[1,6],\"1243\":[7,12],\"1244\":[2],\"1245\":[4,34],\"1246\":[5,14],\"1247\":[3,51],\"1248\":[3,107],\"1249\":[5,57],\"1250\":[2,17],\"1251\":[4,58],\"1252\":[3,28],\"1253\":[3,78],\"1254\":[2],\"1255\":[4,48],\"1256\":[6],\"1257\":[4,45],\"1258\":[4,40],\"1259\":[5,29],\"1260\":[5,24],\"1261\":[8,25],\"1262\":[4,47],\"1263\":[5,62],\"1264\":[2],\"1265\":[4],\"1266\":[4,139],\"1267\":[5,103],\"1268\":[6],\"1269\":[5,148],\"1270\":[4,187],\"1271\":[5,70],\"1272\":[6],\"1273\":[5,144],\"1274\":[7],\"1275\":[4,76],\"1276\":[4,104],\"1277\":[4,158],\"1278\":[3,201],\"1279\":[4,105],\"1280\":[4,162],\"1281\":[1,20],\"1282\":[9,11],\"1283\":[2],\"1284\":[2,43],\"1285\":[3],\"1286\":[4,14],\"1287\":[3,75],\"1288\":[4,84],\"1289\":[2],\"1290\":[3,47],\"1291\":[3,36],\"1292\":[2],\"1293\":[3,24],\"1294\":[5,64],\"1295\":[2,6],\"1296\":[5,100],\"1297\":[4,184],\"1298\":[1,13],\"1299\":[5,98],\"1300\":[4,131],\"1301\":[7,9],\"1302\":[2],\"1303\":[3,18],\"1304\":[3],\"1305\":[4,8],\"1306\":[1,34],\"1307\":[1,33],\"1308\":[3,81],\"1309\":[1,39],\"1310\":[1,30],\"1311\":[2],\"1312\":[3,10],\"1313\":[2,15],\"1314\":[4,33],\"1315\":[3,45],\"1316\":[2],\"1317\":[3,28],\"1318\":[3,94],\"1319\":[3,47],\"1320\":[4],\"1321\":[6,70],\"1322\":[5,34],\"1323\":[3,74],\"1324\":[3,23],\"1325\":[6,40],\"1326\":[2],\"1327\":[4],\"1328\":[4,54],\"1329\":[4,61],\"1330\":[4],\"1331\":[4,95],\"1332\":[3,126],\"1333\":[4,154],\"1334\":[1,15],\"1335\":[8,9],\"1336\":[2],\"1337\":[2,38],\"1338\":[3,47],\"1339\":[3,42],\"1340\":[2],\"1341\":[3,10],\"1342\":[4,32],\"1343\":[4,12],\"1344\":[5,13],\"1345\":[2],\"1346\":[3,61],\"1347\":[3,27],\"1348\":[3,33],\"1349\":[2],\"1350\":[3,6],\"1351\":[4,36],\"1352\":[5,51],\"1353\":[3,15],\"1354\":[4,23],\"1355\":[2,14],\"1356\":[3,16],\"1357\":[3,10],\"1358\":[2,23],\"1359\":[2,31],\"1360\":[2,24],\"1361\":[2],\"1362\":[3,27],\"1363\":[5,20],\"1364\":[3,58],\"1365\":[2],\"1366\":[3],\"1367\":[3,67],\"1368\":[4,74],\"1369\":[3],\"1370\":[6,140],\"1371\":[5,236],\"1372\":[6,179],\"1373\":[5,135],\"1374\":[6,101],\"1375\":[1,22],\"1376\":[9,9],\"1377\":[2],\"1378\":[2,17],\"1379\":[3,13],\"1380\":[3,24],\"1381\":[2],\"1382\":[4,109],\"1383\":[2,52],\"1384\":[2],\"1385\":[3,49],\"1386\":[3,62],\"1387\":[2,22],\"1388\":[3,36],\"1389\":[3],\"1390\":[4,31],\"1391\":[4,20],\"1392\":[3],\"1393\":[4,45],\"1394\":[4,42],\"1395\":[3,39],\"1396\":[2,6],\"1397\":[3,12],\"1398\":[3,25],\"1399\":[4],\"1400\":[1,16],\"1401\":[1,12],\"1402\":[3,96],\"1403\":[3,146],\"1404\":[2,16],\"1405\":[4,44],\"1406\":[3,14],\"1407\":[4,16],\"1408\":[1,26],\"1409\":[1,21],\"1410\":[3,20],\"1411\":[3,17],\"1412\":[4,59],\"1413\":[4,8],\"1414\":[1,37],\"1415\":[1,45],\"1416\":[4],\"1417\":[5,56],\"1418\":[5,41],\"1419\":[3,11],\"1420\":[4,88],\"1421\":[4,48],\"1422\":[2],\"1423\":[3],\"1424\":[5,69],\"1425\":[6,76],\"1426\":[3],\"1427\":[6,334],\"1428\":[5,109],\"1429\":[3],\"1430\":[6,136],\"1431\":[6,115],\"1432\":[5,184],\"1433\":[3],\"1434\":[7,138],\"1435\":[7,281],\"1436\":[9,253],\"1437\":[1,42],\"1438\":[3,10],\"1439\":[2,33],\"1440\":[2,8],\"1441\":[4,26],\"1442\":[2,72],\"1443\":[3,93],\"1444\":[3,67],\"1445\":[3,156],\"1446\":[2,76],\"1447\":[2],\"1448\":[3],\"1449\":[3,38],\"1450\":[5,27],\"1451\":[5,44],\"1452\":[3],\"1453\":[5,103],\"1454\":[3,9],\"1455\":[2],\"1456\":[3],\"1457\":[3],\"1458\":[2,46],\"1459\":[2,142],\"1460\":[2,94],\"1461\":[5],\"1462\":[3,128],\"1463\":[3,73],\"1464\":[5,171],\"1465\":[3],\"1466\":[5],\"1467\":[2,67],\"1468\":[2,393],\"1469\":[2,95],\"1470\":[4],\"1471\":[2,74],\"1472\":[2,151],\"1473\":[1,12],\"1474\":[6,11],\"1475\":[2,35],\"1476\":[2],\"1477\":[3,39],\"1478\":[2,21],\"1479\":[3,32],\"1480\":[3,46],\"1481\":[2,26],\"1482\":[3,55],\"1483\":[4,19],\"1484\":[4,8],\"1485\":[3,5],\"1486\":[3,13],\"1487\":[4],\"1488\":[2,26],\"1489\":[1,28],\"1490\":[4],\"1491\":[2,35],\"1492\":[1,42],\"1493\":[2],\"1494\":[3],\"1495\":[3,36],\"1496\":[3,37],\"1497\":[3,240],\"1498\":[2],\"1499\":[3,181],\"1500\":[3,133],\"1501\":[3],\"1502\":[4,56],\"1503\":[4,136],\"1504\":[1,23],\"1505\":[5,11],\"1506\":[2,36],\"1507\":[2,66],\"1508\":[2,71],\"1509\":[4,60],\"1510\":[5,142],\"1511\":[3,94],\"1512\":[4,34],\"1513\":[2],\"1514\":[4,79],\"1515\":[4],\"1516\":[7,165],\"1517\":[4,135],\"1518\":[9,73],\"1519\":[7,539],\"1520\":[8,356],\"1521\":[8,263],\"1522\":[1,21],\"1523\":[2,35],\"1524\":[5,11],\"1525\":[1],\"1526\":[1],\"1527\":[1,36],\"1528\":[6,9],\"1529\":[2,4],\"1530\":[2],\"1531\":[4],\"1532\":[3],\"1533\":[4],\"1534\":[2],\"1535\":[2],\"1536\":[2],\"1537\":[2,20],\"1538\":[1,81]},\"averageFieldLength\":[2.876543209876543,41.02405563319034],\"storedFields\":{\"0\":{\"h\":\"\",\"t\":[\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1\":{\"h\":\"Java 性能优化神器 JMH 从入门到精通\",\"t\":[\"原文地址：http://hscarb.github.io/java/20220427-jmh.html\"]},\"2\":{\"h\":\"背景\",\"t\":[\"你在写 Java 高性能程序时有没有这样的场景：\",\"纠结使用 ArrayList 还是 LinkedList 哪个更快？\",\"进行运算时，怎么提高效率？使用 int 还是 long？\",\"读写文件时，使用 FileChannel 还是 MappedByteBuffer 更快？\",\"使用锁还是 synchronized？\",\"使用 AtomicLong 还是 LongAdder 更快？\",\"……\",\"特别是在写性能要求高的程序时，这些问题会更频繁地出现。有时上网查询可以找到答案，但是当遇到更复杂、独特的场景时可能就需要自己进行性能压测。\",\"自己写一个测试方法或者 Main 函数固然也可以，但是有没有更【专业】的工具？我们的神器 JMH 闪亮登场。\",\"JMH 是 Java Microbenchmark Harness 的缩写，官方介绍如下：\",\"JMH 是 OpenJDK 提供的 JVM 基准测试工具，用于测试 Java 和其他跑在 JVM 上语言程序的性能。\"]},\"3\":{\"h\":\"JMH 的意义\",\"t\":[\"当对一个程序的一小部分代码或者一个函数进行基准测试时，JVM 或底层硬件可能对这部分测试代码进行许多优化，但当这部分代码作为较大程序的一部分时可能无法应用这些优化。\",\"自己实现基准测试代码时，编写的测试代码可能有缺陷。比如缺乏预热的步骤。\",\"使用 JMH，你可以使用它提供的一系列注解轻松地编写基准测试代码。并且它通常会阻止 JVM 和硬件在基准测试时执行优化。此外它还能提供简单明了的基准测试结果输出，使用一些工具可以对该结果进行可视化。\"]},\"4\":{\"h\":\"JMH 如何工作？\",\"t\":[\"应用 JMH 注解的代码在编译之后会被编译成多个执行类以进行基准测试结果输出。\",\"JMH 按照如上所示的流程进行基准测试。\",\"Fork 为一个新的进程，如果设置用多个进程执行，则各个线程串行执行。\",\"每个线程中先执行预热（Warmup），然后再执行测试（Measurement）。在预热和测试执行过程中，每一轮测试称为一个迭代（Iteration），一个迭代也是测试数据统计的最小单元。在 @Warmup 和 @Measurement 注解中可以指定执行的迭代次数和每次迭代的执行时常。\",\"每个迭代中会根据基准测试的模式（@BenchmarkMode）来调用（Invoke）测试方法，可能一次也可能多次，并计算该测试模式所关注的指标。\",\"可以看到在每次测试前后、每次迭代前后、甚至每次调用方法前后都可以用 @Setup 和 @TearDown 注解来设置启动和停止的方法。\"]},\"5\":{\"h\":\"快速开始\"},\"6\":{\"h\":\"安装插件\",\"t\":[\"使用 JMH 前最好先安装一下配套的 idea 插件。\",\"它可以帮助解析 JMH 的注解。\"]},\"7\":{\"h\":\"使用 Maven archtype\",\"t\":[\"官方推荐的使用方法是使用 Maven archtype 构建项目，这样可以自动生成基准测试代码，打包之后也自带可以运行基准测试代码的 benchmark.jar 包。由于可能需要在 Linux 上测试，所以这个 jar 包十分有用。\",\"运行如下代码使用 maven archtype 构建项目。\",\"mvn archetype:generate \\\\ -DinteractiveMode=false \\\\ -DarchetypeGroupId=org.openjdk.jmh \\\\ -DarchetypeArtifactId=jmh-java-benchmark-archetype \\\\ -DgroupId=org.sample \\\\ -DartifactId=test \\\\ -Dversion=1.0 \",\"如果使用 idea，可以使用 idea 添加 Archtype 后创建。\"]},\"8\":{\"h\":\"引入依赖\",\"t\":[\"JMH 在 JDK9 之后的版本已经原生支持。在 JDK9 之前的版本需要引入依赖。当前最新的版本为 1.35。如果已经使用 Archtype 方式构建项目，那么无需额外引入依赖。\",\"<dependency> <groupId>org.openjdk.jmh</groupId> <artifactId>jmh-core</artifactId> <version>1.35</version> </dependency> <dependency> <groupId>org.openjdk.jmh</groupId> <artifactId>jmh-generator-annprocess</artifactId> <version>1.35</version> </dependency> \"]},\"9\":{\"h\":\"编写测试代码\",\"t\":[\"使用 Archtype 构建的项目已经写好了 MyBenchmark 类，可以直接运行空测试函数。\",\"我们编写代码来测试一下 ArrayList 和 LinkedList 添加数据的性能。假设需要测试分别向两种列表中添加 1000w 数据。\",\"// 使用一个进程来运行测试，如果大于 1，多进程串行执行 @Fork(1) // 类变量的作用域，这里指 linkedList 和 arrayList 在同一个测试类中共享 @State(Scope.Benchmark) // 预热执行 5 次，每次 1 秒 @Warmup(iterations = 5, time = 1) // 测试执行 5 次，每次 1 秒次 @Measurement(iterations = 5, time = 1) // 测试模式为计算测试方法的吞吐量（每秒执行次数） @BenchmarkMode(Mode.Throughput) // 用例计时和输出的时间单位 @OutputTimeUnit(TimeUnit.MILLISECONDS) public class MyBenchmark { private LinkedList<Integer> linkedList; private ArrayList<Integer> arrayList; // 初始化方法，在每次调用测试方法之前执行，类似 JUnit // Level 表示该方法运行的时机，Iteration 表示每次测试都会执行（包括预热） @Setup(Level.Iteration) public void setup() { linkedList = new LinkedList<>(); arrayList = new ArrayList<>(); } // 测试方法，类似 JUnit @Test。标注了 @Benchmark 的方法会被进行基准测试 @Benchmark public void testArrayList() { arrayList.add(1); } @Benchmark public void testLinkedList() { linkedList.add(1); } } \"]},\"10\":{\"h\":\"运行测试\",\"t\":[\"在 idea 安装插件的情况下可以直接运行测试。\",\"另一种方式，可以通过 Archtype 的 benchmark.jar 来运行测试。\",\"mvn clean verify \",\"java -jar target/benchmarks.jar \"]},\"11\":{\"h\":\"查看结果\",\"t\":[\"# JMH version: 1.35 # Blackhole mode: full + dont-inline hint (auto-detected, use -Djmh.blackhole.autoDetect=false to disable) # Warmup: 5 iterations, 1 s each // 预热 5 次，每次 1 秒 # Measurement: 5 iterations, 1 s each // 测试 5 次，每次 1 秒 # Timeout: 10 min per iteration // 每次执行测试方法的超时时间为 10 分钟 # Threads: 1 thread, will synchronize iterations // 单线程执行 # Benchmark mode: Throughput, ops/time // 测试模式：吞吐量，统计每秒操作数 # Benchmark: org.example.MyBenchmark.testArrayList // 本次测试的测试方法 # Run progress: 0.00% complete, ETA 00:00:20 # Fork: 1 of 1 // 第一个进程执行测试 # Warmup Iteration 1: 141579.663 ops/ms // 每次预热耗时 # Warmup Iteration 2: 13048.155 ops/ms # Warmup Iteration 3: 126507.754 ops/ms # Warmup Iteration 4: 127890.530 ops/ms # Warmup Iteration 5: 152379.871 ops/ms Iteration 1: 149509.372 ops/ms // 每次测试执行耗时 Iteration 2: 147695.938 ops/ms Iteration 3: 100544.988 ops/ms Iteration 4: 169084.449 ops/ms Iteration 5: 177057.200 ops/ms Result \\\"org.example.MyBenchmark.testArrayList\\\": 148778.389 ±(99.9%) 114555.755 ops/ms [Average] (min, avg, max) = (100544.988, 148778.389, 177057.200), stdev = 29749.766 CI (99.9%): [34222.635, 263334.144] (assumes normal distribution) # ... # Benchmark: org.example.MyBenchmark.testLinkedList # Run progress: 50.00% complete, ETA 00:00:13 # Fork: 1 of 1 # Warmup Iteration 1: 3997.950 ops/ms # Warmup Iteration 2: 9656.378 ops/ms # Warmup Iteration 3: 9767.753 ops/ms # Warmup Iteration 4: 8815.672 ops/ms # Warmup Iteration 5: 47451.551 ops/ms Iteration 1: 21131.024 ops/ms Iteration 2: 9101.728 ops/ms Iteration 3: 28116.765 ops/ms Iteration 4: 8994.693 ops/ms Iteration 5: 28290.489 ops/ms Result \\\"org.example.MyBenchmark.testLinkedList\\\": 19126.940 ±(99.9%) 37132.831 ops/ms [Average] (min, avg, max) = (8994.693, 19126.940, 28290.489), stdev = 9643.278 CI (99.9%): [≈ 0, 56259.771] (assumes normal distribution) # Run complete. Total time: 00:00:40 // 所有测试执行完毕，耗时 // 测试结果，Mode 表示测试模式，thrpt 表示模式为 Throughput // Score 表示平均耗时，Error 表示误差 Benchmark Mode Cnt Score Error Units MyBenchmark.testArrayList thrpt 5 148778.389 ± 114555.755 ops/ms MyBenchmark.testLinkedList thrpt 5 19126.940 ± 37132.831 ops/ms \"]},\"12\":{\"h\":\"注释详解\",\"t\":[\"这个图片可以帮助快速查阅 JMH 各个注解的含义和用法。\",\"具体的解析可以看 关键注解\"]},\"13\":{\"h\":\"高级用法\",\"t\":[\"详见 基准测试神器JMH —— 详解36个官方例子\"]},\"14\":{\"h\":\"将结果图形化\"},\"15\":{\"h\":\"参考资料\",\"t\":[\"JAVA 拾遗 — JMH 与 8 个测试陷阱\",\"JMH - Java 微基准测试工具（自助性能测试）@Benchmark\",\"顶级Java才懂的，基准测试JMH！\",\"JUC学习笔记 - 08JMH入门\",\"基准测试神器JMH —— 详解36个官方例子\",\"性能调优必备利器之 JMH\",\"JMH - Java Microbenchmark Harness\",\"JMH Cheatsheet\",\"Understanding Java Microbenchmark Harness or JMH Tool\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"16\":{\"h\":\"廖雪峰 Java 教程 笔记\",\"t\":[\"原文地址：http://hscarb.github.io/java/20230530-lxf-java-note.html\",\"https://www.liaoxuefeng.com/wiki/1252599548343744\"]},\"17\":{\"h\":\"2. 面向对象编程\"},\"18\":{\"h\":\"2.1 面向对象基础\"},\"19\":{\"h\":\"包\"},\"20\":{\"h\":\"编译器查找类的步骤\",\"t\":[\"Java编译器最终编译出的.class文件只使用完整类名，因此，在代码中，当编译器遇到一个class名称时：\",\"如果是完整类名，就直接根据完整类名查找这个class；\",\"如果是简单类名，按下面的顺序依次查找： \",\"查找当前package是否存在这个class；\",\"查找import的包是否包含这个class；\",\"查找java.lang包是否包含这个class。\",\"如果按照上面的规则还无法确定类名，则编译报错。\"]},\"21\":{\"h\":\"编译和运行\",\"t\":[\"work ├── bin └── src └── com └── itranswarp ├── sample │ └── Main.java └── world └── Person.java \",\"其中，bin目录用于存放编译后的class文件，src目录按包结构存放Java源码，我们怎么一次性编译这些Java源码呢？\",\"首先，确保当前目录是work目录，即存放src和bin的父目录：\",\"$ ls bin src \",\"然后，编译src目录下的所有Java文件：\",\"$ javac -d ./bin src/**/*.java \",\"命令行-d指定输出的class文件存放bin目录，后面的参数src/**/*.java表示src目录下的所有.java文件，包括任意深度的子目录。\",\"注意：Windows不支持**这种搜索全部子目录的做法，所以在Windows下编译必须依次列出所有.java文件：\",\"C:\\\\work> javac -d bin src\\\\com\\\\itranswarp\\\\sample\\\\Main.java src\\\\com\\\\itranswarp\\\\world\\\\Persion.java \",\"如果编译无误，则javac命令没有任何输出。可以在bin目录下看到如下class文件：\",\"bin └── com └── itranswarp ├── sample │ └── Main.class └── world └── Person.class \",\"现在，我们就可以直接运行class文件了。根据当前目录的位置确定classpath，例如，当前目录仍为work，则classpath为bin或者./bin：\",\"$ java -cp bin com.itranswarp.sample.Main Hello, world! \"]},\"22\":{\"h\":\"内部类\",\"t\":[\"Inner Class的实例不能单独存在，必须依附于一个Outer Class\",\" Outer outer = new Outer(\\\"Nested\\\"); // 实例化一个Outer Outer.Inner inner = outer.new Inner(); // 实例化一个Inner \",\"Outer类被编译为Outer.class，而Inner类被编译为Outer$Inner.class。匿名类被编译为Outer$1.class。如果有多个匿名类，Java编译器会将每个匿名类依次命名为Outer$1、Outer$2、Outer$3……\",\"静态内部类不再依附于Outer的实例，而是一个完全独立的类，因此无法引用Outer.this，但它可以访问Outer的private静态字段和静态方法。\"]},\"23\":{\"h\":\"classpath 和 jar\",\"t\":[\"classpath是JVM用到的一个环境变量，它用来指示JVM如何搜索class。JVM需要知道，如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件。\",\"假设classpath是.;C:\\\\work\\\\project1\\\\bin;C:\\\\shared，当JVM在加载abc.xyz.Hello这个类时，会依次查找：\",\"<当前目录>\\\\abc\\\\xyz\\\\Hello.class\",\"C:\\\\work\\\\project1\\\\bin\\\\abc\\\\xyz\\\\Hello.class\",\"C:\\\\shared\\\\abc\\\\xyz\\\\Hello.class\",\"classpath的设定方法有两种：\",\"在系统环境变量中设置classpath环境变量，不推荐；\",\"在启动JVM时设置classpath变量，推荐。（实际上就是给java命令传入-classpath或-cp参数）\",\"不要设置classpath！默认的当前目录.对于绝大多数情况都够用了。\",\"不要把任何Java核心库添加到classpath中！（如 rt.jar）JVM根本不依赖classpath加载核心库！\"]},\"24\":{\"h\":\"jar 包\",\"t\":[\"jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的class，就可以把jar包放到classpath中\",\"jar包还可以包含一个特殊的/META-INF/MANIFEST.MF文件，MANIFEST.MF是纯文本，可以指定Main-Class和其它信息。JVM会自动读取这个MANIFEST.MF文件，如果存在Main-Class，我们就不必在命令行指定启动的类名，而是用更方便的命令：\",\"java -jar hello.jar \"]},\"25\":{\"h\":\"class 版本\",\"t\":[\"每个版本的JVM，它能执行的class文件版本也不同。例如，Java 11对应的class文件版本是55，而Java 17对应的class文件版本是61。（最多支持到版本61）\",\"可以用Java 17编译一个Java程序，指定输出的class版本要兼容Java 11（即class版本55）。\",\"在javac命令行中用参数--release设置：\",\"$ javac --release 11 Main.java \",\"用参数--source指定源码版本，用参数--target指定输出class版本：\",\"$ javac --source 9 --target 11 Main.java \",\"​ （如果使用Java 17的JDK编译，它会把源码视为Java 9兼容版本，并输出class为Java 11兼容版本。）\"]},\"26\":{\"h\":\"2.2 Java 核心类\"},\"27\":{\"h\":\"字符串和编码\",\"t\":[\"ASCII：美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从0到127，最高位始终为0，称为ASCII编码。例如，字符'A'的编码是0x41，字符'1'的编码是0x31。\",\"GB2312：使用两个字节表示一个汉字，其中第一个字节的最高位始终为1，以便和ASCII编码区分开。例如，汉字'中'的GB2312编码是0xd6d0。\",\"Unicode：为了统一全球所有语言的编码，全球统一码联盟发布了Unicode编码，它把世界上主要语言都纳入同一个编码。\"]},\"28\":{\"h\":\"StringBuilder\",\"t\":[\"StringBuilder，它是一个可变对象，可以预分配缓冲区，往StringBuilder中新增字符时，不会创建新的临时对象。\",\"对于普通的字符串+操作，并不需要我们将其改写为StringBuilder，因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作。\"]},\"29\":{\"h\":\"StringJoiner\",\"t\":[\"StringJoiner：分隔符拼接数组，可以指定开头和结尾。\",\"String还提供了一个静态方法join()，这个方法在内部使用了StringJoiner来拼接字符串，在不需要指定“开头”和“结尾”的时候，用String.join()更方便。\"]},\"30\":{\"h\":\"包装类型\",\"t\":[\"Java的数据类型分两种：基本类型和引用类型。包装类型可以把基本类型变成引用类型。\",\"Java编译器直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。\",\"自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。\"]},\"31\":{\"h\":\"枚举类\",\"t\":[\"enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较\",\"通过name()获取常量定义的字符串，注意不要使用toString()\",\"通过ordinal()返回常量定义的顺序（无实质意义）\"]},\"32\":{\"h\":\"3. 异常处理\"},\"33\":{\"h\":\"Java 的异常\",\"t\":[\" ┌───────────┐ │ Object │ └───────────┘ ▲ │ ┌───────────┐ │ Throwable │ └───────────┘ ▲ ┌─────────┴─────────┐ │ │ ┌───────────┐ ┌───────────┐ │ Error │ │ Exception │ └───────────┘ └───────────┘ ▲ ▲ ┌───────┘ ┌────┴──────────┐ │ │ │ ┌─────────────────┐ ┌─────────────────┐┌───────────┐ │OutOfMemoryError │... │RuntimeException ││IOException│... └─────────────────┘ └─────────────────┘└───────────┘ ▲ ┌───────────┴─────────────┐ │ │ ┌─────────────────────┐ ┌─────────────────────────┐ │NullPointerException │ │IllegalArgumentException │... └─────────────────────┘ └─────────────────────────┘ \",\"Error表示严重的错误，程序对此一般无能为力\",\"Exception则是运行时的错误，它可以被捕获并处理\",\"必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception。\",\"不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。\"]},\"34\":{\"h\":\"抛出异常\",\"t\":[\"如果同时在 catch 和 finally 中抛出异常，finally抛出异常后，原来在catch中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。\",\"通常不要在finally中抛出异常。如果在finally中抛出异常，应该原始异常加入到原有异常中。调用方可通过Throwable.getSuppressed()获取所有添加的被屏蔽异常。\",\"public class Main { public static void main(String[] args) throws Exception { Exception origin = null; try { System.out.println(Integer.parseInt(\\\"abc\\\")); } catch (Exception e) { origin = e; throw e; } finally { Exception e = new IllegalArgumentException(); if (origin != null) { e.addSuppressed(origin); } throw e; } } } \"]},\"35\":{\"h\":\"4. 反射\"},\"36\":{\"h\":\"Class 类\",\"t\":[\"class（包括interface）的本质是数据类型（Type）。\",\"class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。Class实例在JVM中是唯一的。\",\"Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。\",\"数组（例如String[]）也是一种类，而且不同于String.class，它的类名是[Ljava.lang.String。\",\"JVM为每一种基本类型如int也创建了Class实例，通过int.class访问。\"]},\"37\":{\"h\":\"动态加载\",\"t\":[\"JVM在执行Java程序的时候，并不是一次性把所有用到的 class 全部加载到内存，而是第一次需要用到 class 时（程序执行到）才加载。\",\"通过该特性，可以在运行时根据条件加载不同的实现类。\"]},\"38\":{\"h\":\"访问字段\",\"t\":[\"Field getField(name)：根据字段名获取某个public的field（包括父类）\",\"Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）\",\"Field[] getFields()：获取所有public的field（包括父类）\",\"Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）\"]},\"39\":{\"h\":\"调用方法\",\"t\":[\"Method getMethod(name, Class...)：获取某个public的Method（包括父类）\",\"Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类）\",\"Method[] getMethods()：获取所有public的Method（包括父类）\",\"Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）\"]},\"40\":{\"h\":\"获取继承关系\",\"t\":[\"Class getSuperclass()：获取父类类型；\",\"Class[] getInterfaces()：获取当前类实现的所有接口。\",\"通过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现。\"]},\"41\":{\"h\":\"动态代理\",\"t\":[\"不编写实现类，在运行期创建某个interface的实例\",\"通过Proxy创建代理对象，然后将接口方法“代理”给InvocationHandler。\",\"public class Main { public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method); if (method.getName().equals(\\\"morning\\\")) { System.out.println(\\\"Good morning, \\\" + args[0]); } return null; } }; Hello hello = (Hello) Proxy.newProxyInstance( Hello.class.getClassLoader(), // 传入ClassLoader new Class[] { Hello.class }, // 传入要实现的接口 handler); // 传入处理调用方法的InvocationHandler hello.morning(\\\"Bob\\\"); } } interface Hello { void morning(String name); } \"]},\"42\":{\"h\":\"5. 注解\"},\"43\":{\"h\":\"定义注解\",\"t\":[\"@Target({ // 定义Annotation能够被应用于源码的哪些位置 ElementType.TYPE, // 类或接口 ElementType.FIELD, // 字段 ElementType.METHOD, // 方法 ElementType.CONSTRUCTOR, // 构造方法 ElementType.PARAMETER // 方法参数 }) @Retention(RetentionPolicy.RUNTIME) // 注解生命周期，SOURCE：仅编译期；CLASS：仅 class 文件（默认）；RUNTIME：运行期 public @interface Report { int type() default 0; // 参数和默认值 String level() default \\\"info\\\"; String value() default \\\"\\\"; } @Repeatable // 可以定义Annotation是否可重复 @Inherited // 定义子类是否可继承父类定义的Annotation（父类使用注解子类是否也默认定义） \"]},\"44\":{\"h\":\"处理注解\",\"t\":[\"@Retention 配置的注解生命周期：\",\"SOURCE 类型的注解在编译期就被丢掉了；主要由编译器使用，一般不用\",\"CLASS 类型的注解仅保存在class文件中，它们不会被加载进JVM；主要由底层工具库使用，涉及到 class 的加载，一般很少用到\",\"RUNTIME 类型的注解会被加载进JVM，并且在运行期可以被程序读取；经常用到\",\"利用反射 API 获取 Annotation\",\"Class.getAnnotation(Class)\",\"Field.getAnnotation(Class)\",\"Method.getAnnotation(Class)\",\"Constructor.getAnnotation(Class)\"]},\"45\":{\"h\":\"6. 泛型\"},\"46\":{\"h\":\"Java 类型系统\",\"t\":[\" ┌────┐ │Type│ └────┘ ▲ │ ┌────────────┬────────┴─────────┬───────────────┐ │ │ │ │ ┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐ │Class││ParameterizedType││GenericArrayType││WildcardType│ └─────┘└─────────────────┘└────────────────┘└────────────┘ \",\"ParameterizedType: represents a parameterized type such as Collection<String>.\",\"GenericArrayType: represents an array type whose component type is either a parameterized type or a type variable.\",\"GenericArrayType: represents an array type whose component type is either a parameterized type or a type variable.\"]},\"47\":{\"h\":\"编写泛型\",\"t\":[\"静态方法：在static修饰符后面加一个<T>。注意不能引用泛型类型<T>，必须定义其他类型（例如<K>）来实现静态泛型方法；\"]},\"48\":{\"h\":\"擦拭法\",\"t\":[\"擦拭法：Java的泛型是由编译器在编译时实现的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。\",\"不能是基本类型，例如：int；\",\"不能获取带泛型类型的Class，例如：Pair<String>.class；\",\"不能判断带泛型类型的类型，例如：x instanceof Pair<String>；\",\"不能实例化T类型，例如：new T()。\",\"子类可以获取父类的泛型类型<T>。\",\" Class<IntPair> clazz = IntPair.class; Type t = clazz.getGenericSuperclass(); if (t instanceof ParameterizedType) { ParameterizedType pt = (ParameterizedType) t; Type[] types = pt.getActualTypeArguments(); // 可能有多个泛型类型 Type firstType = types[0]; // 取第一个泛型类型 Class<?> typeClass = (Class<?>) firstType; System.out.println(typeClass); // Integer } \"]},\"49\":{\"h\":\"extends 通配符（上界通配符）\",\"t\":[\"使用<? extends Number>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number了。\"]},\"50\":{\"h\":\"7. 集合\"},\"51\":{\"h\":\"8. IO\"},\"52\":{\"h\":\"File\",\"t\":[\"Java标准库的java.io.File对象表示一个文件或者目录：\",\"创建File对象本身不涉及IO操作；\",\"可以获取路径／绝对路径／规范路径：getPath()/getAbsolutePath()/getCanonicalPath()； \",\"绝对路径可以表示成 C:\\\\Windows\\\\System32\\\\..\\\\notepad.exe，而规范路径就是把 . 和 .. 转换成标准的绝对路径后的路径：C:\\\\Windows\\\\notepad.exe。\",\"可以获取目录的文件和子目录：list()/listFiles()；\",\"可以创建或删除文件和目录。 \",\"createNewFile() 创建一个新文件，用 delete() 删除该文件\",\"createTempFile() 来创建一个临时文件，以及 deleteOnExit() 在JVM退出时自动删除该文件\",\"Path对象和File对象类似，但操作更加简单\"]},\"53\":{\"h\":\"InputStream\",\"t\":[\"Java标准库的 java.io.InputStream 定义了所有输入流的超类。java.io包提供了所有同步IO的功能，即读取和写入是阻塞的。\",\"最重要的 read() 虚拟方法读取输入流的下一个字节，并返回字节表示的 int 值（0~255）。读到末尾，返回 -1。\",\"利用缓冲区一次性读取多个字节效率往往要高很多。InputStream提供了两个重载方法来支持读取多个字节： \",\"int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数\",\"int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数\",\"派生类：\",\"FileInputStream 实现了文件流输入；\",\"ByteArrayInputStream 在内存中模拟一个字节流输入。\",\"使用 try(resource) 来保证 InputStream 正确关闭。\"]},\"54\":{\"h\":\"OutputStream\",\"t\":[\"Java标准库的java.io.OutputStream定义了所有输出流的超类：\",\"write(int b) ：写入int最低 8 位表示字节的部分（相当于b & 0xff）到一个输出流。\",\"flush() ：清空输出流，并强制任何正在缓冲的输出字节被写入到底层输出设备。 \",\"一些实现类（BufferedOutputStream）为了提高性能和效率，采用了内部缓冲区的机制。可能缓冲区满可能比较慢，需要手动调用flush。\",\"派生类：\",\"FileOutputStream 实现了文件流输出；\",\"ByteArrayOutputStream 在内存中模拟一个字节流输出。\",\"BufferedOutputStream 使用了内部缓冲区来提高数据写入的效率。\",\"某些情况下需要手动调用OutputStream的flush()方法来强制输出缓冲区。\",\"使用try(resource)来保证OutputStream正确关闭。\"]},\"55\":{\"h\":\"Filter 模式\",\"t\":[\"Java的IO标准库使用Filter模式为InputStream和OutputStream增加功能：\",\"可以把一个InputStream和任意个FilterInputStream组合；\",\"可以把一个OutputStream和任意个FilterOutputStream组合。\",\"Filter模式可以在运行期动态增加功能（又称Decorator模式）。\"]},\"56\":{\"h\":\"读取 classpath 资源\",\"t\":[\"把资源存储在classpath中可以避免文件路径依赖；\",\"Class对象的getResourceAsStream()可以从classpath中读取指定资源；\",\"根据classpath读取资源时，需要检查返回的InputStream是否为null。\"]},\"57\":{\"h\":\"Reader\",\"t\":[\"Reader定义了所有字符输入流的超类，和InputStream的区别是，InputStream是一个字节流，即以byte为单位读取，而Reader是一个字符流，即以char为单位读取：\",\"FileReader实现了文件字符流输入，使用时需要指定编码；\",\"CharArrayReader和StringReader可以在内存中模拟一个字符流输入。\",\"Reader是基于InputStream构造的：可以通过InputStreamReader在指定编码的同时将任何InputStream转换为Reader。\",\"总是使用try (resource)保证Reader正确关闭。\"]},\"58\":{\"h\":\"Writer\",\"t\":[\"Writer定义了所有字符输出流的超类，它是带编码转换器的OutputStream，它把char转换为byte并输出。\",\"FileWriter实现了文件字符流输出；\",\"CharArrayWriter和StringWriter在内存中模拟一个字符流输出。\",\"使用try (resource)保证Writer正确关闭。\",\"Writer是基于OutputStream构造的，可以通过OutputStreamWriter将OutputStream转换为Writer，转换时需要指定编码。\"]},\"59\":{\"h\":\"14. Maven 基础\"},\"60\":{\"h\":\"依赖管理\",\"t\":[\"scope\",\"说明\",\"示例\",\"compile\",\"编译时需要用到该jar包（默认）\",\"commons-logging\",\"test\",\"编译Test时需要用到该jar包\",\"junit\",\"runtime\",\"编译时不需要，但运行时需要用到\",\"mysql\",\"provided\",\"编译时需要用到，但运行时由JDK或某个服务器提供\",\"servlet-api\"]},\"61\":{\"h\":\"构建流程\",\"t\":[\"Maven通过lifecycle、phase和goal来提供标准的构建流程。\",\"lifecycle相当于Java的package，它包含一个或多个phase；\",\"phase相当于Java的class，它包含一个或多个goal；\",\"goal相当于class的method，它其实才是真正干活的。\"]},\"62\":{\"h\":\"phase\",\"t\":[\"Maven的 lifecycle 由一系列 phase 构成，以内置的生命周期 default 为例，它包含以下 phase\",\"validate\",\"initialize\",\"generate-sources\",\"process-sources\",\"generate-resources\",\"process-resources\",\"compile\",\"process-classes\",\"generate-test-sources\",\"process-test-sources\",\"generate-test-resources\",\"process-test-resources\",\"test-compile\",\"process-test-classes\",\"test\",\"prepare-package\",\"package\",\"pre-integration-test\",\"integration-test\",\"post-integration-test\",\"verify\",\"install\",\"deploy\",\"lifecycle clean 会执行3个phase：\",\"pre-clean\",\"clean （注意这个clean不是lifecycle而是phase）\",\"post-clean\",\"使用 mvn 这个命令时，后面的参数是 phase，Maven 自动根据生命周期运行到指定的 phase。\",\"可以指定多个phase，例如，运行mvn clean package，Maven先执行clean生命周期并运行到clean这个phase，然后执行default生命周期并运行到package这个phase。\"]},\"63\":{\"h\":\"goal\",\"t\":[\"执行一个phase又会触发一个或多个goal：\",\"执行的Phase\",\"对应执行的Goal\",\"compile\",\"compiler:compile\",\"test\",\"compiler:testCompile surefire:test\",\"通常情况，我们总是执行phase默认绑定的goal，因此不必指定goal。\"]},\"64\":{\"h\":\"使用插件\",\"t\":[\"执行每个phase，都是通过某个插件（plugin）来执行的，Maven本身其实并不知道如何执行compile，它只是负责找到对应的compiler插件，然后执行默认的compiler:compile这个goal来完成编译。\",\"Maven已经内置了一些常用的标准插件：\",\"插件名称\",\"对应执行的phase\",\"clean\",\"clean\",\"compiler\",\"compile\",\"surefire\",\"test\",\"jar\",\"package\",\"如果标准插件无法满足需求，我们还可以使用自定义插件。使用自定义插件的时候，需要声明。例如，使用maven-shade-plugin可以创建一个可执行的jar，要使用这个插件，需要在pom.xml中声明它：\",\"<project> ... <build> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-shade-plugin</artifactId> <version>3.2.1</version> <executions> <execution> <phase>package</phase> <goals> <goal>shade</goal> </goals> <configuration> <transformers> <transformer implementation=\\\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\\\"> <mainClass>com.itranswarp.learnjava.Main</mainClass> </transformer> </transformers> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> \"]},\"65\":{\"h\":\"Maven Wrapper\",\"t\":[\"使用Maven Wrapper，可以为一个项目指定特定的Maven版本。\",\"指定使用的Maven版本，使用下面的安装命令指定版本，例如3.3.3：\",\"mvn -N io.takari:maven:0.7.6:wrapper -Dmaven=3.3.3 \"]},\"66\":{\"h\":\"15. 网络编程\"},\"67\":{\"h\":\"网络编程基础\",\"t\":[\"如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的IP地址前段是相同的，也就是网络号是相同的。网络号是IP地址通过子网掩码过滤后得到的。例如：\",\"某台计算机的IP是101.202.99.2，子网掩码是255.255.255.0，那么计算该计算机的网络号是：\",\"IP = 101.202.99.2 Mask = 255.255.255.0 Network = IP & Mask = 101.202.99.0 \"]},\"68\":{\"h\":\"TCP 编程\",\"t\":[\"Socket是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP/IP协议把数据传输到网络。\",\"一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于特权端口，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。\"]},\"69\":{\"h\":\"服务器端\",\"t\":[\"Java标准库提供了ServerSocket来实现对指定IP和指定端口的监听。\",\"public class Server { public static void main(String[] args) throws IOException { // 监听指定端口 ServerSocket ss = new ServerSocket(6666); System.out.println(\\\"server is running...\\\"); // 使用一个无限循环来处理客户端的连接，接收新的连接，创建一个新的线程处理 for (;;) { // 阻塞等待，有新的客户端连接进来后，就返回一个Socket实例，用来和刚连接的客户端通信 Socket sock = ss.accept(); System.out.println(\\\"connected from \\\" + sock.getRemoteSocketAddress()); Thread t = new Handler(sock); t.start(); } } } class Handler extends Thread { Socket sock; public Handler(Socket sock) { this.sock = sock; } @Override public void run() { try (InputStream input = this.sock.getInputStream()) { try (OutputStream output = this.sock.getOutputStream()) { handle(input, output); } } catch (Exception e) { try { this.sock.close(); } catch (IOException ioe) { } System.out.println(\\\"client disconnected.\\\"); } } private void handle(InputStream input, OutputStream output) throws IOException { var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); writer.write(\\\"hello\\\\n\\\"); writer.flush(); for (;;) { String s = reader.readLine(); if (s.equals(\\\"bye\\\")) { writer.write(\\\"bye\\\\n\\\"); writer.flush(); break; } writer.write(\\\"ok: \\\" + s + \\\"\\\\n\\\"); writer.flush(); } } } \"]},\"70\":{\"h\":\"客户端\",\"t\":[\"public class Client { public static void main(String[] args) throws IOException { Socket sock = new Socket(\\\"localhost\\\", 6666); // 连接指定服务器和端口 try (InputStream input = sock.getInputStream()) { try (OutputStream output = sock.getOutputStream()) { handle(input, output); } } sock.close(); System.out.println(\\\"disconnected.\\\"); } private static void handle(InputStream input, OutputStream output) throws IOException { var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); Scanner scanner = new Scanner(System.in); System.out.println(\\\"[server] \\\" + reader.readLine()); for (;;) { System.out.print(\\\">>> \\\"); // 打印提示 String s = scanner.nextLine(); // 读取一行输入 writer.write(s); writer.newLine(); writer.flush(); String resp = reader.readLine(); System.out.println(\\\"<<< \\\" + resp); if (resp.equals(\\\"bye\\\")) { break; } } } } \"]},\"71\":{\"h\":\"UDP 编程\",\"t\":[\"UDP没有创建连接，数据包也是一次收发一个，所以没有流的概念。\",\"在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。\"]},\"72\":{\"h\":\"服务器端\",\"t\":[\"DatagramSocket ds = new DatagramSocket(6666); // 监听指定端口 for (;;) { // 无限循环 // 数据缓冲区: byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, buffer.length); ds.receive(packet); // 收取一个UDP数据包 // 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度 // 将其按UTF-8编码转换为String: String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8); // 发送数据: byte[] data = \\\"ACK\\\".getBytes(StandardCharsets.UTF_8); packet.setData(data); ds.send(packet); } \"]},\"73\":{\"h\":\"客户端\",\"t\":[\"DatagramSocket ds = new DatagramSocket(); ds.setSoTimeout(1000); ds.connect(InetAddress.getByName(\\\"localhost\\\"), 6666); // 连接指定服务器和端口 // 发送: byte[] data = \\\"Hello\\\".getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length); ds.send(packet); // 接收: byte[] buffer = new byte[1024]; packet = new DatagramPacket(buffer, buffer.length); ds.receive(packet); String resp = new String(packet.getData(), packet.getOffset(), packet.getLength()); ds.disconnect(); \",\"服务器端用DatagramSocket(port)监听端口；\",\"客户端使用DatagramSocket.connect()指定远程地址和端口；\",\"双方通过receive()和send()读写数据；\",\"DatagramSocket没有IO流接口，数据被直接写入byte[]缓冲区。\"]},\"74\":{\"h\":\"18. 函数式编程\",\"t\":[\"允许把函数本身作为参数传入另一个函数，还允许返回一个函数。\"]},\"75\":{\"h\":\"Lambda 基础\",\"t\":[\"单方法接口被称为 FunctionalInterface。\",\"Comparator\",\"Runnable\",\"Callable\",\"接收 FunctionalInterface 作为参数的时候，可以把实例化的匿名类改写为Lambda表达式，能大大简化代码。\",\"Lambda表达式的参数和返回值均可由编译器自动推断。\",\"只定义了单方法的接口称之为 FunctionalInterface，用注解 @FunctionalInterface 标记。\"]},\"76\":{\"h\":\"方法引用\",\"t\":[\"FunctionalInterface允许传入：\",\"接口的实现类（传统写法，代码较繁琐）；\",\"Lambda表达式（只需列出参数名，由编译器推断类型）；\",\"符合方法签名的静态方法；\",\"符合方法签名的实例方法（实例类型被看做第一个参数类型）；\",\"符合方法签名的构造方法（实例类型被看做返回类型）。\",\"FunctionalInterface不强制继承关系，不需要方法名称相同，只要求方法参数（类型和数量）与方法返回类型相同，即认为方法签名相同。\"]},\"77\":{\"h\":\"20. Web 开发\"},\"78\":{\"h\":\"Servlet 入门\",\"t\":[\" ┌───────────┐ │My Servlet │ ├───────────┤ │Servlet API│ ┌───────┐ HTTP ├───────────┤ │Browser│<──────>│Web Server │ └───────┘ └───────────┘ \",\"Web服务器处理TCP连接，解析HTTP协议。它实现了 Servlet API，使用户能够编写自己的 Servlet 来处理 HTTP 请求。\"]},\"79\":{\"h\":\"21. Spring 开发\"},\"80\":{\"h\":\"21.1 IoC 容器\"},\"81\":{\"h\":\"IoC 原理\",\"t\":[\"组件中用 new 方式创建依赖实例的缺点：\",\"高耦合性\",\"难以测试：需要模拟依赖类的行为\",\"资源管理问题：某些资源每次都实例化可能导致过载\",\"重复代码\",\"难以管理依赖关系\",\"在 IoC 模式下，控制权从应用程序转移到了 IoC 容器，所有的组件不再由应用程序自己创建和配置，而是由 IoC 容器负责，这样，应用程序只需要直接使用已经创建好并配置好的组件。它解决了以下问题：\",\"谁负责创建组件？\",\"谁负责根据依赖关系组装组件？\",\"销毁时，如何按依赖顺序正确销毁？\",\"在Spring的IoC容器中，实现IoC的主要机制是依赖注入，依赖注入可以通过多种方式实现：\",\"Setter 注入：通过 setter 方法注入依赖。\",\"构造方法注入：通过构造方法注入依赖。\",\"在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：\",\"应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；\",\"测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。\"]},\"82\":{\"h\":\"定制 Bean\",\"t\":[\"Spring默认使用Singleton创建Bean，也可指定Scope为Prototype；\",\"可将相同类型的Bean注入List或数组；\",\"可用@Autowired(required=false)允许可选注入；\",\"可用带@Bean标注的方法创建Bean；\",\"可使用@PostConstruct和@PreDestroy对Bean进行初始化和清理；\",\"相同类型的Bean只能有一个指定为@Primary，其他必须用@Quanlifier(\\\"beanName\\\")指定别名；\",\"注入时，可通过别名@Quanlifier(\\\"beanName\\\")指定某个Bean；\",\"可以定义FactoryBean来使用工厂模式创建Bean。\"]},\"83\":{\"h\":\"使用 Resource\",\"t\":[\"Spring提供了Resource类便于注入资源文件。\",\"最常用的注入是通过classpath以classpath:/path/to/file的形式注入。\"]},\"84\":{\"h\":\"使用条件装配\",\"t\":[\"Spring允许通过@Profile配置不同的Bean；\",\"Spring还提供了@Conditional来进行条件装配，Spring Boot在此基础上进一步提供了基于配置、Class、Bean等条件进行装配。\"]},\"85\":{\"h\":\"21.2 使用 AOP\",\"t\":[\"而AOP是一种新的编程方式，它和OOP不同，OOP把系统看作多个对象的交互，AOP把系统分解为不同的关注点，或者称之为切面（Aspect）。\",\"如何把切面织入到核心逻辑中？这正是AOP需要解决的问题。换句话说，如果客户端获得了BookService的引用，当调用bookService.createBook()时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理，就相当于完成了所有业务功能。\",\"在Java平台上，对于AOP的织入，有3种方式：\",\"编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；\",\"类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；\",\"运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。\",\"最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过CGLIB或者Javassist这些第三方库实现。\"]},\"86\":{\"h\":\"21.3 访问数据库\"},\"87\":{\"h\":\"使用声明式事务\",\"t\":[\"默认的事务传播级别是REQUIRED，它满足绝大部分的需求。还有一些其他的传播级别：\",\"SUPPORTS：表示如果有事务，就加入到当前事务，如果没有，那也不开启事务执行。这种传播级别可用于查询方法，因为SELECT语句既可以在事务内执行，也可以不需要事务；\",\"MANDATORY：表示必须要存在当前事务并加入执行，否则将抛出异常。这种传播级别可用于核心更新逻辑，比如用户余额变更，它总是被其他事务方法调用，不能直接由非事务方法调用；\",\"REQUIRES_NEW：表示不管当前有没有事务，都必须开启一个新的事务执行。如果当前已经有事务，那么当前事务会挂起，等新事务完成后，再恢复执行；\",\"NOT_SUPPORTED：表示不支持事务，如果当前有事务，那么当前事务会挂起，等这个方法执行完成后，再恢复执行；\",\"NEVER：和NOT_SUPPORTED相比，它不但不支持事务，而且在监测到当前有事务时，会抛出异常拒绝执行；\",\"NESTED：表示如果当前有事务，则开启一个嵌套级别事务，如果当前没有事务，则开启一个新事务。\",\"上面这么多种事务的传播级别，其实默认的REQUIRED已经满足绝大部分需求，SUPPORTS和REQUIRES_NEW在少数情况下会用到，其他基本不会用到，因为把事务搞得越复杂，不仅逻辑跟着复杂，而且速度也会越慢。\",\"Spring提供的声明式事务极大地方便了在数据库中使用事务。Spring使用声明式事务，最终也是通过执行JDBC事务来实现功能的，原理是使用 ThreadLocal。\",\"Spring总是把JDBC相关的Connection和TransactionStatus实例绑定到ThreadLocal。如果一个事务方法从ThreadLocal未取到事务，那么它会打开一个新的JDBC连接，同时开启一个新的事务，否则，它就直接使用从ThreadLocal获取的JDBC连接以及TransactionStatus。因此，事务只能在当前线程传播，无法跨线程传播。\",\"要实现跨线程传播事务，要想办法把当前线程绑定到ThreadLocal的Connection和TransactionStatus实例传递给新线程，但实现起来非常复杂，根据异常回滚更加复杂，不推荐自己去实现。\"]},\"88\":{\"h\":\"集成 Hibernate\"},\"89\":{\"h\":\"初始化\",\"t\":[\"在Hibernate中，Session是封装了一个JDBC Connection的实例，而SessionFactory是封装了JDBC DataSource的实例，即SessionFactory持有连接池，每次需要操作数据库的时候，SessionFactory创建一个新的Session，相当于从连接池获取到一个新的Connection。\",\"public class AppConfig { @Bean LocalSessionFactoryBean createSessionFactory(@Autowired DataSource dataSource) { var props = new Properties(); props.setProperty(\\\"hibernate.hbm2ddl.auto\\\", \\\"update\\\"); // 生产环境不要使用 props.setProperty(\\\"hibernate.dialect\\\", \\\"org.hibernate.dialect.HSQLDialect\\\"); props.setProperty(\\\"hibernate.show_sql\\\", \\\"true\\\"); var sessionFactoryBean = new LocalSessionFactoryBean(); sessionFactoryBean.setDataSource(dataSource); // 扫描指定的package获取所有entity class: sessionFactoryBean.setPackagesToScan(\\\"com.itranswarp.learnjava.entity\\\"); sessionFactoryBean.setHibernateProperties(props); return sessionFactoryBean; } } \"]},\"90\":{\"h\":\"设置映射关系\",\"t\":[\"// 设置映射关系 @Entity @Table(name=\\\"users) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(nullable = false, updatable = false) public Long getId() { ... } @Column(nullable = false, unique = true, length = 100) public String getEmail() { ... } @Column(nullable = false, length = 100) public String getPassword() { ... } @Column(nullable = false, length = 100) public String getName() { ... } @Column(nullable = false, updatable = false) public Long getCreatedAt() { ... } } \"]},\"91\":{\"h\":\"基本操作\",\"t\":[\"// insert sessionFactory.getCurrentSession().persist(user); // delete User user = sessionFactory.getCurrentSession().byId(User.class).load(id); if (user != null) { sessionFactory.getCurrentSession().remove(user); return true; } // delete User user = sessionFactory.getCurrentSession().byId(User.class).load(id); user.setName(name); sessionFactory.getCurrentSession().merge(user); \"]},\"92\":{\"h\":\"使用高级查询（HQL）\",\"t\":[\"List<User> list = sessionFactory.getCurrentSession() .createQuery(\\\"from User u where u.email = ?1 and u.password = ?2\\\", User.class) .setParameter(1, email).setParameter(2, password) .list(); \",\"和SQL相比，HQL使用类名和属性名，由Hibernate自动转换为实际的表名和列名。详细的HQL语法可以参考Hibernate文档。\",\"NamedQuery 可以在代码中直观地看到查询语句。\",\"@NamedQueries( @NamedQuery( // 查询名称: name = \\\"login\\\", // 查询语句: query = \\\"SELECT u FROM User u WHERE u.email = :e AND u.password = :pwd\\\" ) ) @Entity public class User extends AbstractEntity { ... } \",\"public User login(String email, String password) { List<User> list = sessionFactory.getCurrentSession() .createNamedQuery(\\\"login\\\", User.class) // 创建NamedQuery .setParameter(\\\"e\\\", email) // 绑定e参数 .setParameter(\\\"pwd\\\", password) // 绑定pwd参数 .list(); return list.isEmpty() ? null : list.get(0); } \"]},\"93\":{\"h\":\"21.4 开发 Web 应用\",\"t\":[\"Spring虽然都可以集成任何Web框架，但是，Spring本身也开发了一个MVC框架，就叫Spring MVC。\"]},\"94\":{\"h\":\"22. Spring Boot 开发\"},\"95\":{\"h\":\"使用开发者工具\",\"t\":[\"Spring Boot提供了一个开发者工具，可以监控classpath路径上的文件。只要源码或配置文件发生修改，Spring Boot应用可以自动重启。\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-devtools</artifactId> </dependency> \",\"默认配置下，针对/static、/public和/templates目录中的文件修改，不会自动重启，因为禁用缓存后，这些文件的修改可以实时更新。\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"96\":{\"h\":\"Mockito Note\",\"t\":[\"原文地址：http://hscarb.github.io/java/20230815-mockito-note.html\",\"https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/\",\"https://github.com/eugenp/tutorials/tree/master/testing-modules/mockito-simple\"]},\"97\":{\"h\":\"difference between doReturn() and when()\",\"t\":[\"In the case of mocked objects, it does not matter if it's when/thenReturn or doReturn/when. Mocked objects never calls real methods.\",\"Both approaches behave differently if you use a spied object (annotated with @Spy) instead of a mock (annotated with @Mock):\",\"when(...) thenReturn(...)makes a real method call just before the specified value will be returned. So if the called method throws an Exception you have to deal with it / mock it etc. Of course you still get your result (what you define in thenReturn(...))\",\"doReturn(...) when(...)does not call the method at all.\"]},\"98\":{\"h\":\"Difference between @Mock and @InjectMocks\",\"t\":[\"@Mock creates a mock. @InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock (or @Spy) annotations into this instance.\",\"Note you must use @RunWith(MockitoJUnitRunner.class) or Mockito.initMocks(this) to initialize these mocks and inject them (JUnit 4).\",\"With JUnit 5, you must use @ExtendWith(MockitoExtension.class).\"]},\"99\":{\"h\":\"mock singleton\",\"t\":[\"@RunWith(MockitoJUnitRunner.Silent.class) public class Test { @Mock Singleton singleton; @Before public void setUp() throws Exception { setUpSingletons(); } @After public void tearDown() throws Exception { resetSingletons(); } private void setUpSingletons() throws Exception { final Field instance = Singleton.class.getDeclaredField(\\\"instance\\\"); instance.setAccessible(true); instance.set(instance, singleton); } private void resetSingletons() throws Exception { final Field instance = Singleton.class.getDeclaredField(\\\"instance\\\"); instance.setAccessible(true); instance.set(instance, null); } @Test public void test() { // ... } } \"]},\"100\":{\"h\":\"Mocking Exception Throwing\"},\"101\":{\"h\":\"Non-Void Return Type\",\"t\":[\"First, if our method return type is not void, we can use when().thenThrow():\",\"@Test void givenNonVoidReturnType_whenUsingWhenThen_thenExceptionIsThrown() { MyDictionary dictMock = mock(MyDictionary.class); when(dictMock.getMeaning(anyString())).thenThrow(NullPointerException.class); assertThrows(NullPointerException.class, () -> dictMock.getMeaning(\\\"word\\\")); } \"]},\"102\":{\"h\":\"Void Return Type\",\"t\":[\"If our method returns void, we'll use doThrow():\",\"@Test void givenVoidReturnType_whenUsingDoThrow_thenExceptionIsThrown() { MyDictionary dictMock = mock(MyDictionary.class); doThrow(IllegalStateException.class).when(dictMock) .add(anyString(), anyString()); assertThrows(IllegalStateException.class, () -> dictMock.add(\\\"word\\\", \\\"meaning\\\")); } \"]},\"103\":{\"h\":\"Checked Exception\",\"t\":[\"A workaround is to use a willAnswer() method.\",\"For example the following works (and doesn't throw a MockitoException but actually throws a checked Exception as required here) using BDDMockito:\",\"given(someObj.someMethod(stringArg1)).willAnswer( invocation -> { throw new Exception(\\\"abc msg\\\"); }); \",\"The equivalent for plain Mockito would to use the doAnswer method\"]},\"104\":{\"h\":\"Mocking Static Methods\",\"t\":[\"https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#static_mocks\",\"When using the inline mock maker, it is possible to mock static method invocations within the current thread and a user-defined scope. This way, Mockito assures that concurrently and sequentially running tests do not interfere. To make sure a static mock remains temporary, it is recommended to define the scope within a try-with-resources construct. In the following example, the Foo type's static method would return foo unless mocked:\"]},\"105\":{\"h\":\"No Argument Static Method\",\"t\":[\"@Test void givenStaticMethodWithNoArgs_whenMocked_thenReturnsMockSuccessfully() { assertThat(StaticUtils.name()).isEqualTo(\\\"Baeldung\\\"); try (MockedStatic<StaticUtils> utilities = Mockito.mockStatic(StaticUtils.class)) { utilities.when(StaticUtils::name).thenReturn(\\\"Eugen\\\"); assertThat(StaticUtils.name()).isEqualTo(\\\"Eugen\\\"); } assertThat(StaticUtils.name()).isEqualTo(\\\"Baeldung\\\"); } \"]},\"106\":{\"h\":\"Static Method With Arguments\",\"t\":[\"@Test void givenStaticMethodWithArgs_whenMocked_thenReturnsMockSuccessfully() { assertThat(StaticUtils.range(2, 6)).containsExactly(2, 3, 4, 5); try (MockedStatic<StaticUtils> utilities = Mockito.mockStatic(StaticUtils.class)) { utilities.when(() -> StaticUtils.range(2, 6)) .thenReturn(Arrays.asList(10, 11, 12)); assertThat(StaticUtils.range(2, 6)).containsExactly(10, 11, 12); } assertThat(StaticUtils.range(2, 6)).containsExactly(2, 3, 4, 5); } \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"107\":{\"h\":\"Reactor 模式的 Java 实现（feat. Scalable IO in Java - Doug Lea）\",\"t\":[\"原文地址：http://hscarb.github.io/java/20240827-reactor-java.html\"]},\"108\":{\"h\":\"1. 背景\",\"t\":[\"Doug Lea 在 Scalable IO in Java 的 PPT 中描述了 Reactor 编程模型的思想，大部分 NIO 框架和一些中间件的 NIO 编程都与它一样或是它的变体，包括 Netty。\"]},\"109\":{\"h\":\"1.1 Reactor 模式是什么\",\"t\":[\"内核空间的网络数据收发模型：阻塞 IO（BIO）、非阻塞 IO（NIO）、IO 多路复用、信号驱动 IO、异步 IO。\",\"而 Reactor 模式是对用户空间的 IO 线程模型进行分工的模式，它基于 IO 多路复用来实现。\"]},\"110\":{\"h\":\"1.2 本文内容\",\"t\":[\"本文将介绍 Reactor 编程模型使用 Java NIO 包的三种实现，并提供对应的源码实现和解释。\",\"我会实现一个简单的服务端逻辑：以换行符来识别每次用户输入，将每次用户输入的字符都转成大写，返回给用户。\",\"本文的代码完整实现地址：https://github.com/HScarb/reactor\"]},\"111\":{\"h\":\"2. 传统服务端设计模式（BIO）\",\"t\":[\"一般的 Web 服务端或分布式服务端等应用中，大都具备这些处理流程：读请求（send）、解码（decode）、处理和计算（compute）、编码（encode）、发送响应（send）。\",\"在传统服务端设计中，对每个新的客户端连接都启动一个新的线程去处理，在每个线程中串行执行上述处理流程。这种编程方式也就是 BIO。\"]},\"112\":{\"h\":\"2.1 BIO 服务端\",\"t\":[\"public class BioServer implements Runnable { public int port; public BioServer(int port) { this.port = port; } @Override public void run() { try (final ServerSocket serverSocket = new ServerSocket(port)) { System.out.println(\\\"Server is listening on port \\\" + port); while (!Thread.interrupted()) { try { // 当有新的客户端连接时，accept() 方法会返回一个Socket对象，表示与客户端的连接 // 创建一个新的线程来处理该连接 new Thread(new BioHandler(serverSocket.accept())).start(); } catch (IOException e) { System.out.println(\\\"Error handling client: \\\" + e.getMessage()); } } } catch (IOException e) { System.out.println(\\\"Server exception: \\\" + e.getMessage()); } } } \",\"上述代码中，为每个客户端连接都创建一个 Handler 线程，在 Handler 中处理读请求、解码、处理和计算、编码、发送响应的所有逻辑。\"]},\"113\":{\"h\":\"2.2 BIO Handler\",\"t\":[\"/** * 处理单个客户端连接的具体逻辑 */ public class BioHandler implements Runnable { public Socket socket; public BioHandler(Socket socket) { this.socket = socket; } @Override public void run() { System.out.println(\\\"New client connected\\\"); try ( final BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream())); final PrintWriter writer = new PrintWriter(socket.getOutputStream(), true); ) { writer.print(\\\"bio> \\\"); writer.flush(); String input; // 读取客户端输入的一行内容 while ((input = reader.readLine()) != null) { // 处理客户端输入的内容 final String output = process(input); // 将处理后的内容写回给客户端 writer.println(output); writer.print(\\\"bio> \\\"); writer.flush(); } } catch (IOException e) { System.out.println(\\\"Error handling io: \\\" + e.getMessage()); } finally { try { socket.close(); } catch (IOException e) { System.out.println(\\\"Failed to close socket: \\\" + e.getMessage()); } } } /** * 将客户端输入的内容转换为大写 */ private String process(String requestContent) { return requestContent.toUpperCase(Locale.ROOT); } } \",\"启动这个服务端程序\",\"public class Main { public static final int PORT = 8080; public static void main(String[] args) throws IOException { runBioServer(); } public static void runBioServer() { final BioServer bioServer = new BioServer(PORT); ExecutorService mainThread = Executors.newSingleThreadExecutor(); mainThread.submit(bioServer); mainThread.shutdown(); } } \"]},\"114\":{\"h\":\"2.3 缺陷\",\"t\":[\"上述程序存在缺陷：\",\"线程资源消耗高：每个客户端连接都会创建一个线程，在高并发场景下会导致大量线程创建和销毁，消耗大量系统资源。线程上下文切换开销也会随之增加。\",\"阻塞式 I/O：accept()、readLine()和print()方法都是阻塞式的，这意味着线程在等待I/O操作完成时会被阻塞，无法执行其他任务。这样会导致资源利用率低下。\",\"难于管理和扩展：直接使用new Thread()的方式来处理连接，难以进行线程管理和池化，难以实现更复杂的并发控制和优化。\"]},\"115\":{\"h\":\"3. 优化思路\",\"t\":[\"随着互联网的发展，对服务性能的挑战也越来越大。我们希望能构建更高性能且可伸缩的服务，能够达到：\",\"随着客户端数量的增加而优雅降级\",\"随着硬件资源的增加，性能持续提高\",\"具备低延迟、高吞吐、高质量的服务\"]},\"116\":{\"h\":\"3.1 分而治之\",\"t\":[\"要达到以上目标，我们先考虑将处理过程拆分成更小的任务，每个任务执行一个非阻塞操作，由一个 IO 事件来触发执行。\",\"java.nio 包对这种机制提供了支持：\",\"非阻塞的读和写\",\"通过感知 IO 事件来分发 IO 事件关联的任务\",\"BIO 线程是以 read->decode->process->encode->send 的顺序串行处理，NIO 将其分成了三个执行单元：读取、业务处理和发送，处理过程如下：\",\"读取（read）：如果无数据可读，线程返回线程池；发生读 IO 事件，申请一个线程处理读取，读取结束后处理业务\",\"业务处理（decode、compute、encode）：线程同步处理完业务后，生成响应内容并编码，返回线程池\",\"发送（send）：发生写 IO 事件，申请一个线程进行发送\",\"与 BIO 明显的区别就是，一次请求的处理过程是由多个不同的线程完成的，感觉和指令的串行执行和并行执行有点类似。\",\"分而治之的关键在于非阻塞，这样就能充分利用线程，压榨 CPU，提高系统的吞吐能力。\"]},\"117\":{\"h\":\"3.2 事件驱动\",\"t\":[\"另一个优化思路是基于事件启动，它比其他模型更高效。\",\"使用的资源更少：不用为每个客户端都启动一个线程\",\"开销更少：减少上下文切换，锁的使用也更少\",\"任务分发可能会更慢：必须手动绑定事件和动作\",\"事件驱动架构的服务实现复杂度也更高，必须将处理过程拆分成多个非阻塞的动作，且持续跟踪服务的逻辑状态。并且事件启动无法避免所有的阻塞，比如 CG、缺页中断等。\"]},\"118\":{\"h\":\"4. 前置知识：Java NIO 包\",\"t\":[\"上面提到 java.nio 包提供了非阻塞以及事件驱动机制的支持，是实现 Reactor 模式必不可少的依赖。在介绍 Reactor 模式之前先来简单回顾一下 Java NIO，便于理解后面的代码。\",\"Java NIO 指 java.nio 包，其中的 nio 是 “New Input/Output” 的缩写，它是 Java 1.4 中引入的一套新的 I/O API。也有文章说 Java NIO 中的 NIO 指 “Non-blocking I/O” 的，我认为不太准确。它提供了实现 Non-blocking I/O 的特性和工具，但它不仅仅局限于 Non-blocking I/O，还包括其他许多功能。\",\"Java NIO 主要提供了三个核心组件：Buffer、Channel 和 Selector，他们的关系如下图所示：\",\"Channel（通道）：原 I/O 包中 Stream 的模拟，但 Channel 是双向的，可以读和写，并且支持异步读/写。它必须从 Buffer 读取或写入数据。Channel 可以通过调用 configureBlocking(false) 方法配置为非阻塞模式。 \",\"FileChannel：文件通道，用于文件的读和写。它只能在阻塞模式下运行，其他 3 个 Channel 都可以配置成非阻塞模式。\",\"DatagramChannel：用于 UDP 连接的接收和发送\",\"SocketChannel：把它理解为 TCP 连接通道，简单理解就是 TCP 客户端\",\"ServerSocketChannel：TCP 对应的服务端，用于监听某个端口进来的请求\",\"Buffer（缓冲区）：本质上是一块内存，内部实现是一个数组。用于向 Channel 写入和读取数据。\",\"Selector（选择器）：这个组件用来实现多路复用 I/O，它可以监听多个 Channel 是否准备好进行读取或写入。这样就可以通过一个线程管理多个 Channel，从而管理多个网络连接。 \",\"Channel 必须处于非阻塞模式才能与 Selector 一起使用。这意味着不能将 FileChannel 与 Selector 一起使用。\",\"Selector 可以监听 Channel 上 4 种类型的事件： \",\"SelectionKey.OP_ACCEPT：表示通道接受连接的事件，这通常用于 ServerSocketChannel。\",\"SelectionKey.OP_CONNECT：表示通道完成连接的事件，这通常用于 SocketChannel。\",\"SelectionKey.OP_READ：表示通道准备好进行读取的事件，即有数据可读。\",\"SelectionKey.OP_WRITE：表示通道准备好进行写入的事件，即可以写入数据。\",\"SelectionKey register(Selector sel, int ops)：Channel 的方法，用于注册 Channel 到 Selector，让 Selector 多路复用地监听 Channel 上感兴趣的事件。第二个参数可以是上面 4 种类型的事件中的一种或几种。\",\"SelectionKey：注册后返回的选择键，表示 Channel 在 Selector 上的注册信息，当中包含这些方法： \",\"interestOps()：监听事件的集合\",\"readyOps()：当前收到的事件集合\",\"channel()：被注册的通道\",\"selector()：注册到的选择器\",\"attachment()：附加的一个对象（可选）。在 Reactor 模式中，会把 Acceptor 添加到 Selector 中，Acceptor 是用于处理客户端连接的组件，attach 到 Selector 上之后就可以在客户端连接事件到达时取出 Acceptor，处理客户端连接。\",\"select() ：阻塞当前线程，直到至少有一个 Channel 在这个 Selector 上注册的事件就绪。返回当前就绪的 Channel 的数量。\",\"selectedKeys()：返回已经就绪的通道的选择键，通常在 select() 方法之后调用，获取就绪的 SelectionKey，然后遍历它们处理 IO 事件。可以通过 selectedKeys().iterator().next().channel() 方法遍历和访问这些通道。\"]},\"119\":{\"h\":\"5. 单线程 Reactor\",\"t\":[\"Reactor 是一种设计模式，它使用了上面所说的优化思想：分而治之和事件驱动，旨在编写更可伸缩高性能的应用。wikipedia 对其定义如下：\",\"Reactor 是一个或多个输入事件的处理模式，用于处理并发传递给服务处理程序的服务请求。服务处理程序判断传入请求发生的事件，并将它们同步的分派给关联的请求处理程序。\",\"它更多地是在用户空间的角度，基于 IO 多路复用，对线程进行分工。\",\"Reactor 是一个线程，基于 IO 多路复用技术，它可以不断监听 IO 事件，然后进行分发处理，像一个反应堆一样，因此被称为 Reactor 模式。它主要的工作：\",\"使用 IO 多路复用（JAVA 中的 Selector），监听 IO 事件\",\"将监听到的 IO 事件分发（dispatch）到对应的处理器中进行处理（Acceptor 或者 Handler）\"]},\"120\":{\"h\":\"5.1 设计\",\"t\":[\"下图是 Reactor 单线程版本的基本设计\",\"单线程版本\",\"其中橙色的 Reactor 为一个线程，负责响应客户端请求事件。每当收到一个客户端连接，Reactor 会让 Acceptor 组件处理。\",\"绿色的 Acceptor 组件与 Reactor 运行在同一线程中，负责将客户端连接分发给 Handler 处理（图中的 dispatch 过程）。\",\"Handler 组件负责处理读取、解码、计算、编码、响应整个流程，在单线程 Reactor 中，它也与 Reactor 运行在同一线程中。\",\"单线程版本就是用一个线程完成所有步骤，包括事件的通知、读取和响应过程、业务处理。\"]},\"121\":{\"h\":\"5.2 Reactor 线程初始化\",\"t\":[\"在单线程 Reactor 中，只会初始化一个线程，即 Reactor 线程，由它来调用 Acceptor 实例分发连接事件，Acceptor 继续创建 Handler 进行请求处理。\",\"public class Reactor implements Runnable { /** * 选择器，NIO 组件，通知 Channel 就绪的事件 */ final Selector selector; /** * Handler 的类型 */ final Class<?> handlerClass; /** * TCP 服务端 Socket，监听某个端口进来的客户端连接和请求 */ ServerSocketChannel serverSocket; /** * Reactor 的执行线程 */ public final ExecutorService executor; /** * 直接创建 Reactor 使用 */ public Reactor(int port, Class<?> handlerClass) throws IOException { this.handlerClass = handlerClass; executor = Executors.newSingleThreadExecutor(); selector = Selector.open(); serverSocket = ServerSocketChannel.open(); // 绑定服务端端口 serverSocket.socket().bind(new InetSocketAddress(port)); // 设置服务端 socket 为非阻塞模式 serverSocket.configureBlocking(false); // 注册并关注一个 IO 事件，这里是 ACCEPT（接收客户端连接） final SelectionKey selectionKey = serverSocket.register(selector, SelectionKey.OP_ACCEPT); // 将 Acceptor 作为附件关联到 SelectionKey 上，用于在客户端连接事件发生时取出，让 Acceptor 去分发连接给 Handler selectionKey.attach(new Acceptor()); } } \"]},\"122\":{\"h\":\"5.3 Reactor 线程主循环\",\"t\":[\"/** * 启动 Reactor 线程，执行 run 方法 */ public void startThread() { executor.execute(this); } @Override public void run() { // normally in a new Thread try { // 死循环，直到线程停止 while (!Thread.interrupted()) { // 阻塞，直到至少有一个通道的 IO 事件就绪 selector.select(); // 拿到就绪通道的选择键 SelectionKey 集合 final Set<SelectionKey> selectedKeys = selector.selectedKeys(); // 遍历就绪通道的 SelectionKey final Iterator<SelectionKey> iterator = selectedKeys.iterator(); while (iterator.hasNext()) { // 分发 dispatch(iterator.next()); } // 清空就绪通道的 SelectionKey 集合 selectedKeys.clear(); } } catch (IOException e) { } } /** * 分发事件，将就绪通道的注册键关联的处理器取出并执行 * <p> * 在 MainReactor 中，就绪的是客户端连接事件，处理器是 Acceptor * <p> * 在 SubReactor 中，就绪的是客户端 IO 事件，处理器是 Handler */ private void dispatch(SelectionKey selectionKey) { // 获取 SelectionKey 关联的处理器 final Runnable runnable = (Runnable) selectionKey.attachment(); if (runnable != null) { // 执行处理 runnable.run(); } } \",\"主循环中，使用 java.nio 的 Selector，它底层使用了操作系统的多路复用技术，用一个线程处理多个客户端连接。select() 方法阻塞等待新的监听的事件（在这里是客户端连接事件 OP_ACCEPT）被触发。一旦接受到连接事件，调用 dispatch 方法，取出之前关联到 SelectionKey 上的处理器：Acceptor 附件，并执行它进行请求分发。\"]},\"123\":{\"h\":\"5.4 Acceptor 请求分发\",\"t\":[\"/** * 处理客户端连接事件 */ class Acceptor implements Runnable { @Override public void run() { try { // 接收客户端连接，返回客户端 SocketChannel。非阻塞模式下，没有客户端连接则直接返回 null final SocketChannel socket = serverSocket.accept(); if (socket != null) { // 将提示发送给客户端 socket.write(ByteBuffer.wrap(\\\"reactor> \\\".getBytes())); // 根据 Handler 类型，实例化 Handler final Constructor<?> constructor = handlerClass.getConstructor(Selector.class, SocketChannel.class); // 在 Handler 线程中处理客户端 IO 事件 constructor.newInstance(selector, socket); } } catch (Exception e) { } } } \",\"Acceptor 组件负责客户端连接事件的分发，将客户端连接分发给 Handler 处理。注意这里没有新建线程，Acceptor 的逻辑还是与 Reactor 在同一线程中运行。\"]},\"124\":{\"h\":\"5.5 Handler 初始化\",\"t\":[\"/** * 单线程非阻塞处理器 */ public class NioHandler implements Runnable { private static final int MAX_INPUT_BUFFER_SIZE = 1024; private static final int MAX_OUTPUT_BUFFER_SIZE = 1024; final SocketChannel socket; final SelectionKey selectionKey; ByteBuffer input = ByteBuffer.allocate(MAX_INPUT_BUFFER_SIZE); ByteBuffer output = ByteBuffer.allocate(MAX_OUTPUT_BUFFER_SIZE); static final int READING = 0, SENDING = 1, CLOSED = 2; /** * Handler 当前处理状态 */ int state = READING; /** * 缓存每次读取的内容 */ StringBuilder inputStringBuilder = new StringBuilder(); public NioHandler(Selector selector, SocketChannel socket) throws IOException { this.socket = socket; // 设置非阻塞（NIO）。这样，socket 上的操作如果无法立即完成，不会阻塞，而是会立即返回。 socket.configureBlocking(false); // Optionally try first read now // 注册客户端 socket 到 Selector。 // 这里先不设置感兴趣的事件，分离 register 和 interestOps 这两个操作，避免多线程下的竞争条件和同步问题。 this.selectionKey = socket.register(selector, 0); // 把 Handler 自身放到 selectionKey 的附加属性中，用于在 IO 事件就绪时从 selectedKey 中获取 Handler，然后处理 IO 事件。 this.selectionKey.attach(this); // 监听客户端连接上的 IO READ 事件 this.selectionKey.interestOps(SelectionKey.OP_READ); // 由于 Selector 的注册信息发生变化，立即唤醒 Selector，让它能够处理最新订阅的 IO 事件 selector.wakeup(); } } \",\"Handler 负责处理 I/O 操作和业务处理，这里初始化 Handler。\",\"将客户端的 TCP 通道（SocketChannel）设置非阻塞模式。这样，socket 上的操作如果无法立即完成，不会阻塞，而是会立即返回。\",\"并且将它注册到之前的 Selector 上。在这里先不设置感兴趣的事件（0 表示对任何 IO 事件都不感兴趣），后续通过 interestOps 方法来设置感兴趣的事件。分离 register 和 interestOps 这两个操作，目的是避免多线程下的竞争条件和同步问题。\",\"在 SelectionKey 上附上自己（Handler），以在读取数据时调用 Handler 的 run 方法。\",\"监听读取操作（OP_READ），客户端 SocketChannel 有数据可读时 Selector 的 select 方法返回该 SelectionKey。\",\"立即唤醒可能正在阻塞的 select() 方法，确保新注册的 SelectionKey 立即生效。\"]},\"125\":{\"h\":\"5.6 Handler 执行 I/O 操作和业务处理\",\"t\":[\"Handler 中包含 I/O 操作（read 和 write）和业务操作（process）。process 方法中将读取到的字符转换成大写。\",\"先将 state 初始化为 READING 以接收客户输入（read()）。\",\"客户端每输入一个字符就会触发 OP_READ 事件，我们先把客户输入的字符缓存到 StringBuilder，直到客户端输入换行符时将缓存的字符串进行处理（process()）。并把处理结果放入 output buffer。\",\"处理完成后，将 state 改为 SENDING，将 output buffer 中的内容写到客户端。\",\"写完后将将 state 改为 READING，继续读取。\",\"@Override public void run() { try { if (state == READING) { // 此时通道已经准备好读取数据 read(); } else if (state == SENDING) { // 此时通道已经准备好写入数据 send(); } } catch (IOException ex) { // 关闭连接 try { selectionKey.channel().close(); } catch (IOException ignore) { } } } /** * 从通道读取字节 */ protected void read() throws IOException { // 清空 input buffer input.clear(); // 读取内容到接收 input buffer int n = socket.read(input); // 判断用户是否输入完成 if (inputIsComplete(n)) { // 用户输入完成，进行处理，将用户输入放入 output buffer process(); // 修改 Handler 状态为响应 state = SENDING; // 修改 channel select 的事件类型 // Normally also do first write now selectionKey.interestOps(SelectionKey.OP_WRITE); } } /** * 当读取到 \\\\r\\\\n 时表示结束，切换到响应状态 * * @param bytes 读取的字节数 * -1：到达了流的末尾，连接已经关闭 * 0：当前没有可用数据，连接仍打开，通常在非阻塞模式下返回 * > 0：读取的字节数 * @throws IOException */ protected boolean inputIsComplete(int bytes) throws IOException { if (bytes > 0) { // 将 ByteBuffer 切换成读取模式 input.flip(); // 每次读取一个字符，添加到 inputStringBuilder，如果读到换行符则结束读取 while (input.hasRemaining()) { byte ch = input.get(); if (ch == 3) { // ctrl+c 关闭连接 state = CLOSED; return true; } else if (ch == '\\\\r') { // continue } else if (ch == '\\\\n') { // 读取到了 \\\\r\\\\n，读取结束 return true; } else { inputStringBuilder.append((char) ch); } } } else if (bytes == -1) { // -1 客户端关闭了连接 throw new EOFException(); } else { // bytes == 0 继续读取 } return false; } /** * 进行业务处理，将用户输入转换成大写 * * @throws EOFException 用户输入 ctrl+c 主动关闭 */ protected void process() throws EOFException { // 构造用户输入内容字符串 String requestContent = inputStringBuilder.toString(); // 构造响应 byte[] response = requestContent.toUpperCase(Locale.ROOT).getBytes(StandardCharsets.UTF_8); output.put(response); } /** * 发送响应 */ protected void send() throws IOException { int written = -1; // 切换到读取模式，读取 output buffer，判断是否有数据要发送 output.flip(); // 如果有数据需要发送，则调用 socket.write 方法发送响应 if (output.hasRemaining()) { written = socket.write(output); } // 检查连接是否处理完毕，是否断开连接 if (outputIsComplete(written)) { selectionKey.channel().close(); } else { // 否则继续读取 state = READING; // 把提示发到界面 socket.write(ByteBuffer.wrap(\\\"\\\\r\\\\nreactor> \\\".getBytes())); selectionKey.interestOps(SelectionKey.OP_READ); } } /** * 当用户输入了一个空行，表示连接可以关闭了 */ protected boolean outputIsComplete(int written) { if (written <= 0) { // 用户只敲了个回车， 断开连接 return true; } // 清空旧数据，接着处理后续的请求 output.clear(); inputStringBuilder.delete(0, inputStringBuilder.length()); return false; } \"]},\"126\":{\"h\":\"5.7 单线程 Reactor 启动\",\"t\":[\"public class Main { public static final int PORT = 8080; public static void main(String[] args) throws IOException { runSingleThreadReactor(); } public static void runSingleThreadReactor() throws IOException { final Reactor reactor = new Reactor(PORT, NioHandler.class); // 启动 Reactor 线程，开始监听 IO 事件 reactor.startThread(); reactor.executor.shutdown(); } } \"]},\"127\":{\"h\":\"6. 单 Reactor 多线程\",\"t\":[\"Reactor 作用就是要迅速的触发 Handler ，在单线程 Reactor 中，Handler 与 Reactor 处于同一线程，Handler 进行业务处理的过程会导致 Reactor 变慢。根据上面分而治之的优化思想，可以将业务处理过程（非 IO 操作，上面的 process() 方法）从 Reactor 线程中拆出来，到单独的 Handler 线程池中处理。下图是单 Reactor 多线程版本。\",\"多线程版本将业务处理和 I/O 操作进行分离，Reactor 线程只关注事件分发和实际的 IO 操作，业务处理如协议的编解码都分配给线程池处理。如上图所示，decode、compute、encode 的业务处理过程拆分到单独的 Handler 线程池去处理。\"]},\"128\":{\"h\":\"6.1 Handler 使用线程池\",\"t\":[\"/** * 多线程 Handler，IO 的 read 和 write 操作仍由 Reactor 线程处理，业务处理逻辑（decode、process、encode）由该线程池处理 */ public class MultiThreadNioHandler extends NioHandler { static Executor pool = Executors.newFixedThreadPool(4); static final int PROCESSING = 3; public MultiThreadNioHandler(Selector selector, SocketChannel socket) throws IOException { super(selector, socket); } /** * 重写 read 方法，从客户端 socket 读取数据之后交给线程池进行处理，而不是在当前线程直接处理 */ @Override protected synchronized void read() throws IOException { input.clear(); int n = socket.read(input); // 判断是否读取完毕（客户端是否输入换行符） if (inputIsComplete(n)) { // 切换成处理中状态，多线程进行处理 state = PROCESSING; pool.execute(new Processor()); } } /** * 业务处理逻辑，处理完后切换成发送状态 */ synchronized void processAndHandOff() { try { // 进行业务处理 process(); } catch (EOFException e) { // 直接关闭连接 try { selectionKey.channel().close(); } catch (IOException ex) { ex.printStackTrace(); } return; } // 业务处理完成，切换成发送状态。发送仍交给 Reactor 线程处理。 state = SENDING; selectionKey.interestOps(SelectionKey.OP_WRITE); // 立即唤醒 selector，以便新注册的 OP_WRITE 事件能立即被响应。 // 此时 Reactor 会收到并分发 OP_WRITE 事件，又会走到 Handler 的 run 方法，由 Reactor 线程继续执行 send() selectionKey.selector().wakeup(); } class Processor implements Runnable { @Override public void run() { processAndHandOff(); } } } \"]},\"129\":{\"h\":\"6.2 多线程 Reactor 启动\",\"t\":[\"public class Main { public static final int PORT = 8080; public static void main(String[] args) throws IOException { runMultiThreadReactor(); } public static void runMultiThreadReactor() throws IOException { final Reactor reactor = new Reactor(PORT, MultiThreadNioHandler.class); reactor.startThread(); reactor.executor.shutdown(); } } \"]},\"130\":{\"h\":\"7. 主从 Reactor 多线程\",\"t\":[\"单 Reactor 多线程的情况下，可能会有这样的情况发生：Handler 线程池中业务处理很快，大部分的时间都花在 Reactor 线程处理 I/O 上，导致 CPU 闲置，降低了响应速度。这里也应用分而治之的优化方法，把 I/O 处理的步骤从 Reactor 线程中拆分出来，用线程池去处理，\",\"主从 Reactor 多线程版本设计了一个 主 Reactor 用于处理连接接收事件（OP_ACCEPT），多个 从 Reactor 线程处理实际的 I/O（OP_READ、OP_WRITE），分工合作，匹配 CPU 和 IO 速率。\"]},\"131\":{\"h\":\"7.1 引入 ReactorGroup\",\"t\":[\"在实现主从 Reactor 时，由于 从 Reactor 中有多个 Reactor 线程，设计到选择和管理 Reactor。我借鉴了 Netty 的实现，引入了 ReactorGroup 来管理 Reactor（Netty 中的 EventLoopGroup）。\",\"public class ReactorGroup { /** * Reactor 数组，保存当前 ReactorGroup 下的所有 Reactor */ final Reactor[] children; /** * 计数器，用来选择下一个 Reactor */ int next = 0; public ReactorGroup(int nThreads) { children = new Reactor[nThreads]; for (int i = 0; i < nThreads; i++) { try { children[i] = new Reactor(); } catch (IOException e) { } } } public Reactor next() { final Reactor reactor = children[next]; if (++next == children.length) { next = 0; } return reactor; } /** * 注册 ServerSocketChannel 到 ReactorGroup 中的下一个选中的 Reactor */ public SelectionKey register(ServerSocketChannel serverSocket) throws ClosedChannelException { return next().register(serverSocket); } } \"]},\"132\":{\"h\":\"7.1 Reactor 类实现\",\"t\":[\"Reactor 类作为 main reactor 和 sub reactor 的实现类，主要工作还是接收 IO 事件然后分发出去。实现和单线程 Reactor 中没有区别，它能满足 main reactor 和 sub reactor 的运行逻辑，它们的区别是主要在于监听的 IO 事件的不同和分发时执行的处理器不同：\",\"main reactor：监听 OP_ACCEPT 事件，新的 OP_ACCEPT 事件到达则调用附加在其 SelectionKey 上的 Acceptor 去分发连接给 sub reactor。\",\"sub reactor：监听 OP_READ 和 OP_WRITE 事件，新的事件到达则调用附加在其 SelectionKey 上的 Handler 去处理业务逻辑。\",\"/** * {@link ReactorGroup} 创建 Reactor 使用 */ public Reactor() throws IOException { executor = Executors.newSingleThreadExecutor(); selector = Selector.open(); this.handlerClass = null; } \",\"相比之前的 Reactor 代码，加了一个构造器，让 ReactorGroup 调用。在主从 Reactor 中，Reactor 不再直接绑定服务端 ServerSocketChannel，而是交给一个统一的启动类来讲服务端 ServerSocketChannel 绑定到服务端口。\"]},\"133\":{\"h\":\"7.2 主从 Reactor 启动类\",\"t\":[\"主从 Reactor 包含两个 ReactorGroup，需要一个类来管理 ReactorGroup，并且管理服务端 ServerSocketChannel，绑定到服务端口。这里也是借鉴 Netty 的 ServerBootstrap，编写了一个启动类 MultiReactorBootstrap。\",\"public class MultiReactorBootstrap { /** * 主 Reactor 组 */ private ReactorGroup mainReactorGroup; /** * 从 Reactor 组 */ private ReactorGroup subReactorGroup; private final ServerSocketChannel serverSocket; private final Class<?> handlerClass; public MultiReactorBootstrap(int port, ReactorGroup mainReactorGroup, ReactorGroup subReactorGroup, Class<?> handlerClass) throws IOException { this.mainReactorGroup = mainReactorGroup; this.subReactorGroup = subReactorGroup; this.handlerClass = handlerClass; // 将服务端 ServerSocketChannel 绑定到端口上 serverSocket = ServerSocketChannel.open(); serverSocket.socket().bind(new InetSocketAddress(port)); serverSocket.configureBlocking(false); // 让 Main Reactor 监听 ServerSocketChannel 上的 ACCEPT 事件 SelectionKey selectionKey = this.mainReactorGroup.register(serverSocket); selectionKey.interestOps(SelectionKey.OP_ACCEPT); selectionKey.attach(new Acceptor()); } private class Acceptor implements Runnable { @Override public synchronized void run() { try { SocketChannel socket = serverSocket.accept(); if (socket != null) { socket.write(ByteBuffer.wrap(\\\"reactor> \\\".getBytes())); // 从 Sub Reactor 组中轮询选择一个 Reactor，用于处理新的客户端连接 final Reactor subReactor = subReactorGroup.next(); // 实例化 Handler final Constructor<?> constructor = handlerClass.getConstructor(Selector.class, SocketChannel.class); // 将客户端 SocketChannel 注册到 Sub Reactor 的 Selector 上 constructor.newInstance(subReactor.selector, socket); // 启动 Sub Reactor 线程，开始监听客户端 SocketChannel 上的 IO 事件 subReactor.startThread(); } } catch (Exception e) { throw new RuntimeException(e); } } } } \"]},\"134\":{\"h\":\"7.3 主从 Reactor 启动\",\"t\":[\"public class Main { public static final int PORT = 8080; public static void main(String[] args) throws IOException { runMultiReactor(); } public static void runMultiReactor() throws IOException { // 创建单线程的主 Reactor 组 ReactorGroup mainReactorGroup = new ReactorGroup(1); // 创建 4 个线程的从 Reactor 组 ReactorGroup subReactorGroup = new ReactorGroup(4); new MultiReactorBootstrap(PORT, mainReactorGroup, subReactorGroup, NioHandler.class); } } \"]},\"135\":{\"h\":\"8. Netty 中的 Reactor 模式\",\"t\":[\"Netty 也是基于 Reactor 模式实现的，并且对其进行了扩展和优化，以满足更高的性能和更多的使用场景。Netty 中主要的类与我的实现中的类对应关系如下：\",\"My Implementation\",\"Netty\",\"Reactor\",\"EventLoop\",\"ReactorGroup\",\"EventLoopGroup\",\"Acceptor\",\"ServerBootstrapAcceptor\",\"NioHandler/MultiThreadNioHandler\",\"ChannelInboundHandler/ChannelOutboundHandler\",\"MultiReactorBootstrap\",\"ServerBootstrap\",\"Netty 在上述概念之外，还引入了 Channel Pipeline 的概念，每个 Channel 都关联一个 Pipeline（无论是服务端还是客户端）。它是由多个 Handler 组成的链表，提供了灵活的方式编排业务 Handler。数据可以在 Channel Pipeline 中流动，被多个 Handler 处理。可以在添加 Handler 时为每个 Handler 指定执行的线程池，如果不指定，就会使用 Reactor 的线程来执行。\",\"以下是主从 Reactor 多线程在 Netty 中组件视图和运行逻辑：\",\"image-20240828014319420\",\"主 ReactorGroup 通常只有 1 个 Reactor 线程，用于监听客户端连接事件\",\"Netty 的 ServerBootstrap 初始化时，会在内部将 ServerBootstrapAcceptor 注册到服务端 Channel 的 Pipeline，用于处理客户端连接\",\"客户端连接事件到来时，ServerBootstrapAcceptor 会选择一个从 Reactor，将客户端 SocketChannel 注册上去，开始监听上面的 IO 读写事件\",\"IO 读写事件就绪时，执行 Pipeline，pipeline 会依次执行链表上的 Handler\",\"一般来说，在某个或某些 Handler 中会有耗时的业务逻辑，也会配置对应的业务线程池来执行这些逻辑。Handler 在对读到的数据解码之后交给对应的业务线程进行业务处理。\",\"业务逻辑处理完毕后，调用 pipeline 的写方法，进行 IO 写，将处理后的响应写回客户端。\",\"Netty 中的 Reactor 线程也是一个线程，内部时一个死循环。它除了轮询和处理 IO 就绪事件以外，还需要执行异步任务和定时任务。\",\"img\",\"Reactor 会优先处理 IO 事件，对于执行异步任务的时间，Reactor 有一个配置来设置处理 IO 事件和执行异步任务的时间比例（默认一比一），随后执行异步任务。\"]},\"136\":{\"h\":\"参考资料\",\"t\":[\"Java NIO 核心知识总结\",\"Java NIO：Buffer、Channel 和 Selector\",\"《Scalable IO in Java》译文\",\"Reactor 典型的 NIO 编程模型\",\"聊聊Netty那些事儿之从内核角度看IO模型\",\"一文聊透 Netty 核心引擎 Reactor 的运转架构\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"137\":{\"h\":\"Java 最强 IO\",\"t\":[\"原文地址：http://hscarb.github.io/java/99991231-java-best-io.html\",\"MappedByteBuffer VS FileChannel 孰强孰弱？\",\"FileChannel, ByteBuffer, Memory-Mapped I/O, Locks [Java Files Tutorial, Part 6]\",\"论最强IO：MappedByteBuffer VS FileChannel\",\"MappedByteBuffer的一点优化\",\"文件 IO 操作的一些最佳实践\",\"天池中间件大赛百万队列存储设计总结【复赛】\",\"MappedByteBuffer vs. FileChannel?\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"138\":{\"h\":\"java\",\"t\":[\"Java 性能优化神器 JMH 从入门到精通\",\"廖雪峰 Java 教程 笔记\",\"Mockito Note\",\"Reactor 模式的 Java 实现（feat. Scalable IO in Java - Doug Lea）\"]},\"139\":{\"h\":\"Vim笔记\",\"t\":[\"原文地址：http://hscarb.github.io/other/20191229-vim-note.html\"]},\"140\":{\"h\":\"Vim模式\"},\"141\":{\"h\":\"Normal普通模式\",\"t\":[\"移动、操作\",\"u undo\"]},\"142\":{\"h\":\"Insert插入模式\",\"t\":[\"进入\",\"i insert\",\"a append\",\"o open a line below\",\"I insert before line\",\"A append after line\",\"O append a line above\",\"gi 快速跳转到最后一次编辑的地方并进入插入模式\",\"退出\",\"esc 退出到Normal模式\",\"ctrl+c 回退到Normal模式\",\"ctrl+[ 回退到Normal模式\",\"插入模式快捷键\",\"ctrl+h 删除上一字符\",\"ctrl+w 删除上一单词\",\"ctrl+u 删除当前行\"]},\"143\":{\"h\":\"Command命令模式\",\"t\":[\"Normal下输入:后执行命令\",\":vs (vertical split)\",\":sp (split)\",\":% s/foo/bar/g 全局替换\",\":set number/set nu 显示行号\",\":set nonu 隐藏行号\",\":syntax on 语法高亮\",\":set hls 搜索高亮 highlight search\",\":set incsearch 增量搜索 边搜索边高亮\",\":help {cmd} 查看帮助\",\":e 重新加载该文件\",\"Read\",\":r! echo % 插入文件名\",\":r! echo %:p 插入文件名全路径\",\":help read\",\":help filename-modifiers\"]},\"144\":{\"h\":\"Visual可视模式\",\"t\":[\"v Normal模式下进入\",\"V 选择行\",\"ctrl+v 块状选择\",\"可视模式下快捷键\",\"d delete 删除\",\"y yank 复制\",\"p paste 粘贴\"]},\"145\":{\"h\":\"快速移动\",\"t\":[\"在Normal模式下\",\"word 以非空白符分割的单词\",\"WORD 以空白符分割的单词\",\"移动\",\"hjkl ←↓↑→\",\"w/W 下一个word/WORD开头\",\"e/E 下一个word/WORD尾\",\"b/B backword 回到上一个word/WORD开头\",\"行间搜索移动\",\"f{char} find 移动到char字符\",\"F{char} rfind 从行尾开始搜索移动到char\",\"t till 移动到char的前一个字符\",\"T rtill 从行尾移动到char前一个字符\",\";/,继续搜索该行下一个/上一个\",\"水平移动\",\"0 移动到行首\",\"^移动到第一个非空白字符\",\"$ 移动到行尾\",\"g_移动到行尾非空白字符\",\"垂直移动\",\"() 在句子间移动\",\"{} 在段落间移动\",\"页面移动\",\"gg/G 移动到文件开头/结尾\",\"ctrl+o 快速返回\",\"H/M/L 跳转到屏幕开头Head 中间Middle 结尾Lower\",\"ctrl+u upword 向上翻页\",\"ctrl+f 向下翻页\",\"zz 把屏幕置为中间\"]},\"146\":{\"h\":\"快速增删改查\"},\"147\":{\"h\":\"快速删除\",\"t\":[\"快速删除字符/单词\",\"x 删除一个字符\",\"d{} delete 配合文本对象删除一个单词\",\"dw delete (around) word\",\"daw = dw delete around word (include space)\",\"diw delete word (exclude space)\",\"删除行\",\"dd delete line\",\"dt{} delete till {}\",\"d$ delete to end of the sline\",\"d0 delete to start of the line\",\"重复\",\"{num}{cmd} repeat cmdnum times\",\"{num}x 删除num个字符\",\"{num}dd 删除num行\"]},\"148\":{\"h\":\"快速修改\",\"t\":[\"r{} replace 替换一个字符为{}\",\"s substitute 删除当前字符并进入插入模式\",\"c{obj} change 删除文本对象并进入插入模式\",\"ct{} change to {} 删除到``并进入插入模式\",\"R 连续替换字符\",\"S 删除整行并进入插入模式\",\"C 删除整行并进入插入操作\",\"{num}r{char} 替换num个字符为char\",\"{num}s 删除num个字符并入插入模式\"]},\"149\":{\"h\":\"快速查询\",\"t\":[\"/ 前向搜索\",\"? 反向搜索\",\"n/N 跳转到上一个/下一个匹配\",\"*/# 搜索光标所在的当前单词，前向/后向匹配\"]},\"150\":{\"h\":\"正则搜索替换\",\"t\":[\":[range]s[ubstitute]/{pattern}/{string}/[flags] 查找并且替换文本，支持正则表达式\",\"range 表示范围，10,20表示10-20行，%表示全部\",\"pattern 要替换的模式（正则表达式）\",\"string 替换后文本\",\"flags 替换标志 \",\"g global 全局范围执行\",\"c confirm 替换前需要确认\",\"nnumber 报告匹配的次数而不替换，可用来查询匹配次数\"]},\"151\":{\"h\":\"多文件操作\",\"t\":[\"vim {filename1} {filename2} -O 在多个窗口打开多个文件\",\"三种多文件操作概念\",\"Buffer: 打开的一个文件的内存缓冲区\",\"Window: Buffer可视化的分割区域\",\"Tab：可以组织为窗口的一个工作区\"]},\"152\":{\"h\":\"Buffer缓冲区\",\"t\":[\":ls 列举当前缓冲区\",\":b n 跳转到第n个缓冲区\",\":bpre:bnext:bfirst:blast\",\":b buffer_name 加上tab补全来跳转\",\":e {文件名} 修改文件\"]},\"153\":{\"h\":\"Window窗口\",\"t\":[\"是可视化的分割区域\",\"一个缓冲区可以分割成多个窗口，每个窗口也可以打开不同缓冲区\",\"ctrl + w, s:sp 水平分割\",\"ctrl + w, v:vs 垂直分割\",\"每个窗口可以继续被无限分割\",\"窗口切换\",\"ctrl + w, w 窗口间循环切换\",\"ctrl + w, h 切换到左边的窗口\",\"ctrl + w, j 切换到下边的窗口\",\"ctrl + w, k 切换到上边的窗口\",\"ctrl + w, l 切换到右边的窗口\",\"移动窗口\",\"ctrl + w, H 左移窗口\",\"ctrl + w, J 下移窗口\",\"ctrl + w, K 上移窗口\",\"ctrl + w, L 右移窗口\",\"重排窗口\",\":h window-resize 查看文档\",\"ctrl + w, = 使所有窗口等宽、等高\",\"ctrl + w, _ 最大化活动窗口的高度\",\"ctrl + w, | 最大化活动窗口的宽度\",\"[N], ctrl + w, _ 把活动窗口的高度设为[N]行\",\"[N], ctrl + w, | 把活动窗口的宽度设为[N]列\"]},\"154\":{\"h\":\"Tab标签页 将窗口分组\",\"t\":[\"Tab是可以容纳一系列窗口的容器\",\":h tabpage 查看文档\",\"Vim的Tab和其他编辑器不太一样，可以想象成Linux的虚拟桌面\",\"如一个Tab管理所有Python文件，一个Tab管理所有HTML文件\",\"Tab操作\",\":tabnew {filename} 新建标签页，打开{filename}\",\":tabe[dit] {filename} 在新标签页中打开{filename}\",\"ctrl + w, T 把当前窗口移到一个新标签页\",\":tabc[lose] 关闭当前标签页及其中的所有窗口\",\":tabo[nly] 只保留活动标签页，关闭所有其他标签页\",\"Tab切换\",\"Command模式命令\",\"普通模式命令\",\"用途\",\":tabn[ext] {N}\",\"{N}gt\",\"切换到编号为{N}的标签页\",\":tabn[ext]\",\"gt\",\"切换到下一标签页\",\":tabp[revious]\",\"gT\",\"切换到上一标签页\"]},\"155\":{\"h\":\"Vim的Text Object\",\"t\":[\"文本对象操作方式\",\"[number]<command>[text object]\",\"number 次数\",\"command 命令 d(elete), c(hange), y(ank), v(isual)\",\"text object 操作的文本对象 w单词，s句子，p段落\",\"iw inner word，表示这个单词，不包含单词外的字符\",\"aw around word，这个单词及环绕这个单词的字符(包含空格)\",\"操作成对括号中的内容\",\"i(i) 1 * ([2 + 3])\",\"a(a) 1 * [(2 + 3)]\",\"i<i> The <[tag]>\",\"......\",\"{}\",\"[]\",\"\\\"\\\"\",\"``\",\"ci\\\" 删除双引号里面的内容并进入插入模式\"]},\"156\":{\"h\":\"Vim复制粘贴与寄存器\",\"t\":[\"Normal模式赋值粘贴\",\"y(ank) 复制\",\"p(ut) 粘贴\",\"d(elete) 剪切\",\"v(isual) 选中要复制的地方\",\"yiw 复制一个单词\",\"yy 复制一行\",\"Insert模式复制粘贴\",\"和其他编辑器差不多\",\"在vimrc设置autoindent，粘贴代码会缩进错乱\",\"需要用:set paste:set nopaste解决\"]},\"157\":{\"h\":\"Vim寄存器\",\"t\":[\"Vim复制粘贴操作的是寄存器而不是系统剪贴板\",\"默认复制和剪切的内容放到了“无名寄存器”\",\"Vim使用多组寄存器进行剪切、复制与粘贴\",\"\\\"{register} 指定寄存器 {register}为有名寄存器a-z\",\"\\\"\\\" 无名寄存器\",\"\\\"ayiw 复制一个单词到寄存器a中\",\"\\\"bdd剪切当前行到寄存器b中\",\":reg {register}查看寄存器内容\"]},\"158\":{\"h\":\"常见寄存器\",\"t\":[\"\\\"0 复制专用寄存器，使用y复制文本同时会被拷贝到复制寄存器0\",\"\\\"+ 系统剪贴板，在复制前加上\\\"+可以将内容复制到系统剪贴板\",\"\\\"% 当前文件名\",\"\\\". 上次插入文本\",\":set clipboard=unnamedset clipboard+=unnamed 直接复制粘贴系统剪贴板内容\"]},\"159\":{\"h\":\"Vim宏(Macro)\",\"t\":[\"一系列命令的集合\",\"可以使用宏录制一系列操作，然后用于回放\",\"可以方便的应用在多行文本上\"]},\"160\":{\"h\":\"录制和回放宏\",\"t\":[\"q{register} 在普通模式下录制到register寄存器\",\"q 结束录制\",\"@{register} 回放某寄存器中的宏\"]},\"161\":{\"h\":\"将宏应用到多行，在Command模式下执行Normal模式命令\",\"t\":[\"在visual模式下选择多行\",\":'<,'> 输冒号进入Command模式\",\":'<,'>normal @a 为多行执行normal命令\"]},\"162\":{\"h\":\"Vim补全\",\"t\":[\"命令\",\"补全类型\",\"常用\",\"ctrl + n\",\"普通关键字\",\"√\",\"ctrl + w, ctrl + n\",\"当前缓冲区关键字\",\"ctrl + x, ctrl + i\",\"包含文件关键字\",\"ctrl + x, ctrl + ]\",\"标签文件关键字\",\"ctrl + x, ctrl + k\",\"字典查找\",\"ctrl + x, ctrl + l\",\"整行补全\",\"ctrl + x, ctrl + f\",\"文件名补全\",\"√\",\"ctrl + x, ctrl + o\",\"全能(Omni)补全\",\"√\"]},\"163\":{\"h\":\"更换配色\",\"t\":[\":colorscheme 显示当前主题颜色，默认default\",\":colorscheme <ctrl + d> 显示所有配色\",\":colorscheme {配色名} 修改配色\"]},\"164\":{\"h\":\"插件\"},\"165\":{\"h\":\"安装插件管理器\",\"t\":[\"推荐插件：https://github.com/junegunn/vim-plug\",\"安装：\",\"iwr -useb https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim |` ni \\\"$(@($env:XDG_DATA_HOME, $env:LOCALAPPDATA)[$null -eq $env:XDG_DATA_HOME])/nvim-data/site/autoload/plug.vim\\\" -Force \",\"使用： \",\":edit $MYVIMRC\",\"call plug#begin() \\\" List your plugins here Plug 'tpope/vim-sensible' call plug#end() \",\"Reload the file :source % or restart Vim, then you can, \",\":PlugInstall to install the plugins\",\":PlugUpdate to install or update the plugins\",\":PlugDiff to review the changes from the last update\",\":PlugClean to remove plugins no longer in the list\"]},\"166\":{\"h\":\"插件网站\",\"t\":[\"https://vimawesome.com/\"]},\"167\":{\"h\":\"快速跳转插件\",\"t\":[\"if exists('g:vscode') Plug 'asvetliakov/vim-easymotion', { 'as': 'vsc-easymotion' } else Plug 'vim-easymotion/vim-easymotion' endif \\\" ... \\\" easy motion 添加递归映射（后面那个也是一个映射，所以要递归映射） \\\" 含义为：按下 ss，就开始搜索 2 个字符的 EasyMotion 跳转 nmap ss <Plug>(easymotion-s2)ggjjjjjjjjjjk \\\" easy motion let g:EasyMotion_smartcase = 1 \\\" 启用智能大小写匹配 nmap <Leader>j <Plug>(easymotion-jumptoanywhere) \\\" 按下;j跳转到任意位置 nmap <Leader>f <Plug>(easymotion-s2) \\\" 按下;f触发双字符搜索 \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"168\":{\"h\":\"Erlang 学习笔记\",\"t\":[\"原文地址：http://hscarb.github.io/other/20220614-erlang-note.html\"]},\"169\":{\"h\":\"顺序编程\"},\"170\":{\"h\":\"基本概念\"},\"171\":{\"h\":\"Erlang shell\",\"t\":[\"# 启动 erl # 停止 q() # 对应 init:stop() # 立即停止系统 erlang:halt() \",\"% 注释 \",\"可以挂接一个shell到集群里另一个Erlang节点上运行的Erlang系统，甚至还可以生成一个安全shell（secure shell，即ssh）直接连接远程计算机上运行的Erlang系统。通过它，可以与Erlang节点系统中任何节点上的任何程序进行交互。\",\"f() 命令让shell忘记现有的任何绑定。help() 命令获取帮助。\",\"6> help(). ** shell internal commands ** b() -- display all variable bindings e(N) -- repeat the expression in query <N> f() -- forget all variable bindings f(X) -- forget the binding of variable X h() -- history h(Mod) -- help about module h(Mod,Func)-- help about function in module h(Mod,Func,Arity) -- help about function with arity in module ht(Mod) -- help about a module's types ht(Mod,Type) -- help about type in module ht(Mod,Type,Arity) -- help about type with arity in module hcb(Mod) -- help about a module's callbacks hcb(Mod,CB) -- help about callback in module hcb(Mod,CB,Arity) -- help about callback with arity in module history(N) -- set how many previous commands to keep results(N) -- set how many previous command results to keep catch_exception(B) -- how exceptions are handled v(N) -- use the value of query <N> rd(R,D) -- define a record rf() -- remove all record information rf(R) -- remove record information about R rl() -- display all record information rl(R) -- display record information about R rp(Term) -- display Term using the shell's record information rr(File) -- read record information from File (wildcards allowed) rr(F,R) -- read selected record information from file(s) rr(F,R,O) -- read selected record information with options ** commands in module c ** bt(Pid) -- stack backtrace for a process c(Mod) -- compile and load module or file <Mod> cd(Dir) -- change working directory flush() -- flush any messages sent to the shell help() -- help info h(M) -- module documentation h(M,F) -- module function documentation h(M,F,A) -- module function arity documentation i() -- information about the system ni() -- information about the networked system i(X,Y,Z) -- information about pid <X,Y,Z> l(Module) -- load or reload module lm() -- load all modified modules lc([File]) -- compile a list of Erlang modules ls() -- list files in the current directory ls(Dir) -- list files in directory <Dir> m() -- which modules are loaded m(Mod) -- information about module <Mod> mm() -- list all modified modules memory() -- memory allocation information memory(T) -- memory allocation information of type <T> nc(File) -- compile and load code in <File> on all nodes nl(Module) -- load module on all nodes pid(X,Y,Z) -- convert X,Y,Z to a Pid pwd() -- print working directory q() -- quit - shorthand for init:stop() regs() -- information about registered processes nregs() -- information about all registered processes uptime() -- print node uptime xm(M) -- cross reference check a module y(File) -- generate a Yecc parser ** commands in module i (interpreter interface) ** ih() -- print help for the i module true \"]},\"172\":{\"h\":\"整数运算\",\"t\":[\"1> 2 + 3 * 4. 14 \",\"Erlang可以用任意长度的整数执行整数运算。在Erlang里，整数运算是精确的，因此无需担心运算溢出或无法用特定字长（ word size）来表示某个整数。\"]},\"173\":{\"h\":\"变量\",\"t\":[\"1> X = 123. 2> X. 123 \",\"所有变量名都必须以大写字母开头。\",\"Erlang 中的 = 是一个模式匹配操作符，当关联一个值与一个变量时，所下的是一种断言，也就是事实陈述。这个变量具有那个值，仅此而已。\",\"X 不是一个变量，是一次性赋值变量，只能被赋值一次。\",\"变量的作用域是它定义时所处的语汇单元。不存在全局变量或私有变量的说法。\",\"在Erlang里， =是一次模式匹配操作。 Lhs = Rhs 的真正意思是：计算右侧（ Rhs）的值，然后将结果与左侧（ Lhs）的模式相匹配。 我们第一次说 X = SomeExpression时， Erlang对自己说：“我要做些什么才能让这条语句为真？”因为X还没有值，它可以绑定X到SomeExpression这个值上，这条语句就成立了。\",\"这符合了 Erlang 这种函数式编程语言的不可变状态。\"]},\"174\":{\"h\":\"浮点数\",\"t\":[\"1> 5/3. 1.6666666666666667 % 用 / 给两个整数做除法时，结果会自动转换成浮点数。 2> 4/2. 2.0 % 整除结果仍是浮点数 3> 5 div 3. 1 % N 除以 M 然后舍去余数 4> 5 rem 3. 2 % N 除以 M 后剩下的余数 5> 4 div 2. 2 % 浮点数的程序会存在和C等语言一样的浮点数取整与精度问题 \"]},\"175\":{\"h\":\"原子\",\"t\":[\"表示常量值，也可以视作枚举类型。\",\"原子是全局性的，而且不需要宏定义或包含文件就能实现。\",\"原子以小写字母开头，后接一串字母、数字、下划线（_）或at（@）符号。\",\"也可以放在单引号内，以大写字母开头或包含字母数字以外字符的原子。\",\"原子的值就是它本身\"]},\"176\":{\"h\":\"元组\",\"t\":[\"数量固定的项目归组成单一的实体\",\"元组里的字段没有名字，常用做法是将元组第一个元素设为一个原子，用来表示元组是什么。\",\"{point, 10, 5}. Person = {person, {name, joe}, {height, 1.82}, {footsize, 42}, {eyecolour, brown}}. % 用模式匹配的方式提取元组的值 Point = {point, 10, 45}. {point, X, Y} = Point. % 用_作为占位符 Person = {person, {name, joe, armstrong}, {footsize, 42}}. {_,{_,Who,_},_}=Person. Who. > joe \"]},\"177\":{\"h\":\"列表\",\"t\":[\"[8,hello,0,{cost,apple,10},3] \",\"用来存放任意数量的事物\",\"第一个元素称为列表头，剩下元素是列表尾。\",\"访问列表头是一种非常高效的操作，因此基本上所有的列表处理函数都从提取列表头开始，然后对它做一些操作，接着处理列表尾。\",\"如果T是一个列表，那么[H|T]也是一个列表， 它的头是H，尾是T。竖线（|） 把列表的头与尾分隔开。 []是一个空列表。\",\"% 扩展列表 7> Things = [{apples,10},{pears,6},{milk,3}]. [{apples,10},{pears,6},{milk,3}] 8> Things1=[{oranges,4},{newspaper,1}|Things]. [{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}] % 提取列表元素，[X|Y] = L（ X和Y都是未绑定变量）会提取列表头作为X，列表尾作为Y。 9> [Buy1|Things2]=Things1. [{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}] 10> Buy1. {oranges,4} 11> Things2. [{newspaper,1},{apples,10},{pears,6},{milk,3}] %% 12> [Buy2,Buy3|Things3]=Things2. [{newspaper,1},{apples,10},{pears,6},{milk,3}] 13> Buy2. {newspaper,1} 14> Buy3. {apples,10} 15> Things3. [{pears,6},{milk,3}] \"]},\"178\":{\"h\":\"字符串\",\"t\":[\"严格来说，Erlang 里没有字符串。用整数组成的列表或一个二进制型表示字符串。当用整数列表表示字符串时，列表里的每个元素代表了一个Unicode字符。\",\"16> Name=\\\"Hello\\\". % \\\"Hello\\\"其实只是一个列表的简写，这个列表包含了代表字符串里各个字符的整数字符代码 \\\"Hello\\\" % shell打印某个列表的值时，如果列表内的所有整数都代表可打印字符，它就会将其打印成字符串字面量。否则，打印成列表记法 17> [1,2,3]. [1,2,3] 18> [83,117,114,112,114,105,115,101]. \\\"Surprise\\\" 19> [1,83,117,114,112,114,105,115,101]. [1,83,117,114,112,114,105,115,101] % 如果shell将某个整数列表打印成字符串，而你其实想让它打印成一列整数，那就必须使用格式化的写语句 1> X = [97,98,99]. \\\"abc\\\" 3> io:format(\\\"~w~n\\\",[X]). [97,98,99] % $a实际上就是代表字符a的整数 20> I = $s. 115 22> [$S,117,114,112,114,105,115,101]. \\\"Surprise\\\" % 必须使用特殊的语法才能输入某些字符，在打印列表时也要选择正确的格式惯例。 23> X=\\\"a\\\\x{221e}b\\\". [97,8734,98] 24> io:format(\\\"~ts~n\\\",[X]). a\\\\x{221E}b \"]},\"179\":{\"h\":\"模块与函数\"},\"180\":{\"h\":\"模块：module\",\"t\":[\"模块是Erlang的基本代码单元。模块保存在扩展名为 .erl 的文件里，而且必须先编译才能运行模块里的代码。编译后的模块以 .beam 作为扩展名。\",\"逗号 , 分隔函数调用、数据构造和模式中的参数。\",\"分号 ; 分隔子句。我们能在很多地方看到子句，例如函数定义，以及case、 if、try..catch和receive表达式。\",\"句号 .（后接空白）分隔函数整体，以及shell里的表达式。\",\"% geometry.erl -module(geometry). % 模块声明，模块名必须与存放该模块的主文件名相同 -export([area/1]). % 导出声明，Name/N 指带有 N 个参数的函数 Name。已导出函数相当于公共方法，未导出函数相当于私有方法 % 函数定义，area 函数有两个子句 area({rectangle, Width, Height}) -> Width * Height; % 子句以分号隔开 area({square, Side}) -> Side * Side. % 以句号结尾 \",\"1> c(geometry). % 在 erlang shell 中编译，编译之后产生 geometry.beam 目标代码块 {ok,geometry} 2> geometry:area({rectangle, 10, 5}). % 调用函数，要附上模块名 50 3> geometry:area({square, 3}). 9 \",\"-module(geometry). -export([area/1, test/0]). % 添加测试，测试仅仅需要模式匹配和= test() -> 12 = area({rectangle, 3, 4}), 144 = area({square, 12}), tests_worked. area({rectangle, Width, Height}) -> Width * Height; area({square, Side}) -> Side * Side. \",\"5> c(geometry). {ok,geometry} 6> geometry:test(). tests_worked \",\"% 情况分析函数 total([{What, N} | T]) -> shop:cost(What) * N + total(T); total([]) -> 0. \"]},\"181\":{\"h\":\"高阶函数 fun\",\"t\":[\"Erlang 是函数式编程语言，表示函数可以被用作参数，也可以返回函数。\",\"操作其他函数的函数被称为高阶函数。\",\"代表函数的数据类型是 fun。\",\"1> Double = fun(X) -> 2 * X end. #Fun<erl_eval.44.65746770> 2> Double(2). 4 % fun 可以有多个子句 3> TempConvert = fun({c, C}) -> {f, 32 + C * 9 / 5}; ({f, F}) -> {c, (F - 32) * 5 / 9} end. #Fun<erl_eval.44.65746770> 4> TempConvert({c, 100}). {f,212.0} 5> TempConvert({f, 212}). {c,100.0} \",\"% 标准库高阶函数 %% map 6> L = [1,2,3,4]. [1,2,3,4] 7> lists:map(fun(X) -> 2 * X end, L). [2,4,6,8] %% filter 8> Even = fun(X) -> (X rem 2) =:= 0 end. #Fun<erl_eval.44.65746770> 9> Even(8). true 10> Even(7). false 11> lists:map(Even, [1,2,3,4,5,6,7,8]). [false,true,false,true,false,true,false,true] 12> lists:filter(Even, [1,2,3,4,5,6,7,8]). [2,4,6,8] \",\"% 返回 fun 的函数，括号内的东西就是返回值 13> MakeTest = fun(L) -> (fun(X) -> lists:member(X, L) end) end. #Fun<erl_eval.44.65746770> 15> Fruit = [apple, pear, orange]. [apple,pear,orange] 16> IsFruit = MakeTest(Fruit). #Fun<erl_eval.44.65746770> 17> IsFruit(pear). true 18> IsFruit(dog). false 19> lists:filter(IsFruit, [dog,orange,cat,apple,bear]). [orange,apple] 22> Mult = fun(Times) -> (fun(X) -> X * Times end) end. #Fun<erl_eval.44.65746770> 23> Triple = Mult(3). #Fun<erl_eval.44.65746770> 24> Triple(5). 15 \"]},\"182\":{\"h\":\"实现 for\",\"t\":[\"% Erlang 没有 for 循环，而是需要自己编写控制结构 % 创建列表[F(1), F(2), ..., F(10)] for(Max, Max, F) -> [F(Max)]; for(I, Max, F) -> [F(I) | for(I + 1, Max, F)]. 9> lib_misc:for(1,10,fun(I)->I end). [1,2,3,4,5,6,7,8,9,10] 10> lib_misc:for(1,10,fun(I)->I*I end). [1,4,9,16,25,36,49,64,81,100] \"]},\"183\":{\"h\":\"列表处理（sum、map）\",\"t\":[\"%% 列表求和函数 sum([H | T]) -> H + sum(T); sum([]) -> 0. %% map 函数 map(_, []) -> []; map(F, [H | T]) -> [F(H) | map(F, T)]. total(L) -> sum(map(fun({What, N}) -> shop:cost(What) * N end, L)). \"]},\"184\":{\"h\":\"列表推导（[F(X) || X <- L]）\",\"t\":[\"列表推导（list comprehension）是无需使用fun、 map或filter就能创建列表的表达式。它让程序变得更短，更容易理解。\",\"1> L = [1,2,3,4,5]. [1,2,3,4,5] 2> [2*X||X<-L]. % [F(X) || X <- L]：由 F(X) 组成的列表（X 从列表 L 中提取） [2,4,6,8,10] \",\"列表推导的常规形式\",\"[X || Qualifier1, Qualifier2, ...] \",\"X 是任一表达式，后面的限定符可以是生成器、位串生成器或过滤器。\",\"生成器（generator）的写法是 Pattern <- ListExpr ，其中的 ListExp 必须是一个能够得出列表的表达式。\",\"位串（bitstring）生成器的写法是 BitStringPattern <= BitStringExpr ，其中的 BitStringExpr 必须是一个能够得出位串的表达式。\",\"过滤器（filter）既可以是判断函数（即返回true或false的函数），也可以是布尔表达式。请注意，列表推导里的生成器部分起着过滤器的作用\",\"%% 快速排序 qsort([]) -> []; qsort([Pivot | T]) -> qsort([X || X <- T, X < Pivot]) % 生成器 + 过滤器，生成一个比 Pivot 小的数组成的列表，递归 ++ [Pivot] % ++ 是中缀插入操作符，在中间插入 Pivot ++ qsort([X || X <- T, X >= Pivot]). %% 毕达哥拉斯三元数组 %% 提取1到N的所有A值，1到N的所有B值，1到N的所有C值，条件是A + B + C小于等于N并且A*A + B*B = C*C。 pythag(N) -> [ {A, B, C} || A <- lists:seq(1, N), B <- lists:seq(1, N), C <- lists:seq(1, N), A + B + C =< N, A * A + B * B =:= C * C ]. \"]},\"185\":{\"h\":\"内置函数\",\"t\":[\"built-in function，是那些作为Erlang语言定义一部分的函数。有些内置函数是用Erlang实现的，但大多数是用Erlang虚拟机里的底层操作实现的。最常用的内置函数（例如list_to_tuple）是自动导入的。\",\"4> list_to_tuple([12,cat,\\\"hello\\\"]). {12,cat,\\\"hello\\\"} 5> time(). {22,55,25} \"]},\"186\":{\"h\":\"关卡（when）\",\"t\":[\"关卡（guard）是一种结构，可以用它来增加模式匹配的威力，它通过 when 引入。通过使用关卡，可以对某个模式里的变量执行简单的测试和比较。 \",\"关卡由一系列关卡表达式组成，由 , 分割，都为 true 是值才为 true。（AND）\",\"关卡序列（guard sequence）是指单一或一系列的关卡，用 ; 分割，只要一个为 true，它的值就为 true。（OR）\",\"原子 true 关卡防止在某个 if 表达式的最后。\",\"% Guard 是用于增强模式匹配的结构。 % Guard 可用于简单的测试和比较。 % Guard 可用于函数定义的头部，以`when`关键字开头，或者其他可以使用表达式的地方。 max(X, Y) when X > Y -> X; max(X, Y) -> Y. % guard 可以由一系列 guard 表达式组成，这些表达式以逗号分隔。 % `GuardExpr1, GuardExpr2, ..., GuardExprN` 为真，当且仅当每个 guard 表达式均为真。 is_cat(A) when is_atom(A), A =:= cat -> true; is_cat(A) -> false. is_dog(A) when is_atom(A), A =:= dog -> true; is_dog(A) -> false. % guard 序列 `G1; G2; ...; Gn` 为真，当且仅当其中任意一个 guard 表达式为真。 is_pet(A) when is_dog(A); is_cat(A) -> true; is_pet(A) -> false. \"]},\"187\":{\"h\":\"case 表达式\",\"t\":[\"case Expression of Pattern1 [when Guard1] -> Body1; Pattern2 [when Guard2] -> Body2; ... end % `case` 表达式。 % `filter` 返回由列表`L`中所有满足`P(x)`为真的元素`X`组成的列表。 filter(P, [H|T]) -> case P(H) of true -> [H|filter(P, T)]; false -> filter(P, T) end; filter(P, []) -> []. filter(fun(X) -> X rem 2 == 0 end, [1, 2, 3, 4]). % [2, 4] \",\"Expression 被执行，假设它的值为 Value\",\"Value 轮流与 Pattern1（带有可选的关卡 Guard1）、Pattern2 等模式进行匹配，直到匹配成功。\",\"一旦发现匹配，相应的表达式序列就会执行，而表达式序列执行的结果就是 case 表达式的值。如果所有模式都不匹配，就会发生异常错误（exception）。\"]},\"188\":{\"h\":\"if 表达式\",\"t\":[\"if Guard1 -> Expr_seq1; Guard2 -> Expr_seq2; ... end % `if` 表达式。 max(X, Y) -> if X > Y -> X; X < Y -> Y; true -> nil; end. \",\"执行 Guard1。 如果得到的值为 true，那么if的值就是执行表达式序列 Expr_seq1 所得到的值。\",\"如果 Guard1 不成功，就会执行 Guard2， 以此类推，直到某个关卡成功为止。\",\"if表达式必须至少有一个关卡的执行结果为true， 否则就会发生异常错误。\",\"很多时候， if 表达式的最后一个关卡是原子 true， 确保当其他关卡都失败时表达式的最后部分会被执行。（相当于最后带 else）因为 erlang 的所有表达式都应该有值。\"]},\"189\":{\"h\":\"归集器\",\"t\":[\"只遍历列表一次，返回两个列表。\",\"%% 归集器 odds_and_even(L) -> odds_and_evens_acc(L, [], []). odds_and_evens_acc([H|T], Odds, Evens) -> case (H rem 2) of 1 -> odds_and_evens_acc(T, [H|Odds], Evens); 0 -> odds_and_evens_acc(T, Odds, [H|Evens]) end; odds_and_evens_acc([], Odds, Evens) -> {Odds, Evens}. \"]},\"190\":{\"h\":\"记录（record）与映射组（map）\",\"t\":[\"元组用于保存固定数量的元素，而列表用于保存可变数量的元素。记录其实就是元组的另一种形式。\",\"使用 record：有一大堆元组，并且每个元组都有相同的结构\",\"使用 map：键值对\"]},\"191\":{\"h\":\"record\",\"t\":[\"% Record 可以将元组中的元素绑定到特定的名称。 % Record 定义可以包含在 Erlang 源代码中，也可以放在后缀为`.hrl`的文件中（Erlang 源代码中 include 这些文件）。 -record(todo, { status = reminder, % Default value who = joe, text }). % 在定义某个 record 之前，我们需要在 shell 中导入 record 的定义。 % 我们可以使用 shell 函数`rr` (read records 的简称）。 rr(\\\"records.hrl\\\"). % [todo] % 创建和更新 record。 X = #todo{}. % 创建 todo，所有键都是原子 % #todo{status = reminder, who = joe, text = undefined} X1 = #todo{status = urgent, text = \\\"Fix errata in book\\\"}. % #todo{status = urgent, who = joe, text = \\\"Fix errata in book\\\"} X2 = X1#todo{status = done}. % 创建 X1 的副本，并修改 status 为 done % #todo{status = done,who = joe,text = \\\"Fix errata in book\\\"} % 提取 record 字段 > #todo{who=W, text=Txt} = X2. > W. joe > Txt. \\\"Fix errata in book\\\" % 如果只是想要记录里的单个字段，就可以使用“点语法”来提取该字段。 > X2#todo.text. \\\"Fix errata in book\\\" % 让 shell 忘掉 todo 定义 rf(todo). \"]},\"192\":{\"h\":\"map\",\"t\":[\"映射组在系统内部是作为有序集合存储的，打印时总是使用各键排序后的顺序。\",\"表达式K => V有两种用途，一种是将现有键K的值更新为新值V，另一种是给映射组添加一个全新的K-V对。这个操作总是成功的。\",\"表达式K := V的作用是将现有键K的值更新为新值V。 如果被更新的映射组不包含键K，这个操作就会失败。\",\"映射组在比较时首先会比大小，然后再按照键的排序比较键和值。\",\"% 创建 map > F1 = #{a => 1, b => 2}. #{a => 1,b => 2} % => 更新或设值 11> F3 = F1#{c=>xx}. #{a => 1,b => 2,c => xx} % := 只能更新值 12> F4=F1#{c := 3}. ** exception error: bad key: c in function maps:update/3 called as maps:update(c,3,#{a => 1,b => 2}) *** argument 3: not a map in call from erl_eval:'-expr/5-fun-0-'/2 (erl_eval.erl, line 256) in call from lists:foldl/3 (lists.erl, line 1267) 13> F4 = F3#{c := 3}. #{a => 1,b => 2,c => 3} \"]},\"193\":{\"h\":\"顺序程序的错误处理\",\"t\":[\"exit(Why) \",\"当你确实想要终止当前进程时就用它。如果这个异常错误没有被捕捉到，信号 {'EXIT', Pid,Why} 就会被广播给当前进程链接的所有进程。\",\"throw(Why) \",\"这个函数的作用是抛出一个调用者可能想要捕捉的异常错误。在这种情况下，我们注明了 被调用函数可能会抛出这个异常错误。有两种方法可以代替它使用 \",\"为通常的情形编写代码并且有意忽略异常错误\",\"把调用封装在一个 try...catch 表达式里， 然后对错误进行处理。\",\"error(Why) \",\"这个函数的作用是指示“崩溃性错误”，也就是调用者没有准备好处理的非常严重的问题。它与系统内部生成的错误差不多。\",\"% 当遇到内部错误或显式调用时，会触发异常。 % 显式调用包括 `throw(Exception)`, `exit(Exception)` 和 % `erlang:error(Exception)`. generate_exception(1) -> a; generate_exception(2) -> throw(a); generate_exception(3) -> exit(a); generate_exception(4) -> {'EXIT', a}; generate_exception(5) -> erlang:error(a). % Erlang 有两种捕获异常的方法。其一是将调用包裹在`try...catch`表达式中。 catcher(N) -> try generate_exception(N) of Val -> {N, normal, Val} catch throw:X -> {N, caught, thrown, X}; exit:X -> {N, caught, exited, X}; error:X -> {N, caught, error, X} end. % 另一种方式是将调用包裹在`catch`表达式中。 % 此时异常会被转化为一个描述错误的元组。 catcher(N) -> catch generate_exception(N). \"]},\"194\":{\"h\":\"用 try ... catch 捕获异常\",\"t\":[\"try ... catch 具有一个值\",\"try ... catch 表达式和case表达式之间的相似性，像是它的强化版，基本上是 case 表达式加上最后的 catch 和 after 区块。\",\"首先执行 FuncOrExpessionSeq 。 如果执行过程没有抛出异常错误，那么函数的返回值就会与Pattern1（ 以及可选的关卡Guard1）、 Pattern2等模式进行匹配，直到匹配成功。如果能匹配，那么整个 try...catch 的值就通过执行匹配模式之后的表达式序列得出。 如果 FuncOrExpressionSeq 在执行中抛出了异常错误，那么ExPattern1等捕捉模式就会与它进行匹配，找出应该执行哪一段表达式序列。ExceptionType是一个原子（ throw、exit和error其中之一），告诉我们异常错误是如何生成的。如果省略了ExceptionType， 就会使用默认值throw。\",\"% Erlang 有两种捕获异常的方法。其一是将调用包裹在`try...catch`表达式中。 catcher(N) -> try generate_exception(N) of Val -> {N, normal, Val} catch throw:X -> {N, caught, thrown, X}; exit:X -> {N, caught, exited, X}; error:X -> {N, caught, error, X} end. demo1() -> [catcher(I) || I <- [1, 2, 3, 4, 5]]. % 提供了概括信息 >try_test:demo1(). [{1,normal,a}, {2,caught,thrown,a}, {3,caught,exited,a}, {4,normal,{'EXIT',a}}, {5,caught,error,a}] \"]},\"195\":{\"h\":\"用 catch 捕捉异常错误\",\"t\":[\"catch 和 try ... catch 里的 catch 不是一回事，异常错误如果发生在 catch 语句里， 就会被转换成一个描述此错误的 {'EXIT', ...}元组。\",\"% 另一种方式是将调用包裹在`catch`表达式中。 % 此时异常会被转化为一个描述错误的元组。 catcher2(N) -> catch generate_exception(N). demo2() -> [{I, catcher2(I)} || I <- [1, 2, 3, 4, 5]]. % 提供了详细的栈跟踪信息 > try_test:demo2(). [{1,a}, {2,a}, {3,{'EXIT',a}}, {4,{'EXIT',a}}, {5, {'EXIT',{a,[{try_test,generate_exception,1, [{file,\\\"try_test.erl\\\"},{line,23}]}, {try_test,catcher2,1,[{file,\\\"try_test.erl\\\"},{line,38}]}, {try_test,'-demo2/0-lc$^0/1-0-',1, [{file,\\\"try_test.erl\\\"},{line,41}]}, {try_test,'-demo2/0-lc$^0/1-0-',1, [{file,\\\"try_test.erl\\\"},{line,41}]}, {erl_eval,do_apply,6,[{file,\\\"erl_eval.erl\\\"},{line,689}]}, {shell,exprs,7,[{file,\\\"shell.erl\\\"},{line,686}]}, {shell,eval_exprs,7,[{file,\\\"shell.erl\\\"},{line,642}]}, {shell,eval_loop,3,[{file,\\\"shell.erl\\\"},{line,627}]}]}}}] \"]},\"196\":{\"h\":\"针对异常的编程样式\",\"t\":[\"sqrt(X) when X < 0 -> % 内置函数 error 可以改进错误信息 error({squareRootNegativeArgument, X}); sqrt(X) -> math:sqrt(X). % 函数多半应该返回 {ok, Value} 或 {error, Reason} error_process(X) -> case f(X) of {ok, Val} -> do_some_thing_with(Val); {error, Why} -> %% process this error do_other_thing_with(error) end. % 捕捉一切可能的异常错误 error_process3(X) -> try my_func(X) catch _:_ -> process_error() end. \"]},\"197\":{\"h\":\"栈跟踪（erlang:get_stacktrace()）\"},\"198\":{\"h\":\"二进制型与位语法\"},\"199\":{\"h\":\"顺序编程补遗\"},\"200\":{\"h\":\"apply\",\"t\":[\"内置函数apply(Mod, Func, [Arg1, Arg2, ..., ArgN])会将模块Mod里的Func函数应用到Arg1, Arg2, ... ArgN这些参数上。\",\"> apply(erlang, atom_to_list, [hello]). \\\"hello\\\" \",\"应当尽量避免使用apply。 当函数的参数数量能预先知道时， M:F(Arg1, Arg2, ... ArgN) 这种调用形式要比apply好得多。\"]},\"201\":{\"h\":\"算数表达式\"},\"202\":{\"h\":\"属性\",\"t\":[\"模块属性的语法是 -AtomTag(...) ， 它们被用来定义文件的某些属性。\",\"包含预定义的模块属性和用户定义的属性。\"]},\"203\":{\"h\":\"预定义模块属性\",\"t\":[\"-module(modulename)：模块声明\",\"-import(Mod, [Name/Arity1, Name2/Arity2, ...])：列举了哪些函数要导入到模块中\",\"-compile(Options)：添加 Options 到编译器选项列表中\",\"-vsn(Version)：指定模块的版本号\"]},\"204\":{\"h\":\"用户定义的模块属性\",\"t\":[\"-SomeTag(Value).：SomeTag 必须是一个原子，Value 必须是一个字面数据类型\",\"-author({jeo, armstring}). -purpose(\\\"example of attributes\\\"). \"]},\"205\":{\"h\":\"块表达式\",\"t\":[\"用于以下情形：代码某处的Erlang语法要求单个表达式，但我们想使用一个表达式序列\",\"begin Expr1, ..., ExprN end \"]},\"206\":{\"h\":\"布尔值 布尔表达式\",\"t\":[\"Erlang没有单独的布尔值类型。不过原子true和false具有特殊的含义，可以用来表示布尔值。\",\"not B1\",\"B1 and B2\",\"B1 or B2\",\"B1 xor B2\"]},\"207\":{\"h\":\"动态代码载入\",\"t\":[\"每当调用 someModule:someFunction(...) 时，调用的总是最新版模块里的最新版函数，哪怕当代码在模块里运行时重新编译了该模块也是如此。 Erlang允许一个模块的两个版本同时运行：当前版和旧版。重新编译某个模块时，任何运行旧版代码的进程都会被终止，当前版成为旧版，新编译的版本则成为当前版\"]},\"208\":{\"h\":\"预处理器\",\"t\":[\"Erlang模块在编译前会自动由Erlang的预处理器进行处理。预处理器会展开源文件里所有的宏，并插入必要的包含文件。\",\"如调试某个有问题的宏时，应该保存预处理器的输出。\",\"erlc -P some_module.erl \"]},\"209\":{\"h\":\"转义序列\",\"t\":[\"可以在字符串和带引号的原子里使用转义序列来输入任何不可打印的字符。\"]},\"210\":{\"h\":\"函数引用\",\"t\":[\"引用在当前或外部模块里定义的某个函数。\",\"fun LocalFunc/Arity：引用当前模块的本地函数\",\"fun Mod:RemoteFunc/Arity：引用 Mod 模块的外部函数\"]},\"211\":{\"h\":\"包含文件\",\"t\":[\"许多模块需要共享通用的记录定义，就会把它们放到包含文件里，再由所有需要这些定义的模块包含此文件\",\"-include(Filename).\",\"按照Erlang的惯例，包含文件的扩展名是.hrl。 FileName应当包含一个绝对或相对路径，使预处理器能找到正确的文件。包含库的头文件（ library header file）时可以用下面的语法：\",\"-include_lib(\\\"kernel/include/file.hrl\\\") \"]},\"212\":{\"h\":\"列表操作：++、--\",\"t\":[\"++ 和 -- 是用于列表添加和移除的中缀操作符。\",\"A ++ B 使A和B相加（也就是附加）。\",\"A -- B 从列表A中移除列表B。 移除的意思是B中所有元素都会从A里面去除。 \",\"请注意：如果符号X在B里只出现了K次，那么A只会移除前K个X。\"]},\"213\":{\"h\":\"宏 -define()\",\"t\":[\"% 宏语法模板，erlang预处理器 epp 碰到 ?MacronName 的表达式时会展开这个宏 -define(Constant, Replacement). -define(Func(Var1, Var2, .., Var), Replacement). \",\"-define(macro1(X, Y), {a, X, Y}). foo(A) -> ?macro1(A+10, b) % --- 展开后 --- foo(A) -> {a, A+10, b}. \",\"预制宏\",\"?FILE\",\"?MODULE\",\"?LINE\"]},\"214\":{\"h\":\"宏控制流\",\"t\":[\"-undef(Macro).\",\"-ifdef(Macro).\",\"-ifndef(Macro).\",\"-else.\",\"-endif.\"]},\"215\":{\"h\":\"数字\",\"t\":[\"Erlang里的数字不是整数就是浮点数，整数的运算时精确的。\",\"% K 进制 2#00101010 16#af6bfa23 % $ 写法，代表 ASCII 字符的整数代码 $a % 97的简写 % 浮点数 1.0 3.14159 -2.3e+6 23.56E-27 \"]},\"216\":{\"h\":\"操作符优先级\"},\"217\":{\"h\":\"进程字典\",\"t\":[\"每个Erlang进程都有一个被称为进程字典（ process dictionary）的私有数据存储区域。他是一个 map。\",\"put(Key, Value) -> OldValue.\",\"get(Key) -> Value.\",\"get() -> [{Key, Value}].：返回整个进程字典\",\"get_keys(Value) -> [Key].：返回字典里面所有值为 Value 的键\",\"erase(Key) -> Value.\",\"erase() -> [{Key, Value}].\",\"1> erase(). [] 2> put(x, 20). undefined 3> get(x). 20 4> get(y). undefined 5> put(y, 40). undefined 6> get(y). 40 7> get(). [{y,40},{x,20}] 8> erase(x). 20 9> get(). [{y,40}] \"]},\"218\":{\"h\":\"引用\",\"t\":[\"引用（ reference）是一种全局唯一的Erlang数据类型。它们由内置函数 erlang:make_ref() 创建。 引用的用途是创建独一无二的标签，把它存放在数据里并在后面用于比较是否相等。\"]},\"219\":{\"h\":\"短路布尔表达式\",\"t\":[\"只在必要时才对参数求值\",\"Expr1 orelse Expr2：Expr1 || Expr2\",\"Expr1 andalso Expr2：Expr1 && Expr2\"]},\"220\":{\"h\":\"比较数据类型\"},\"221\":{\"h\":\"类型\"},\"222\":{\"h\":\"编译和运行程序\"},\"223\":{\"h\":\"改变开发环境\",\"t\":[\"code:get_path() 获取当前载入路径值\",\"-spec code:add_patha(Dir) 向载入路径的开头添加一个新目录 Dir\",\"-spec code:add_pathz(Dir) 向载入路径的末端添加一个新目录 Dir\"]},\"224\":{\"h\":\"运行程序的不同方式\",\"t\":[\"% erlang shell erl 1> c(hello). {ok,hello} 2> hello:start(). Hello world ok % 命令行界面直接编译和运行 $ erlc hello.erl % -noshell 不带交互式 shell 的方式启动 Erlang % -s hello start 运行 hello:start() 函数 % -s init stop 在之前的命令完成后执行 init:stop() 函数，从而停止系统 $ erl -noshell -s hello start -s init stop Hello world \",\"#!/usr/bin/env escript main(Args) -> io:format(\\\"Hello world~n\\\"). \"]},\"225\":{\"h\":\"makefile 使编译自动化\"},\"226\":{\"h\":\"并发和分布式程序\"},\"227\":{\"h\":\"现实世界中的并发\",\"t\":[\"Erlang进程没有共享内存，每个进程都有它自己的内存。要改变其他某个进程的内存，必须向它发送一个消息，并祈祷它能收到并理解这个消息。\"]},\"228\":{\"h\":\"并发编程\",\"t\":[\"Erlang 编写并发程序只需要三个基本函数\"]},\"229\":{\"h\":\"基本并发函数\",\"t\":[\"Pid = spawn(Mod, Func, Args)：创建一个并行进程来执行 apply(Mod, Func, Args)\",\"Pid = spawn(Fun)：创建一个新的并发进程来执行 FUn()\",\"Pid ! Message：向 Pid 进程发送消息 Message，消息发送是异步的。Pid1 ! Pid2 ! ... ! Msg 意思是把消息 Msg 发给所有进程\",\"receive ... end：接收发送给某个进程的消息\",\"receive Pattern1 [when Guard1] -> Expressions1; Pattern2 [when Guard2] -> Expressions2; ... end \",\"每个进程都带有一个进程邮箱，与进程同步创建。收到的消息会被放入该进程的邮箱，程序执行一条接收语句时才会读取邮箱。\"]},\"230\":{\"h\":\"客户端-服务器\",\"t\":[\"% Erlang 依赖于 actor并发模型。在 Erlang 编写并发程序的三要素： % 创建进程，发送消息，接收消息 % 启动一个新的进程使用`spawn`函数，接收一个函数作为参数 F = fun() -> 2 + 2 end. % #Fun<erl_eval.20.67289768> spawn(F). % <0.44.0> % `spawn` 函数返回一个pid(进程标识符)，你可以使用pid向进程发送消息。 % 使用 `!` 操作符发送消息。 % 我们需要在进程内接收消息，要用到 `receive` 机制。 -module(caculateGeometry). -compile(export_all). caculateAera() -> receive {rectangle, W, H} -> W * H; {circle, R} -> 3.14 * R * R; _ -> io:format(\\\"We can only caculate area of rectangles or circles.\\\") end. % 编译这个模块，在 shell 中创建一个进程，并执行 `caculateArea` 函数。 c(caculateGeometry). CaculateAera = spawn(caculateGeometry, caculateAera, []). CaculateAera ! {circle, 2}. % 12.56000000000000049738 % shell也是一个进程(process), 你可以使用`self`获取当前 pid self(). % <0.41.0> \"]},\"231\":{\"h\":\"进程很轻巧\",\"t\":[\"% 查看允许的最大进程数量 > erlang:system_info(processlimit). 262144 \"]},\"232\":{\"h\":\"带超时的接收\",\"t\":[\"为避免接收语句因为消息不来而一直等待，可以给接收语句增加一个超时设置，设置进程等待接收消息的最长时间。\",\"receive Pattern1 [when Guard1] -> Expressions1; Pattern2 [when Guard2] -> Expressions2; ... after Time -> Expressions end \"]},\"233\":{\"h\":\"选择性接收\",\"t\":[\"receive 基本函数从进程邮箱中提取消息，做模式匹配，把未匹配的消息加入队列供以后处理，并管理超时。\"]},\"234\":{\"h\":\"注册进程\",\"t\":[\"一般创建进程时，只有父进程知道子进程的 PID。使用注册进程的方法，可以公布进程标识符，让任何进程都能与该进程通信。\",\"% 用 AnAtom 作为名称来注册进程 Pid register(AnAtom, Pid) % 移除与 AnAtom 关联的所有注册信息 unregister(AnAtom) % 检查 AnAtom 是否已被注册 whereis(AnAtom) -> Pid | undefined % 返回包含系统里所有注册进程的列表 registered() -> [AnAtom::atom()] \"]},\"235\":{\"h\":\"尾递归的说明\",\"t\":[\"尾递归：收到消息进行处理之后立即再次调用 loop()\",\"% 并发程序模板 % 接收并打印出任何发给它的消息 -module(ctemplate). -compile(export_all). start() -> spawn(?MODULE, loop, []). rpc(Pid, Request) -> Pid ! {self(), Request}, receive {Pid, Response} -> Response end. loop(X) -> receive Any -> io:format(\\\"Received:~p~n\\\", [Any]), loop(X) end. \"]},\"236\":{\"h\":\"分布式编程\"},\"237\":{\"h\":\"两种分布式模型\",\"t\":[\"分布式 Erlang\",\"程序在 Erlang 节点（node）上运行，节点是一个独立的 Erlang 系统，包含一个自带地址空间和进程组的完整虚拟机。\",\"通常运行在数据同一个局域网的集群上，并受防火墙保护。\",\"基于套接字的分布式模型\",\"用 TCP/IP 套接字来编写运行在不可信环境中的分布式应用程序。不如分布式 Erlang 那样强大，但是更安全。\"]},\"238\":{\"h\":\"编写一个分布式程序\",\"t\":[\"分布式应用程序编写顺序\",\"在常规非分布式会话里编写和测试程序\",\"在运行于同一台计算机上的两个不同 Erlang 节点中测试程序\",\"在运行于两台物理隔离计算机上的两个不同 Erlang 节点里测试程序。\"]},\"239\":{\"h\":\"编程库与框架\"},\"240\":{\"h\":\"接口技术\"},\"241\":{\"h\":\"Erlang 如何与外部程序通信\",\"t\":[\"Erlang 通过端口对象与外部程序通信。端口的行为就像一个 Erlang 进程。\",\"-spec open_port(PortName, [Opt]) -> Port 可以创建端口\",\"% 向端口发送Data Port ! {PicC, {command, Data}} % 把相连进程的 PID 从 PicC 改为 Pid1 Port ! {PicC, {connect, Pid1}} % 关闭端口 Port ! {Pid, close} \"]},\"242\":{\"h\":\"用端口建立外部 C 程序接口\"},\"243\":{\"h\":\"在 Erlang 里调用 shell 脚本\",\"t\":[\"% 运行字符串的命令并捕捉结果 os:cmd(\\\"ifconfig\\\"). \"]},\"244\":{\"h\":\"文件编程\"},\"245\":{\"h\":\"套接字编程\"},\"246\":{\"h\":\"用 WebSocket 和 Erlang 进行浏览\"},\"247\":{\"h\":\"用 ETS 和 DETS 存储数据\",\"t\":[\"ets 和 dets 是两个系统模块，用来高效存储海量的 Erlang 数据。它们都提供大型的键-值查询表。可以被多个进程共享。\",\"ETS（Erlang Term Storage）：常驻内存，查找时间是恒定的。易失。没有垃圾收集机制，不会有垃圾收集的负担。\",\"DETS（Disk ETS）：使用磁盘存储，速度慢于 ETS，内存占用也小很多。非易失。打开时会进行一致性检查，损坏会尝试修复，可能会花很长时间；表中最后一项可能是损坏的会丢失。\"]},\"248\":{\"h\":\"表的类型\",\"t\":[\"ETS 和 DETS 表保存的是元组。元组里的某一个元素（默认是第一个）被称为该表的键。\",\"异键表（set）：表里所有的键都是唯一的\",\"有序异键（ordered set）：元组会被排序\",\"同键表（bag）：允许多个元素拥有相同的键\",\"副本同键（duplicate bag）：可以有多个元组拥有相同的键，而且在同一张表里可以存在多个相同的元组\",\"-module(ets_test). %% API -export([start/0]). start() -> lists:foreach(fun test_ets/1, [set, ordered_set, bag, duplicate_bag]). test_ets(Mode) -> TableId = ets:new(test, [Mode]), ets:insert(TableId, {a, 1}), ets:insert(TableId, {b, 2}), ets:insert(TableId, {a, 1}), ets:insert(TableId, {a, 3}), List = ets:tab2list(TableId), io:format(\\\"~-13w => ~p~n\\\", [Mode, List]), ets:delete(TableId). \",\"λ erl Eshell V12.3.2.1 (abort with ^G) 1> c(ets_test). {ok,ets_test} 2> ets_test:start(). set => [{b,2},{a,3}] ordered_set => [{a,3},{b,2}] bag => [{b,2},{a,1},{a,3}] duplicate_bag => [{b,2},{a,1},{a,1},{a,3}] ok \"]},\"249\":{\"h\":\"影响 ETS 表效率的因素\",\"t\":[\"ETS 表在内部是用散列表表示的，（ordered set）用平衡二叉树表示。\"]},\"250\":{\"h\":\"保存元组到磁盘\"},\"251\":{\"h\":\"Mnesia：Erlang 数据库\",\"t\":[\"Mnesia是一种用Erlang编写的数据库。\",\"Mnesia的速度极快，可以保存任何类型的Erlang数据结构。它还是高度可定制的。数据表既可以保存在内存里（为了速度），也可以保存在磁盘上（为了持久性）。表还可以在不同机器之间进行复制，从而实现容错行为。\"]},\"252\":{\"h\":\"创建初始数据库\",\"t\":[\"$ erl % mnesia:create_schema(NodeList) 会在 Erlang 节点列表的所有节点上都初始化一个新的 Mnesia 数据库，会初始化并且创建一个目录结构来保存 1> mnesia:create_schema([node()]). ok 2> init:stop(). ok $ ls Mnesia.nonode@nohost # 创建名为 joe 的 erlang 节点 $ erl -sname joe # 启动 erlang 时指向一个特定的数据库 $ erl -mnesia dir '\\\"/home/joe/some/path/to/Mnesia.company\\\"' \"]},\"253\":{\"h\":\"数据库查询\",\"t\":[\"-module(test_mnesia). -import(lists, [foreach/2]). -compile(export_all). %% IMPORTANT: The next line must be included %% if we want to call qlc:q(...) -include_lib(\\\"stdlib/include/qlc.hrl\\\"). % Mnesia 里的表是一个包含若干行的**异键或同键表**，其中每一行都是**一个 Erlang 记录**。要在 Mnesia 里表示这些表，需要一些**记录定义**来对表里的行进行定义。 -record(shop, {item, quantity, cost}). -record(cost, {name, price}). -record(design, {id, plan}). %% 初始化数据表 do_this_once() -> mnesia:create_schema([node()]), mnesia:start(), mnesia:create_table(shop, [{attributes, record_info(fields, shop)}]), mnesia:create_table(cost, [{attributes, record_info(fields, cost)}]), mnesia:create_table(design, [{attributes, record_info(fields, design)}]), mnesia:stop(). start() -> mnesia:start(), mnesia:wait_for_tables([shop,cost,design], 20000). %% SQL equivalent %% SELECT * FROM shop; demo(select_shop) -> do(qlc:q([X || X <- mnesia:table(shop)])); %% SQL equivalent %% SELECT item, quantity FROM shop; demo(select_some) -> do(qlc:q([{X#shop.item, X#shop.quantity} || X <- mnesia:table(shop)])); %% SQL equivalent %% SELECT shop.item FROM shop %% WHERE shop.quantity < 250; demo(reorder) -> do(qlc:q([X#shop.item || X <- mnesia:table(shop), X#shop.quantity < 250 ])); %% SQL equivalent %% SELECT shop.item %% FROM shop, cost %% WHERE shop.item = cost.name %% AND cost.price < 2 %% AND shop.quantity < 250 demo(join) -> do(qlc:q([X#shop.item || X <- mnesia:table(shop), X#shop.quantity < 250, Y <- mnesia:table(cost), X#shop.item =:= Y#cost.name, Y#cost.price < 2 ])). do(Q) -> F = fun() -> qlc:e(Q) end, {atomic, Val} = mnesia:transaction(F), Val. example_tables() -> [%% The shop table {shop, apple, 20, 2.3}, {shop, orange, 100, 3.8}, {shop, pear, 200, 3.6}, {shop, banana, 420, 4.5}, {shop, potato, 2456, 1.2}, %% The cost table {cost, apple, 1.5}, {cost, orange, 2.4}, {cost, pear, 2.2}, {cost, banana, 1.5}, {cost, potato, 0.6} ]. add_shop_item(Name, Quantity, Cost) -> Row = #shop{item=Name, quantity=Quantity, cost=Cost}, F = fun() -> mnesia:write(Row) end, mnesia:transaction(F). remove_shop_item(Item) -> Oid = {shop, Item}, F = fun() -> mnesia:delete(Oid) end, mnesia:transaction(F). farmer(Nwant) -> %% Nwant = Number of oranges the farmer wants to buy F = fun() -> %% find the number of apples [Apple] = mnesia:read({shop,apple}), Napples = Apple#shop.quantity, Apple1 = Apple#shop{quantity = Napples + 2*Nwant}, %% update the database mnesia:write(Apple1), %% find the number of oranges [Orange] = mnesia:read({shop,orange}), NOranges = Orange#shop.quantity, if NOranges >= Nwant -> N1 = NOranges - Nwant, Orange1 = Orange#shop{quantity=N1}, %% update the database mnesia:write(Orange1); true -> %% Oops -- not enough oranges mnesia:abort(oranges) end end, mnesia:transaction(F). reset_tables() -> mnesia:clear_table(shop), mnesia:clear_table(cost), F = fun() -> foreach(fun mnesia:write/1, example_tables()) end, mnesia:transaction(F). add_plans() -> D1 = #design{id = {joe,1}, plan = {circle,10}}, D2 = #design{id = fred, plan = {rectangle,10,5}}, D3 = #design{id = {jane,{house,23}}, plan = {house, [{floor,1, [{doors,3}, {windows,12}, {rooms,5}]}, {floor,2, [{doors,2}, {rooms,4}, {windows,15}]}]}}, F = fun() -> mnesia:write(D1), mnesia:write(D2), mnesia:write(D3) end, mnesia:transaction(F). get_plan(PlanId) -> F = fun() -> mnesia:read({design, PlanId}) end, mnesia:transaction(F). \"]},\"254\":{\"h\":\"性能分析、调试与跟踪\"},\"255\":{\"h\":\"Erlang 代码的性能分析工具\",\"t\":[\"cprof 统计各个函数被调用的次数。它是一个轻量级的性能分析器，在活动系统上运行它会增加 5%～ 10% 的系统负载。\",\"fprof显示调用和被调用函数的时间，结果会输出到一个文件。它适用于实验室或模拟系统里的大型系统性能分析，并会显著增加系统负载。\",\"eprof 测量 Erlang 程序是如何使用时间的。它是 fprof 的前身，适用于小规模的性能分析。\",\"(scarb@DESKTOP-72654G4)5> cprof:start(). 9795 (scarb@DESKTOP-72654G4)6> shout:start(). ** exception error: undefined function shout:start/0 (scarb@DESKTOP-72654G4)7> mnesia:stop(). stopped (scarb@DESKTOP-72654G4)8> cprof:pause(). 9795 (scarb@DESKTOP-72654G4)9> cprof:analyse(mnesia). {mnesia,1,[{{mnesia,stop,0},1}]} \"]},\"256\":{\"h\":\"运行时诊断\",\"t\":[\"deliberate_error(A) -> bad_function(A, 12), lists:reverse(A). bad_function(A, _) -> {ok, Bin} = file:open({abc,123}, A), binary_to_list(Bin). \",\"错误消息之后是栈跟踪信息。它以发生错误的函数名开头，后面是当前函数完成后将会返回的各个函数清单（包括函数名、模块名和行号）。由此可知，错误发生在 lib_misc:bad_function/2 里，而此函数将会返回到 lib_misc:deliberate_error/1，以此类推。\"]},\"257\":{\"h\":\"调试方法\"},\"258\":{\"h\":\"io:format 调试\",\"t\":[\"给程序添加打印语句是最常见的调试形式。可以简单地在程序的关键位置添加 io:format(...) 语句来打印出感兴趣的变量值。\",\"调试并行程序时，一种好的做法是在发送消息到别的进程之前先把它打印出来，收到消息之后也要立即打印。\"]},\"259\":{\"h\":\"转储至文件\",\"t\":[\"dump(File, Term) -> Out = File ++ \\\".tmp\\\", io:format(\\\"** dumping to ~s~n\\\",[Out]), {ok, S} = file:open(Out, [write]), io:format(S, \\\"~p.~n\\\",[Term]), file:close(S). \"]},\"260\":{\"h\":\"Erlang 调试器\"},\"261\":{\"h\":\"跟踪消息与进程执行\",\"t\":[\"erlang:trace(PidSpec, How, FlagList) 它会启动跟踪。PidSpec 告诉系统要跟踪什么进程，How 是一个开启或关闭跟踪的布尔值，FlagList 指定了要跟踪的事件（比如，可以跟踪所有的函数调用，跟踪所有正在发送的消息，跟踪垃圾收集何时进行，等等）。 一旦调用了 erlang:trace/3 这个内置函数，调用它的进程就会在跟踪事件发生时收到跟踪消息。跟踪事件本身是通过调用 erlang:trace_pattern/3确定的。\",\"erlang:trace_pattern(MFA, MatchSpec, FlagList)\",\"它用于设置一个跟踪模式。如果模式匹配，请求的操作就会执行。这里的MFA是一个{Module, Function, Args}元组，指定要对哪些代码应用跟踪模式。 MatchSpec是一个模式，会在每次进入MFA指定的函数时进行测试，而FlagList规定了跟踪条件满足时要 做什么。\",\"可以用库模块 dbg 来执行与之前相同的跟踪。\",\"fib(0) -> 1; fib(1) -> 1; fib(N) -> fib(N - 1) + fib(N - 2). test1() -> dbg:tracer(), dbg:tpl(tracer_test, fib, '_', dbg:fun2ms(fun(_) -> return_trace() end)), dbg:p(all, [c]), tracer_test:fib(4). \"]},\"262\":{\"h\":\"OTP 介绍\",\"t\":[\"Open Telecom Platform（开放电信平台），它是一个应用程序操作系统，包含了一组库和实现方式，可以构建大规模、容错和分布式的应用程序。它由瑞典电信公司爱立信开发，在爱立信内部用于构建容错式系统。标准的Erlang分发套装包含OTP库。\",\"OTP 包含了许多强大的工具，例如一个完整的 Web 服务器，一个FTP服务器和一个 CORBAORB 等。\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"263\":{\"h\":\"Arthas 笔记\",\"t\":[\"原文地址：http://hscarb.github.io/other/20230306-arthas-note.html\"]},\"264\":{\"h\":\"Arthas idea plugin 文档\",\"t\":[\"https://www.yuque.com/wangji-yunque/rk4eks/ruradh\"]},\"265\":{\"h\":\"执行静态方法和 Spring 对象方法\",\"t\":[\"https://hicode.club/articles/2022/03/30/1648606091635.html\"]},\"266\":{\"h\":\"Spring\",\"t\":[\"设置输出内容为json\",\"options json-format true \",\"找到 org.springframework.boot.loader.LaunchedURLClassLoader 的 hash\",\"classloader -l \",\"找到 spring 对象并执行方法\",\"# 执行无参数 vmtool -c f2c488 --action getInstances \\\\ --className org.springframework.context.ApplicationContext \\\\ --express 'instances[0].getBean(\\\"globalCtxManager\\\").obtGlobalStatistics()' # 执行带参数的方法，其中参数是普通变量 vmtool -c f2c488 --action getInstances \\\\ --className org.springframework.context.ApplicationContext \\\\ --express 'instances[0].getBean(\\\"globalCtxManager\\\").obtUserAliveStatus(1156083311884992513L)' # 执行带参数的方法，其中参数是对象。如果需要构建对象，可以参考： # https://juejin.cn/post/6844904013859651597#heading-16 vmtool -c f2c488 --action getInstances \\\\ --className org.springframework.context.ApplicationContext \\\\ --express 'instances[0].getBean(\\\"liveCoreService\\\").searchLiveInfo((#demo=new com.uewell.ubirth.bus.live.bo.live.LiveInfoParam(), #demo.setId('12345L'),#demo))' \"]},\"267\":{\"h\":\"直接执行静态方法\",\"t\":[\"ognl -c 54acff7d '@io.netty.buffer.PooledByteBufAllocator@DEFAULT' ognl -c f2c488 '@io.netty.util.internal.PlatformDependent@DIRECT_BUFFER_PREFERRED' \"]},\"268\":{\"h\":\"使用Arthas显式执行代码，避免重启应用，10倍提升本地研发效率\",\"t\":[\"https://github.com/alibaba/arthas/issues/1823\"]},\"269\":{\"h\":\"前提\",\"t\":[\"本方法最适用于 Spring Boot 项目。\"]},\"270\":{\"h\":\"谁拖垮了效率？\",\"t\":[\"本地开发时有两个操作最耗时：\",\"每次代码变更都要重启一次项目，重启的时间相对较长。\",\"代码深层次的一个方法，也需要有类似 HTTP 的触发入口一层一层调用过来，这是非常麻烦的事。\",\"所以我在寻找一种可以不停机的开发方法，所有变更都能随时生效，代码随写随测。\"]},\"271\":{\"h\":\"探索\",\"t\":[\"代码热变更方面，我使用了久负盛名的 IDEA 插件 JRebel。该插件可以做到绝大部分的新增/修改代码，安装使用方式可以在网上搜索。\",\"但有了 JRebel 之后，我发现仍然很难调用看到的方法，如果通过 HTTP 接口调用过来很麻烦，过程很长，并且前后的一些操作的结果也是我不想要的。再比如写着写着突然对某个资源的响应内容不确定。 我希望能随时调用看到的每一个方法。后来看了一些 arthas 的 user case 和文档，大脑中最后几块拼图也终于拼上了。\"]},\"272\":{\"h\":\"准备工作\",\"t\":[\"随意调用方法，其实是指 Spring 上下文中的方法。否则直接写 main 方法或 Tester 代码就可以随写随测。以 Spring 的上下文进行调用才是我们想要的。以下是准备工作：\",\"安装 IDEA Arthas 插件：https://arthas.aliyun.com/doc/idea-plugin.html\",\"项目中增加依赖 Arthas Spring Boot Starter：https://arthas.aliyun.com/doc/spring-boot-starter.html ，担心安全问题的话可以只在本地开启，其他环境配置 spring.arthas.enabled = false\",\"代码中提供获取 Spring ApplicationContext 的变量的方法，参考 https://github.com/WangJi92/arthas-plugin-demo/blob/master/src/main/java/com/wangji92/arthas/plugin/demo/common/ApplicationContextProvider.java，并配置好插件获取 Spring Context 的路径:\",\"截屏2021-06-14 下午1 39 34\"]},\"273\":{\"h\":\"开始起飞\",\"t\":[\"使用 JRebel 的方式启动项目，启动后浏览器打开 Arthas 控制台 http://localhost:8563 ，在要调用的方法上选择复制Static Spring Context Invoke Method Field\",\"随后到 Arthas 控制台粘贴即可：\",\"整个开发过程中 Arthas 控制台不用关，随时想测某个方法时，复制命令 -> 控制台执行 -> 观察 即可。\",\"此方法对以下一些场景有奇效：\",\"XXL-Job 任务执行。本地不希望任务在跑，就可以在启动时关闭任务注册功能。测试时也可以不依赖 xxl-job admin 随时调试任务。\",\"Dubbo 服务。不用模拟客户端或者泛化调用之类的，直接用 arthas 整。Arthas 命令不方便设置复杂的入参，这种情况可以在方法中自行覆盖参数，用 JRebel 热更新一下就行。\"]},\"274\":{\"h\":\"ognl 使用姿势\",\"t\":[\"https://cloud.tencent.com/developer/article/1846725\",\"https://juejin.cn/post/6844904013859651597\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"275\":{\"h\":\"分布式系统韧性架构压舱石OpenChaos\",\"t\":[\"原文地址：http://hscarb.github.io/other/20230306-openchaos.html\",\"Key Takeaways\",\"本文首先以现今分布式系统的复杂性和稳定性的需求引出混沌工程概念，并阐述了OpenChaos在传统混沌工程上的优化与创新。\",\"第二部分中，介绍了OpenChaos的架构，详细讲解了它的可靠性模型和弹性模型的工作原理，并以两个实战案例展示了OpenChaos在实际应用场景中可以发挥的效果。\",\"最后一部分展望未来，提出了OpenChaos后续的发展方向。\"]},\"276\":{\"h\":\"背景\",\"t\":[\"随着Serverless，微服务（含服务网格）与越来越多的容器化架构应用的出现，我们构建、交付与运维系统的方式变的越发复杂。这种复杂性增加了系统状态可观测性的难度。在已有的生产环境中，我们有不同的方式来获取信息，增强系统的可观测性。起始的时候，可能是非常简单的给定一个特定的条件，产生一个特定的指标输出。进一步的，使用结构化和关联日志，或进行分布式跟踪，引入事件总线如Apache EventMesh、EventGrid等。随着Codeless组合式应用快速发展，Serverless设计理念也在不断被一些分布式系统设计者逐步接受。免运维，按需付费，极致弹性，多租共池等等无不在逼迫我们重新审视老式架构的合理性，催生新架构的不断演进。融合架构是这几年被提的最多的一个词，以往支撑在线/离线系统的复杂架构不断被融合，通过可分可合的设计与部署方式去适配各种业务场景。在这样的背景下，我们开始认真审视并思考，是否有一种更为现代化的工具，能够帮助发现并应对分布式云这种底座对架构设计以及上层应用带来的诸如可靠，安全，弹性等一系列韧性架构的挑战。\",\"混沌工程思想给我们带来了一定程度的启发。Netflix最初为了搬迁基础设施上云创建了 Chaos Monkey，由此拉开了混沌工程学的序幕。再到后来，CNCF成立了专门的兴趣小组，希望能够推动这一领域的标准诞生。OpenChaos创始团队早期也和这些社区的先行者进行过多轮交流。可惜的是，2019年随着该兴趣组并入App Delivery SIG后再无太大动静。这几年国家政策大力引导下，企业的数字化升级不断加快，越来越多的CIO、CTO甚至包括CEO开始重视并投入到混沌工程实践中。国内由信通院牵头的混沌工程实验室也在如火如荼地推动该领域的飞速发展，从全链路压测，混沌故障引入到催生未来架构变革的多云多活参考架构的制定。这些无不昭示着这一产业在飞速发展。根据国内外科技媒体调研统计，到2025年，80%的组织将实施混沌工程实践。通过全链路压测，混沌故障，以及多云多活架构等策略的整体导入，可以将意外停机时间减少50%，实现真正意义上的秒级RTO/RPO。让应用、业务创新更加专注。\"]},\"277\":{\"h\":\"良药虽好，但也有局限\",\"t\":[\"混沌工程的最基本流程是在生产环境小规模定期自动化执行试验，为系统随机的注入故障，来观察 \\\"系统边界\\\"。它主要关注系统面对故障所展现出的容错能力，可靠性。目前市面上绝大部分混沌工程工具，倾向于构造以黑盒随机为主的故障类型，对底层基础设施（硬件，操作系统，数据库与中间件）理解与洞察较少。缺少统一的框架标准、成熟的specific度量指标。同时，分析反馈较弱，无法给出全面彻底的诊断建议，尤其通过强化学习，生成式AI等能力可以进一步解决目前随机故障注入，进行自愈风险分析与优化建议。\",\"面向有更多复杂特性的分布式系统，仅通过观察系统应对故障的表现是有局限的，并且依赖于观察是极其主观的，很难形成统一的评测标准，也较难针对表现分析系统缺陷。系统的可观测性，不仅需要模型的全面覆盖，还需要完备的监测系统，并提供全面的结果报告，甚至智能预测，来指导架构提升自身的韧性能力。分布式领域资深技术专家，开源顶级项目Apache RocketMQ，OpenMessaging最初的创始人冯嘉曾表示\\\"云原生分布式架构的演进正在朝着组装式架构，韧性架构进一步发展\\\"。在这样的背景下，他提出并带领团队创造了OpenChaos这一新兴项目。\"]},\"278\":{\"h\":\"OpenChaos 需要解决的本质问题\",\"t\":[\"韧性架构，覆盖高靠性、安全、弹性、不可变基础设施等特性。实现真正的韧性架构毫无疑问是现代分布式系统的演进方向。针对分布式系统韧性能力，OpenChaos借助混沌工程思想，对其定义进行延伸扩展。针对一些分布式系统特有属性，如Pub/Sub系统的投递语义与推送效率，调度编排系统的精准调度、弹性伸缩与冷启效率，streaming系统的流批实时性、反压效率，检索系统的查全率与查准率，分布式系统共识组件的一致性等，设置专用的检测模型。OpenChaos 内置可扩展的模型支持，以便验证在大规模数据请求以及各种故障冲击下的韧性表现，并为架构演进提供进一步优化建议。\"]},\"279\":{\"h\":\"架构与案例分析\",\"t\":[\"图1\"]},\"280\":{\"h\":\"整体架构\",\"t\":[\"OpenChaos的工作原理是这样的：控制面对整个流程进行控制，负责使集群节点组成一个待测试的分布式集群。并会根据需要测试的分布式基础设施找到对应的Driver组件并载入，根据设置的并发数建立相应个数的客户端。控制节点根据 Model 组件定义的执行流程控制客户端对集群进行操作。演练过程中，Detection Model 会对集群节点根据不同的观测特性引入对应的事件。Metrics 模块会在实验中监测被测集群的表现。演练结束后，Checker组件会对实验中的业务和非业务数据进行自动化分析，得出测试结果并输出可视化图表。\",\"如图1所示，OpenChaos的整体架构可以分为管理层，执行层与被测组件层。\",\"最上层为管理层，它包含了用户界面和控制器（Control），控制器负责调度引擎层的组件进行工作。最下层为被测组件，它可以是自部署的分布式系统集群，也可以是容器或者云厂商承载的分布式系统。\",\"中间层是执行层，也是OpenChaos强大能力的秘密所在。模型（Model）是执行的流程的基本单元，它定义了对分布式系统进行操作的基本形式。控制器在模型中载入需要测试的分布式系统的驱动（Driver），并根据配置的并发数创建相应的客户端（Client），最终使用客户端对分布式系统执行操作。**检测模型（Detection Model）**会根据用户关注的不同观测特性引入对应的事件，比如引入故障或者系统的扩缩容。Metrics 模块会在实验中监测被测集群的表现。演练结束后，**度量模型（Measurement Model）**组件会对实验中的业务和非业务数据进行自动化分析，得出测试结果并输出可视化图表。\"]},\"281\":{\"h\":\"检测模型与度量模型\"},\"282\":{\"h\":\"检测模型\",\"t\":[\"传统混沌工程主要关注系统的稳定性，它们的普遍实现是通过黑盒的故障注入来模拟一些常见的通用故障。OpenChaos中的检测模型关注更高维度的属性------韧性，它包含可靠性，还包含如弹性、安全性等特性的检测模型。相较于传统混沌工程，OpenChaos不仅支持普遍的黑盒故障注入，还可恶意针对分布式基础软件如消息或缓存等的主备倒换，网络分区导致的脑裂等问题做定制检测，以观察他们在这种情况下的表现。\"]},\"283\":{\"h\":\"度量模型\",\"t\":[\"由于分布式系统的复杂性，对于分布式系统韧性的观测更需要一个简单直观的分析报告，来让人更方便地发现分布式系统可能存在的缺陷和不足。度量模型会对系统的表现进行分析，以统一的标准化计算输出结果与图表，方便使用者进行对比分析。以消息系统的稳定性评估为例，度量模型会根据实验中故障注入情况与系统表现，计算出系统的 RPO（Recovery Point Objective）和 RTO（Recovery Time Objective）。输出集群的处理语义情况，如是否符合 at least once 或 exactly once；故障恢复情况，故障期间是否出现系统不可用，及不可用的恢复时间；故障下是否满足预期的分区顺序性；系统在整个实验过程中的响应时间等。\"]},\"284\":{\"h\":\"可靠性案例分析\",\"t\":[\"我们使用OpenChaos对ETCD集群进行可靠性测试，发现在主节点网络断开，单独成为一个分区的场景下，ETCD客户端视角下，集群缺乏自动恢复能力。\",\"图2\",\"下面是利用 OpenChaos执行的一个实验结果示例，是一个3节点 ETCD 集群在主节点与从节点网络断开，单独成为一个分区时的表现，模拟的业务流量速率为1000 tps。\",\"图3\",\"从图中可以看出实验持续10分钟，共注入十次主节点网络分区故障，间隔为30秒，故障期间集群表现不一致。下图为更详细的实验结果。\",\"在第1/3/6/8次故障期间，集群无法自行恢复；其他故障期间花费7秒会恢复集群为可用状态，但整个实验中没有出现数据丢失。\",\"图4\",\"通过查看实验过程信息，发现每次主节点被分区时，集群均可在故障期间自行转移主节点。通过分析源码 ，ETCD 客户端在面对ETCD内部错误时，不会进行重试连接其他节点。导致在客户端优先连接的节点为主节点，并发生不可用时，即便主节点已经成功转移，整体集群恢复为可用，业务仍处于未恢复状态。该问题我们也已经report给ETCD社区，等待进一步修复。\"]},\"285\":{\"h\":\"弹性案例分析\",\"t\":[\"弹性也是分布式系统需要重点关注的能力，除可靠性外，OpenChaos支持对系统扩缩容能力的度量与评测。与可靠性不同，分布式系统的弹性能力不能通过编排固定频率的事件以触发检测。OpenChaos可以根据用户设置的操作系统指标或业务指标阈值来触发扩缩容。\",\"例如，你可以指定集群CPU平均占用的预期值为 40%，或系统响应的预期时间为100ms。弹性检测模型会根据指定的预期值与当前系统表现，根据OpenChaos内置的算法来计算出要弹到的目标规模，来触发扩缩容动作。实验结束后，度量模型会计算出集群的\\\"加速比效率\\\"，与\\\"扩缩代价\\\"和对应规模下集群的性能。\",\"注：\\\"加速比效率\\\"和\\\"扩缩代价\\\"为OpenChaos中度量分布式系统弹性能力的指标，前者表示分布式系统并行化的性能和效果，后者表示系统伸缩的速率。\",\"弹性的含义不仅包括实例节点的伸缩能力，同样也包含具体业务（应用）单元的伸缩能力。为了探索Kafka分区的最佳使用实践，我们设计了实验以探索单个topic分区的扩容能力。在实验中我们还会统计在不同分区个数下消息收发的吞吐量，以了解分区数量对消息吞吐量的影响和达到最大吞吐量的最优分区数数量。\",\"图5为三节点集群上的一个 topic 的分区从 1 扩到 9000 时的 tps 和延迟情况。\",\"图5\",\"图6为各指标随着实验时间的变化情况。\",\"图6\",\"图7是具体的弹性评测结果部分截图，展示了在不同规模下，系统表现出的性能以及弹性变更的花销与效率。其中changeCost 和 resilienceEfficienty 为上文描述的扩缩代价与加速比效率结果。\",\"图7\",\"从上述结果能够看出，此实验规格下的 Kafka 集群，新增1个分区的平均时间约20ms。在分区数量达到 26 的时候性能达到最优，该情况下吞吐量达到130万，此时CPU 总体利用率达到 93%。在分区数达到450+时，性能明显下降。当分区数达到 1992 时，吞吐量降到 3.8万，CPU总体利用率达到 97%。\"]},\"286\":{\"h\":\"未来规划\",\"t\":[\"目前 OpenChaos已支持接入大多数分布式系统，如Apache Kafka、Apache RocketMQ、DLedger、 Redis、ETCD等。随着开源之夏2022活动的召开，我们开放了更多分布式系统接入的工作，供广大学生选择与参与[1]。与此同时，我们与混沌工程师实验室紧密合作。助力信通院颁发了国内首个《分布式消息队列稳定性评估标准》。作为该项标准的主要贡献者，华为云中间件消息产品家族也是唯一一个全面通过验收标准的厂商。未来，我们会继续打磨该项目，加快生态建设，努力将它打造成分布式系统韧性架构的压舱石，推动云原生架构不断演进。关键时候方能\\\"任凭风浪起，稳坐钓鱼船\\\"。\",\"作者简介：\",\"思莹，资深研发工程师，对分布式系统一致性算法，韧性架构，模式识别有深刻的理解与研究。\",\"嘉浩，资深中间件研发工程师，负责华为云分布式中间件设计与研发，擅长中间件性能优化，喜欢大道至简的设计理念。\",\"马海，华为云中间件可靠性技术专家，擅长混沌工程、性能测试，事件驱动架构设计。\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\",\"https://summer-ospp.ac.cn/#/org/prodetail/221bf0008↩︎\"]},\"287\":{\"h\":\"Vim 显示、去除换行符\",\"t\":[\"原文地址：http://hscarb.github.io/other/20230316-vim-linebreaker.html\"]},\"288\":{\"h\":\"背景\",\"t\":[\"Dos 和 windows：采用回车+换行（CR/LF）表示下一行\",\"UNIX/Linux：采用换行符（LF）表示下一行\",\"MAC OS：采用回车符（CR）表示下一行\",\"CR用符号\\\\r表示, 十进制ASCII代码是13, 十六进制代码为0x0D\",\"LF用符号\\\\n表示, 十进制ASCII代码是10, 十六制为0x0A.\"]},\"289\":{\"h\":\"显示换行符\",\"t\":[\":set list shows newline ($)\",\":e ++ff=unix shows CR (^M)\",\"if you want to see both, :set list then :e ++ff=unix\"]},\"290\":{\"h\":\"去除 CR\",\"t\":[\":%s/\\\\r//g\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"291\":{\"h\":\"廖雪峰 JavaScript 教程 笔记\",\"t\":[\"原文地址：http://hscarb.github.io/other/20230813-lxf-js-note.html\",\"https://www.liaoxuefeng.com/wiki/1022910821149312\"]},\"292\":{\"h\":\"1. 快速入门\"},\"293\":{\"h\":\"1.2 数据类型和变量\"},\"294\":{\"h\":\"1.2.1 数据类型\",\"t\":[\"JS 中定义了以下几种数据类型：\",\"Number\",\"123; // 整数123 0.456; // 浮点数0.456 1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5 -99; // 负数 NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示 Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity \",\"字符串\",\"布尔值\",\"null 和 undefined\",\"数组\",\"[1, 2, 3.14, 'Hello', null, true]; new Array(1, 2, 3); // 创建了数组[1, 2, 3] \",\"对象：由键-值组成的无序集合，键都是字符串类型，值可以是任意数据类型\",\"var person = { name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null }; person.name; // 'Bob' person.zipcode; // null \",\"变量：变量名是大小写英文、数字、$和_的组合，且不能用数字开头\"]},\"295\":{\"h\":\"1.2.2 比较运算符\",\"t\":[\"==：它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；\",\"===：它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。\",\"NaN这个特殊的Number与所有其他值都不相等，包括它自己。唯一能判断NaN的方法是通过isNaN()函数。\",\"浮点数在运算过程中会产生误差。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值\"]},\"296\":{\"h\":\"1.2.3 strict 模式\",\"t\":[\"在strict模式下运行的JavaScript代码，强制通过var申明变量，避免变量自动被声明为全局变量。\",\"'use strict'; // 在JavaScript代码的第一行写上'use strict' \"]},\"297\":{\"h\":\"1.3 字符串\",\"t\":[\"`这是一个 多行 字符串`; // 字符串连接 var message = '你好, ' + name + ', 你今年' + age + '岁了!'; // 模板字符串 var name = '小明'; var age = 20; var message = `你好, ${name}, 你今年${age}岁了!`; // 获取长度 var s = 'Hello, world!'; s.length; // 13 // 获取字符 var s = 'Hello, world!'; s[0]; // 'H' s[6]; // ' ' s[7]; // 'w' s[12]; // '!' s[13]; // undefined 超出范围的索引不会报错，但一律返回undefined \"]},\"298\":{\"h\":\"1.4 数组\",\"t\":[\"// 直接给Array的length赋一个新的值会导致Array大小的变化 var arr = [1, 2, 3]; arr.length; // 3 arr.length = 6; arr; // arr变为[1, 2, 3, undefined, undefined, undefined] arr.length = 2; arr; // arr变为[1, 2] // 通过索引赋值时，索引超过了范围，同样会引起Array大小的变化 var arr = [1, 2, 3]; arr[5] = 'x'; arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] // slice() 与 String 的 substring() 类似，截取部分元素：[x, y) var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C'] arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G'] // push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉 var arr = [1, 2]; arr.push('A', 'B'); // 返回Array新的长度: 4 arr; // [1, 2, 'A', 'B'] arr.pop(); // pop()返回'B' arr; // [1, 2, 'A'] arr.pop(); arr.pop(); arr.pop(); // 连续pop 3次 arr; // [] arr.pop(); // 空数组继续pop不会报错，而是返回undefined // unshift()：往Array的头部添加若干元素，shift()：把Array的第一个元素删掉 var arr = [1, 2]; arr.unshift('A', 'B'); // 返回Array新的长度: 4 arr; // ['A', 'B', 1, 2] arr.shift(); // 'A' arr; // ['B', 1, 2] arr.shift(); arr.shift(); arr.shift(); // 连续shift 3次 arr; // [] arr.shift(); // 空数组继续shift不会报错，而是返回undefined arr; // [] // sort 排序 var arr = ['B', 'C', 'A']; arr.sort(); arr; // ['A', 'B', 'C'] // splice：从指定索引开始删除若干元素，然后再从该位置添加若干元素 var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle']; // 从索引2开始删除3个元素,然后再添加两个元素: arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite'] arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] // 只删除,不添加: arr.splice(2, 2); // ['Google', 'Facebook'] arr; // ['Microsoft', 'Apple', 'Oracle'] // 只添加,不删除: arr.splice(2, 0, 'Google', 'Facebook'); // 返回[],因为没有删除任何元素 arr; // ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle'] // concat 连接，返回一个新的 Array var arr = ['A', 'B', 'C']; arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4] // join 串联字符串 var arr = ['A', 'B', 'C', 1, 2, 3]; arr.join('-'); // 'A-B-C-1-2-3' \"]},\"299\":{\"h\":\"1.5 对象\",\"t\":[\"var xiaoming = { name: '小明', 'middle-school': 'No.1 Middle School' }; xiaoming['middle-school']; // 'No.1 Middle School' 'name' in xiaoming; // true 'grade' in xiaoming; // false 'toString' in xiaoming; // true，in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的 delete xiaoming['name']; // 删除name属性 xiaoming.name; // undefined delete xiaoming.school; // 删除一个不存在的school属性也不会报错 // 判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法 var xiaoming = { name: '小明' }; xiaoming.hasOwnProperty('name'); // true xiaoming.hasOwnProperty('toString'); // false \"]},\"300\":{\"h\":\"1.8 Map 和 Set\",\"t\":[\"为了解决对象的 Key 必须为字符串的问题，ES6 引入了 Map 和 Set 。\"]},\"301\":{\"h\":\"1.8.1 Map\",\"t\":[\"var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]); m.get('Michael'); // 95 var m = new Map(); // 空Map m.set('Adam', 67); // 添加新的key-value m.set('Bob', 59); m.has('Adam'); // 是否存在key 'Adam': true m.get('Adam'); // 67 m.delete('Adam'); // 删除key 'Adam' m.get('Adam'); // undefined \"]},\"302\":{\"h\":\"1.8.2 Set\",\"t\":[\"Key 不能重复\",\"var s1 = new Set(); // 空Set var s2 = new Set([1, 2, 3]); // 含1, 2, 3 \"]},\"303\":{\"h\":\"1.9 iterable\",\"t\":[\"遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。\",\"具有iterable类型的集合可以通过新的for ... of循环来遍历。\",\"for ... in ：便利对象的属性名称\",\"for ... of ：只遍历集合本身的元素\",\"var a = ['A', 'B', 'C']; var s = new Set(['A', 'B', 'C']); var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]); for (var x of a) { // 遍历Array console.log(x); } for (var x of s) { // 遍历Set console.log(x); } for (var x of m) { // 遍历Map console.log(x[0] + '=' + x[1]); } \",\"forEach：iterator 内置的方法，每次迭代就自动回调该函数\",\"var a = ['A', 'B', 'C']; // 如果对某些参数不感兴趣，JavaScript的函数调用不要求参数必须一致，可以忽略它们 a.forEach(function (element, index, array) { // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index); }); \"]},\"304\":{\"h\":\"2. 函数\"},\"305\":{\"h\":\"2.1 函数定义和调用\"},\"306\":{\"h\":\"2.1.1 函数定义\",\"t\":[\"function abs(x) { if (x >= 0) { return x; } else { return -x; } } var abs = function (x) { if (x >= 0) { return x; } else { return -x; } }; \"]},\"307\":{\"h\":\"2.1.2 调用函数\",\"t\":[\"传入参数个数多或者少都允许，少的话变量会被赋值为 undefined。\"]},\"308\":{\"h\":\"arguments\",\"t\":[\"arguments 只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array，常用于判断传入参数的个数。\"]},\"309\":{\"h\":\"rest\",\"t\":[\"表示除了已定义参数之外的参数。rest 只能写在最后，前面用...标识\",\"function foo(a, b, ...rest) { console.log('a = ' + a); console.log('b = ' + b); console.log(rest); } foo(1, 2, 3, 4, 5); // 结果: // a = 1 // b = 2 // Array [ 3, 4, 5 ] foo(1); // 结果: // a = 1 // b = undefined // Array [] \"]},\"310\":{\"h\":\"2.2 变量作用域与解构赋值\",\"t\":[\"var申明的变量有作用域。内部函数可以访问外部函数定义的变量。在查找变量时从自身函数定义开始，从“内”向“外”查找。\"]},\"311\":{\"h\":\"2.2.1 变量提升\",\"t\":[\"JavaScript的函数会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部。所以应在函数内部先声明所有变量。\",\"function foo() { var x = 1, // x初始化为1 y = x + 1, // y初始化为2 z, i; // z和i为undefined // 其他语句: for (i=0; i<100; i++) { ... } } \"]},\"312\":{\"h\":\"2.2.2 全局作用域\",\"t\":[\"不在任何函数内定义的变量就具有全局作用域，它们作为属性被绑定到 JS 的全局对象 window。\"]},\"313\":{\"h\":\"2.2.3 名字空间\",\"t\":[\"减少命名冲突的方法是把自己的所有变量和函数全部绑定到一个全局变量中。\",\"// 唯一的全局变量MYAPP: var MYAPP = {}; // 其他变量: MYAPP.name = 'myapp'; MYAPP.version = 1.0; // 其他函数: MYAPP.foo = function () { return 'foo'; }; \"]},\"314\":{\"h\":\"2.2.4 局部作用域\",\"t\":[\"var 变量的作用域是函数维度的，无法定义在 for 循环中局部作用域的变量。\",\"let替代var可以申明一个块级作用域的变量\",\"function foo() { var sum = 0; for (let i=0; i<100; i++) { sum += i; } // SyntaxError: i += 1; } \"]},\"315\":{\"h\":\"2.2.5 常量\",\"t\":[\"const定义常量，const与let都具有块级作用域，一般常量用全部大写的名称。\"]},\"316\":{\"h\":\"2.2.6 解构赋值\",\"t\":[\"同时对一组变量进行赋值，多个变量用中括号括起来。\",\"var [x, y, z] = ['hello', 'JavaScript', 'ES6']; let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素 var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: { city: 'Beijing', street: 'No.1 Road', zipcode: '100001' } }; var {name, address: {city, zip}} = person; name; // '小明' city; // 'Beijing' zip; // undefined, 因为属性名是zipcode而不是zip // 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性: address; // Uncaught ReferenceError: address is not defined var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school' }; // 把passport属性赋值给变量id: // 对singe设置默认值 let {name, passport:id, single=true} = person; name; // '小明' id; // 'G-12345678' // 注意: passport不是变量，而是为了让变量id获得passport属性: passport; // Uncaught ReferenceError: passport is not defined \",\"其他使用场景\",\"var x=1, y=2; [x, y] = [y, x] // 快速获取当前页面的域名和路径 var {hostname:domain, pathname:path} = location; function buildDate({year, month, day, hour=0, minute=0, second=0}) { return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second); } buildDate({ year: 2017, month: 1, day: 1 }); // Sun Jan 01 2017 00:00:00 GMT+0800 (CST) \"]},\"317\":{\"h\":\"2.3 方法\",\"t\":[\"绑定到对象上的函数，内部可以使用 this，表示当前对象。\",\"在一个独立函数调用中，根据是否是strict模式，this指向undefined或window。\"]},\"318\":{\"h\":\"2.3.1 apply\",\"t\":[\"apply 方法指定 this 指向哪个对象，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。\"]},\"319\":{\"h\":\"call\",\"t\":[\"另一个与apply()类似的方法是call()，唯一区别是：\",\"apply()把参数打包成Array再传入；\",\"call()把参数按顺序传入。\",\"Math.max.apply(null, [3, 5, 4]); // 5 Math.max.call(null, 3, 5, 4); // 5 // 对普通函数，通常把this绑定为null \"]},\"320\":{\"h\":\"2.3.2 装饰器\",\"t\":[\"// 用自定义函数替换原函数 var count = 0; var oldParseInt = parseInt; // 保存原函数 window.parseInt = function () { count += 1; return oldParseInt.apply(null, arguments); // 调用原函数 }; \"]},\"321\":{\"h\":\"2.4 高阶函数\",\"t\":[\"接受其他函数作为参数的函数。\"]},\"322\":{\"h\":\"2.4.1 map/reduce\"},\"323\":{\"h\":\"map\",\"t\":[\"应用函数在每个数组元素。\",\"function pow(x) { return x * x; } var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81] \"]},\"324\":{\"h\":\"reduce\",\"t\":[\"把函数作用在数组上，把结果继续与序列的下一个元素做积累计算。\",\"var arr = [1, 3, 5, 7, 9]; arr.reduce(function (x, y) { return x * 10 + y; }); // 13579 \"]},\"325\":{\"h\":\"2.4.2 filter\",\"t\":[\"var arr = [1, 2, 4, 5, 6, 9, 10, 15]; var r = arr.filter(function (x) { return x % 2 !== 0; }); r; // [1, 5, 9, 15] // 接收多个参数 var r, arr = ['apple', 'strawberry', 'banana', 'pear', 'apple', 'orange', 'orange', 'strawberry']; r = arr.filter(function (element, index, self) { return self.indexOf(element) === index; }); \"]},\"326\":{\"h\":\"2.4.3 sort\",\"t\":[\"可以接收一个判断函数，返回 -1, 0, 1\"]},\"327\":{\"h\":\"2.4.4 Array\",\"t\":[\"every()方法可以判断数组的所有元素是否满足测试条件。\",\"find()方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回undefined\",\"findIndex()也是查找符合条件的第一个元素，返回这个元素的索引，如果没有找到，返回-1\",\"forEach()和map()类似，它也把每个元素依次作用于传入的函数，但不会返回新的数组\"]},\"328\":{\"h\":\"2.5 闭包\"},\"329\":{\"h\":\"2.5.1 函数作为返回值\",\"t\":[\"function lazy_sum(arr) { var sum = function () { return arr.reduce(function (x, y) { return x + y; }); } return sum; } var f = lazy_sum([1, 2, 3, 4, 5]); // function sum() f(); // 15 \",\"这种程序结构称为“闭包（Closure）”。\"]},\"330\":{\"h\":\"2.5.2 闭包\",\"t\":[\"当一个函数返回了一个函数后，其内部的局部变量还被新函数引用（上面的 arr）。\",\"注意不要引用任何循环变量，或者后续会发生变化的变量。如果一定要引用循环变量，再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。\",\"function count() { var arr = []; for (var i=1; i<=3; i++) { arr.push((function (n) { return function () { return n * n; } })(i)); // 创建一个匿名函数并立即执行，需要把整个函数定义括起来 } return arr; } var results = count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2]; f1(); // 1 f2(); // 4 f3(); // 9 \",\"闭包可以封装一个私有变量\",\"function create_counter(initial) { var x = initial || 0; return { inc: function () { x += 1; return x; } } } var c1 = create_counter(); c1.inc(); // 1 c1.inc(); // 2 c1.inc(); // 3 \"]},\"331\":{\"h\":\"2.6 箭头函数\",\"t\":[\"是匿名函数的一种简写，和匿名函数不同的是内部的this是词法作用域，由上下文确定\",\"x => x * x // 两个参数: (x, y) => x * x + y * y // 无参数: () => 3.14 // 可变参数: (x, y, ...rest) => { var i, sum = x + y; for (i=0; i<rest.length; i++) { sum += rest[i]; } return sum; } // 返回对象，括号括起来 x => ({ foo: x }) \"]},\"332\":{\"h\":\"2.7 Generator\",\"t\":[\"像一个函数，可以返回多次。由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。\",\"function* fib(max) { var t, a = 0, b = 1, n = 0; while (n < max) { yield a; [a, b] = [b, a + b]; n ++; } return; } var f = fib(5); f.next(); // {value: 0, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 1, done: false} f.next(); // {value: 2, done: false} f.next(); // {value: 3, done: false} f.next(); // {value: undefined, done: true} for (var x of fib(10)) { console.log(x); // 依次输出0, 1, 1, 2, 3, ... } \"]},\"333\":{\"h\":\"3. 标准对象\",\"t\":[\"包装对象，不建议使用\",\"var n = new Number(123); // 123,生成了新的包装类型 var b = new Boolean(true); // true,生成了新的包装类型 var s = new String('str'); // 'str',生成了新的包装类型 \",\"不要使用new Number()、new Boolean()、new String()创建包装对象；\",\"用parseInt()或parseFloat()来转换任意类型到number；\",\"用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；\",\"通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}；\",\"typeof操作符可以判断出number、boolean、string、function和undefined；\",\"判断Array要使用Array.isArray(arr)；\",\"判断null请使用myVar === null；\",\"判断某个全局变量是否存在用typeof window.myVar === 'undefined'；\",\"函数内部判断某个变量是否存在用typeof myVar === 'undefined'。\"]},\"334\":{\"h\":\"3.1 Date\"},\"335\":{\"h\":\"3.2 RegExp\"},\"336\":{\"h\":\"3.3 JSON\",\"t\":[\"JavaScript内置了JSON的解析。\"]},\"337\":{\"h\":\"3.3.1 序列化\",\"t\":[\"var s = JSON.stringify(xiaoming); // 第二个参数用于筛选需要输出的属性，null 为全部，也可以传入函数对每个键值对进行处理 // 第三个参数用来指定缩进 JSON.stringify(xiaoming, null, ' '); \"]},\"338\":{\"h\":\"3.3.2 反序列化\",\"t\":[\"JSON.parse('[1,2,3,true]'); // [1, 2, 3, true] JSON.parse('{\\\"name\\\":\\\"小明\\\",\\\"age\\\":14}'); // Object {name: '小明', age: 14} JSON.parse('true'); // true JSON.parse('123.45'); // 123.45 // 接收函数，转换解析出的属性 var obj = JSON.parse('{\\\"name\\\":\\\"小明\\\",\\\"age\\\":14}', function (key, value) { if (key === 'name') { return value + '同学'; } return value; }); console.log(JSON.stringify(obj)); // {name: '小明同学', age: 14} \"]},\"339\":{\"h\":\"4. 面向对象编程\",\"t\":[\"JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。\",\"var Student = { name: 'Robot', height: 1.2, run: function () { console.log(this.name + ' is running...'); } }; var xiaoming = { name: '小明' }; // 将 xiaoming 的原型指向对象 Student xiaoming.__proto__ = Student; \",\"JavaScript的原型链和Java的Class区别在于它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。\",\"可以在运行期修改原型对象。\",\"Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象\",\"// 原型对象: var Student = { name: 'Robot', height: 1.2, run: function () { console.log(this.name + ' is running...'); } }; function createStudent(name) { // 基于Student原型创建一个新对象: var s = Object.create(Student); // 初始化新对象: s.name = name; return s; } var xiaoming = createStudent('小明'); xiaoming.run(); // 小明 is running... xiaoming.__proto__ === Student; // true \"]},\"340\":{\"h\":\"4.1 创建对象\",\"t\":[\"每个创建对象都有原型链，访问对象属性时会逐级往上查，直到 Object.prototype。\",\"arr ----> Array.prototype ----> Object.prototype ----> null foo ----> Function.prototype ----> Object.prototype ----> null \"]},\"341\":{\"h\":\"4.1.2 构造函数\",\"t\":[\"用 new 关键字调用构造函数，可以返回一个对象。this 指向新创建的对象，默认返回 this。\",\"function Student(name) { this.name = name; this.hello = function () { alert('Hello, ' + this.name + '!'); } } var xiaoming = new Student('小明'); xiaoming instanceof Student; // true // xiaoming ----> Student.prototype ----> Object.prototype ----> null // 让所有创建的对象共享一个 hello 函数，节省内存：将 Student.hello 移到 Student.prototype.hello function Student(name) { this.name = name; } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); }; // 编写工厂方法，参数灵活 function createStudent(props) { return new Student(props || {}) } \"]},\"342\":{\"h\":\"4.2 原型继承\",\"t\":[\"用于扩展一个原型。\",\"JavaScript的原型继承实现方式就是：\",\"定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；\",\"借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；\",\"继续在新的构造函数的原型上定义新方法。\",\"function inherits(Child, Parent) { var F = function () {}; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; } function Student(props) { this.name = props.name || 'Unnamed'; } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); } function PrimaryStudent(props) { Student.call(this, props); this.grade = props.grade || 1; } // 实现原型继承链: inherits(PrimaryStudent, Student); // 绑定其他方法到PrimaryStudent原型: PrimaryStudent.prototype.getGrade = function () { return this.grade; }; \"]},\"343\":{\"h\":\"4.3 class 继承\",\"t\":[\"class的作用就是让JavaScript引擎去实现原来需要我们自己编写的原型链代码。简而言之，用class的好处就是极大地简化了原型链代码。\"]},\"344\":{\"h\":\"4.3.1 class 定义\",\"t\":[\"class Student { constructor(name) { this.name = name; } hello() { alert('Hello, ' + this.name + '!'); } } \"]},\"345\":{\"h\":\"4.3.2 class 继承\",\"t\":[\"class PrimaryStudent extends Student { constructor(name, grade) { super(name); // 记得用super调用父类的构造方法! this.grade = grade; } myGrade() { alert('I am at grade ' + this.grade); } } \"]},\"346\":{\"h\":\"5. 浏览器\"},\"347\":{\"h\":\"5.5 AJAX\",\"t\":[\"Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。\",\"让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。\",\"AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。\"]},\"348\":{\"h\":\"5.5.1 XMLHttpRequest 对象\",\"t\":[\"现代浏览器上写AJAX主要依靠XMLHttpRequest对象：\",\"function success(text) { var textarea = document.getElementById('test-response-text'); textarea.value = text; } function fail(code) { var textarea = document.getElementById('test-response-text'); textarea.value = 'Error code: ' + code; } var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象 request.onreadystatechange = function () { // 状态发生变化时，函数被回调 if (request.readyState === 4) { // 成功完成 // 判断响应结果: if (request.status === 200) { // 成功，通过responseText拿到响应的文本: return success(request.responseText); } else { // 失败，根据响应码判断失败原因: return fail(request.status); } } else { // HTTP请求还在继续... } } // 发送请求: request.open('GET', '/api/categories'); request.send(); alert('请求已发送，请等待响应...'); \"]},\"349\":{\"h\":\"5.5.2 Fetch API\",\"t\":[\"浏览器还提供了原生支持的Fetch API，以Promise方式提供。配合async写法，代码更加简单。\",\"async function get(url) { let resp = await fetch(url); return resp.json(); } // 发送异步请求: get('/api/categories').then(data => { let textarea = document.getElementById('fetch-response-text'); textarea.value = JSON.stringify(data); }); \"]},\"350\":{\"h\":\"5.5.3 安全限制\",\"t\":[\"默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致：域名要相同（www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。\"]},\"351\":{\"h\":\"5.6 Promise\",\"t\":[\"JS 中所有代码都是单线程执行的，所有网络操作、浏览器事件都必须异步执行。\",\"“承诺将来会执行”的对象在JavaScript中称为 Promise 对象。\",\"// 两个参数都是函数 function test(resolve, reject) { var timeOut = Math.random() * 2; log('set timeout to: ' + timeOut + ' seconds.'); setTimeout(function () { if (timeOut < 1) { log('call resolve()...'); resolve('200 OK'); } else { log('call reject()...'); reject('timeout in ' + timeOut + ' seconds.'); } }, timeOut * 1000); } var p1 = new Promise(test); var p2 = p1.then(function (result) { console.log('成功：' + result); }); var p3 = p2.catch(function (reason) { console.log('失败：' + reason); }); // 可以串联起来 new Promise(test).then(function (result) { console.log('成功：' + result); }).catch(function (reason) { console.log('失败：' + reason); }); \"]},\"352\":{\"h\":\"5.6.1 并行执行多个任务： Promise.all\",\"t\":[\"var p1 = new Promise(function (resolve, reject) { setTimeout(resolve, 500, 'P1'); }); var p2 = new Promise(function (resolve, reject) { setTimeout(resolve, 600, 'P2'); }); // 同时执行p1和p2，并在它们都完成后执行then: Promise.all([p1, p2]).then(function (results) { console.log(results); // 获得一个Array: ['P1', 'P2'] }); \"]},\"353\":{\"h\":\"5.6.2 并行执行并只获得先返回的结果： Promise.race\",\"t\":[\"var p1 = new Promise(function (resolve, reject) { setTimeout(resolve, 500, 'P1'); }); var p2 = new Promise(function (resolve, reject) { setTimeout(resolve, 600, 'P2'); }); Promise.race([p1, p2]).then(function (result) { console.log(result); // 'P1' }); \"]},\"354\":{\"h\":\"5.7 async 函数\",\"t\":[\"用关键字async配合await调用Promise，实现异步操作，但代码却和同步写法类似。\",\"async function可以定义一个异步函数，异步函数和Promise可以看作是等价的，在async function内部，用await调用另一个异步函数，写起来和同步代码没啥区别，但执行起来是异步的。\",\"// 定义一个异步函数 async function get(url) { let resp = await fetch(url); // 自动实现异步调用 return resp.json(); } // 与下面的 Promise 代码等价 let promise = fetch(url); promise.then((resp) => { // 拿到resp }) \"]},\"355\":{\"h\":\"6. 错误处理\",\"t\":[\"高级语言通常都提供了更抽象的错误处理逻辑try ... catch ... finally，JavaScript也不例外。\"]},\"356\":{\"h\":\"6.1 错误类型\",\"t\":[\"JavaScript有一个标准的Error对象表示错误，还有从E rror派生的TypeError、ReferenceError等错误对象。\",\"try { ... } catch (e) { if (e instanceof TypeError) { alert('Type error!'); } else if (e instanceof Error) { alert(e.message); } else { alert('Error: ' + e); } } \"]},\"357\":{\"h\":\"6.2 抛出错误\",\"t\":[\"throw new Error('输入错误'); \"]},\"358\":{\"h\":\"6.3 错误传播\",\"t\":[\"如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。\",\"不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获。\"]},\"359\":{\"h\":\"6.4 异步错误处理\",\"t\":[\"JavaScript引擎是一个事件驱动的执行引擎，代码总是以单线程执行，而回调函数的执行需要等到下一个满足条件的事件出现后，才会被执行。涉及到异步代码，无法在调用时捕获异常，原因就是在捕获的当时，回调函数并未执行。\"]},\"360\":{\"h\":\"9. Node.js\",\"t\":[\"基于JavaScript语言和V8引擎的开源Web服务器项目，第一次把JavaScript带入到后端服务器开发。\",\"优势\",\"借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。\",\"JavaScript语言本身是完善的函数式语言，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。\",\"全局启用严格模式\",\"node --use_strict calc.js \"]},\"361\":{\"h\":\"9.1 模块\",\"t\":[\"Node环境中，一个.js文件就称之为一个模块（module）。可以被其他地方引用，也可以引用其他模块。\",\"// hello.js var s = 'Hello'; function greet(name) { console.log(s + ', ' + name + '!'); } // 堆外暴露变量 module.exports = greet; \",\"// 引入hello模块，用相对路径 var greet = require('./hello'); var s = 'Michael'; greet(s); // Hello, Michael! \"]},\"362\":{\"h\":\"9.1.1 CommonJS 规范\"},\"363\":{\"h\":\"模块路径搜索\",\"t\":[\"如果只写模块名，Node会依次在内置模块、全局模块和当前模块下查找hello.js\"]},\"364\":{\"h\":\"9.1.2 模块的实现原理\",\"t\":[\"把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。\",\"// 准备module对象: var module = { id: 'hello', exports: {} }; var load = function (module) { // 读取的hello.js代码: function greet(name) { console.log('Hello, ' + name + '!'); } module.exports = greet; // hello.js代码结束 return module.exports; }; var exported = load(module); // 保存module: save(module, exported); \"]},\"365\":{\"h\":\"9.1.3 module.exports vs exports\",\"t\":[\"如果要输出一个键值对象{}，可以利用exports这个已存在的空对象{}，并继续在上面添加新的键值；\",\"如果要输出一个函数或数组，必须直接对module.exports对象赋值。\",\"所以我们可以得出结论：直接对module.exports赋值，可以应对任何情况：\",\"module.exports = { foo: function () { return 'foo'; } }; \",\"或者：\",\"module.exports = function () { return 'foo'; }; \",\"最终，我们强烈建议使用module.exports = xxx的方式来输出模块变量，这样，你只需要记忆一种方法。\"]},\"366\":{\"h\":\"9.2 基本模块\"},\"367\":{\"h\":\"9.3 Web 开发\"},\"368\":{\"h\":\"9.3.4 WebSocket\",\"t\":[\"WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。\",\"WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求。\",\"GET ws://localhost:3000/ws/chat HTTP/1.1 Host: localhost Upgrade: websocket Connection: Upgrade Origin: http://localhost:3000 Sec-WebSocket-Key: client-random-string Sec-WebSocket-Version: 13 \",\"该请求和普通的HTTP请求有几点不同：\",\"GET请求的地址不是类似/path/，而是以ws://开头的地址；\",\"请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；\",\"Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；\",\"Sec-WebSocket-Version指定了WebSocket的协议版本。\",\"随后，服务器如果接受该请求，就会返回如下响应：\",\"HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: server-random-string \",\"该响应代码101表示本次连接的HTTP协议即将被更改，更改后的协议就是Upgrade: websocket指定的WebSocket协议。\",\"一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本，这样，在浏览器处理起来就十分容易。\",\"为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。\",\"安全的WebSocket连接机制和HTTPS类似。首先，浏览器用wss://xxx创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。\"]},\"369\":{\"h\":\"使用 ws\",\"t\":[\"// package.json \\\"dependencies\\\": { \\\"ws\\\": \\\"1.1.1\\\" } \",\"然后 npm install\",\"服务端\",\"// 导入WebSocket模块: const WebSocket = require('ws'); // 引用Server类: const WebSocketServer = WebSocket.Server; // 实例化: const wss = new WebSocketServer({ port: 3000 }); // 响应message事件，在收到消息后再返回一个ECHO: xxx的消息给客户端 wss.on('connection', function (ws) { console.log(`[SERVER] connection()`); ws.on('message', function (message) { console.log(`[SERVER] Received: ${message}`); ws.send(`ECHO: ${message}`, (err) => { if (err) { console.log(`[SERVER] error: ${err}`); } }); }) }); \",\"客户端\",\"let ws = new WebSocket('ws://localhost:3000/test'); // 打开WebSocket连接后立刻发送一条消息: ws.on('open', function () { console.log(`[CLIENT] open()`); ws.send('Hello!'); }); // 响应收到的消息: ws.on('message', function (message) { console.log(`[CLIENT] Received: ${message}`); } \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"370\":{\"h\":\"PowerJob 原理详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/other/20230820-powerjob.html\",\"作者：zmt-Eason\",\"PowerJob是新一代分布式任务调度与计算框架，支持CRON、API、固定频率、固定延迟等调度策略，提供工作流来编排任务解决依赖关系，能让用户轻松完成作业的调度与繁杂任务的分布式计算。\"]},\"371\":{\"h\":\"1. 为什么选择Powerjob\",\"t\":[\"当前比较流行的开源调度框架包括Quartz、elasticjob、xxl-job等。Quartz可以认为是第一代调度框架，不提供Web页面，只能通过API完成任务配置，更多地是支持单机场景的调度，在分布式场景下需要基于DB锁进行任务执行，性能会有瓶颈。\",\"摘下网上的一幅图，给出了各个开源调度中间件的对比：\",\"以下是官方列出的主要特性：\",\"使用简单： 提供前端Web界面，允许开发者可视化地完成调度任务的管理（增、删、改、查）、任务运行状态监控和运行日志查看等功能。\",\"定时策略完善： 支持CRON表达式、固定频率、固定延迟和API四种定时调度策略。\",\"执行模式丰富： 支持单机、广播、Map、MapReduce四种执行模式，其中Map/MapReduce处理器能使开发者寥寥数行代码便获得集群分布式计算的能力。\",\"DAG工作流支持： 支持在线配置任务依赖关系，可视化得对任务进行编排，同时还支持上下游任务间的数据传递\",\"执行器支持广泛： 支持Spring Bean、内置/外置Java类、Shell、Python等处理器，应用范围广。\",\"运维便捷： 支持在线日志功能，执行器产生的日志可以在前端控制台页面实时显示，降低debug成本，极大地提高开发效率。\",\"依赖精简： 最小仅依赖关系型数据库（MySQL/PostgreSQL/Oracle/MS SQLServer…），同时支持所有Spring Data JPA所支持的关系型数据库。\",\"高可用&高性能： 调度服务器经过精心设计，一改其他调度框架基于数据库锁的策略，实现了无锁化调度。部署多个调度服务器可以同时实现高可用和性能的提升（支持无限的水平扩展）。\",\"故障转移与恢复： 任务执行失败后，可根据配置的重试策略完成重试，只要执行器集群有足够的计算节点，任务就能顺利完成。\",\"其适用场景如下：\",\"有定时执行需求的业务场景：如每天凌晨全量同步数据、生成业务报表等。\",\"有需要全部机器一同执行的业务场景：如使用广播执行模式清理集群日志。\",\"有需要分布式处理的业务场景：比如需要更新一大批数据，单机执行耗时非常长，可以使用Map/MapReduce处理器完成任务的分发，调动整个集群加速计算。\",\"powerjob从架构和技术选型上较大程度参考了schedulerX，个人觉得比较好用的点主要在于一个在于支持代码中自定义实现MapReduce动态分片。MapReduce就是一个任务切分多个子任务并行处理。在简单单机场景下就是开启多线程来同时处理一个大任务，在多个机器下可以有多台机器同时并行处理同一个任务，分布式调度的MapReduce模型就是为使用者在代码开发层面屏蔽上述并行协调的逻辑，让使用者可以通过简单的业务逻辑开发完成并行任务设计开发。此外，还支持在线日志功能，能够在控制台上统一看到所有worker上报的日志，方便运维。\"]},\"372\":{\"h\":\"2. 架构解析\",\"t\":[\"PowerJob 引入了调度中心来统一解决任务的配置和调度，整个系统由调度中心（powerjob-server）和执行器（powerjob-worker）构成。\",\"调度中心是一个基于 SpringBoot 的 Web 应用，根据提供服务的对象可以划分为对外和对内两层。对外部分面向用户，即提供 HTTP 服务，允许开发者在前端界面上可视化完成任务、工作流等信息的配置与管理；对内部分则负责完成开发者所录入任务的调度和派发，同时维护注册到本注册中心所有执行器集群的状态。\",\"执行器是一个普通的 Jar 包，需要接入调度中心的应用依赖该 Jar 包并完成初始化后，powerjob-worker 便正式启动并提供服务。执行器的整体逻辑就是监听来自调度中心的任务执行请求，一旦接收到任务就开始分配资源、初始化执行器开始处理，同时维护着一组后台线程定期上报自身的健康状态、任务执行状态。\",\"调度中心和执行器之间通过 akka-remote 进行通讯。Akka 是一个基于 Actor 模型的并发和分布式计算工具包，主要用于构建高并发、分布式、容错性高的系统，其用于远程通信的优势如下：\",\"提高开发效率：Akka 通过提供统一的地址方案实现了 Actor 之间的通信位置透明性，无论 Actor 是在本地还是远程，都可以使用相同的方式来通信。并且实现起来非常简洁，通过一两句代码就能实现可靠、异步的远程通信。\",\"高并发性：基于轻量级的 Actor 模型，Akka 可以轻松地支持数百万并发 Actor 实例，从而实现高并发。\",\"容错性：Akka 提供了“let it crash”策略，通过使用 Actor 的监控机制，当 Actor 发生故障时可以进行自动恢复。\",\"异步解耦：Actor 之间的所有通信都是通过异步消息传递实现的，这避免了传统的锁和线程同步以及资源竞争问题。\",\"调度中心可以多实例部署来做到调度中心高可用，执行器也可以通过集群部署实现高可用，同时，如果开发者实现了 MapReduce 这一具有分布式处理能力的处理器，也可以调动整个集群的计算资源完成任务的分布式计算。\",\"为了便于模型的设计和功能的划分，PowerJob 为执行器节点分配了 3 种角色，分别是 TaskTracker、ProcessorTracker 和 Processor。\",\"TaskTracker 是每一个任务的主节点，充当worker集群中的 master 角色，每个任务每次只会产生一个 TaskTracker。它负责如Map子任务的分发、状态监控和集群中各执行节点的健康检查，并定期将任务的运行时信息上报给 server。当需要执行分布式任务时，powerjob-server 会根据集群中各个 worker 节点的内存占用、CPU 使用率和磁盘使用率进行健康度计算，得分最高的节点将作为本次任务的 master 节点，即承担 TaskTracker 的职责。\",\"ProcessorTracker 是每一个执行器节点中负责执行器管理的角色，每个任务在每个执行器节点（JVM 实例）上都会产生一个 ProcessorTracker。它负责管理执行器节点任务的执行，包括接受来自 TaskTracker 的任务、上报本机任务执行情况和执行状态等功能。\",\"Processor 是每一个执行器节点中负责具体执行任务的角色，也就是真正的执行单元，每个任务在每个执行器节点都会生成若干个 Processor。控制台上可以控制“实例并发数”，也就是每个节点上Processor最大的数量，它接受来自 ProcessorTracker 派发的执行任务并完成计算。\"]},\"373\":{\"h\":\"3. 关键流程解析\",\"t\":[\"后续源码解析基于4.3.3版本\"]},\"374\":{\"h\":\"3.1 server初始化流程\",\"t\":[\"以下是官方提供的server初始化流程图\",\"img\",\"主要关注两个部分：\",\"CoreScheduleTaskManager类负责管理所有调度的任务，在server初始化时，该类拉起了调度、状态检查、数据清理的定时线程。\",\"不同调度线程的逻辑较为类似，以PowerScheduleService#scheduleNormalJob0方法为例，该方法逻辑如下：\",\"查询本server负责的所有appId列表\",\"以任务开启 + 指定调度类型（CRON、DAILY_TIME_INTERVAL） + 指定appId + 即将需要调度执行为条件查询jobInfo表，查出所有待执行的job\",\"创建任务实例InstanceInfo，初始化status为WAITING_DISPATCH等待派发，推入时间轮等待运行\",\"计算下一次调度时间，更新jobInfo\",\"看到这里可能有疑问，如果在一个周期内job要执行多次，这里只会插入一个任务实例执行一次，那么剩余的任务实例是否就没有调度了？以上逻辑只适用于cron和DAILY_TIME_INTERVAL这类任务，其中CRON 表达式最小间隔 15S，高频率执行则使用秒级任务 FIXED_RATE 和 FIXED_DELAY，由如下方法处理。\",\"处理秒级任务的scheduleFrequentJobCore流程如下：\",\"查询本server负责的所有appId列表\",\"从jobInfo表查询所有enable状态的秒级任务，从日志表InstanceInfo中查询运行状态的jobId\",\"对于未运行的job，根据生命周期计算是否需要执行，并计算delay后放入时间轮或立即执行。\",\"秒级任务在任务正常运行状态只会在日志表产生一条运行记录，server端只是负责拉起这个任务，把后续执行的动作都放到了worker端，worker相当于会启动定期任务去执行秒级任务。这样设计的初衷应该是考虑到秒级任务执行频率较大，每次由server去调度代价太大。\",\"状态检查线程负责定时查询任务运行后一定时间内还处于运行中、等待派发、等待worker接受状态的任务，并根据任务类型、任务配置重试策略的判断是否发起重试。\",\"server网络通信层初始化\",\"该部分负责将配置的protocol进行激活初始化，目前支持的protocol包括akka和http（基于vertx实现）。以akka为例，下图为初始化流程，server端主要对两种Actor，FriendActor和WorkerRequestHandler进行actor与handler方法的绑定，前者负责服务端与服务端的通讯，如用于探测是否存活的ping请求，后者负责处理接受worker端发来的通讯请求。\"]},\"375\":{\"h\":\"3.2 worker初始化流程\",\"t\":[\"worker全流程图如下（源自官网）：\",\"如果在任务执行过程中增加了worker，此时新worker会向server发送心跳，server在下一次下发ServerScheduleJobReq请求时会携带最新worker信息：\",\"image-20230808222542658\",\"对于秒级任务和MAP、MapReduce任务，TaskTracker会动态加载最新worker列表。\",\"如果执行过程中worker下线，那么这个任务实例的状态就停留在DISPATCH_SUCCESS_WORKER_UNCHECK或WAITING_DISPATCH或WORKER_RECEIVED状态，tasktracker定期任务检测到该instance任务的processorTracker长时间未更新上报状态，会重新分发。TaskTracker分发任务的时候，会分发给可用的ProcessorTracker（1分钟内未上报会被移除出可用worker列表），这样，丢失的任务会被TaskTracker重新分发到可用的worker去，保证任务不丢失。\"]},\"376\":{\"h\":\"3.3 创建Job\",\"t\":[\"image-20230820175906698\"]},\"377\":{\"h\":\"4.源码解析\"},\"378\":{\"h\":\"4.1 MapReduce动态分片\",\"t\":[\"动态注册最新worker列表\",\"TaskTracker逻辑中，对于MAP、MapReduce以及秒级任务会起一个定时线程，每隔一分钟探测是否需要加载新的worker，逻辑如下：\",\"image-20230810213003545\",\"首先判断当前可用的worker节点数是否达到了maxWorkerCount，如果未达到则请求server获取最新的可用worker列表，对于新的worker进行注册逻辑。这样每次有新的worker上线，可以将子任务分发给新的worker去计算，从而充分调度整个集群的能力\",\"分发子任务\",\"调用map方法时，构造了ProcessorMapTaskRequest请求发送给TaskTracker，源码见MapProcessor接口的map方法。TaskTracker接收到请求后，会将子任务初始化为WAITING_DISPATCH状态插入TaskDo表，等待调度器调度。\",\"TaskTracker的检查任务执行情况的定时任务中，若判断当前任务所有子任务已结束，对于MAP不关心结果，对于MapReduce任务会执行LAST_TASK任务，如下代码：\",\"image-20230820172907951\",\"在ProcessorTracker中判断是LAST_TASK，则执行最终任务，此任务的实现交给用户去定义，代码如下：\",\"image-20230820173150917\"]},\"379\":{\"h\":\"4.2 时间轮\",\"t\":[\"在PowerScheduleService#scheduleNormalJob0方法中，会查询即将需要调度执行的任务，这里的阈值是30秒，也就是将30秒内即将执行的任务加载到时间轮中待执行，并更新下一次触发时间。\",\"image-20230810215820437\",\"InstanceTimeWheelService类中定义了两个时间轮：\",\"image-20230810222719156\",\"其中TIMER用于精确调度，精确度为1ms（受限于sleep方法的精度无法更加提高），而SLOW_TIMER则用于加载高延迟的任务，它的精确度为10s，下面看下schedule方法是怎么实现的：\",\"image-20230810222921012\",\"这里实现了多级时间轮：首先判断了delayMS的时长，如果小于60s，会调用realSchedule，加载到TIMER时间轮中等待调度，而对于长周期的方法，也就是大于1分钟后等待调度的，则放入SLOW_TIMER时间轮等待调度，这里有意思的是，被SLOW_TIMER到期触发的逻辑就是realSchedule方法。试想下，如果把所有任务都加载到TIMER这个高精度时间轮，由于这种高精度的时间轮需要频繁地检查和执行任务，这在 CPU 资源上可能是昂贵的，这样设计可以减少资源消耗，提高资源利用率。\",\"时间轮的实现在timewheel包下，目录如下：\",\"image-20230810222518520\",\"其UML类图如下：\",\"image-20230810222550532\",\"可以看到HashedWheelTimer是最为关键的类，这个类的初始化做了以下几件事：\",\"初始化轮盘，这里轮盘个数为2的N次方，为了后续可以通过&取余高效地计算任务在时间轮的所属下标；\",\"初始化执行线程池taskProcessPool，用于执行时间轮到期的任务；\",\"启动后台线程Indicator。\",\"这里Indicator线程模拟了指针的转动，其逻辑如下：\",\"不断地将任务从waitingTasks队列推入时间轮，waitingTasks是一个LinkedBlockingQueue数据结构，其中存放的元素是HashedWheelTimerFuture，它包装了等待执行的TimerTask，维护了预期执行时间以及任务的状态（等待、运行中、完成、取消）。由于LinkedBlockingQueue是线程安全的，所以统一由Indicator线程从队列中取数据，计算在时间轮中的index下标，并添加到对应时间格的任务链表中；\",\"处理取消的任务。这里逻辑同上类似，也是不断地从LinkedBlockingQueue类型的canceledTasks队列中取数据，并从时间格的任务链表中删除对应任务；\",\"模拟指针转动，计算当前时间距离下一个时间格的时间，并执行sleep；\",\"从当前时间格的任务链表中取出待执行的任务，提交到taskProcessPool线程池中执行。\",\"schedule方法的逻辑比较简单，并判断如果是已经到期或者过期任务，则直接执行，否则计算任务的目标执行时间，初始化HashedWheelTimerFuture对象并添加到waitingTasks队列，等待Indicator任务去取数据。\"]},\"380\":{\"h\":\"4.3 无锁化设计和高可用的关键：分组隔离机制\",\"t\":[\"powerjob的特性上有一个比较有趣的点：无锁化设计，性能强劲无上限。下面就来看看它是如何实现的。\",\"worker的初始化方法中，有这么一段代码，调用了ServerDiscoveryService的start方法：\",\"image-20230812213654007\",\"这里定时调用discovery方法，下面看下这个方法的逻辑：\",\"image-20230812213755060\",\"这里就是根据worker配置的server的ip列表去请求，调用/acquire方法，下面看下server的这个方法做了什么事情，用一张流程图归纳：\",\"也就是说一个appId分组下所有worker都是由一个server节点去接管，这样避免了多个server通过加锁来抢占调度任务的情况，这里的appId逻辑分组概念比较类似RocketMQ的ConsumerGroup。这样就形成了一个小型的子系统，虽然整个 PowerJob 系统中存在着多台 server 和多个 worker 集群，但是对于这个分组的运行来说，只要有这个分组对应的 worker 集群以及它们连接的那一台 server 就够了。那么在这个小型“子系统”内部，只存在着一台 server，也就不存在重复调度问题了，这台server连接着这个分组下所有的worker，负责所有worker的调度。同时，也在没有引入其它中间件的情况下实现了高可用，一旦server的master节点异常，马上就可以由其它可用server去接管。\",\"可以看出，如果某一时刻要调度的worker达到一定量级，那么server的性能就会成为瓶颈。对于这种情况，可以考虑将appId切分为appId1、appId2、appId3等，实现类似水平分片的效果。\"]},\"381\":{\"h\":\"参考文献\",\"t\":[\"https://github.com/HelloGitHub-Team/Article/tree/master/contents/Java/PowerJob\",\"https://www.yuque.com/powerjob/guidence/intro\",\"https://developer.aliyun.com/group/schedulerx/?spm=a2c6h.12873639.article-detail.2.2d7e3458acP35v#/?_k=fybx5c\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"382\":{\"h\":\"一致性哈希 原理和实现\",\"t\":[\"原文地址：http://hscarb.github.io/other/20231015-consistent-hash.html\"]},\"383\":{\"h\":\"1. 背景\"},\"384\":{\"h\":\"1.1 使用场景\",\"t\":[\"在分布式系统（数据分片）中，为了提高系统容量，就会将数据水平切分到不同的节点来存储，这样每个节点保存的数据可能是不同的。\",\"比如一个分布式 KV（key-valu） 缓存系统，它的所有 key 分布在不同节点，但某个 key 应该到哪个或者哪些节点上获得，应该是确定的。\",\"在访问这个系统时，我们希望让对相同 key 的操作落在相同的节点上。\",\"这里就需要使用到一致性哈希算法，将 key 通过一致性哈希计算之后可以得到相同的节点编号。\"]},\"385\":{\"h\":\"1.1 什么是一致性哈希算法\",\"t\":[\"了解一致性哈希之前需要先了解哈希算法，它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。相同的输入一定得到相同的输出，不同的输入大概率得到不同的输出。\",\"最简单的哈希算法是通过将 key 转换为整数，然后根据节点数取模，比如：\",\"public static int simpleHash(String key, int tableSize) { int sum = 0; for (char c : key.toCharArray()) { sum += (int) c; } return sum % tableSize; } \",\"其中 tableSize 为分布式系统的节点个数。\",\"但是当节点数量发生变化时（增加或删除节点），这里的 tableSize 将发生改变，简单的哈希算法无法保证节点数量发生之后，对相同的 key 哈希仍然能够得到同样的结果。这就意味着如果仍然需要正常使用这个分布式系统，对同一个 key 对应的数据来说，它需要迁移到新的哈希结果对应的节点。\",\"这就需要引入一致性哈希算法，它能够确保只发生少量的数据迁移。\"]},\"386\":{\"h\":\"2. 概要设计\",\"t\":[\"上面说到，哈希算法是将 key 用某种方式转换成数字，然后根据节点数取模。当节点数量改变之后计算的结果自然也会改变。\"]},\"387\":{\"h\":\"2.1 哈希环\",\"t\":[\"想要让节点数量改变后计算结果尽可能保持稳定，可以换一个思路：将节点相对均匀地放置在一个环上，然后将 key 经过 hash 的结果距离最近的节点作为哈希的结果。这个环被称为哈希环。\",\"img\",\"如图所示，将 3 个节点均匀分布在范围为 [0, 2^32) 的范围中（也就是 Long 的范围），hash 之后的 key 在哈希环上查找下一个距离它最近的节点，作为哈希的结果。\",\"下面展示增加和减少节点的场景，无论是增加还是减少节点，都只有较少的映射关系需要改变。\",\"img\",\"img\"]},\"388\":{\"h\":\"2.2 不均衡问题和虚拟节点\",\"t\":[\"在实际情况下，每个节点在哈希环中的位置也是由 hash 函数计算得到，它的位置是随机的。也就是说可能会存在节点分布不均衡的问题。\",\"img\",\"在上图中，节点分布不均衡，导致大量的哈希结果落在同一个节点上。\",\"这里引入虚拟节点，即每个节点都在哈希环上“分身”成 N 个节点，这样每个节点的分布就相对更均匀。\",\"如下图所示，每个节点“分身”成 3 个节点，节点数量多了之后分布也相对均匀。\",\"img\"]},\"389\":{\"h\":\"3. 详细设计\"},\"390\":{\"h\":\"3.1 哈希算法\",\"t\":[\"首先需要实现一个哈希算法，用哈希算法将字符串转换为 Long，对应哈希环上的位置。常见的哈希算法有：\",\"算法\",\"输出长度（位）\",\"输出长度（字节）\",\"MD5\",\"128 bits\",\"16 bytes\",\"SHA-1\",\"160 bits\",\"20 bytes\",\"RipeMD-160\",\"160 bits\",\"20 bytes\",\"SHA-256\",\"256 bits\",\"32 bytes\",\"SHA-512\",\"512 bits\",\"64 bytes\",\"可以采用取哈希算法得到结果的前 4 位，转换成 Long。\"]},\"391\":{\"h\":\"3.2 哈希环\",\"t\":[\"哈希环实际上是一个 HashMap，Key 是长整型，表示哈希环上的位置；Value 是虚拟节点（可以是虚拟节点的名称，也可以是虚拟节点类，包含其名称）。\",\"由于需要向后查找虚拟节点的位置，所以 HashMap 需要根据 Key 排序，在 Java 中的 TreeMap 即为按 Key 排序的 Map 实现。\"]},\"392\":{\"h\":\"3.3 添加和删除节点\",\"t\":[\"首先需要确定节点的虚拟节点数量，比如 10 个。\"]},\"393\":{\"h\":\"3.3.1 添加节点\",\"t\":[\"添加节点时需指定节点名称，如 NodeA。实际添加时是添加 10 个虚拟节点，名称可以为 NodeA1,NodeA2, ..., NodeA10。\",\"对虚拟节点名称使用哈希算法，计算出其在哈希环上的位置，并且放入哈希环。\"]},\"394\":{\"h\":\"3.3.2 删除节点\",\"t\":[\"根据虚拟节点的数量和名称，可以通过哈希算法计算出其所有虚拟节点在哈希环上的位置，然后移除即可。\"]},\"395\":{\"h\":\"3.4 路由\",\"t\":[\"路由函数接收一个路由键 key，经过哈希函数计算得出哈希环上的位置，随即向后找离他最近的虚拟节点，即为路由到的节点。\",\"在 Java 中可以使用 TreeMap，它底层实现是红黑树，可以根据 key 值找到下一个离它最近的节点。\"]},\"396\":{\"h\":\"4. Java 实现\",\"t\":[\"这里引用 RocketMQ 中 ConsistentHashRouter 的实现，它用于在发送消息时按照一致性哈希的方式选择 Topic 的目标队列。\",\"/** * Represent a node which should be mapped to a hash ring */ public interface Node { /** * @return the key which will be used for hash mapping */ String getKey(); } public class VirtualNode<T extends Node> implements Node { final T physicalNode; final int replicaIndex; public VirtualNode(T physicalNode, int replicaIndex) { this.replicaIndex = replicaIndex; this.physicalNode = physicalNode; } @Override public String getKey() { return physicalNode.getKey() + \\\"-\\\" + replicaIndex; } public boolean isVirtualNodeOf(T pNode) { return physicalNode.getKey().equals(pNode.getKey()); } public T getPhysicalNode() { return physicalNode; } } \",\"/** * To hash Node objects to a hash ring with a certain amount of virtual node. * Method routeNode will return a Node instance which the object key should be allocated to according to consistent hash * algorithm */ public class ConsistentHashRouter<T extends Node> { /** * 一致性哈希环 */ private final SortedMap<Long /* 哈希环位置，0~2^32-1 */, VirtualNode<T> /* 虚拟节点 */> ring = new TreeMap<>(); private final HashFunction hashFunction; public ConsistentHashRouter(Collection<T> pNodes, int vNodeCount) { this(pNodes, vNodeCount, new MD5Hash()); } /** * @param pNodes collections of physical nodes * @param vNodeCount amounts of virtual nodes * @param hashFunction hash Function to hash Node instances */ public ConsistentHashRouter(Collection<T> pNodes, int vNodeCount, HashFunction hashFunction) { if (hashFunction == null) { throw new NullPointerException(\\\"Hash Function is null\\\"); } this.hashFunction = hashFunction; if (pNodes != null) { // 在哈希环中为每个物理节点添加 vNodeCount 个虚拟节点 for (T pNode : pNodes) { addNode(pNode, vNodeCount); } } } /** * 在哈希环中为每个物理节点添加 vNodeCount 个虚拟节点 * add physic node to the hash ring with some virtual nodes * * @param pNode physical node needs added to hash ring * @param vNodeCount the number of virtual node of the physical node. Value should be greater than or equals to 0 */ public void addNode(T pNode, int vNodeCount) { if (vNodeCount < 0) throw new IllegalArgumentException(\\\"illegal virtual node counts :\\\" + vNodeCount); int existingReplicas = getExistingReplicas(pNode); for (int i = 0; i < vNodeCount; i++) { VirtualNode<T> vNode = new VirtualNode<>(pNode, i + existingReplicas); ring.put(hashFunction.hash(vNode.getKey()), vNode); } } /** * 从哈希环中移除物理节点 * remove the physical node from the hash ring */ public void removeNode(T pNode) { Iterator<Long> it = ring.keySet().iterator(); while (it.hasNext()) { Long key = it.next(); VirtualNode<T> virtualNode = ring.get(key); if (virtualNode.isVirtualNodeOf(pNode)) { it.remove(); } } } /** * 找到对应 key 在哈希环上顺时针最近的物理节点 * with a specified key, route the nearest Node instance in the current hash ring * * @param objectKey the object key to find a nearest Node */ public T routeNode(String objectKey) { if (ring.isEmpty()) { return null; } Long hashVal = hashFunction.hash(objectKey); SortedMap<Long, VirtualNode<T>> tailMap = ring.tailMap(hashVal); Long nodeHashVal = !tailMap.isEmpty() ? tailMap.firstKey() : ring.firstKey(); return ring.get(nodeHashVal).getPhysicalNode(); } /** * 获取物理节点在哈希环中已经存在的虚拟节点数量 * * @param pNode 物理节点 * @return 在哈希环中已经存在的虚拟节点数量 */ public int getExistingReplicas(T pNode) { int replicas = 0; for (VirtualNode<T> vNode : ring.values()) { if (vNode.isVirtualNodeOf(pNode)) { replicas++; } } return replicas; } /** * 默认的一致性哈希方法，取 MD5 值的前 4 位 */ //default hash function public static class MD5Hash implements HashFunction { MessageDigest instance; public MD5Hash() { try { instance = MessageDigest.getInstance(\\\"MD5\\\"); } catch (NoSuchAlgorithmException e) { } } @Override public long hash(String key) { instance.reset(); instance.update(key.getBytes(StandardCharsets.UTF_8)); byte[] digest = instance.digest(); long h = 0; // 取 MD5 值的前 4 位，转换成长整型 for (int i = 0; i < 4; i++) { h <<= 8; h |= ((int) digest[i]) & 0xFF; } return h; } } } \"]},\"397\":{\"h\":\"参考资料\",\"t\":[\"什么是一致性哈希？\",\"哈希算法\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"398\":{\"h\":\"Echo 职业选手写的奶德大秘境完全指南 and 3000 分奶德倾囊相授\",\"t\":[\"原文地址：http://hscarb.github.io/other/20241216-wow-restoration-druid-mythic-guide.html\",\"原文地址：https://maxroll.gg/wow/class-guides/restoration-druid-mythic-plus-guide\",\"原文作者：rycn\",\"翻译者：金甲虫，wow ID：卖豆腐啦-伊森利恩，联系 qq：524251838\",\"简介：rycn 是 Echo 战队治疗组智囊，是 Echo 尼鲁巴尔王宫 M 首杀团成员（神牧）。本文在正式服开大米之前第一版就已经发布，在 11.05 版本更新后又进行了更新。本文更适合有一定大米经验并且想提升打更高层的玩家。\"]},\"399\":{\"h\":\"译者序\",\"t\":[\"先贴个自己的大米分数，3000 分是我给自己定的一个小目标，如今达到了这个小目标也有信心把这个指南发出来了，后面就佛系打本，这赛季 13 全限就差不多了。关于文中的内容有疑问或者希望讨论的可以直接在帖子里回复，我会进行解答和回复。另外图中键位也可以参考，我觉得调的很合理了。\",\"image-20241215225813833\",\"这篇翻译会加很多我自己的个人理解，丰富指南的内容，我把它当作我这个版本大米之路的总结。下面先来一段心路历程。\",\"我可以算老 wower，但某种程度上也是萌新。我在 2010 年 TBC 末期就入坑 wow，但那时候太小，游戏时间不多，每周打个海山或 BT 金团是我唯一的乐趣，后来 WLK 没怎么玩就 AFK 了。大学时候军团再临版本玩过几个月又 AFK 了，几乎没有深度进行过开荒。这次 wow 国服回归因为好多朋友都回来玩所以突然有个念头想回来和朋友一起吹逼，而且也听说正式服加了大米玩法，练级也快了，适合我这种加班的打工人体制。\",\"我一开始就把主要目标定为大米，因为 30 分钟左右一盘，时间比较灵活，而且可以无限打挑战自己。之前玩了 10+ 年星际 2，它的乐趣点就在于实力变强带来的成就感。记得在哪看到一句话，不必成为职业选手，但是要用职业选手的方式去练习。于是带着不断变强的想法踏上大米之路。\",\"大学到现在已经有 8-9 年没打 wow 了，基本可以算新手重新上路。拿起自己 TBC 时候玩的奶德重新出发，刚开始玩的时候觉得和以前的 wow 基本不是一个游戏，以前打团只要铺回春，AoE 来了读成长，然后愈合打几下地鼠，现在都研究了一下都不用回春来奶了，要不停预铺，读愈合，还要不停躲地板。一开始和朋友打 5M 都灭的死去活来，经常中地板暴毙。我记忆犹新的是回响尾王灭了 10+ 次，因为一直不知道变形会解除定身，一直变豹子过去踩然后变人解除定身被吸进去。\",\"这样也被朋友说过很多次，那个时候确实基本功太差，无法兼顾加血和躲地板，痛定思痛我尝试找到科学的提升方法。按照星际的经验，最快速的提升方法就是抄职业选手的作业。于是就去 WCL 抄前排大佬的天赋，然后看各个博主的攻略视频研究手法，紧接着就是不断打本练习。\",\"渐渐从打 4c 变成能勉强打 7-8c，然后到打 9c 仙林刷满了鎏金。我是大米开了几周后才和朋友们灭的死去活来拿了 10c 的低保。后面随着装等的提升，大概鎏金刷满到 630 左右，渐渐的能限 10c 11c了，然后越打越有信心很快就把 11c 全限了。这一段时间正反馈还是很足的，多打多研究就会有提升，这时候在奶德群里看到有大佬说这赛季怎么也打到 3000 分吧，于是我就把 3000 分作为我自己的一个小目标。\",\"开始尝试打 12c 以后就变得不那么好玩了，12c 和 11c 难度提升巨大，数值上增加了 20%，11c 的打法到 12c 完全不一样了。一开始 AoE 伤害把我吓傻了，因为 11c 我是听着露露语音才进行的预铺，12c AoE 没有预铺就是直接死。不仅难度上升，进组也变得困难。弱势职业的劣势也体现出来，不仅数值弱，进本也难。而且愿意奶德的很多都是不太会选妃的钥匙主，很容易进本就黑散。没办法这时候重新去研究 Boss 技能、手法，查看高手第一视角的技能顺序，然后写小作文不断申请进本练习。冲 12-13 的阶段是负反馈最多的阶段，没车队真的难，很多次都不想打了，但是最终还是想打到 3000 分实现定下的目标。\",\"这篇翻译就是在 12-13 申请集合石的时候慢慢写的，每次仔细看都会有新的收获，翻译的过程中也会去查看每个技能描述，提升了副本的理解。\",\"3000 分在 IO 上已经算前 1% 的玩家了，对于一个算是新开始玩的加班狗来说我已经满意了。我会把我所有的理解都在译者注中分享出来，希望看到的小树苗都能在大米的路上少走弯路快速提升。当然我的理解仅限于 13c，更高层可能就不对了。\",\"另：因为加班下班时间不固定，所以没有找车队，下赛季如果还大米的话一定找个车队。\"]},\"400\":{\"h\":\"1. 概述\",\"t\":[\"image-20241209220115906\",\"大秘境整体评分（满分 5）\",\"奶量：3\",\"伤害：4\",\"功能性：3\",\"生存能力：4\",\"机动性：4\",\"毕业配装\",\"译者注\",\"这里装了 4 种不同颜色的宝石是为了触发顶峰渎神玉的特效。\",\"image-20241215215356412\"]},\"401\":{\"h\":\"2. 英雄天赋\",\"t\":[\"树奶偏向于群奶和可以减少主要技能的 CD，猫奶更偏向于单奶和猫形态下的伤害。\",\"在大米的环境下，猫奶比树奶在大多数场景下的表现更好，所以本指南着重讲解猫奶。\",\"天赋解析：\",\"树奶\",\"每当你召唤一个林莽卫士，你将获得以下增益： \",\"林中和谐：你每有一个激活的林莽卫士，你造成的治疗效果提高 5%。\",\"自然之威：你的林莽卫士激活时使你的回春术、百花齐放、生命绽放的治疗效果提高 10%。\",\"月照树人：你的林莽卫士每 6 秒对周围的目标释放月火术。\",\"梦境涌现 \",\"林莽卫士使你的下一个指定目标的治疗效果会在附近产生 2 片梦境之瓣，为附近的最多 3 个盟友恢复 (120% 法强，与精通相关) 点生命值，最多叠加 3 次。\",\"可以被梦境之力增强：梦境涌现释放的治疗法术额外产生一篇梦境之瓣。\",\"猫奶\",\"野性成长、愈合和百花齐放造成的治疗有机会在目标身上产生共生绽华，极大提高目标收到的治疗效果。\",\"共生绽华可以被以下英雄天赋增强： \",\"茁壮植被：共生绽华会使你的目标收到的治疗效果提升 20%。\",\"根须网道：每个激活的共生绽华使你的法术的治疗效果提高 2%。每个激活的觅血缠藤使你的技能造成的上盖提高 2%。\",\"爆裂增生：当共生绽华失效或者你对其目标释放回春术时，会对附近最多 3 个盟友造成（20% 法强）的治疗。\",\"译者注\",\"这里描述的有些过于绝对，其实树奶在大多数情况下和猫奶差不太多，可以按个人喜好选择。我两种英雄天赋都用，根据副本和层数进行调整，根据我打 13c 的经验来看都是奶的过去的，不过千丝老三确实是猫奶要好奶很多。\",\"我的理解是：树奶更稳定（减伤、主动召树人增加治疗效果），AoE 伤害不错（免费星火），猫奶 HPS 上限更高（共生绽华），少量目标下伤害可观（觅血缠藤）。\",\"树奶除了上述效果以外还有几个关键的天赋：\",\"防护愈合，可以提供 8% 减伤。这个在冲层时可以提升生存能力。\",\"盛放注能，5 次愈合后的下一个星火变成瞬发并且造成 2 倍伤害。由于快速生长天赋的存在，我们在双绽放天赋下用一个愈合可以上 3 个愈合 HoT，也就是每放 2 个愈合就可以获得一个瞬发星火，光用这个来打伤害全程都能打 20w 左右。在 AoE 场景下树奶伤害不比猫奶低，甚至还更高。\",\"猫奶除了上述效果以外还有的关键天赋：\",\"祥和体制：愈合对自己治疗效果提高 35%。这样就可以节省 GCD 奶别人，有些 Boss 有奇效（千丝老三）。\",\"猫奶的治疗量加成确实大，共生绽华有 20%+ 的治疗效果加成，治疗量上限大于树奶，但触发不那么稳定（可以点出种植天赋来稳定生成共生绽华）。\",\"记得打开小队框架上共生绽华的图标，这样可以及时对他释放回春术。\"]},\"402\":{\"h\":\"3. 天赋\",\"t\":[\"image-20241210011543913\",\"天赋代码：CkGAAAAAAAAAAAAAAAAAAAAAAsxMzYjZmZmFz2AMLbstMmBAAAAAAAAAAAwyghZGY0MMzMmhZmB0GAAAAAADAgZAAQAAAz2MbNLzsZDzMDmxA\"]},\"403\":{\"h\":\"3.1 什么时候用这套天赋\",\"t\":[\"这套天赋是通用天赋，可以在任何本中使用，它点了不少增强生存能力的职业天赋。你需要根据你要的功能性来修改天赋，适应词缀和对应的副本。对应副本的天赋将在下面提供。\",\"译者注\",\"现在奶德专精天赋和英雄天赋点法还是比较固定的，这套是标准的双绽放结界猫奶。但是要知道这个天赋是正式服大米开始前就给出来的，他在那时就提供了现在看来的标准天赋，可见实力和理解。\",\"左边可以根据需要来调整。\",\"关于结界和丰饶，这里可以进行选择，在一些治疗缺口很大的本，在集合石环境下我的体验是丰饶会更好，奶量更足。而结界可以省更多的 GCD 来打输出。\",\"关于翡翠灌注和欣欣向荣（双小迅捷），我个人习惯是用欣欣向荣。欣欣向荣的好处是一可以多一个救急手段，二可以多触发一次丛林之魂。翡翠灌注的话则是给一个人灌注之后就不用管他了，可以去奶别人。现在小迅捷数值加强了 25%，欣欣向荣也不失为一个好选择，根据习惯的手法来选择。\",\"也有双回春的天赋点法，个人没有用过双回春，但看别人双回春在 13-14c 是完全可以奶的。我的理解是双回春 GCD 会非常吃紧，没有余力去打输出，蓝量也可能吃紧。IO 前列的高手也基本都是双绽放天赋，本着抄顶尖选手作业的想法我更推荐用双绽放。\",\"下面给出我自己的一些常用天赋\",\"image-20241216225228495\",\"这一套是偏向于治疗量的猫奶，适合 AoE 伤害很高的本，我是用它奶过 13 千丝的。红色的可以去掉，换成蓝色的。粉色可以按习惯自行抉择。\",\"点出夺魂咆哮是为了多一个群控，集合石来擦屁股，加上牛头人的踩地板有两个群控。\",\"自如变形是变猫输出神器，变猫省一个 GCD，没有他很不习惯。\",\"痛击其实伤害占比很小，可点可不点。\",\"英雄天赋选了种植，因为这套偏治疗，不追求打很多伤害而是追求稳定加治疗量。\",\"把野性成长加强换成了双叶伴身和铁皮减 CD，这两个也是集合石擦屁股神器，并且双大迅捷让你可以在万灵时几乎总是有一个大迅捷。\",\"结界换成了丰饶，还是因为追求治疗量。\",\"image-20241216225919351\",\"CkGAvcQZXENQPQXqed372Hg2KuxMzYjZmZmFz2MDYZjttxMAAAAAAAAAAAAWGMYGYkhZmxMmZmxCaDAAAAAgBwAmBYZZsgpZmlhAgZbmtmlZ2shZGYGD \",\"这套是纯输出猫奶，在仙林、通灵和 12c 以下割草用。几乎没有点生存向的，全部挪给输出。右边主要把萌芽之叶换成了赛梦。我通灵和仙林能打到 40w 左右。\",\"image-20241216230343443\",\"CkGAvcQZXENQPQXqed372Hg2KuxMzYhZmZmFz2MDYZjttxMAAAAAAAAAAAAWMMMzMDjMDYmZmZmBm2AAAAAAYAAMDwyyYBTzMLDBAz2MbNLzsZhxYGmxA \",\"这套是输出向树奶天赋，参考的前 10 奶德 Jdotb。丰饶结界可以随意，AoE 伤害压力小就换结界。\",\"这套除了没有打断、控制少以外没啥缺点。\",\"它点出了平衡德相关的所有天赋，伤害很足，每分钟都可以星涌术触发野心，有野心的时候可以打星火用赛梦来奶，奶量很足，而且还有免费星火。单体有 6 秒 CD 的星涌和愤怒，伤害还凑合。最省心的是不用变猫，全程站桩。全程一般可以打 30w+，不比猫奶低。\",\"这个天赋推荐给新手使用。可以把赛梦换成萌芽之叶来增加治疗量，野性成长增强那两点也还是可以换成双叶伴身和铁皮减 CD。这套光用免费星火也能打个 20w 左右。\",\"其余的调整点主要是破晨和通灵可以把强化驱散那点拿掉，点别的。\",\"如果怕奶量不够还可以把变形大师换成森林再生，把触发大树规划到治疗手牌里。\"]},\"404\":{\"h\":\"3.2 了解会影响手法的天赋\"},\"405\":{\"h\":\"3.2.1 专精天赋\",\"t\":[\"翡翠灌注：迅捷治愈不再消耗一个持续治疗效果，并使你在目标身上的持续治疗效果的持续时间延长8秒。\",\"迅捷治愈不再消耗一个持续治疗效果，它能够极大地增强你的单目标治疗。\",\"塞纳留斯的指引：万灵之召的冷却时间缩短50%，持续时间缩短25%，使用的法术数量降低25%。万灵之召使用特殊法术或技能的几率提高。\",\"降低万灵的 CD，让它变得很灵活。在 60 秒 CD 的情况下你可以用万灵打伤害，仍然能在关键伤害时治疗。\",\"森林之风（也叫愈合顺劈）：消耗节能施法使你的愈合还能以60%的效果对周围一名受伤的盟友施放滋养（为一个友方目标恢复 [446% 法强] 点生命值。获得 300% 的 [精通：相生] 增益。），优先选择具有你的持续治疗效果的目标。\",\"大大增强了对次要目标的治疗，并且能够收到精通的加成。\",\"蔓生绽放：你的生命绽放可以同时在两个目标身上生效，但生命绽放的治疗效果降低10%。\",\"这个天赋让你可以在两个不同目标身上释放生命绽放，并且与其他很多天赋有联动。\",\"光合作用：当你的生命绽放施放在自己身上时，你的周期性治疗效果的治疗速度提高10%。当你的生命绽放效果在盟友身上时，你在其身上的周期性治疗效果有4%几率使其绽放。\",\"选择正确的生命绽放目标将至关重要。\",\"快速生长：愈合的持续治疗效果提高50%，且其持续治疗效果也会作用于你的生命绽放的目标。\",\"将愈合的持续治疗效果施加到所有生命绽放的目标，让你能用一个技能就上 3 个愈合的 HoT。\",\"新绿：生命绽放进行最终绽放时，可以治疗最多3名拥有你的百花齐放效果的目标，使其恢复(77.76% 法强)点生命值。\",\"好的车队可以最大化它的作用，当 DPS 和奶比较危险时，T 可以走出百花齐放的圈里。\",\"愈合之涌：迅捷治愈的冷却时间缩短最多40%，由使用时目标的生命值决定。生命值越低，缩短的冷却时间就越多。\",\"当小迅捷的目标选择的比较好时（血量更低的目标），让你更频繁地使用小迅捷。\"]},\"406\":{\"h\":\"3.2.2 职业天赋\",\"t\":[\"橡木树皮：铁木树皮提供 30% 减伤。\",\"巨熊活力：在变为熊形态之后的 4 秒内，你的生命值和护甲提高15%。 \",\"在你切换到熊形态时短时间内提升生命值上限。可以当作一个减伤来应对尖刺伤害。注意在变回人之后生命值上限仍然保持，直到 buff 移除。\",\"译者注\",\"巨熊活力可以无限重复触发，没有 CD。\"]},\"407\":{\"h\":\"3.2.3 英雄天赋\",\"t\":[\"万华疾行：在树皮术期间，你的移动速度提高10%，每秒都会在脚下绽开鲜花，为附近最多3名受伤的盟友恢复(20% 法强)点生命值。 \",\"在使用树皮书时增加一个小的持续治疗和移动速度加成。\",\"孪生双芽：当觅血缠藤或共生绽华生长时，它们有20%几率使附近一个有效目标身上的同类型植物立即生长。 \",\"非常强大的输出伤害天赋，与爆裂增生非常契合。\",\"译者注\",\"如果更注重治疗的稳定性，而且点了欣欣向荣的话，可以选择点种植，小迅捷稳定产生共生绽华，提高治疗量。\",\"image-20241216005240125\"]},\"408\":{\"h\":\"4. 技能循环\"},\"409\":{\"h\":\"4.1 套装效果\",\"t\":[\"2 件套：愈合、野性成长、迅捷治愈的治疗效果提高 10%。\",\"4 件套：当你使用丛林之魂加成的治疗技能，你的治疗效果会在之后的 6 秒内提高 8%。\"]},\"410\":{\"h\":\"4.2 技能优先级\"},\"411\":{\"h\":\"4.2.1 治疗\",\"t\":[\"在集中站位的地方保持百花齐放，在小队移动的时候移动百花齐放的位置，因为这是你性价比最高的技能。\",\"在两个目标（最好是 2 个脆皮 DPS）上保持生命绽放，在持续时间小于 4.5 秒的时候刷新生命绽放。\",\"如果有 AOE 伤害，在野性成长之后使用迅捷治愈。\",\"如果有持续的伤害，不要让林莽卫士的 CD 空转。\",\"使用有清晰预兆效果的愈合。\",\"给生命绽放的目标上回春术，触发更多新绿。\",\"对受到伤害并且没有愈合 HoT 的目标释放愈合。\",\"对受到伤害的目标上回春术。\",\"如果受到持续的伤害，不断对其使用愈合。\",\"译者注\",\"应对普通 AoE 的预铺手法是如下：\",\"地毯\",\"俩脆皮 DPS 双绽放\",\"愈合没有绽放的人\",\"结界默认给 T 或自己，如果有 DoT 点名则给点名的人。\",\"基础预铺大概要 6-7 个 GCD，高额 AoE 下，除了上面预铺之外再把回春铺满，需要 5 个额外 GCD。\",\"所以普通 AoE 前 5 秒就开始预铺，高额 GCD 前 10 秒就开始预铺。\",\"然后 AoE 读出来前读野性成长，树人 + 小迅捷（获得丛林之魂和急速、套装加成），然后不停愈合。\",\"对于 DoT 点名的人，可以奶一口之后给他一个绽放，吃三层精通继续愈合。\"]},\"412\":{\"h\":\"4.2.2 输出\",\"t\":[\"单目标\",\"保持割裂 DoT\",\"使用 4 星以上的凶猛撕咬\",\"保持斜掠 DoT\",\"用撕碎来泄能\",\"保持月火术 DoT\",\"保持阳炎术 DoT\",\"在猫形态下攻击\",\"如果没法近战，搓愤怒\",\"小于 5 目标 AoE\",\"给尽可能多的目标上割裂 DoT\",\"给尽可能多的目标上斜掠 DoT\",\"保持聚好的怪上的痛击 DoT\",\"用横扫来泄能\",\"保持聚好的怪上的阳炎术 DoT\",\"保持所有目标上的月火术 DoT\",\"在猫形态下输出\",\"如果没法近战，搓星火术\",\"译者注\",\"多目标的手法是潜行-斜掠-痛击-tab斜掠给每个怪挂斜掠-选择最大的怪割裂-横扫攒豆-选择第二大的怪割裂-如果怪小于 4000w 血就撕咬（因为整队的单体 DPS 也就是 400w，割裂保持不了一半以上的时间不如撕咬）\",\"5+ 目标 AoE \",\"保持聚好的怪上的阳炎术 DoT\",\"搓星火术\",\"译者注\",\"关于奶要不要打伤害这个问题，我认为每个人追求不同。如果追求成为顶尖玩家，那么一开始就应该照着上限最高的方式去练习。如果追求没有那么高，那么完全不打伤害也是可以限 12-13c 的。\"]},\"413\":{\"h\":\"4.3 手牌\",\"t\":[\"塞纳里奥结界： \",\"当你对有生命绽放并且在百花齐放圈里的目标用塞纳里奥结界，在塞纳里奥结界持续的时间内他几乎是不会被持续性伤害打死的。你只需要担心会秒杀他的尖刺伤害。注意用翡翠灌注来延长 HoT 和结界的时间。\",\"林莽卫士 \",\"一次性用多个林莽卫士可以作为一个治疗手牌。一般在 AoE 时，你会给每个队友身上铺很多 HoT，这时候林莽卫士的治疗就会受到多层精通加成。当有持续伤害时不要让林莽卫士的 CD 空转。但是当一些 BOSS 根据时间轴间歇性有高额伤害的时候，把林莽卫士的 CD 用在最危险的时候。\",\"这个技能不会受到 GCD 限制，也可以在变形的状态下使用，不会解除变形，因此它可以在你变猫打伤害的时候提供少量的持续治疗。\"]},\"414\":{\"h\":\"5. 深入理解\"},\"415\":{\"h\":\"5.1 最大化生命绽放的效果\",\"t\":[\"为生命绽放选择正确的目标在关键时刻可以大幅提升治疗量。你应该优先把生命绽放放在受到伤害的目标上，最好不要一直放在自己身上。这是因为它和光合作用、新绿的联动。这些天赋让你能够在生命绽放的目标上叠加大量持续治疗效果（和精通层数），大大增加新绿的触发。\",\"不要把生命绽放放在自己身上的另一个原因是，这样的话你就受不到生命绽放提供的大量吸血治疗量（治疗自己不会触发吸血）。大多数时候你只要站在百花齐放圈里面，在自己身上随便放点 HoT，配合吸血，就可以应对普通的 AoE 伤害。\"]},\"416\":{\"h\":\"5.2 最大化百花齐放的效果\",\"t\":[\"要最大化百花齐放的效果最重要的就是圈的位置。放的好不仅能提高你的 DPS 和 HPS，也能提升你队友的。在高额 AoE 时他们最好能够都站在百花齐放圈里。\",\"在车队配合很好的情况下，如果 T 不需要治疗，可以让他走出百花齐放的圈，因为新绿只会治疗 3 个目标。\"]},\"417\":{\"h\":\"5.3 最大化野性之心效果\",\"t\":[\"在野性之心时，由于你每 2 秒都会自动获得一个连击点数，所以你需要微调一下使用连击点数的方式。当你达到 3 个连击点，而且能量还没有满，你可以等待自动生成连击点，并使用 4 星终结技来避免原始之怒（如果点了)导致的连击点溢出。\",\"在 2-4 目标的情况下你应该也使用上述策略。在 5+ 目标的 AoE 中手法不变。\",\"译者注\",\"原始之怒一般不会点出，所以不用太在意这条。\"]},\"418\":{\"h\":\"5.4 理解游戏机制\"},\"419\":{\"h\":\"5.4.1 无损补 HoT/DoT\",\"t\":[\"HoT 或 DoT 被重新施加时，是在原来持续时间的基础上延长，最多可延长至超过最大持续时间的30%。\",\"以下技能是受这个机制影响的：\",\"平衡 \",\"月火术\",\"阳炎术\",\"野性 \",\"斜掠\",\"割裂\",\"重击\",\"守护 \",\"重击\",\"恢复 \",\"回春术\",\"愈合\",\"生命绽放\",\"译者注\",\"这也就是为什么生命绽放在还剩 4.5 秒内就可以补，因为生命绽放持续时间为 15 秒，15 * 30% = 4.5。\"]},\"420\":{\"h\":\"5.4.2 施法排队窗口\",\"t\":[\"这个机制允许你在读完一个技能之前就排队执行下一个技能。\",\"默认情况下，这个窗口设定为 400 毫秒，这意味着你可以在当前施法结束前最多400毫秒按下下一个技能。这确保了在当前操作后你的下一个动作能立即执行。\",\"Spell Queue Window Illustration\",\"如果没有这个机制，你的技能之间可能会有很大的间隔，导致你的输出损失，除非你不停按键按的飞快。\",\"如果你想知道你当前的法术队列窗口，可以在聊天框中输入以下命令查看。\",\"/dump GetCVar(\\\"SpellQueueWindow\\\") \"]},\"421\":{\"h\":\"5.4.3 次要属性收益递减\",\"t\":[\"争霸艾泽拉斯版本引入了次要属性衰减的机制。下表是当前没有衰减情况下次要属性提升 1% 所需要的副属性数值：\",\"属性\",\"效果\",\"需要的数值\",\"急速\",\"1% 急速\",\"660\",\"暴击\",\"1% 暴击\",\"700\",\"全能\",\"1% 伤害提升和 0.5% 减伤\",\"780\",\"精通\",\"1% 精通\",\"1400\",\"闪避\",\"减少 1% 收到的 AoE 伤害\",\"544\",\"吸血\",\"恢复造成伤害和治疗的 1% 的生命值\",\"1020\",\"速度\",\"移动速度提高 1%\",\"170\",\"在衰减阈值前，属性数值和它对应的效果是线性增长的，也就是说 1% 的提升会直接增加当前你属性 1% 的效果。在超过一定阈值后会按照属性值所在的区间进行衰减。\",\"二级属性\",\"-10%\",\"-20%\",\"-30%\",\"-40%\",\"-50%\",\"-100%\",\"急速\",\"19800 - 26400\",\"26400 - 33000\",\"33000 - 39600\",\"39600 - 46200\",\"46200 - 132000\",\">132000\",\"暴击\",\"21000 - 28000\",\"28000 - 35000\",\"35000 - 42000\",\"42000 - 49000\",\"49000 - 140000\",\">140000\",\"全能\",\"23400 - 31200\",\"31200 - 39000\",\"39000 - 46800\",\"46800 - 54600\",\"54600 - 156000\",\">156000\",\"精通\",\"21000 - 28000\",\"28000 - 35000\",\"35000 - 42000\",\"42000 - 49000\",\"49000 - 140000\",\">140000\",\"三级属性\",\"-20%\",\"-40%\",\"-60%\",\"-100%\",\"闪避\",\"5440 - 8160\",\"8160 - 10880\",\"10880 - 26656\",\">26656\",\"吸血\",\"10200 - 15300\",\"15300 - 20400\",\"20400 - 49980\",\">49980\",\"速度\",\"1700 - 2550\",\"2550 - 3400\",\"3400 - 8330\",\">8330\",\"译者注\",\"举个例子：在 19800 急速之前，每 660 急速提供 1% 急速效果加成，19800 能提供 30% 急速加成。当急速超过 19800 之后，每 660 急速只提供 0.9% 急速加成。\",\"按豆豆的说法，优先堆急速，到 26400 之前都可以堆。\"]},\"422\":{\"h\":\"6. 副本\",\"t\":[\"译者注\",\"个人副本难度评级，可以先挑简单的去打\",\"一星：回响，只有老一数值比较高，后面都是机制 Boss。仙林：DPS 检测本，只有尾王有灭点，会打就还好。破晨：老二和他之前几个小 Boss 有压力，压力在治疗，T 和 DPS 没什么压力。\",\"二星：围攻，看似没什么灭点，但 Combo 很容易减员，13c 打了很多次。\",\"三星：矶石，很有治疗压力，时间相对充裕一点。通灵，很吃打断和道具的使用，有 DK 会好很多，治疗压力反而不大。千丝，治疗检测本，13c 我居然一次过，奶的住后二基本就能过。\",\"四星：格瑞，每波小怪都是灭点，很吃打断和控制链，反倒是 Boss 还好。\"]},\"423\":{\"h\":\"6.1 艾拉-卡拉，回响之城\",\"t\":[\"推荐用标准天赋，见上面天赋那栏。\",\"译者注\",\"个人推荐的适合集合石的 MDT 参考\",\"image-20241215142157323\",\"!LvvtYTnpm0Zt3z(NK42KUjDHBMHz6so1YImJ(IQuhBQ00n9C0dW36Eb6fQ9wucajrs5XYYMKap8WdaswM9jRzQ9)CNdxJ)nynZ9DwZ9Fy(D(U2UxQUZAo11nn(j3LR9tJ2JkET186PHzh46v3q0v4GNShzXRkaJZZxU4gdM52b3RUb4eZxNhgUswLUDKJxIQ434LYEug)PogfCJk8p14Un4sD0ROdSdlFzWwbaecpHgbSE1D0Xa8lDUcpwMDC9YMaTNgMUynEVW59zOUanrxbN46b0BUMCNyxuAa84viD5sKVCfXvUiNOCIOamccujgIaSMmPcTqLXmGxAheJf1oEwYHfGpqQkdbMZluNMc5MewG7kI7vi3ZOqH2XfeYK6XjbGrcatIEhl)GaWu7KtHldOfUtcaJkvSMI0uVuauqp2go(2ioXWKs(KCEBwhwmDnxKf2lj7P(mS0KlYqCuLICDrVacwtztmLiOQirrbubO0NXxDHlSDYK2LGLL7wtrlrDbUYDCpQCBHrqCxxGOSKwhY5fUkrjDlv5iRB21grLoyKdAje0ul1iiOgbXojatg2ArqvezwrESocUWAwUlj84fiKpeFIHvX1WTB2obrtbJs6lSRiZX1rVTAEnveBOgivXtdQin4qwca7qOstbn5LxMoB1TZnmvbr0ugikqqUTk1oM1iIDcW45(2V0UcBz38AGVLx0C4wixfniKnyixEMaL)WGta)S(EH3pp(SBA8HU3a5rynbN7l9JpBB3m5X4BlqMzU07dF07V6cBV9yfnGppEAWfcUhg9tGiDAomDpSpa3D7SbIhoTeCVfV)3F)Z)8R))hFMBnD9EF)55HW3rAB(MZ9cL12)b \"]},\"424\":{\"h\":\"6.1.1 Boss\"},\"425\":{\"h\":\"阿瓦诺克斯\",\"t\":[\"将塞纳里奥结界用在蛛纱强袭（AoE + 地板放蛛网）的时候\",\"image-20241215192750663\",\"警示尖鸣（3 秒 6 下持续 AoE）造成的是物理伤害，因此变熊也可以作为一个减伤来规划。在树皮术和铁皮 CD 转不过来的时候用变熊来生存。\",\"image-20241215192807338\",\"在血少的紧急情况时使用甘霖。\",\"译者注\",\"这个 Boss 现在的打法都是把 Boss 拉到靠近蛋的位置，等蜘蛛孵出来了就可以和 Boss 一起 A 小蜘蛛。注意这样打 DPS 和奶要扛小蜘蛛的伤害，及时奶上。\",\"放地板的方式是全体和 T 重合站位，每出一个地板就往场外（比如我们在场地左边，就往左边走，这样中间不会被污染）的方向走一步，尽可能节省场地。\"]},\"426\":{\"h\":\"阿奴布泽克特\",\"t\":[\"保持靠近 Boss 的位置，因为距离越远躲穿刺（扇形地板 AoE）就越难。\",\"对中感染（DoT 点名）的目标规划和使用你的治疗手牌。\",\"image-20241215192830671\",\"手牌转不过来可以用减伤，或者规划团队减伤。\",\"译者注\",\"这个 Boss 算该本最简单的，注意刷好被感染点名的人的血。穿刺单变熊吃都不会死，不过还是建议开树皮。\"]},\"427\":{\"h\":\"收割者卡吉尔\",\"t\":[\"在抓握之血的时候关注你的化生：生命之树持续时间，因为化生结束之后你会摆脱定身效果，可能会被拖入宇宙奇点而死亡。\",\"总是驱散一个培植毒药，因为它会造成大量伤害。\",\"image-20241215192900593\",\"中培植毒药的时候规划减伤。\",\"译者注\",\"这个 Boss 别去近战位贪那点输出，近战位放绿水本来就很挤了。驱散毒药的时候一般先驱自己，驱之前走到不会波及队友的地方驱。\"]},\"428\":{\"h\":\"6.1.2 小怪\",\"t\":[\"要打断的重要技能： \",\"颤声侍从 - 共振弹幕\",\"image-20241215192916809\",\"伊克辛（老一前第一个小 Boss） - 惊惧尖鸣：恐惧，需要打断\",\"沾血的网法师 - 恶臭齐射\",\"image-20241215192957117\",\"鲜血监督者 - 毒液箭雨\",\"image-20241215193008536\",\"需要特别注意的技能： \",\"哨兵鹿壳虫（老二前过道） - 预警尖鸣：读条很长，但必须打断，否则会招来附近的所有怪。\",\"image-20241215193023688\",\"蛛魔搬运者（老三前大甲虫） - 野蛮猛击：每次都会带有眩晕效果。\",\"纳克特（老一前第二个小 Boss） - 巢穴的召唤：超高额 AoE 伤害。\",\"译者注\",\"第二个小 Boss 的 AoE 特别痛，第一次打 12c 被吓傻了。给他留一个减伤 + 万灵来应对。没有裁缝的话会有第二波 AoE，记得提前预铺和减伤。\"]},\"429\":{\"h\":\"6.2 千丝之城\",\"t\":[\"推荐用标准天赋，见上面天赋那栏。\",\"译者注\",\"适合集合石的 MDT 参考\",\"image-20241215143844442\",\"!Tr1sosnmq0RdSR9N8XBzqiXMWi5wS0s9h7HaHeuANMzUaiwYEwWHGZecXTaxv5K2ot0KPNPRUQ37vVQQ2Wm7n6HJF0EYFj8VEJ(Rw7NmnmJ(W5Zd9V3oEPDO30uWRm6P2Zgn)dxFZPx(c7DSAJ(0q3W49h6SEV9T9UbaUdt(H7G4T9pyE1QCo)OPrc84TpgEv)VF(T)8JV)3F9BJ(CRZ1EAQZ)uG)Dg91dDtwaWttJJ2E)9tDDHpHTeqpDSZE12HYDS15FNZDXInsdd7g)sUVEQ)b7qpYpJjb(TFge4rJ(ITl0)qBIfcuek8lb6wGA(LG2B4MgriHWFFwiXmciZqFB0oNW6CylLMFbKDtj(2kuQZaszvphjbwo8gjnNIOdyRSjOZkr4dTiGpRcjGvGOvhnLzaPkuub7wPzrkQ8DysCgHAn1fuBWuPAuqmaQCjgY(cwcozycelUcXsijlzh6jIcWuAeSfOIOCRTvGP6HO7tKT7yMSLKSf1ivsY8Lr3VKSFjrLcS8gPa9drfQyvY40dzVN4Bogfz18gMibr4by3N5OWCQmDuwLIvDoz1jfdqcRqLjE8sXismwE1KYzBrMiLmE2qxHU3mlsckYm5PeaRdB14I4mHiMVz7jWjIer5MxIlxyP8vXWbhTIqBB0ydwSdpWMy4jSFdJTGuXFRrjGr4u2XAJ3An8TgChyZdoueRVFxuRmtN5xgCoDVPYyHojlI(Py1KfpFf5ZpgT0xS5ykEBk3WPWHl72sgEzFBHGShoTXhBM4xgjrzwJFeDlqEQGQPmQRImXRiNzT4lnBCtwKU)Ti(Q46aWd9Tkf4ZmFvRmleQQv8vBE(Hgl)EI(X8)) \"]},\"430\":{\"h\":\"6.2.1 Boss\"},\"431\":{\"h\":\"演说者基克斯威兹克\",\"t\":[\"在疑之影点名的时候分散站位，这样你才可以立即驱散一个。\",\"喧神教化（持续 AoE)每 32 秒一次，你刚好可以一次用森林再生，一次用万灵来奶。\",\"image-20241215201426626\",\"在高层，受到疑之影点名并且没有被秒驱散的人必须开减伤。\",\"image-20241215201348939\",\"译者注\",\"其实这个 AoE 每那么痛，普通预铺 + 野性成长就可以奶住，大部分时间可以变猫输出。\",\"DoT 点名前记得散开，读一个野性成长。也有不驱散开减伤强吃的打法，避免驱一个撞到球。\",\"AoE 的时候和 T 集合跟他走。\"]},\"432\":{\"h\":\"女王之牙\",\"t\":[\"在霜凝匕首前就站到近战位，帮 T 快速移除冰冻之血 DoT。\",\"寒冰镰刀要准备一个治疗手牌来应对。\",\"image-20241215201449103\",\"飞刀投掷和寒冰镰刀 Combo 时，要开个减。\",\"image-20241215201457283\",\"译者注\",\"这个 Boss 只有寒冰镰刀造成大规模 AoE 伤害，把万灵和树皮留给寒冰镰刀。\"]},\"433\":{\"h\":\"凝结聚合体\",\"t\":[\"粘稠黑暗会击退你，确保不要被击退到黑水中。\",\"每次黑暗脉动的时候用万灵抬血，没有的话用森林再生的大树。这个时候你需要持续高额的治疗。\",\"image-20241215201702659\",\"黑暗脉动的时候每个人必须开个减。这个技能每 70 秒一次，所以你的树皮肯定是能转好的。\",\"译者注\",\"第一次奶 12c 根本奶不住，用了 2 个 ZF 才打过的。研究了打法以后会变得好奶很多。\",\"需要组一个 DK 或者 CJQ 来在某一轮帮吃球开无敌顶掉，第三轮或第四轮。\",\"用猫奶天赋，出球之后变猫去吃，自己吃越多越好，然后给自己刷爆。给自己贴绽放然后站在地毯里面刷更快，对别人也是，可以先绽放再刷。\",\"每次 AoE 击退的时候变熊。\",\"万灵和树皮留给黑暗脉动。\"]},\"434\":{\"h\":\"大捻接师艾佐\",\"t\":[\"image-20241215145423899\",\"队伍尽量集合站在百花齐放圈里，因为这个 Boss 对治疗量要求极高。\",\"与队伍站在一起，不要提前让变易异常触发。\",\"image-20241215201726940\",\"震颤猛击或晦幽纺纱的时候变熊来承受尖刺伤害。\",\"译者注\",\"这个 Boss 给治疗的压力也是拉满，可以参考上面的时间轴来给手牌。大概是一次捻接，接一个尖刺 AoE，在尖刺 AoE 之前尽量把团血刷满，然后变熊吃尖刺。如果团血不满不要变熊，自己磕大红或者洞穴住民，接着刷别人，至少保证 DPS 在大半条血吃尖刺 AoE。\"]},\"435\":{\"h\":\"6.2.2 小怪\",\"t\":[\"要打断的重要技能： \",\"苏雷吉缚丝者 - 流丝缠缚\",\"image-20241215201816500\",\"安苏雷克的传令官 - 扭曲思绪\",\"image-20241215201829968\",\"隐秘网士 - 愈合之网\",\"要注意的技能： \",\"女王之眼 - 虚空奔袭：多目标 DoT\",\"image-20241215201912795\",\"皇家虫群卫士 - 贪婪之虫：群体高额 DoT\",\"image-20241215201847343\",\"魁梧的战甲尉 - 震颤猛击\",\"长者织影 - 晦幽纺纱\"]},\"436\":{\"h\":\"6.3 矶石宝库\",\"t\":[\"推荐用标准天赋，见上面天赋那栏。\",\"译者注\",\"集合石使用的 MDT 参考\",\"image-20241215151908021\",\"!Tv1YUvnmq0FP7KeNhBPWIUjTsgqInw6(WUkqiP6gNs5haXs2Zc(i4BcH4Vap(54KQgDLTZ4Z5mNzMubiERGpF6JYZ6fZsTG)fP8tIEqWpE5Y807LxxgMNe9SIgbFD4IGFZBMHpC37odShf8NooUkrmoVE9QCsF)64OOVnUNVEAu(KC0I4JMxIS0dKF6lSpMfL2Nkdx2hZIA8rJV3fkGBkPBQIB84ebPctMZZJZxfCLQuQueKCxQHIDbf7ck2mcsioDYqOu8lLjSQisHrHQMssikDmI6iJ4BQS3pSWedCyt2IYVy)zmIdLeEN3cyulO1ERUmVsDcZLM942MDKx4wnhcMOxxI3smuQhIm0rlKmsG6iG(aoeIGGyWJ0jGk2uYDfQ2mO8DBWg9ySMimLjKzXJ0jIaQUHSEZqDUjtjDwdTo2dGW3A5PXHRRWgcOlRw76syKo7A72g7Io7I2SSX2RhLsRfT8HnF6aX5qDIDGLrp46qGUSKnoFK49i4QQWlz1H7UzGmsAXbxSoxXqgMNgnGjk48mOilrc2cvREukcmshr9dUUdtvzhO0bgCFLy)SnuVXcTkngEU5MObIntjIQEHCG2)VFM1tUVub02sx6VF(fQY63GqnwB)l895xVo9GCE62lpJWFqW1s5NhMEqCsWxKJM)Ta(1)uNe)6GsFNsTi1lPMhlIA5ZMF5)7NF7p)47)9x)2RO7pok1A5TtQz0vpUQNVbphj5vBIbvH972xguQHZRJ6VkCt)I)p \"]},\"437\":{\"h\":\"6.3.1 Boss\"},\"438\":{\"h\":\"E.D.N.A\",\"t\":[\"Boss 读条震地猛击的时候驱散震地回响，让 T 能够获取震地回响驱散后的盾。\",\"消尖刺的时候需要用一个治疗手牌来抬血。\",\"image-20241215202136495\",\"消尖刺的时候开一个减伤。\",\"译者注\",\"可能有人不知道什么时候驱散，再讲一下驱散是要在 Boss 读完震地猛击前驱，这样 T 才能吃住震地猛击不死。\",\"另外老一消柱子也要分配好，因为消越多柱子的时候就会吃越多的伤害，高层 3 根消完是吃不住的。我的规划是每次出来的柱子都消 2 根，最后 AoE 打 2 根，这样伤害比较平均。也有每次消 1 根，然后 AoE 消 4 根开减伤吃的。怎么消要提前和队友商量好，一般让一个远程帮你消。\",\"image-20241215202938679\"]},\"439\":{\"h\":\"斯卡莫拉克\",\"t\":[\"每当虚空碎片（黑球）生成时，马上吃掉一个获取不稳定的能量来增加治疗效果。在加固壳壁前再吃一个球，延长增益效果。\",\"Boss 放虚空释能时交你的治疗手牌。\",\"image-20241215203347297\",\"在虚空释能时开个减。\",\"译者注\",\"在出球的时候会有一波 AoE，用野性成长 + 愈合奶。把万灵和树皮留到打盾的时候，打盾前要满预铺。DPS 留爆发打盾。\"]},\"440\":{\"h\":\"代言人布洛克 & 多利塔\",\"t\":[\"找到安全的排气口，可以用狂奔怒吼帮助落位。\",\"Boss 释放排放口技能的时候准备一个万灵来应对大额 AoE 伤害。\",\"image-20241215203859038\",\"排放口上的地板有岩浆的时候开树皮。\",\"译者注\",\"放排放口技能的同时会有 AoE 伤害，这时候还需要跑路到安全的排放口。所以在排放口之前要预铺好。\"]},\"441\":{\"h\":\"虚空代言人艾里克\",\"t\":[\"用狂奔怒吼去找黑洞移除虚空腐蚀。\",\"image-20241215203926333\",\"这个 Boss 对 HPS 有较高要求，所以错开使用你的治疗手牌，保证高 HPS。\",\"如果 Boss 放熵能清算（地板放水）的时候你身上还有虚空腐蚀，开个减。\",\"image-20241215203939693\",\"译者注\",\"机制 Boss，其实治疗量压力没那么大。\",\"你和脆皮 DPS 优先去放黑洞，先站到靠近黑洞的地方。\",\"变熊来吃放水的尖刺伤害。\",\"在放水前进行预铺，防止放水造成减员。\"]},\"442\":{\"h\":\"6.3.2 小怪\",\"t\":[\"要打断的重要技能 \",\"阴森的虚空之魂 - 咆哮恐惧\",\"虚缚嚎叫者 - 穿透哀嚎\",\"image-20241215204004565\",\"要注意的技能 \",\"虚缚抢劫者 - 虚空爆发：持续多次高额 AoE\",\"image-20241215204022624\",\"熔炉装货工 - 熔岩迫击炮：点名高额 DoT\",\"image-20241215204041404\",\"击石者 - 巨石碾压：高额尖刺 AoE + 击退 + 叠层伤害增加\",\"image-20241215204059731\",\"咒炉荣誉卫兵 - 重盾奔袭：看箭头躲开\",\"咒炉塑石者 - 爆地图腾：第一时间转火\"]},\"443\":{\"h\":\"6.4 破晨号\",\"t\":[\"推荐天赋\",\"image-20241215193433070\",\"CkGAAAAAAAAAAAAAAAAAAAAAAsxMzYjZmZmFzyAMLYbZMDAAAAAAAAAAAglBYmBGNDjZMDzMDMtxAAAAAAGAAzMgllxCmmZWGAAAALMzMwMG \",\"译者注\",\"该副本难度为一星，T 和 DPS 压力都不大，对奶来说老二和它前面的几个小 Boss 都要求技能规划和奶量，但是一旦会打就稳过。\",\"这里原作者推荐了树奶 + 大树的天赋组合，是 8 个本里面唯一推荐树奶的本，不太清楚是为什么。我推测是为了用大树奶过老二球 + AoE 的 Combo。其实用猫奶 + 万灵也可以奶过。\",\"破晨可以把强化驱散去掉换成强化回春术。\",\"适合集合石的 MDT 参考\",\"image-20241215194805833\",\"!1rzuoUniqy4RuasCSFTTQs5L0vcRkTVGQt8Wk361SYbYM(sph9a0N3lqVqT3IYmyJbVDLqwXKz(()zMXOyQALSTtR7o76TFxDKXvsxxRs(i)(pQFAS4E9bLSPT1m8zy8sNzqDChFVsAo9v4S9IpFRsETP3biQZUXryWENRV3ZAtCdP7upCfWnvYXoT9tA9fGs)iJyyJX(b3WdGz4q7n))X8XBb4XUHhuNuYlqVxv0fuIOe(eFYlxe18dCXPLaxw8N1j7YWTeXyr9n9MrLuRfGwNKqiKTuw7iCfP4ePG44lB)purMvqsOHq2tult5TDLxeak7cXfbc7vLPsf69Odi7Sl5LLxRN10INNfuElnPvb5TTBOJmJoMLRQTwQfuN5y9jbeHotwumJoLszearmiOF6cfKxUQ6fOU)TDFzM7xC4SCfzQvTQmhAoLZMoPHK7sXkBHLBgpP)4jxN6KDHYE1BBCFDGMiZk)8nZ(jvDMieA(qs1ujNcBXC0CmMs2Wdlm4WsT8(1YeREZ0AyuhyQ2yNoZR(MbNzY1sKupt6(VEUz67d8KLsGUyWc38p)7V)5FE5x)4lC)AkT7A6bRfomOnOzACwZ7X9XBlE3QyWRtOQ2Za8TaE1)o \",\"7 打完之后看嗜血的 CD，CD 好了就去打 8 先把嗜血开了，避免空转嗜血 CD。\"]},\"444\":{\"h\":\"6.4.1 Boss\"},\"445\":{\"h\":\"代言人夏多克朗\",\"t\":[\"尽快驱散燃烧之影。\",\"燃烧之影被驱散掉之后，团队会受到暗影之幕吸奶盾，用治疗手牌快速把吸奶盾奶爆。\",\"手牌没啥需要规划的，在危险的时候用就行。\",\"译者注\",\"这个是纯机制 Boss，流程固定的，治疗压力不大。都会打的情况下这个 Boss 就是送的。\",\"要注意的点\",\"在燃烧之影前尽量多铺点 HoT，可以尽快奶爆吸奶盾。\",\"在黑曜光束前尽量奶满 T 的血。\",\"放圈只会点远程放，两个远程尽量站在一起可以节省场地。放圈的时候进行移动可以完全规避圈的伤害。\",\"万灵可以全部变猫打伤害。\"]},\"446\":{\"h\":\"阿努布伊卡基\",\"t\":[\"黑暗法球不要朝墙放，尽可能让它有更远的飞行距离。\",\"image-20241215204238526\",\"晦影腐朽（持续 5 秒高额 AoE）每 41 秒 1 次，要交替使用治疗手牌和个减，并与团队沟通。\",\"image-20241215204245794\",\"其他人轮流使用个减和群减来降低晦影腐朽的伤害。\",\"译者注\",\"这个是本赛季治疗压力最大的 Boss 里可以排前三的，但是它的时间轴也是固定的，规划好手牌以后没那么可怕。可以按 AoE 时间来分配手牌。分享下我个人的技能规划。\",\"球：树皮，普通预铺（双绽放 + 愈合） + 野性 + 树人小迅捷+ 愈合 * N\",\"1-AoE：大迅捷万灵\",\"球：开铁皮，回春铺满 + 野性 + 树人小迅捷 + 愈合 * N\",\"2-AoE：小迅捷树人 + 愈合 * N\",\"球 + 3-AoE：树皮，回春铺满 + 成长 + 大迅捷万灵\",\"球：回春铺满 + 成长 + 树人小迅捷 + 愈合 * N\",\"4-AoE：铁皮，树人小迅捷+ 愈合 * N\",\"后续还有的话就按上述循环\",\"借用一个奶德群群友的图片供参考：\",\"IMG_0187\"]},\"447\":{\"h\":\"拉夏南\",\"t\":[\"让队员不要在侵蚀喷涌（AoE）时捡炸弹，避免伤害叠加。\",\"在侵蚀喷涌（AoE）的时候奶过去，其他人的个减要留到喷丝射线（放蛛网圈)。\",\"image-20241215204348230\",\"作为治疗你不会被蛛网圈点名，所以把个减留到 侵蚀喷涌 AoE 的时候用。\",\"译者注\",\"捡炸弹的时候注意群刷。\",\"第二阶段放蛛网的人需要重点刷血，可以给铁皮和小迅捷。\"]},\"448\":{\"h\":\"6.4.2 小怪\",\"t\":[\"要打断的重要技能\",\"夜幕影法师 - 诱捕暗影\",\"image-20241215204904785\",\"夜幕司令官 - 深渊嗥叫\",\"image-20241215204917425\",\"夜幕祭师 - 折磨光束\",\"image-20241215204933153\",\"要注意的技能\",\"坚不可摧的伊克斯雷腾 - 恐惧猛击、深渊轰击\",\"夜幕黑暗建筑师 - 招引增援\",\"死亡尖啸者艾肯塔克 - 暗黑法球、深渊轰击\",\"在暗黑法球爆炸的时候注意奶中深渊轰击的人\",\"扬升者维斯可里亚 - 晦影腐朽、深渊轰击\",\"在晦影腐朽 AoE 期间注意被深渊轰击 DoT 点名的人\",\"image-20241215205111368\",\"译者注\",\"老二前的几个小 Boss 特别猛。\",\"扬升者维斯可里亚，会 AoE 和 单点，这两个技能循环。要时刻保持全队 HoT 预铺来应对 AoE，并且过量奶中 DoT 的人。落地第一个 AoE 是来不及预铺的，直接野性成长接万灵。\",\"死亡尖啸者艾肯塔克，会法球和单点，Combo 特别痛很容易减员。Combo 的时候要强刷中 DoT 的人，即便自己吃大红。\"]},\"449\":{\"h\":\"6.5 仙林\",\"t\":[\"推荐用标准天赋，见上面天赋那栏。\",\"译者注\",\"该副本难度为一星，只要 DPS 够就比较轻松，几乎没有很大的治疗缺口。唯一的灭点在尾王，但是都会打的话还好。\",\"仙林是奶德最适合输出的一个本，个人推荐把萌芽之叶换成赛梦，并且点出野性之心来输出。这是我使用的天赋，放弃了几乎所有防御性的职业天赋点，换成输出。\",\"image-20241215194155393\",\"CkGAvcQZXENQPQXqed372Hg2KuxMzYjZmZmFz2MDYZjttxMAAAAAAAAAAAAWGMYGYkhZmxMmZmxCaDAAAAAgBwAmBYZZsgpZmlhAgZbmtmlZ2shZGYGD \"]},\"450\":{\"h\":\"6.5.1 Boss\"},\"451\":{\"h\":\"英格拉·马洛克\",\"t\":[\"如果灵魂之箭没有打断很容易造成减员，确保在黑暗之拥的时候打断所有的灵魂之箭。\",\"把治疗手牌留到黑暗之拥的时候，因为在那之前没有伤害。\",\"无需特殊规划治疗手牌，在紧急的时候使用。\",\"译者注\",\"DPS 要用一些爆发去打高个子，不然打太慢可能后面黑暗之拥奶不住。\",\"万灵看团血，可以留到易伤去压 Boss。\",\"除了黑暗之拥的时候都可以输出。\"]},\"452\":{\"h\":\"唤雾者\",\"t\":[\"帮忙用纠缠根须控制狐狸。\",\"把治疗手牌留到猜谜游戏，那是唯一有伤害的时候。\",\"在猜谜游戏的时候使用个减。\",\"译者注\",\"除了猜谜游戏的时候都可以输出，猜谜游戏前进行预铺和减伤。万灵可以都用来打 Boss。\"]},\"453\":{\"h\":\"特雷德奥瓦\",\"t\":[\"在酸蚀排放（天降绿水）的时候尽量少移动，以免之后杀死队友。\",\"image-20241215171153903\",\"把治疗手牌留到吞噬（打盾），这是唯一造成大量伤害的时候。\",\"image-20241215171206523\",\"被标记为猎物点名时开个减。\",\"译者注\",\"酸蚀排放这个描述就很灵性，所以放绿水的时候要尽可能少动，第一次走一步，第二次走两步就行。\",\"这个 Boss 和 T 集中站位放水来节省场地。\",\"拉断连线前就远离 T。\",\"可以用野性冲锋来快速接近 T。\"]},\"454\":{\"h\":\"6.5.2 小怪\",\"t\":[\"要打断的重要技能：\",\"德鲁斯特收割者 - 收割精魄\",\"image-20241215171033646\",\"锥喉鹿角巨虫 - 模拟抗性\",\"image-20241215171103409\",\"要注意的技能\",\"德鲁斯特恶爪者 - 濒死之息：削弱怪物也削弱玩家。\",\"image-20241215171438636\",\"仙木灵居民 - 过度生长\",\"image-20241215171651887\",\"德鲁斯特碎枝者 - 愤怒鞭挞：在 50% 血的时候触发。\",\"image-20241215171822169\",\"纱雾防御者 - 迷雾结界\",\"image-20241215171902081\",\"纱雾追猎者 - 迷雾噬咬\",\"image-20241215171954964\",\"纱雾钉刺蛾 - 心能注入：要驱散\",\"image-20241215172052368\",\"锥喉鹿角巨虫 - 酸性新星：尖刺 AoE\",\"image-20241215172150767\"]},\"455\":{\"h\":\"6.6 通灵战潮\",\"t\":[\"推荐天赋\",\"image-20241215193734907\",\"CkGAAAAAAAAAAAAAAAAAAAAAAsxMzYjZmZmFz2AMLLstMmBAAAAAAAAAAAwyAMzAjmhZmxMMzMg2AAAAAAYAAMDAAAAAMbzs1sMzmNmZmBzY \",\"译者注\",\"这里仅仅把推荐天赋的强化驱散换成了森林小径。\",\"这个本难度为四星，很考验打断和控制，每次打这个本我都能有 10 打断左右，帮忙打断通灵箭雨。\",\"这个本 Vickman（io 排名第一的奶德）是没有点萌芽之叶，换成了赛梦。我个人也推荐点赛梦，因为除了老三 AoE 伤害比较高之外这个本其实 AoE 伤害不多，是比较适合输出的一个本。\",\"这是我通灵的天赋点，放弃了几乎所有防御性职业天赋点换成输出，并且点出了吹风（来补断寒冰箭雨）。\",\"image-20241215194427722\",\"适合集合石的 MDT 路线参考：\",\"image-20241216002026405\",\"!1v1sUXnmm0R0ik)DzBZMSrjfkOljW8rkWTo2fZiNMEbk6YUVl6HONPIIElQeLLhkBeaJzSKiF8rYhLrb(aQhp8rZr3f)Roup1Dc1308Enm(MNupChQ3F604WhmNV0noGQsOg1N6S2UJt9UVIkXou)8((jtaQJtNpBgC3p13JQ2L16Pd9MNn(9eO(CN1DN1EXqHujO46wS9MPHhnJd3E6fujlrTZyEQB4r8aQVy69enqdYpFa8U9zFSwak9JcOh)lsuvqp(xkPNQGJQAI5Qg)FcpmERJowtoUyFrWExyvcxxyZ4cYXs2j6JJ9JNrT1knwld2OjnPDyawKaKbfHBfBrc3aQTgM7ColKePfapDAOJAJNSJYhF(gYSODjAi55LCU(XyrXQStAsoCLBTHCoLF1m6VKAcEc2Wx452201ATh8bYtFULWQwSBHNPteLXJQIPDnpAWQYzaFrwdviZPEnljd27BalOvqbIkETCfIOmhJMS0hYcdRAVufwZYqHDjXLzsuhLHXzOzsKPTsunwtiXSOjdPkgKnrTbTzbPSkPnRZAlTzTLKZowkeNQtm7AQqZfrcK6LSAhNJvBKhr8ZhZ3f70rboWfp7fXMlKkBvKP1SReIjBlDuz8kHSjghfGenw6sGiV5kYgYHOMakXn3hSmnLdn1Ma(nmm5X8MrXoqowXLrG4vKmbzkWLYxdOCoeKShYe)ax4UDGN01BM4ZAvq9QkMsEnIv4dBMUHMxXbfKn4dZsa6JfoZl(F1)7NF7p)47)9x)Eg1733BCoZTd2XqK2p5gFxy)WhqE7kBcFGHUw7lgZNIXa)p \",\"这个本道具的规划也很重要\",\"1 可以晕上面的一个怪拿一个盾来用\",\"2 也直接拿盾来用\",\"5 6 之间的球留给纳组达，打断他和小怪的通灵箭\",\"7 和 9 的球留给老二\",\"8 如果断不过来可以用一颗球，时间够可以拆开打\",\"8 9 之间要组个能跳怪的职业，DZ 或 SS，或者全队吃隐身药\"]},\"456\":{\"h\":\"6.6.1 Boss\"},\"457\":{\"h\":\"凋骨\",\"t\":[\"用夺魂咆哮来控制召出来的小虫子。\",\"用尽一切手段来最大化你的输出，因为这个 Boss 没有 AoE 伤害。\",\"被深重呕吐点名时变熊并且开个减。\",\"译者注\",\"万灵可以全部变猫输出。\",\"呕吐前可以读个野性成长，然后需要在奶一下呕吐点名对象，因为有后续的 DoT 伤害。\",\"image-20241215173748900\",\"还可以用旋风和吹风来控小虫子\"]},\"458\":{\"h\":\"阿玛厄斯\",\"t\":[\"把治疗手牌留到在最终收割后，这是唯一有伤害的时候。\",\"image-20241215174110519\",\"如果打断用完了，被通灵箭点名的人要开减伤。\",\"译者注\",\"这个 Boss 有 DK 会好打很多，直接拉脆骨法师。没有的话我们最好把一个法师设焦点来补断箭雨。\",\"可以安抚 Boss 的狂暴状态。\",\"大部分时间都可以趴下输出。\",\"用一根矛。\"]},\"459\":{\"h\":\"外科医生缝肉\",\"t\":[\"在关键时刻用狂奔怒吼帮助队友落位（或者跑路）\",\"可以把治疗手牌留到多个憎恶存在的时候，因为溃烂会造成严重的 AoE 伤害。\",\"image-20241215174519187\",\"被缝针点名时开减伤。\",\"image-20241215174529495\",\"译者注\",\"这个 Boss 经过削弱已经没那么难了。\",\"钩下来用一根矛。\",\"注意如果有第三钩，提前去对准台子上的 Boss 位置，这样 Boss 上去之后刚好能钩下来。\"]},\"460\":{\"h\":\"缚霜者纳尔佐\",\"t\":[\"把治疗手牌留到冰缚之盾，这是唯一造成 AoE 伤害的时候。\",\"image-20241215174720831\",\"冰缚之盾时开减伤。\",\"译者注\",\"用一根矛。\",\"大部分时间都可以趴下输出，出盾的时候甚至可以用万灵来打掉。\"]},\"461\":{\"h\":\"6.6.2 小怪\",\"t\":[\"要打断的重要技能：\",\"尸体收割者 - 排干体液\",\"image-20241215174851075\",\"骷髅劫掠者 - 刺耳尖啸\",\"尸体采集者 - 瘀液喷撒\",\"image-20241215175101355\",\"译者注\",\"脆骨法师 - 寒冰箭雨 也要打断。如果放出来一个是能奶上来的，但是配合寒冰箭的 Combo 极容易造成减员。如果放出来第一时间开减伤，并用万灵把血抬满。\",\"要注意的技能：\",\"佐尔拉姆斯通灵师/纳组达 - 严酷命运\",\"image-20241215175539840\",\"骷髅劫掠者 - 恐怖顺劈：要近战位躲开的头前顺劈\",\"血肉工匠 - 切肉飞刀：也能对敌人造成伤害，应该让他瞄准敌人释放。\",\"忠诚的造物 - 脊锤重压：没法打断的圆形范围伤害。\",\"译者注\",\"第一波大波次也可以开野性之心星火来奶，奶量是够的。稳一点就提前预铺满，守门人 AoE 的时候减伤 + 万灵。\"]},\"462\":{\"h\":\"6.7 围攻伯拉勒斯\",\"t\":[\"推荐用标准天赋，见上面天赋那栏。\",\"译者注\",\"推荐组个盗贼来跳怪，下面是有 DZ 的推荐路线。\",\"image-20241215195105012\"]},\"463\":{\"h\":\"6.7.1 Boss\"},\"464\":{\"h\":\"“屠夫”血钩\",\"t\":[\"用狂奔怒吼帮助被上钩了点名的队友跑路。\",\"把治疗手牌留到铁钩拉人之后，确保没人有被炽热弹雨（小怪的读条技） Combo 打死。\",\"如果被炽热弹雨点名并且铁钩拉人马上就要来了，开减伤。\",\"译者注\",\"只有铁钩的时候会有伤害，Boss 撞炸弹易伤可以去打输出。\",\"铁钩之后是点名，所以被铁钩拉过去之前要找好炸弹并且准备跑到位置，不要被点名了才开始找炸弹再跑。\"]},\"465\":{\"h\":\"恐怖船长洛克伍德\",\"t\":[\"在炽烈弹射前进行 HoT 预铺。\",\"image-20241215180459593\",\"炽烈弹射的目标要开减伤。\",\"译者注\",\"AoE 前预铺愈合和野性，第二个 AoE 时会伴随地板，这时候可能没法读条愈合，所以把万灵留在这个时候。\"]},\"466\":{\"h\":\"哈达尔·黑渊\",\"t\":[\"用狂奔怒吼帮小队躲避海潮涌动。\",\"激流破奔是这个 Boss 唯一的伤害技能，在释放前把队伍的血刷满。\",\"image-20241215180833859\",\"在激流破奔前开减伤。\",\"译者注\",\"AoE 时尽量不要站到靠近中间台子的地方，以便海潮涌动的时候中间台子边上有地方战。\",\"大部分时候都可以变猫输出。\"]},\"467\":{\"h\":\"维克戈斯\",\"t\":[\"小队分散站位，以便你能秒驱一个腐败之水。\",\"猛击 AoE 的时候注意奶腐败之水点名的队友。\",\"承受腐败之水 DoT 的时候开减伤。\",\"对没有减伤的腐败之水目标用铁皮。\"]},\"468\":{\"h\":\"6.7.2 小怪\",\"t\":[\"要打断的重要技能：\",\"艾什凡指挥官 - 强化怒吼\",\"image-20241215181308589\",\"水鼠帮唤风者 - 窒息之水\",\"image-20241215181344130\",\"水鼠帮劫掠者 - 恶臭喷吐\",\"image-20241215181441353\",\"要注意的技能：\",\"雕骨执行者 - 抽脸者：地板很难看清的扇形伤害 AoE\",\"铁潮袭击者 - 铁钩 + 狂野风暴 Combo\",\"黑油投弹者 - 火焰炸弹\",\"艾什凡指挥官 - 艾泽里特炸药\",\"image-20241215182415039\",\"铁潮火枪手 - 炽热弹雨\",\"艾什凡观察员 - 瞄准火炮\",\"水鼠帮歼灭者 - 碾压重击\",\"译者注\",\"这个本老一前面的怪 铁钩 + 随便一个读条，特别容易 Combo 死人。所以不要省减伤，读条点你就开减伤，还有尽量把队友血奶满防止猝死。\",\"第二波怪可以卡视角规避沉默 AoE 和铁钩。\",\"这个本属于没有特别明显的难点，但是很容易死人的。\"]},\"469\":{\"h\":\"6.8 格瑞姆巴托\",\"t\":[\"推荐用标准天赋，见上面天赋那栏。\",\"译者注\",\"推荐适合集合石的 MDT 路线：\",\"image-20241215195222819\",\"!TvvtUXnpm0R0qjl)Z2VeGVgua3a4bDrxiK5h5GP11oyg500n5C0dqx3lqVqT3Ikrkjt5jako2sKp(4JuC0GERU74P((thMhSFx3cB0DZNoQ7(0JG69pzF3T38)6UDhpon(rZ5lNMg1TkrLU7BgZxCMR7EE3WSXdZH5ZNnJ27Nhg0TfPV7M3pyE2mGg)K7WloJBb2JwbUK4QqB9FLFG1)iUL1Be9b4(O7W0W0zDxFV003Z8MmPeHqXrTGdHGbHhGgJUTXDMLfuYYkejazznhpiec)bLrSZjM0WIzWlk5acqNU7o2fzpoaculOWGczssGfvbA4DcQrVAiN2qob4P(G0qa6pGGkkLYqcXudARc8ff(sj(sL3ifMwUD2MPznEzFrZ8wH2KQwIvYr)ENCq2LQXfH6VLHujhjzMIRwv14aQqalraRIaYlGi4vXAbhww1lpBty0GyGLFi4nic))6YEdw2R55bedE4alwz2UkF8kQklKl9Dr2WaP9Qlr(Lkb(6gDxBowdAwsvKBBITK2fxR08UCjpK0DRQmUJxcxquWfprax4nOpxyJuwYqEhSuLtnjyRSnvesG5qGJZBmMiXjzMauqcGmaQKlafC6cq0s827cxwpljbnjwyNBk4fPHtX(Nu0uzrlWlX1XjmDjbzzw(eA5dTnaTpKs9LMMyhJFvIRkCvtJrOPiBc)fgB5zf(EjjenHTams0qNYykxZlyRhEekQGGvWSO3C(kO2tbnRWNBEzbOrM1u7OGM(1G0wKgAWbxS0)SAMKfrD7vtwwyaPNIA6IwyUfnRuqkNObzGSGyqjklYGYjlj5rQiLtczmRy5kwSX2M(D0BNhF0mnE3Xx8yi0DwJ5RNgFuVx3DXmyoy9)48sRA35t92p03FXyt)IBarR5f3Z)(7F8NF9ZxFO61huHu((DdgR1C3y)Kxg2nBNUXVVpm)3kB88aJZ0(p7c(La86)9 \",\"4 如果两波读条怪血都很多那么不要合，集合石很容易漏打断\",\"6 需要有爆发，并且控制链好\"]},\"470\":{\"h\":\"6.8.1 Boss\"},\"471\":{\"h\":\"乌比斯将军\",\"t\":[\"用狂奔怒吼来躲避轨道上的龙喷。\",\"在命令咆哮前变熊。\",\"image-20241215182827848\",\"译者注\",\"每次放水都可以变熊来减伤。\",\"可以用人形态野性冲锋来赶路，直接冲到安全的跑道。这样你就不用跑路，有更多的 GCD 来奶人。\"]},\"472\":{\"h\":\"铸炉之主索朗格斯\",\"t\":[\"将烈火斩引向最近的墙，节省场地。\",\"把治疗手牌留到它拔剑的时候，那时候有大量 AoE。\",\"被熔浆火花 DoT 点名的人开减伤。\"]},\"473\":{\"h\":\"达加·燃影者\",\"t\":[\"最优先驱散熵能诅咒。\",\"image-20241215184719630\",\"在暮光打击时用治疗手牌。\",\"在暮光打击时开个减。\",\"译者注\",\"国服的卡 BUG 把这个 Boss 变成送的。唯一要注意的是不要撞到火人。\",\"大部分时候都可以变猫打。\"]},\"474\":{\"h\":\"埃鲁达克\",\"t\":[\"在暗影飓风时用狂奔怒吼帮助落位。\",\"在虚空涌动时强奶，因为减伤要留到深渊腐蚀点名的时候。\"]},\"475\":{\"h\":\"6.8.2 小怪\",\"t\":[\"需要打断的重要技能：\",\"暮光唤地者 - 剧烈震颤\",\"暮光欺诈者 - 思维链\",\"image-20241215190201000\",\"需要注意的技能：\",\"暮光毁灭者 - 晦暗之风：可以卡视角规避\",\"暮光监督者 - 鲁莽战术：可以安抚。\",\"image-20241215190614750\",\"熔核巨人 - 熔岩觉醒\",\"image-20241215190652972\",\"暮光熔岩操纵使 - 扬升和黑暗喷发：在 50% 生命值时触发，造成灼烧炽热的群体 AoE。\",\"暮光术士 - 暗影烈焰笼罩\",\"image-20241215190934135\",\"暮光执行者 - 怒火渐燃：可以安抚\",\"image-20241215191110658\",\"变异幼崽 - 暗影之伤：\",\"无面腐蚀者 - 腐蚀（高额 DoT）和心智贯透（地板触手）\"]},\"476\":{\"h\":\"7. 属性优先级\",\"t\":[\"在大米下的属性优先级如下\",\"智力 > 急速 > 全能 >= 精通 >> 暴击\",\"你通常应该优先穿装等更高的装备。\",\"译者注\",\"按豆豆的说法，急速到 26400 （20% 衰减阈值）前都可以堆。\",\"奶德的精通很强，但是如果极限冲层还是要堆全能（Vickman 是堆全能），我打的 13c 这个层数其实都可以。\"]},\"477\":{\"h\":\"7.1 三级属性\",\"t\":[\"闪避：减少受到的AoE伤害。\",\"吸血： 将你造成的部分伤害和治疗转换为对你的治疗。（不包括自我治疗）\",\"速度：提升移动速度。（可与其他移动速度能力叠加）\",\"闪避和吸血都不错，速度就比较鸡肋。吸血对治疗来说可以提供可观的治疗量\"]},\"478\":{\"h\":\"8. 装备\"},\"479\":{\"h\":\"8.1 毕业装备\",\"t\":[\"槽位\",\"物品\",\"获取地\",\"头部\",\"‍密道兜帽\",\"仙林\",\"颈部\",\"苏雷吉狂热者的徽章\",\"席克兰（团本老三）\",\"肩部\",\"‍大山猫之喉\",\"套装/化生台\",\"披风\",\"悲碎之翼\",\"拉夏南（团本老四）\",\"胸甲\",\"‍大山猫之皮\",\"套装/化生台\",\"护腕\",\"符烙护腕\",\"制造业\",\"手套\",\"‍大山猫开膛之爪\",\"套装/化生台\",\"腰带\",\"树液饕餮腰带\",\"仙林\",\"腿部\",\"大山猫绑腿\",\"套装/化生台\",\"靴子\",\"大灵猫之踏\",\"套装/化生台\",\"戒指 1\",\"缝肉的错位玺戒\",\"通灵战潮\",\"戒指 2\",\"实验体08752号的指环\",\"千丝之城\",\"饰品 1\",\"暗影飓风\",\"格瑞姆巴托\",\"饰品 2\",\"无羁拟态者\",\"仙林\",\"武器\",\"‍具现毒瘴节杖\",\"血缚恐魔（团本老二）\",\"副手副手\",\"流浪者的火炬\",\"制造业\"]},\"480\":{\"h\":\"8.2 大米获取的替代品（无制造业、团本）\",\"t\":[\"槽位\",\"物品\",\"获取地\",\"头部\",\"‍密道兜帽\",\"仙林\",\"颈部\",\"“紧急制动”钥匙链\",\"矶石宝库\",\"肩部\",\"‍折翼肩章\",\"破晨号\",\"披风\",\"砧皮斗篷\",\"矶石宝库\",\"胸甲\",\"涂脏大衣\",\"千丝之城\",\"护腕\",\"复生畸体腕带\",\"通灵战潮\",\"手套\",\"钢铁掠夺者手套\",\"围攻伯拉勒斯\",\"腰带\",\"树液饕餮腰带\",\"仙林\",\"腿部\",\"荧光之线马裤\",\"格瑞姆巴托\",\"靴子\",\"唤焰者的便鞋\",\"格瑞姆巴托\",\"Ring 1戒指 1\",\"缝肉的错位玺戒\",\"通灵战潮\",\"Ring 2戒指2\",\"实验体08752号的指环\",\"千丝之城\",\"饰品 1\",\"暗影飓风\",\"格瑞姆巴托\",\"饰品 2\",\"无羁拟态者\",\"仙林\",\"双手武器\",\"‍仙曲钢铁乐杖\",\"矶石宝库\",\"单手武器\",\"无礼放血者\",\"艾拉-卡拉，回响之城\",\"副手\",\"护存暗渊之桶\",\"千丝之城\",\"译者注\",\"可以用 KeystoneLoot 插件来查看每个副本的掉落。露露插件包默认已经整合，聊天框输入 /ksl 即可显示。\"]},\"481\":{\"h\":\"8.3 饰品\",\"t\":[\"下面推荐一些主动和被动的替代饰品。不同副本里有些饰品比其他饰品更好。\"]},\"482\":{\"h\":\"8.3.1 主动饰品备选\",\"t\":[\"间谍大师裹网：一个很强大的主动饰品，需要精确规划使用时机。要 4 分钟才能叠到最大层数，所以要在关键伤害时用它，而不是 CD 好了就用。\",\"image-20241214153106815\",\"译者注\",\"据很多人说甲虫饰品也是大米高层一个不错的选择，极大加强自己的生存能力，并且能够在高额 AoE 下有空余的 GCD 去奶别人。我没有甲虫所以没有体验过。\",\"image-20241215024207452\"]},\"483\":{\"h\":\"8.3.2 被动饰品备选\",\"t\":[\"image-20241214153427138\",\"强能水晶：数值很强的随机次要属性触发饰品。\",\"image-20241214153517135\",\"紫卵：在不同情况下分别提供主要属性和次要属性。在聚怪时使用它，保持你想要的属性。\",\"image-20241214153644775\",\"卵囊：也是一个数值很高的饰品，同时能提供少量的伤害。\"]},\"484\":{\"h\":\"8.4 美化\",\"t\":[\"暗月徽记：扬升 \",\"数值很强的美化，每 8 秒为你提供大量随机的次要属性。\",\"蠕动装甲带： \",\"使你的扬升效果翻倍。\",\"制造业装等是 636，神话装备最高是 639，所以除了两件美化装备（可以提供 2 倍的扬升效果）外都应该穿 639 的神话装备。\",\"image-20241215024445134\"]},\"485\":{\"h\":\"9. 消耗品\",\"t\":[\"合剂：淬火矫健合剂\",\"image-20241215032600780\",\"译者注\",\"全能合剂也是一个选择，在非输出本我个人是吃全能合剂来增加生存能力。\",\"食物：降圣白昼盛宴\",\"image-20241215032522331\",\"战斗药水\",\"阿加法力药水\",\"image-20241215032835974\",\"恢复药水炸弹\",\"image-20241215032910709\",\"译者注\",\"恢复药水炸弹感觉比较鸡肋。还有几个战斗药水推荐，这几个都共 CD，一般大米里用最多的是洞穴住民的挚爱。\",\"洞穴住民的挚爱\",\"image-20241215032805951\",\"淬火药水（爆发药）：全部副属性（除了你磕了合剂的）都提升 2000+。在插钥匙之前可以卡一个，不占 CD，适合开始就拉一波大的本。\",\"image-20241215033019166\",\"生命药水\",\"阿加治疗药水\",\"image-20241215135111155\",\"译者注\",\"大红其实也可以作为一个治疗手牌来用，在极限 AoE 下优先刷别人，自己吃大红。\",\"武器油\",\"阿加法力之油\",\"image-20241215135123397\",\"强化符文\",\"晶化强化符文\",\"image-20241215135141478\",\"宝石\",\"打孔：项链、戒指可以用卓越珠宝师的底座（拍卖行可买）最多打 2 个孔。头、护腕、腰带可以用蛛魔宝石编织者（宏伟宝库旁边用 6 个低保里的奖币换)。\",\"顶峰渎神玉\",\"image-20241215033513748\",\"迅捷翡翠\",\"image-20241215033429691\",\"迅捷蓝玉\",\"image-20241215033448338\",\"万能翡翠\",\"image-20241215033615401\",\"精湛翡翠\",\"image-20241215033648476\"]},\"486\":{\"h\":\"9.1 附魔\",\"t\":[\"头盔\",\"‍Nerubian Gemweaver‍尼鲁布宝石编织者\",\"披风\",\"附魔披风 - 吸血尖牙之诵\",\"胸部\",\"附魔胸甲 - 晶脉辉煌\",\"腿\",\"夕阳魔线\",\"Boots靴子\",\"附魔靴子 - 卫士进击\",\"戒指\",\"附魔戒指 - 绚灿急速\",\"武器\",\"附魔武器 - 焰心威权\"]},\"487\":{\"h\":\"10. 种族\",\"t\":[\"极限冲层推荐暗夜精灵，影遁在某些副本中非常重要。\",\"影遁：激活之后遁入阴影，降低敌人侦测到你的几率。持续直到取消或进行移动。取消这个效果之后，你对任何仍在战斗中的敌人造成的威胁值将恢复。 \",\"使用方式：引到怪之后用隐遁可以脱战，甚至对于侦测目标，如果影遁之前离他足够远，也可以脱战。\"]},\"488\":{\"h\":\"11. 宏\",\"t\":[\"所有奶德治疗法术都可以做成鼠标指向宏。\",\"译者注\",\"由于翻译每个技能太麻烦，这里我就直接放上我个人用的宏了，涵盖几乎原文提供的宏，还更丰富。我做了很多双向宏来节省键位，双向宏就是目标为敌人的时候用伤害技能，目标为友放时使用治疗技能。\"]},\"489\":{\"h\":\"11.1 鼠标指向宏\",\"t\":[\"回春/月火\",\"#showtooltip 回春术 /cast [@mouseover,harm] 月火术;[@mouseover,help] [help]回春术;[harm]月火术;回春术 \",\"生命绽放/阳炎术\",\"#showtooltip 生命绽放 /cast [@mouseover,harm] 阳炎术; [@mouseover,help] [help]生命绽放;[harm]阳炎术;生命绽放 \",\"愈合/愤怒\",\"#showtooltip 愈合 /cast [@mouseover,harm] 愤怒; [@mouseover,help] [help]愈合;[harm]愤怒;愈合 \",\"迅捷治愈+树人\",\"#showtooltips 迅捷治愈 /cast [@mouseover,help] 林莽卫士 /cast [@mouseover,help] 迅捷治愈 \",\"结界\",\"#showtooltip 塞纳里奥结界 /cast [@mouseover,help] 塞纳里奥结界 \",\"野性成长/星火术\",\"#showtooltip 野性成长 /cast [@mouseover,harm] 星火术; [@mouseover,help] [help]野性成长;[harm]星火术;野性成长 \",\"铁木树皮/复生\",\"#showtooltip 铁木树皮 /cast [@mouseover,help,dead] [help,dead]复生;[target,help] [@mouseover,help] 铁木树皮; \",\"百花齐放鼠标指向\",\"#showtooltip 百花齐放 /use [@cursor]百花齐放 \",\"乌索尔旋风鼠标指向\",\"#showtooltip 乌索尔旋风 /use [@cursor]乌索尔旋风 \"]},\"490\":{\"h\":\"11.2 其他推荐的宏\",\"t\":[\"焦点打断\",\"#showtooltip 迎头痛击 /cast [exists,nodead,target=focus][exists,target=target]迎头痛击 /clearfocus [target=focus, dead] \",\"赶路\",\"#showtooltip 潜行 /cast [indoors,nocombat,noswimming,nostance:2]潜行;[indoors,combat,noswimming,nostance:2]猎豹形态;[indoors,swimming,nostance:3]旅行形态;[outdoors,nostance:3]旅行形态;[stance:2]急奔 \",\"大迅捷+愈合\",\"#showtooltip 自然迅捷 /cast 自然迅捷 /stopcasting /cast [@mouseover,help] 愈合 \",\"激活自己\",\"#showtooltips 激活 /cast [@player] 激活 \",\"按一下变熊，按两下狂暴回复\",\"#showtooltip 熊形态 /cast [nostance:1]熊形态; /cast [stance:1]狂暴回复 \",\"按一下变猫，后续按释放横扫\",\"#showtooltip 横扫 /cast [nocombat,noswimming,nostance:2]潜行;[combat,nostance:2]猎豹形态;[combat,stance:2]横扫 \",\"目标是敌人则按一下变豹子按两下冲锋，目标是友方则按一下变人按两下冲锋。\",\"#showtooltip 野性冲锋 /use [harm,form:1]野性冲锋 /use [harm,form:0]猎豹形态 /cancelaura [help,noform:1]猎豹形态 /cancelaura [combat,help,noform:1]旅行形态 /use 野性冲锋 \",\"友方清除腐蚀，敌方安抚\",\"#showtooltip /cast [@mouseover,exists,nodead,noharm]清除腐蚀;[@mouseover,exists,help,dead,combat]复生;[help,dead,combat]复生;[harm]安抚;[]清除腐蚀 \",\"修改最大镜头距离（到最远）\",\"/console cameraDistanceMaxZoomFactor 2.6 \"]},\"491\":{\"h\":\"12. 插件\",\"t\":[\"下面是本文作者（rycn）的界面截图，阐明了大米中使用的插件和用法。\",\"Druid MUI 1024 X 605\",\"OmniCD：小队 CD 监控\",\"ElvUI / BetterBlizzFrames：团队框架\",\"WeakAuras：技能提示\",\"Plater：姓名版\",\"BigWigs：Boss 技能\",\"Details：伤害统计\",\"译者注\",\"不想自己折腾插件的玩家强烈建议直接用露露插件整合包，她的语音提示基本上把大米轮椅化了，AoE、驱散、站位、队友技能等等都有语音提示，有的 Boss 甚至规划了减伤（破晨老二），能极大地提升大米游戏体验。\"]},\"492\":{\"h\":\"13. 常见问题\",\"t\":[\"为什么我一直死？ \",\"把铁木树皮也作为你的个减。\",\"为什么我的蓝经常用完？ \",\"保持生命绽放 HoT 一直不断，不要浪费任何一个清晰预兆效果。\",\"译者注\",\"关于第一个问题（经常死），我还有一些理解。\",\"不要省减伤，经常看到有人捏着减伤不用，作为奶很难救。树皮 + 铁皮基本上可以保证你三分之一的时间都有减伤了，在大量读条小怪聚怪开始读条的时候可以就交减伤，很大程度上能减少被秒的概率（比如围攻的 Combo 或者多个条一起点你）。\",\"尖刺伤害时变熊。有些可以预料到的尖刺伤害都可以用变熊来吃，不仅增加自己的存活概率，还能腾出 GCD 奶别人。有些 AoE 前也可以先变熊一下，然后放治疗技能直接变回来，可以吃到巨熊活力的生命值加成。\",\"在高额 AoE 下可以看情况规划树皮铁皮一起放，腾出 GCD 奶别人。比如破晨老二 Combo、千丝老三 AoE。\",\"关于第二个问题（蓝耗），一般情况下奶德点了变形大师天赋，不会缺蓝。在 Boss 战治疗压力低的时候进行输出顺便回蓝。在高层丰饶下的愈合也很省蓝。\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"493\":{\"h\":\"阮一峰 TypeScript 教程 笔记\",\"t\":[\"原文地址：http://hscarb.github.io/other/99991231-ryf-ts-note.html\",\"https://wangdoc.com/typescript/\"]},\"494\":{\"h\":\"1. 简介\"},\"495\":{\"h\":\"1.3 动态类型与静态类型\",\"t\":[\"TypeScript 引入了一个更强大、更严格的类型系统，属于静态类型语言。变量类型和属性都是静态的，不允许随机增删\"]},\"496\":{\"h\":\"2. 基本用法\"},\"497\":{\"h\":\"2.3 TypeScript 的编译\",\"t\":[\"TypeScript 官方没有做运行环境，只提供编译器。编译时，会将类型声明和类型相关的代码全部删除，只留下能运行的 JavaScript 代码，并且不会改变 JavaScript 的运行结果。\"]},\"498\":{\"h\":\"2.6 tsc 编译器\",\"t\":[\"npm install -g typescript tsc -v tsc -h tsc --all \",\"pnpm add typescript -D pnpm tsc \",\"tsc file1.ts file2.ts --outFile app.js # 多个文件编译成一个 tsc app.ts --outDir dist # 指定保存到其他目录 tsc --target es2015 app.ts # 指定编译后的 JavaScript 版本 tsc --noEmitOnError app.ts # 报错就停止编译，不生成编译产物 tsc --noEmit app.ts # 只检查类型是否正确，不生成 JavaScript 文件 \"]},\"499\":{\"h\":\"2.6.5 tsconfig.json\",\"t\":[\"$ tsc file1.ts file2.ts --outFile dist/app.js \",\"上面这个命令写成tsconfig.json，就是下面这样。\",\"{ \\\"files\\\": [\\\"file1.ts\\\", \\\"file2.ts\\\"], \\\"compilerOptions\\\": { \\\"outFile\\\": \\\"dist/app.js\\\" } } \",\"有了这个配置文件，编译时直接调用tsc命令就可以了。\",\"$ tsc \"]},\"500\":{\"h\":\"2.7 ts-node 模块\",\"t\":[\"ts-node 是一个非官方的 npm 模块，可以直接运行 TypeScript 代码。\",\"$ npm install -g ts-node $ ts-node script.ts $ ts-node > const twice = (x:string) => x + x; > twice('abc') 'abcabc' > \"]},\"501\":{\"h\":\"3. any 类型，unknown 类型，never 类型\",\"t\":[\"TypeScript 有两个“顶层类型”（any和unknown），但是“底层类型”只有never唯一一个。\"]},\"502\":{\"h\":\"3.1 any 类型\",\"t\":[\"没有任何限制，该类型的变量可以赋予任意类型的值。\",\"对于开发者没有指定类型、TypeScript 必须自己推断类型的那些变量，如果无法推断出类型，TypeScript 就会认为该变量的类型是any。\",\"any类型除了关闭类型检查，还会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错。\",\"let x:any = 'hello'; let y:number; y = x; // 不报错 y * 123 // 不报错 y.toFixed() // 不报错 \"]},\"503\":{\"h\":\"3.2 unknown 类型\",\"t\":[\"与 any 含义相同，表示类型不确定。解决 any 类型污染问题。\",\"限制：\",\"不能直接赋值给其他类型的变量（除了any类型和unknown类型）。\",\"let v:unknown = 123; let v1:boolean = v; // 报错 let v2:number = v; // 报错 \",\"不能直接调用 unknown 类型变量的方法和属性。\",\"能够进行的运算是有限的，只能进行比较运算（运算符==、===、!=、!==、||、&&、?）、取反运算（运算符!）、typeof运算符和instanceof运算符这几种，其他运算都会报错。\",\"只有经过类型缩小（缩小 unknown 变量类型范围）才能使用\",\"let a:unknown = 1; if (typeof a === 'number') { let r = a + 10; // 正确 } let s:unknown = 'hello'; if (typeof s === 'string') { s.length; // 正确 } \"]},\"504\":{\"h\":\"3.3 never 类型\",\"t\":[\"空类型，不包含任何值。不能给它赋任何值。\",\"使用场景：\",\"在一些类型运算中，保证类型运算的完整性。\",\"function fn(x:string|number) { if (typeof x === 'string') { // ... } else if (typeof x === 'number') { // ... } else { x; // never 类型 } } \",\" * 可以赋值给任意其他类型 ```ts function f():never { throw new Error('Error'); } let v1:number = f(); // 不报错 let v2:string = f(); // 不报错 let v3:boolean = f(); // 不报错 \"]},\"505\":{\"h\":\"4. 类型系统\"},\"506\":{\"h\":\"4.1 基本类型\",\"t\":[\"JavaScript 语言（注意，不是 TypeScript）将值分成8种类型。\",\"boolean\",\"string\",\"number\",\"bigint\",\"symbol\",\"object：对象、数组、函数\",\"undefined：未定义\",\"null：空\",\"TypeScript 继承了 JavaScript 的类型设计，以上8种类型可以看作 TypeScript 的基本类型。\",\"注意，上面所有类型的名称都是小写字母，首字母大写的Number、String、Boolean等在 JavaScript 语言中都是内置对象，而不是类型名称。\",\"另外，undefined 和 null 既可以作为值，也可以作为类型，取决于在哪里使用它们。\"]},\"507\":{\"h\":\"4.2 包装对象类型\"},\"508\":{\"h\":\"4.2.1 包装对象的概念\",\"t\":[\"JavaScript 的8种类型之中，五种属于原始类型（primitive value），代表最基本的、不可再分的值。\",\"boolean\",\"string\",\"number\",\"bigint\",\"symbol\",\"五种原始类型的值，都有对应的包装对象（wrapper object）。指的是这些值在需要时，会自动产生的对象。\",\"Symbol()和BigInt()不能作为构造函数使用，剩下三种可以。\",\"Boolean()\",\"String()\",\"Number()\",\"const s = new String('hello'); typeof s // 'object' s.charAt(1) // 'e' \"]},\"509\":{\"h\":\"4.2.2 包装对象类型与字面量类型\",\"t\":[\"String类型可以赋值为字符串的字面量，也可以赋值为包装对象。但是，string类型只能赋值为字面量，赋值为包装对象就会报错。\",\"const s1:String = 'hello'; // 正确 const s2:String = new String('hello'); // 正确 const s3:string = 'hello'; // 正确 const s4:string = new String('hello'); // 报错 \",\"建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象。而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错。\"]},\"510\":{\"h\":\"4.3 Object 类型与 object 类型\"},\"511\":{\"h\":\"4.3.1 Object 类型\",\"t\":[\"所有可以转成对象的值，都是Object类型，这囊括了几乎所有的值。除了undefined和null这两个值不能转为对象，其他任何值都可以赋值给Object类型。\",\"{}是Object类型的简写形式，所以使用Object时常常用空对象代替。\",\"let obj:{}; obj = true; obj = 'hi'; obj = 1; obj = { foo: 123 }; obj = [1, 2]; obj = (a:number) => a + 1; \"]},\"512\":{\"h\":\"4.3.2 object 类型\",\"t\":[\"小写的object类型代表 JavaScript 里面的狭义对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。\",\"let obj:object; obj = { foo: 123 }; obj = [1, 2]; obj = (a:number) => a + 1; obj = true; // 报错 obj = 'hi'; // 报错 obj = 1; // 报错 \",\"大多数时候，我们使用对象类型，只希望包含真正的对象，不希望包含原始类型。所以，建议总是使用小写类型object，不使用大写类型Object。\"]},\"513\":{\"h\":\"4.4 undefined 和 null 的特殊性\",\"t\":[\"任何其他类型的变量都可以赋值为undefined或null。\"]},\"514\":{\"h\":\"4.5 值类型\",\"t\":[\"单个值也是一种类型，称为“值类型”。\",\"遇到const命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。\",\"let x:'hello'; x = 'hello'; // 正确 x = 'world'; // 报错 // x 的类型是 \\\"https\\\" const x = 'https'; // y 的类型是 string const y:string = 'https'; \",\"只包含单个值的值类型，用处不大。实际开发中，往往将多个值结合，作为联合类型使用。\"]},\"515\":{\"h\":\"4.6 联合类型\",\"t\":[\"联合类型（union types）指的是多个类型组成的一个新类型，使用符号|表示。\",\"联合类型A|B表示，任何一个类型只要属于A或B，就属于联合类型A|B。\",\"let x:string|number; x = 123; // 正确 x = 'abc'; // 正确 \",\"联合类型可以与值类型相结合，表示一个变量的值有若干种可能。\",\"let setting:true|false; let gender:'male'|'female'; let rainbowColor:'赤'|'橙'|'黄'|'绿'|'青'|'蓝'|'紫'; let name:string|null; let x: | 'one' | 'two' | 'three' | 'four'; \",\"如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”（type narrowing），区分该值到底属于哪一种类型，然后再进一步处理。\",\"function getPort(scheme: 'http'|'https') { switch (scheme) { case 'http': return 80; case 'https': return 443; } } \"]},\"516\":{\"h\":\"4.7 交叉类型\",\"t\":[\"交叉类型A&B表示，任何一个类型必须同时属于A和B，才属于交叉类型A&B。\",\"// 主要用途是表示对象的合成 let obj: { foo: string } & { bar: string }; obj = { foo: 'hello', bar: 'world' }; // 为对象类型添加新属性 type A = { foo: number }; type B = A & { bar: number }; \"]},\"517\":{\"h\":\"4.8 type 命令\",\"t\":[\"type命令用来定义一个类型的别名。作用域是块级作用域。\",\"type Age = number; let age:Age = 55; \"]},\"518\":{\"h\":\"4.9 typeof 运算符\",\"t\":[\"JavaScript 里面，typeof运算符只可能返回八种结果，而且都是字符串。\",\"typeof undefined; // \\\"undefined\\\" typeof true; // \\\"boolean\\\" typeof 1337; // \\\"number\\\" typeof \\\"foo\\\"; // \\\"string\\\" typeof {}; // \\\"object\\\" typeof parseInt; // \\\"function\\\" typeof Symbol(); // \\\"symbol\\\" typeof 127n // \\\"bigint\\\" \",\"TypeScript 将typeof运算符移植到了类型运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。\",\"const a = { x: 0 }; type T0 = typeof a; // { x: number } type T1 = typeof a.x; // number let a = 1; let b:typeof a; if (typeof a === 'number') { b = a; } \",\"typeof命令的参数不能是类型。\"]},\"519\":{\"h\":\"4.10 块级类型声明\",\"t\":[\"类型可以声明在代码块（用大括号表示）里面，并且只在当前代码块有效。\",\"if (true) { type T = number; let v:T = 5; } else { type T = string; let v:T = 'hello'; } \"]},\"520\":{\"h\":\"4.11 类型的兼容\",\"t\":[\"type T = number|string; let a:number = 1; let b:T = a; \",\"如果类型A的值可以赋值给类型B，那么类型A就称为类型B的子类型（subtype）。在上例中，类型number就是类型number|string的子类型。\",\"凡是可以使用父类型的地方，都可以使用子类型，但是反过来不行。\"]},\"521\":{\"h\":\"5. 数组\",\"t\":[\"JavaScript 数组在 TypeScript 里面分成两种类型，分别是数组（array）和元组（tuple）。\"]},\"522\":{\"h\":\"5.1 简介\",\"t\":[\"TypeScript 的数组所有成员类型必须相同。\",\"let arr:number[] = [1, 2, 3]; let arr:(number|string)[]; let arr:any[]; // 另一种写法，用 Array 接口 let arr:Array<number> = [1, 2, 3]; let arr:Array<number|string>; \"]},\"523\":{\"h\":\"5.2 数组的类型推断\",\"t\":[\"// 推断为 any[] const arr = []; // 赋值时会自动更新类型推断 arr.push(123); arr // 推断类型为 number[] arr.push('abc'); arr // 推断类型为 (string|number)[] \",\"类型推断的自动更新只发生初始值为空数组的情况。如果初始值不是空数组，类型推断就不会更新。\"]},\"524\":{\"h\":\"5.3 只读数组，const 断言\",\"t\":[\"JavaScript const命令声明的数组变量是可以改变成员。TypeScript 允许声明只读数组，方法是在数组类型前面加上readonly关键字。\",\"TypeScript 将readonly number[]与number[]视为两种不一样的类型，后者是前者的子类型。（数组是只读数组的子类型）\",\"const arr:readonly number[] = [0, 1]; arr[1] = 2; // 报错 arr.push(3); // 报错 delete arr[0]; // 报错 // 另外写法 const a1:ReadonlyArray<number> = [0, 1]; const a2:Readonly<number[]> = [0, 1]; \"]},\"525\":{\"h\":\"5.4 多维数组\",\"t\":[\"var multi:number[][] = [[1,2,3], [23,24,25]]; \"]},\"526\":{\"h\":\"6. 元组\"},\"527\":{\"h\":\"6.1 简介\",\"t\":[\"TypeScript 特有的数据类型，各个成员的类型可以不同的数组。必须声明每个成员的类型。\",\"// 数组的成员类型写在方括号外面（number[]），元组的成员类型是写在方括号里面（[number]） const s:[string, string, boolean] = ['a', 'b', true]; // 问号后缀表示该成员是可选的，可选成员必须在必选成员之后 let a:[number, number?] = [1]; // 扩展运算符 ... 表示不限成员数量的元组，它可以用在任意位置 type NamedNums = [ string, ...number[] ]; const a:NamedNums = ['A', 1, 2]; // 不确定元组成员类型和数量，可以放置任意数量和类型的成员 type Tuple = [...any[]]; // 方括号读取成员类型 type Tuple = [string, number]; type Age = Tuple[1]; // number \"]},\"528\":{\"h\":\"6.2 只读元组\",\"t\":[\"type t = readonly [number, string] type t = Readonly<[number, string]> // 泛型写法Readonly<T> \"]},\"529\":{\"h\":\"6.4 扩展运算符\",\"t\":[\"扩展运算符（...）将数组（注意，不是元组）转换成一个逗号分隔的序列，这时 TypeScript 会认为这个序列的成员数量是不确定的，因为数组的成员数量是不确定的。\",\"const arr = [1, 2, 3]; console.log(...arr) \",\"元组使用扩展运算符，成员数量是确定的。\"]},\"530\":{\"h\":\"7. symbol 类型\"},\"531\":{\"h\":\"7.1 简介\",\"t\":[\"Symbol 是 ES2015 新引入的一种原始类型的值。它类似于字符串，但是每一个 Symbol 值都是独一无二的，与其他任何值都不相等。\",\"let x:symbol = Symbol(); let y:symbol = Symbol(); x === y // false \"]},\"532\":{\"h\":\"8. 函数\"},\"533\":{\"h\":\"8.1 简介\",\"t\":[\"需要在声明函数时，给出参数的类型和返回值的类型。缺乏足够信息，就会推断该参数的类型为any。\",\"// 写法一 const hello = function (txt:string) { console.log('hello ' + txt); } // 写法二 const hello: (txt:string) => void = function (txt) { console.log('hello ' + txt); }; // 用type命令为函数类型定义一个别名，便于指定给其他变量。 type MyFunc = (txt:string) => void; const hello:MyFunc = function (txt) { console.log('hello ' + txt); }; \",\"TypeScript 允许省略参数。\"]},\"534\":{\"h\":\"8.2 Function 类型\",\"t\":[\"Function 类型表示函数\"]},\"535\":{\"h\":\"8.3 箭头函数\",\"t\":[\"普通函数的一种简化写法。\",\"const repeat = (str:string, times:number):string => str.repeat(times); function greet(fn:(a:string) => void):void { fn('world'); } \"]},\"536\":{\"h\":\"8.4 可选参数\",\"t\":[\"function f(x?:number) { // ... } f(); // OK f(10); // OK \"]},\"537\":{\"h\":\"8.5 参数默认值\",\"t\":[\"function createPoint(x:number = 0, y:number = 0):[number, number] { return [x, y]; } createPoint() // [0, 0] \"]},\"538\":{\"h\":\"8.6 参数解构\",\"t\":[\"可以用类型别名\",\"type ABC = { a:number; b:number; c:number }; function sum({ a, b, c }:ABC) { console.log(a + b + c); } \"]},\"539\":{\"h\":\"8.7 rest 参数\",\"t\":[\"表示函数剩余的所有参数，可以试数组，也可以是元组。\",\"// rest 参数为数组 function joinNumbers(...nums:number[]) { // ... } // rest 参数为元组 function f(...args:[boolean, number]) { // ... } \"]},\"540\":{\"h\":\"8.8 readonly 只读参数\",\"t\":[\"function arraySum(arr:readonly number[]) { // ... arr[0] = 0; // 报错 } \"]},\"541\":{\"h\":\"8.9 void 类型\",\"t\":[\"表示函数没有返回值\",\"function f():void { console.log('hello'); } \"]},\"542\":{\"h\":\"8.10 never 类型\",\"t\":[\"never类型表示肯定不会出现的值。它用在函数的返回值，就表示某个函数肯定不会返回值，即函数不会正常执行结束。\"]},\"543\":{\"h\":\"抛出错误的函数\",\"t\":[\"function fail(msg:string):never { throw new Error(msg); } \"]},\"544\":{\"h\":\"无限执行的函数\",\"t\":[\"const sing = function():never { while (true) { console.log('sing'); } }; \"]},\"545\":{\"h\":\"8.11 局部类型\",\"t\":[\"声明其他类型，只在函数内部有效\",\"function hello(txt:string) { type message = string; let newTxt:message = 'hello ' + txt; return newTxt; } const newTxt:message = hello('world'); // 报错 \"]},\"546\":{\"h\":\"8.12 高阶函数\",\"t\":[\"函数的返回值还是一个函数，那么前一个函数就称为高阶函数（higher-order function）。\",\"(someValue: number) => (multiplier: number) => someValue * multiplier; \"]},\"547\":{\"h\":\"8.13 函数重载\",\"t\":[\"接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。\",\"TypeScript 对于“函数重载”的类型声明方法是，逐一定义每一种情况的类型。\",\"// 声明 function reverse(str:string):string; function reverse(arr:any[]):any[]; // 完整类型声明，兼容前面的重载 function reverse( stringOrArray:string|any[] ):string|any[] { if (typeof stringOrArray === 'string') return stringOrArray.split('').reverse().join(''); else return stringOrArray.slice().reverse(); } \"]},\"548\":{\"h\":\"8.14 构造函数\",\"t\":[\"使用new命令调用。构造函数的类型写法，就是在参数列表前面加上new命令。\",\"class Animal { numLegs:number = 4; } // 构造函数 type AnimalConstructor = new () => Animal; // 传入一个构造函数 function create(c:AnimalConstructor):Animal { return new c(); } const a = create(Animal); \"]},\"549\":{\"h\":\"9. 对象\"},\"550\":{\"h\":\"9.1 简介\",\"t\":[\"const obj:{ x:number; // 可以以分号结尾 y:number; add(x:number, y:number): number; } = { x: 1, y: 1 }; // 属性类型以逗号结尾 type MyObj = { x:number, y:number, }; \"]},\"551\":{\"h\":\"9.2 可选属性\",\"t\":[\"在属性名后面加一个问号。\",\"const obj: { x: number; y?: number; } = { x: 1 }; // 可选属性读取之前，需要判断是否为undefined才能使用 // 写法一 let firstName = (user.firstName === undefined) ? 'Foo' : user.firstName; let lastName = (user.lastName === undefined) ? 'Bar' : user.lastName; // 写法二，使用Null判断运算符?? let firstName = user.firstName ?? 'Foo'; let lastName = user.lastName ?? 'Bar'; \"]},\"552\":{\"h\":\"9.3 只读属性\",\"t\":[\"const person:{ readonly age: number } = { age: 20 }; person.age = 21; // 报错 // 只能在对象初始化时赋值 type Point = { readonly x: number; readonly y: number; }; const p:Point = { x: 0, y: 0 }; p.x = 100; // 报错 \"]},\"553\":{\"h\":\"9.4 属性名的索引类型\",\"t\":[\"type MyObj = { [property: string]: string // 不管这个对象有多少属性，只要属性名为字符串，且属性值也是字符串，就符合这个类型声明。 }; const obj:MyObj = { foo: 'a', bar: 'b', baz: 'c', }; \"]},\"554\":{\"h\":\"9.5 解构赋值\",\"t\":[\"用于直接从对象中提取属性\",\"const {id, name, price} = product; // 另一种写法：类型写法 const {id, name, price}:{ id: string; name: string; price: number } = product; \"]},\"555\":{\"h\":\"9.7 严格字面量检查\",\"t\":[\"const point:{ x:number; y:number; } = { x: 1, y: 1, z: 1 // 报错 }; const myPoint = { x: 1, y: 1, z: 1 }; const point:{ x:number; y:number; } = myPoint; // 正确，等号右边是变量，不触发严格字面量检查 \"]},\"556\":{\"h\":\"9.9 空对象\",\"t\":[\"这种写法其实在 JavaScript 很常见：先声明一个空对象，然后向空对象添加属性。但是，TypeScript 不允许动态添加属性，所以对象不能分步生成，必须生成时一次性声明所有属性。\",\"// 错误 const pt = {}; pt.x = 3; pt.y = 4; // 正确 const pt = { x: 3, y: 4 }; \"]},\"557\":{\"h\":\"10. interface\"},\"558\":{\"h\":\"10.1 简介\",\"t\":[\"对象的模板，使用了某个模板的对象，就拥有了指定的类型结构。\",\"它的成员有5种形式。\",\"对象属性\",\"对象的属性索引\",\"对象方法\",\"函数\",\"构造函数\",\"interface Point { x: number; y: number; s?: string; readonly a: string; // 属性索引 [prop: string]: number; // 对象方法 f(x: boolean): string; f: (x: boolean) => string; f: { (x: boolean): string }; // 函数 (x:number, y:number): number; // 构造函数 new (message?: string): Error; } \",\"interface 里面的函数重载，不需要给出实现。但是，由于对象内部定义方法时，无法使用函数重载的语法，所以需要额外在对象外部给出函数方法的实现。\",\"interface A { f(): number; f(x: boolean): boolean; f(x: string, y: string): string; } // 额外在对象外部给出函数方法的实现 function MyFunc(): number; function MyFunc(x: boolean): boolean; function MyFunc(x: string, y: string): string; function MyFunc( x?:boolean|string, y?:string ):number|boolean|string { if (x === undefined && y === undefined) return 1; if (typeof x === 'boolean' && y === undefined) return true; if (typeof x === 'string' && typeof y === 'string') return 'hello'; throw new Error('wrong parameters'); } const a:A = { f: MyFunc } \"]},\"559\":{\"h\":\"10.2 interface 的继承\"},\"560\":{\"h\":\"10.2.1 interface 继承 interface\",\"t\":[\"interface Shape { name: string; } interface Circle extends Shape { radius: number; } \",\"允许继承多个，子接口与父接口的同名属性必须是类型兼容的，不能有冲突，否则会报错。\"]},\"561\":{\"h\":\"10.2.2 interface 继承 type\",\"t\":[\"type Country = { name: string; capital: string; } interface CountryWithPop extends Country { population: number; } \"]},\"562\":{\"h\":\"10.2.3 interface 继承 class\",\"t\":[\"class A { x:string = ''; y():boolean { return true; } } interface B extends A { z: number } \"]},\"563\":{\"h\":\"10.3 接口合并\",\"t\":[\"多个同名接口会合并成一个接口。\",\"interface Box { height: number; width: number; } interface Box { length: number; } \",\"函数重载。而且，后面的定义比前面的定义具有更高的优先级。但字面量类型有更高的优先级。\",\"interface Cloner { clone(animal: Animal): Animal; } interface Cloner { clone(animal: Sheep): Sheep; } interface Cloner { clone(animal: Dog): Dog; clone(animal: Cat): Cat; } // 等同于 interface Cloner { clone(animal: Dog): Dog; clone(animal: Cat): Cat; clone(animal: Sheep): Sheep; clone(animal: Animal): Animal; } \"]},\"564\":{\"h\":\"10.4 interface 与 type 的异同\",\"t\":[\"几乎所有的 interface 命令都可以改写为 type 命令，他们可以定义一个类型，class命令也有类似作用，通过定义一个类，同时定义一个对象类型。但是，它会创造一个值，编译后依然存在。如果只是单纯想要一个类型，应该使用type或interface。\",\"type Country = { name: string; capital: string; } interface Coutry { name: string; capital: string; } \",\"区别\",\"type能够表示非对象类型，而interface只能表示对象类型（包括数组、函数等）。\",\"interface可以继承其他类型，type不支持继承。\",\"同名interface会自动合并，同名type则会报错。也就是说，TypeScript 不允许使用type多次定义同一个类型。\",\"interface不能包含属性映射（mapping），type可以。\",\"this关键字只能用于interface。\",\"type 可以扩展原始数据类型，interface 不行。\",\"interface无法表达某些复杂类型（比如交叉类型和联合类型），但是type可以。\",\"综上所述，如果有复杂的类型运算，那么没有其他选择只能使用type；一般情况下，interface灵活性比较高，便于扩充类型或自动合并，建议优先使用。\"]},\"565\":{\"h\":\"11. 类\"},\"566\":{\"h\":\"11.1 简介\",\"t\":[\"class Point { x:number; y:number; // 函数重载 constructor(x:number, y:string); constructor(s:string); constructor(xs:number|string, y?:string) { // ... } add(point:Point) { return new Point( this.x + point.x, this.y + point.y ); } } \"]},\"567\":{\"h\":\"11.1.4 存取器方法\",\"t\":[\"存取器（accessor）是特殊的类方法，包括取值器（getter）和存值器（setter）两种方法。\",\"它们用于读写某个属性，取值器用来读取属性，存值器用来写入属性。\",\"class C { _name = ''; get name() { return this._name; } set name(value) { this._name = value; } } \"]},\"568\":{\"h\":\"11.1.5 属性索引\",\"t\":[\"class MyClass { [s:string]: boolean | ((s:string) => boolean); get(s:string) { return this[s] as boolean; } } \",\"[s:string]表示所有属性名类型为字符串的属性，它们的属性值要么是布尔值，要么是返回布尔值的函数。\"]},\"569\":{\"h\":\"11.2 类的 interface 接口\"},\"570\":{\"h\":\"11.2.1 implements 关键字\",\"t\":[\"interface 接口或 type 别名，可以用对象的形式，为 class 指定一组检查条件。然后，类使用 implements 关键字，表示当前类满足这些外部类型条件的限制。\",\"interface 只是指定检查条件，如果不满足这些条件就会报错。它并不能代替 class 自身的类型声明。\",\"interface Country { name:string; capital:string; } // 或者 type Country = { name:string; capital:string; } class MyCountry implements Country { name = ''; capital = ''; } \"]},\"571\":{\"h\":\"11.2.2 实现多个接口\",\"t\":[\"class Car implements MotorVehicle { } class SecretCar extends Car implements Flyable, Swimmable { } \"]},\"572\":{\"h\":\"11.3 Class 类型\"},\"573\":{\"h\":\"11.3.1 实例类型\",\"t\":[\"interface MotorVehicle { } class Car implements MotorVehicle { } // 写法一 const c1:Car = new Car(); // 写法二 const c2:MotorVehicle = new Car(); \",\"变量的类型可以写成类Car，也可以写成接口MotorVehicle。它们的区别是，如果类Car有接口MotoVehicle没有的属性和方法，那么只有变量c1可以调用这些属性和方法。\"]},\"574\":{\"h\":\"11.3.2 类的自身类型\",\"t\":[\"用 typeof 运算符可以获得类的自身类型。\"]},\"575\":{\"h\":\"11.5 可访问性修饰符\",\"t\":[\"类的内部成员的外部可访问性，由三个可访问性修饰符（access modifiers）控制：public、private和protected。\",\"这三个修饰符的位置，都写在属性或方法的最前面。\",\"public修饰符是默认修饰符，如果省略不写，实际上就带有该修饰符。因此，类的属性和方法默认都是外部可访问的。\",\"class Greeter { public greet() { console.log(\\\"hi!\\\"); } } const g = new Greeter(); g.greet(); \"]},\"576\":{\"h\":\"11.5.4 实例属性的简写形式\",\"t\":[\"构造方法的参数x前面有public修饰符，这时 TypeScript 就会自动声明一个公开属性x，不必在构造方法里面写任何代码，同时还会设置x的值为构造方法的参数值。注意，这里的public不能省略。\",\"除了public修饰符，构造方法的参数名只要有private、protected、readonly修饰符，都会自动声明对应修饰符的实例属性。\",\"class A { constructor( public a: number, protected b: number, private c: number, readonly d: number ) {} } // 编译结果 class A { a; b; c; d; constructor(a, b, c, d) { this.a = a; this.b = b; this.c = c; this.d = d; } } \"]},\"577\":{\"h\":\"11.6 静态成员\",\"t\":[\"静态成员是只能通过类本身使用的成员，不能通过实例对象使用。类的内部可以使用static关键字，定义静态成员。static关键字前面可以使用 public、private、protected 修饰符。\",\"class MyClass { static x = 0; static printX() { console.log(MyClass.x); } } MyClass.x // 0 MyClass.printX() // 0 \"]},\"578\":{\"h\":\"11.7 泛型类\",\"t\":[\"class Box<Type> { contents: Type; constructor(value:Type) { this.contents = value; } } const b:Box<string> = new Box('hello!'); \",\"新建实例时，变量的类型声明需要带有类型参数的值，不过本例等号左边的Box<string>可以省略不写，因为可以从等号右边推断得到。\"]},\"579\":{\"h\":\"11.8 抽象类，抽象成员\",\"t\":[\"TypeScript 允许在类的定义前面，加上关键字abstract，表示该类不能被实例化，只能当作其他类的模板。这种类就叫做“抽象类”（abstract class）。\",\"abstract class A { id = 1; } const a = new A(); // 报错 class B extends A { amount = 100; } const b = new B(); b.id // 1 b.amount // 100 \"]},\"580\":{\"h\":\"11.9 this 问题\",\"t\":[\"类的方法经常用到this关键字，它表示该方法当前所在的对象。有些场合需要给出this类型，但是 JavaScript 函数通常不带有this参数，这时 TypeScript 允许函数增加一个名为this的参数，放在参数列表的第一位，用来描述函数内部的this关键字的类型。\",\"class A { name = 'A'; getName() { return this.name; } } const a = new A(); a.getName() // 'A' \"]},\"581\":{\"h\":\"13. Enum 类型\"},\"582\":{\"h\":\"13.1 简介\",\"t\":[\"enum Color { Red, // 0 Green, // 1 Blue // 2 } let c = Color.Green; // 1 // 等同于 let c = Color['Green']; // 1 let c:Color = Color.Green; // 正确 let c:number = Color.Green; // 正确 // 编译后 let Color = { Red: 0, Green: 1, Blue: 2 }; \",\"Enum 结构Color，里面包含三个成员Red、Green和Blue。第一个成员的值默认为整数0，第二个为1，第三个为2，以此类推。\",\"Enum 结构本身也是一种类型。比如，上例的变量c等于1，它的类型可以是 Color，也可以是number。\",\"由于 TypeScript 的定位是 JavaScript 语言的类型增强，所以官方建议谨慎使用 Enum 结构，因为它不仅仅是类型，还会为编译后的代码加入一个对象。\",\"Enum 结构比较适合的场景是，成员的值不重要，名字更重要，从而增加代码的可读性和可维护性。\"]},\"583\":{\"h\":\"13.2 Enum 成员的值\",\"t\":[\"成员的值可以是任意数值，甚至可以相同，但不能是大整数（Bigint）。不能重新赋值。\",\"如果只设定第一个成员的值，后面成员的值就会从这个值开始递增。\",\"enum Color { Red = 7, Green, // 8 Blue // 9 } // 或者 enum Color { Red, // 0 Green = 7, Blue // 8 } \"]},\"584\":{\"h\":\"13.3 同名 Enum 的合并\",\"t\":[\"enum Foo { A, } enum Foo { B = 1, } enum Foo { C = 2, } // 等同于 enum Foo { A, B = 1， C = 2 } \"]},\"585\":{\"h\":\"13.4 字符串 Enum\",\"t\":[\"字符串枚举的所有成员值，都必须显式设置。如果没有设置，成员值默认为数值，且位置必须在字符串成员之前。\",\"enum Direction { Up = 'UP', Down = 'DOWN', Left = 'LEFT', Right = 'RIGHT', } // 可以混合赋值 enum Enum { One = 'One', Two = 'Two', Three = 3, Four = 4, } \"]},\"586\":{\"h\":\"13.5 keyof 运算符\",\"t\":[\"enum MyEnum { A = 'a', B = 'b' } // 'A'|'B' type Foo = keyof typeof MyEnum; // keyof 运算符可以取出 Enum 结构的所有成员名，作为联合类型返回。 \"]},\"587\":{\"h\":\"13.6 反向映射\",\"t\":[\"可以通过成员值获得成员名。\",\"enum Weekdays { Monday = 1, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday } console.log(Weekdays[3]) // Wednesday \"]},\"588\":{\"h\":\"14. 类型断言\"},\"589\":{\"h\":\"14.1 简介\",\"t\":[\"TypeScript 提供了“类型断言”这样一种手段，允许开发者在代码中“断言”某个值的类型，告诉编译器此处的值是什么类型。TypeScript 一旦发现存在类型断言，就不再对该值进行类型推断，而是直接采用断言给出的类型。\",\"允许开发者在某个位置“绕过”编译器的类型推断，让本来通不过类型检查的代码能够通过，避免编译器报错。\",\"类型断言有两种语法。\",\"// 语法一：<类型>值 <Type>value // 语法二：值 as 类型（推荐） value as Type // 语法一 let bar:T = <T>foo; // 语法二 let bar:T = foo as T; \"]},\"590\":{\"h\":\"15. 模块\"},\"591\":{\"h\":\"15.1 简介\",\"t\":[\"任何包含 import 或 export 语句的文件，就是一个模块（module）。相应地，如果文件不包含 export 语句，就是一个全局的脚本文件。\",\"模块本身是一个作用域，不属于全局作用域。模块内部的变量、函数、类只在内部可见，对于模块外部是不可见的。暴露给外部的接口，必须用 export 命令声明；如果其他文件要使用模块的接口，必须用 import 命令来输入。\",\"在脚本头部添加\",\"export {}; \",\"可以让当前文件当作模块处理，所有它的代码变成内部代码。\",\"// a.ts type Bool = true | false; export { Bool }; // b.ts import { Bool } from './a'; // TypeScript 允许加载模块时，省略模块文件的后缀名，它会自动定位，将./a定位到./a.ts let foo:Bool = true; \"]},\"592\":{\"h\":\"15.2 import type 语句\",\"t\":[\"import 在一条语句中，可以同时输入类型和正常接口，但不利于区分类型和正常接口，容易造成混淆。为了解决这个问题，TypeScript 引入了两个解决方法。\",\"在 import 语句输入的类型前面加上type关键字。\",\"import { type A, a } from './a'; \",\"使用 import type 语句，这个语句只能输入类型，不能输入正常接口。\",\"// 正确 import type { A } from './a'; // 报错 import type { a } from './a'; \"]},\"593\":{\"h\":\"15.3 importsNotUsedAsValues 编译设置\",\"t\":[\"TypeScript 特有的输入类型（type）的 import 语句，编译成 JavaScript 时怎么处理呢？\",\"TypeScript 提供了importsNotUsedAsValues编译设置项，有三个可能的值。\",\"（1）remove：这是默认值，自动删除输入类型的 import 语句。\",\"（2）preserve：保留输入类型的 import 语句。\",\"（3）error：保留输入类型的 import 语句（与preserve相同），但是必须写成import type的形式，否则报错。\"]},\"594\":{\"h\":\"15.4 CommonJS 模块\",\"t\":[\"CommonJS 是 Node.js 的专用模块格式，与 ES 模块格式不兼容。\"]},\"595\":{\"h\":\"15.4.1 import = 语句\",\"t\":[\"TypeScript 使用import =语句输入 CommonJS 模块。\",\"import fs = require('fs'); const code = fs.readFileSync('hello.ts', 'utf8'); \",\"TypeScript 还允许使用import * as [接口名] from \\\"模块文件\\\"输入 CommonJS 模块。\",\"import * as fs from 'fs'; // 等同于 import fs = require('fs'); \"]},\"596\":{\"h\":\"15.4.2 export = 语句\",\"t\":[\"TypeScript 使用export =语句，输出 CommonJS 模块的对象，等同于 CommonJS 的module.exports对象。\",\"let obj = { foo: 123 }; export = obj; \",\"export =语句输出的对象，只能使用import =语句加载。\"]},\"597\":{\"h\":\"15.5 模块定位\",\"t\":[\"模块定位（module resolution）指的是确定 import 语句和 export 语句里面的模块文件位置。\",\"模块定位有两种方法，一种称为 Classic 方法，另一种称为 Node 方法。可以使用编译参数moduleResolution，指定使用哪一种方法。\",\"没有指定定位方法时，就看原始脚本采用什么模块格式。如果模块格式是 CommonJS（即编译时指定--module commonjs），那么模块定位采用 Node 方法，否则采用 Classic 方法（模块格式为 es2015、 esnext、amd, system, umd 等等）。\"]},\"598\":{\"h\":\"15.5.1 相对模块，非相对模块\",\"t\":[\"相对模块指的是路径以/、./、../开头的模块。下面 import 语句加载的模块，都是相对模块。\",\"import Entry from \\\"./components/Entry\\\";\",\"import { DefaultHeaders } from \\\"../constants/http\\\";\",\"import \\\"/mod\\\";\",\"非相对模块指的是不带有路径信息的模块。下面 import 语句加载的模块，都是非相对模块。\",\"import * as $ from \\\"jquery\\\";\",\"import { Component } from \\\"@angular/core\\\";\"]},\"599\":{\"h\":\"15.5.2 Classic 方法\",\"t\":[\"以当前脚本的路径作为“基准路径”，计算相对模块的位置。\",\"非相对模块，也是以当前脚本的路径作为起点，一层层查找上级目录。\"]},\"600\":{\"h\":\"15.5.3 Node 方法\",\"t\":[\"Node 方法就是模拟 Node.js 的模块加载方法。\",\"相对模块依然是以当前脚本的路径作为“基准路径”。\",\"非相对模块则是以当前脚本的路径作为起点，逐级向上层目录查找是否存在子目录node_modules。\"]},\"601\":{\"h\":\"15.5.4 路径映射\",\"t\":[\"TypeScript 允许开发者在tsconfig.json文件里面，手动指定脚本模块的路径。\",\"baseUrl：可以手动指定脚本模块的基准目录。\",\"{ \\\"compilerOptions\\\": { \\\"baseUrl\\\": \\\".\\\" } } \",\"paths：指定非相对路径的模块与实际脚本的映射。\",\"{ \\\"compilerOptions\\\": { \\\"baseUrl\\\": \\\".\\\", \\\"paths\\\": { \\\"jquery\\\": [\\\"node_modules/jquery/dist/jquery\\\"] } } } \",\"rootDirs：指定模块定位时必须查找的其他目录。\",\"{ \\\"compilerOptions\\\": { \\\"rootDirs\\\": [\\\"src/zh\\\", \\\"src/de\\\", \\\"src/#{locale}\\\"] } } \"]},\"602\":{\"h\":\"15.5.5 tsc 的 --traceResolution 参数\",\"t\":[\"tsc 命令有一个--traceResolution参数，能够在编译时在命令行显示模块定位的每一步。\"]},\"603\":{\"h\":\"15.5.6 tsc 的 --noResolve 参数\",\"t\":[\"--noResolve参数，表示模块定位时，只考虑在命令行传入的模块。\"]},\"604\":{\"h\":\"17. 装饰器\"},\"605\":{\"h\":\"17.1 简介\",\"t\":[\"装饰器用来在定义时修改类的行为。\",\"前缀是@，后面是一个表达式。\",\"@后面的表达式，必须是一个函数（或者执行后可以得到一个函数）。\",\"这个函数接受所修饰对象的一些相关值作为参数。\",\"这个函数要么不返回值，要么返回一个新对象取代所修饰的目标对象。\",\"function simpleDecorator( value:any, context:any ) { console.log(`hi, this is ${context.kind} ${context.name}`); return value; } @simpleDecorator class A {} // \\\"hi, this is class A\\\" \"]},\"606\":{\"h\":\"17.3 装饰器的结构\",\"t\":[\"type Decorator = ( value: DecoratedValue, context: { kind: string; name: string | symbol; addInitializer?(initializer: () => void): void; static?: boolean; private?: boolean; access: { get?(): unknown; set?(value: unknown): void; }; } ) => void | ReplacementValue; \",\"上面代码中，Decorator是装饰器的类型定义。它是一个函数，使用时会接收到value和context两个参数。\",\"value：所装饰的对象。\",\"context：上下文对象，TypeScript 提供一个原生接口ClassMethodDecoratorContext，描述这个对象。 \",\"kind：字符串，表示所装饰对象的类型，可能取以下的值。 \",\"'class'\",\"'method'\",\"'getter'\",\"'setter'\",\"'field'\",\"'accessor'\",\"name：字符串或者 Symbol 值，所装饰对象的名字，比如类名、属性名等。\",\"addInitializer()：函数，用来添加类的初始化逻辑。以前，这些逻辑通常放在构造函数里面，对方法进行初始化，现在改成以函数形式传入addInitializer()方法。注意，addInitializer()没有返回值。\",\"private：布尔值，表示所装饰的对象是否为类的私有成员。\",\"static：布尔值，表示所装饰的对象是否为类的静态成员。\",\"access：一个对象，包含了某个值的 get 和 set 方法。\"]},\"607\":{\"h\":\"17.4 类装饰器\",\"t\":[\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"608\":{\"h\":\"other\",\"t\":[\"Vim笔记\",\"Erlang 学习笔记\",\"Arthas 笔记\",\"分布式系统韧性架构压舱石OpenChaos\",\"Vim 显示、去除换行符\",\"廖雪峰 JavaScript 教程 笔记\",\"PowerJob 原理详解 & 源码解析\",\"一致性哈希 原理和实现\",\"Echo 职业选手写的奶德大秘境完全指南 and 3000 分奶德倾囊相授\"]},\"609\":{\"h\":\"RabbitMQ 进程内流控（Flow Control） 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rabbitmq/20220131-rabbitmq-flow-control.html\"]},\"610\":{\"h\":\"1. 概述\"},\"611\":{\"h\":\"1.1 为什么要流控？\",\"t\":[\"流控主要是为了防止生产者生产消息速度过快，超过 Broker 可以处理的速度。这时需要暂时限制生产者的生产速度，让 Broker 的处理能够跟上生产速度。\",\"Erlang进程之间不共享内存，每个进程都有自己的进程邮箱，进程间只通过消息来通信。Erlang没有对进程邮箱的大小进行限制，所以当有大量消息持续发往某个进程时，会导致该进程邮箱过大，最终内存溢出并崩溃。如果没有流控，可能会导致内部进程邮箱的大小很快达到内存阈值。\"]},\"612\":{\"h\":\"1.2 RabbitMQ 的多种流控机制\"},\"613\":{\"h\":\"1.2.1 全局流控（内存高水位、磁盘低水位）\",\"t\":[\"RabbitMQ 可以对内存和磁盘使用量设置阈值，当达到阈值后，生产者将被完全阻塞（处于block状态） ，直到对应项恢复正常。\",\"内存和磁盘的流控相当于全局流控，流控时发送消息被完全阻塞，通常会阻塞较长时间（几分钟以上）才恢复。\",\"全局流控时，从Web UI可以观察到 Connection 处于blocked状态。\",\"在 rabbitmq-java-client 中，可以用给 Connection 添加 blockedListener 的方式监听阻塞和阻塞解除的事件，用以在客户端应对可能的阻塞情况。\",\"connection.addBlockedListener( reason -> { try { unblock(); } catch (InterruptedException e) { e.printStackTrace(); } }, () -> latch.countDown() ); \"]},\"614\":{\"h\":\"1.2.2 进程内流控\",\"t\":[\"进程内流控是针对 Erlang 进程的流控，与全局流控不是一个概念。又可称作 Per-Connection Flow Control。\",\"在 RabbitMQ Broker 中使用多种进程来处理消息，进程的处理顺序如下。\",\"A simplified depiction of message flows\",\"A simplified depiction of message flows\",\"reader -> channel -> queue process -> message store \",\"进程内流控指的是这4种进程之间的流控。\",\"进程内流控不会影响到消费端。\",\"某进程处于流控状态时，从 Web UI 可以观察到该进程的状态为黄色flow，此时该进程会暂时阻塞消息的生产。\",\"A queue in flow state\",\"A queue in flow state\",\"进程内流控的阻塞时间通常很短，在1秒之内。但是也有长至几分钟的。\",\"进程内流控是阻塞在 Broker 端的 socket 接收方法中，client 端无法监听和做出处理。\",\"从 RabbitMQ 3.5.5 版本开始，引入了一套基于信用证的流控实现。\",\"本文主要讨论基于信用证的进程内流控实现。\"]},\"615\":{\"h\":\"1.2.3 发送方确认\",\"t\":[\"这其实并不属于流控机制，但是通过生产者确认的方式可以让发送消息不丢失，并且控制发送消息的速度。\",\"未开启发送方确认时，消息可能未达到服务器就发送完毕。\",\"发送方确认开启后，消息在投递到匹配的队列后会给发送方返回一个确认请求，至此发送消息的动作才执行完毕。\"]},\"616\":{\"h\":\"1.2.4 消费者预取\",\"t\":[\"通过Channel#basicQos(int prefetchCount)方法设置消费者允许存在的的最大未Ack消息数量，可以达到预取一批消息到消费者进行消费的目的。\"]},\"617\":{\"h\":\"2. 概要流程\",\"t\":[\"从 RabbitMQ 3.5.5 版本开始，引入了一套基于信用证的流控实现。\"]},\"618\":{\"h\":\"2.1 信用证配置\",\"t\":[\"信用证流控的两个参数可以通过查询环境变量的方式找到\",\"rabbitmqctl eval 'application:get_all_env(rabbit).' # ... {credit_flow_default_credit,{400,200}} # {InitialCredit, MoreCreditAfter} # ... \",\"其中400表示每个进程初始的信用值，200表示下游进程处理200个消息后会一次性给上游进程加200信用值。\",\"这两个参数在老一点的版本中为{200, 50}。\"]},\"619\":{\"h\":\"2.2 基于信用证的流控\",\"t\":[\"Erlang 进程与操作系统的进程不同，是一种轻量级进程。\",\"简单来说，RabbitMQ中有四种进程。\",\"reader -> channel -> queue process -> message store 400 400 400 \",\"在初始化时，会为前三种进程分配信用值，分配的值为InitialCredit，默认400。\",\"当进程处理一条消息并且发给下游进程时，它自己的信用值会减一。\",\"下游进程处理完一条消息时，会给上有进程发一个Ack消息。但是此时并不会直接让上游进程的信用值加一，而是等到处理完MoreCreditAfter条消息（默认200）时，才将上游进程的信用值加200。\",\"当进程的信用值将为1时，就会阻塞上游进程向它发送消息。\"]},\"620\":{\"h\":\"3. 详细流程\"},\"621\":{\"h\":\"3.1 流控详细流程\",\"t\":[\"下图每个橙色组件都是一个 Erlang 进程。\",\"每个RabbitMQ broker在内部都是通过actor模式实现的，不同组件之间通过消息传递(有时是本地的)进行通信。\",\"A simplified depiction of message flows\",\"A simplified depiction of message flows\",\"下面我们把这个模型简化，然后分析基于信用证的流控机制。\",\"rabbit_reader：Connection 的处理进程。负责接收、解析 AMQP 协议数据包，将消息发送到 Channel\",\"rabbit_channel：Channel 的处理进程，负责处理 AMQP 协议的各种方法、进行路由解析；进行安全和协调的处理等\",\"rabbit_amqqueue_process：Queue 的处理进程，负责将消息存入内存、将队列索引持久化\",\"rabbit_msg_store：Store 的处理进程，负责消息的持久化\",\"Credit based flow control with classic queues、\",\"Credit based flow control with classic queues、\",\"信用证初始化时，下游进程分别为前三个进程 reader、channel、queue 分配初始信用值InitialCredit(400)（图中1）\",\"当 reader 进程开始处理一条消息，它会先将自己的信用值-1，然后将消息处理完后发给 channel 进程（图中2）\",\"channel 进程接收 reader 发过来的消息时，会在信用证系统种进行 ack 操作。channel 进程会持续追踪它从 reader 进程 ack 了多少条消息。当累计接收并 ack 的消息数达到MoreCreditAfter(200) 后，会给 reader 分配新的MoreCreditAfter(200)信用值。（图中3）\",\"当进程字典中的信用值降为0时，该进程会被阻塞。它不会接收消息也不会发送消息，直到获得新的信用值。\",\"最终，TCP 读取进程被阻塞，从 socket 读取的操作被停止。\"]},\"622\":{\"h\":\"3.2 如何识别性能瓶颈\",\"t\":[\"在管理 UI 中，你可能看到 Connection、Channel、Queue 处于flow状态，说明它们最近处于流控状态。这意味着它们暂时耗尽了信用值，等待下游进程授予更多信用。进程内流控可能在1秒钟内触发多次。\",\"如何通过flow状态识别进程的性能瓶颈？\",\"简单来说，一个进程的flow状态会导致它的上游进程进入flow状态。而该进程进入flow状态的原因是因为它的下游进程成为了性能瓶颈。\",\"例如，在下图中，Queue 进程成为性能瓶颈：\",\"Credit exhaustion.\",\"Credit exhaustion.\",\"上图中，Queue 处理缓慢，这就意味着 Queue 可能在较长时间内都没有授予 Channel 新的信用值。Channel 处理比 Queue 快，这样 Channel 的信用值就会先一步耗尽。\",\"Channel 信用值耗尽后，Channel 被阻塞，不会接受消息也不会处理消息，这样 Reader 的信用值也将会耗尽。\",\"也就是说，Queue 如果是性能瓶颈，最终会导致它的上游，即 Channel 和 Reader 处于flow状态。\",\"下面可以总结出判断性能瓶颈在何处的结论：\",\"当某个 Connection 处于flow状态，但这个 Connection 中没有一个 Channel 处于flow状态时，这就意味这个 Connection 中有一个或者多个 Channel 出现了性能瓶颈。某些 Channel 进程的运作(比如处理路由逻辑)会使得服务器 CPU 的负载过高从而导致了此种情形。尤其是在发送大量较小的非持久化消息时，此种情形最易显现。\",\"当某个 Connection 处于flow状态 ，并且这个 Connection 中也有若干个 Channel 处于flow状态，但没有任何一个对应的队列处于flow状态时，这就意味着有一个或者多个队列出现了性能瓶颈。这可能是由于将消息存入队列的过程中引起服务器 CPU 负载过高，或者是将队列中的消息存入磁盘的过程中引起服务器 I/O 负载过高而引起的此种情形。尤其是在发送大量较小的持久化消息时，此种情形最易显现。\",\"当某个 Connection 处于flow状态，同时这个 Connection 中也有若干个 Channel 处于flow状态，井且也有若干个对应的队列处于flow状态时，这就意味着在消息持久化时出现了性能瓶颈。在将队列中的消息存入磁盘的过程中引起服务器 I/O 负载过高而引起的此种情形。尤其是在发送大量较大的持久化消息时，此种情形最易显现。\"]},\"623\":{\"h\":\"4. 源码解析\",\"t\":[\"在 Erlang 中，每个进程都保存为一个.erl文件。这里的进程与操作系统的进程不同，是一个由 Erlang 系统管理的轻量级进程。而信用证流控的逻辑都位于credit_flow.erl文件中。\",\"下面我们以rabbit_reader（Connection 进程）和rabbit_channel进程为例，看一下源码中如何处理信用的流动和消息的阻塞。\"]},\"624\":{\"h\":\"4.1 处理消息，减少信用\",\"t\":[\"当rabbit_reader处理一个有内容的命令（比如basic.publish)，会执行如下加粗逻辑\",\"% rabbit_reader.erl process_frame(Frame, Channel, State) -> ChKey = {channel, Channel}, case (case get(ChKey) of undefined -> create_channel(Channel, State); Other -> {ok, Other, State} end) of {error, Error} -> handle_exception(State, Channel, Error); {ok, {ChPid, AState}, State1} -> case rabbit_command_assembler:process(Frame, AState) of {ok, NewAState} -> put(ChKey, {ChPid, NewAState}), post_process_frame(Frame, ChPid, State1); {ok, Method, NewAState} -> rabbit_channel:do(ChPid, Method), put(ChKey, {ChPid, NewAState}), post_process_frame(Frame, ChPid, State1); **{ok, Method, Content, NewAState} -> rabbit_channel:do_flow(ChPid, Method, Content), put(ChKey, {ChPid, NewAState}), post_process_frame(Frame, ChPid, control_throttle(State1));** {error, Reason} -> handle_exception(State1, Channel, Reason) end end. \",\"可以看到会先执行rabbit_channel:doflow/3，再看一下这个方法\",\"% rabbit_channel_common.erl do_flow(Pid, Method, Content) -> %% Here we are tracking messages sent by the rabbit_reader %% process. We are accessing the rabbit_reader process dictionary. credit_flow:send(Pid), gen_server2:cast(Pid, {method, Method, Content, flow}). \",\"可以看到在rabbit_channel中会调用credit_flow:send/1方法。这里的Pid是 Channel 的进程号。\",\"这里的逻辑是：rabbit_reader通过credit_flow模块来追踪它已经向rabbit_channel进程发送的消息数，每发一条消息就会将自己的信用值减一。被追踪的信息保存在rabbit_reader的进程字典中。\",\"注意，尽管这里是在rabbit_channel模块中调用credit_flow:send/1方法，但是此处仍处于rabbit_reader进程中，只有在执行完gen_server2:cast/2方法后才会进入到rabbit_channel进程的内存空间。因此，当credit_flow:send/1方法被调用时，信用值减一的操作仍然在rabbit_reader进程中被追踪。\",\"见下面credit_flow:send/2和credit_flow:UPDATE的定义，通过调用get/1和put/2方法获取并更新进程字典的值。\",\"% credit_flow.erl send(From, {InitialCredit, _MoreCreditAfter}) -> ?UPDATE({credit_from, From}, InitialCredit, C, if C == 1 -> block(From), 0; true -> C - 1 end). \",\"% credit_flow.erl %% process dict update macro - eliminates the performance-hurting %% closure creation a HOF would introduce -define(UPDATE(Key, Default, Var, Expr), begin %% We deliberately allow Var to escape from the case here %% to be used in Expr. Any temporary var we introduced %% would also escape, and might conflict. Var = case get(Key) of undefined -> Default; V -> V end, put(Key, Expr) end). \",\"来看一下进程字典中关于信用证的信息\",\"Untitled\",\"用来保存信用值信息的 key 是{credit_from, From}，From表示消息接受者的进程号（这里是rabbit_channel）。当这个 key 对应的值达到 0，拥有该进程字典的进程会被阻塞（调用credit_flow:block/1）方法\"]},\"625\":{\"h\":\"4.2 进程阻塞，停止接收信息\",\"t\":[\"上面说到，当进程字典中的信用值达到 0 时，会调用credit_flow:block/1方法，我们来看看这个方法中做了什么。\",\"% credit_flow.erl block(From) -> ?TRACE_BLOCKED(self(), From), case blocked() of false -> put(credit_blocked_at, erlang:monotonic_time()); true -> ok end, ?UPDATE(credit_blocked, [], Blocks, [From | Blocks]). \",\"这里更新了进程字典中credit_blocked的值，将阻塞这个进程的下游进程ID（这里是rabbit_channel）加入到credit_blocked中。\",\"注意，因为rabbit_reader可能会将消息发送给多个进程，所以它也可能被多个进程阻塞。因此credit_blocked的值是一个进程ID列表。\",\"credit_blocked -> [pid()] \",\"那么进程阻塞之后，如何停止信息接收？我们来分析一下rabbit_reader接收消息的入口，recvloop方法。\",\"% rabbit_reader.erl recvloop(Deb, Buf, BufLen, State = #v1{pending_recv = true}) -> mainloop(Deb, Buf, BufLen, State); recvloop(Deb, Buf, BufLen, State = #v1{connection_state = blocked}) -> mainloop(Deb, Buf, BufLen, State); recvloop(Deb, Buf, BufLen, State = #v1{connection_state = {become, F}}) -> throw({become, F(Deb, Buf, BufLen, State)}); recvloop(Deb, Buf, BufLen, State = #v1{sock = Sock, recv_len = RecvLen}) when BufLen < RecvLen -> case rabbit_net:setopts(Sock, [{active, once}]) of ok -> mainloop(Deb, Buf, BufLen, State#v1{pending_recv = true}); {error, Reason} -> stop(Reason, State) end; \",\"其中mainloop会调用recvloop函数，达成无限循环的效果。\",\"rabbit_reader每接收一个包，就设置套接字属性为{active, once}，若当前连接处于blocked状态，则不设置{active, once}，这个接收进程就阻塞在receive方法上。\"]},\"626\":{\"h\":\"4.3 增加信用值\",\"t\":[\"rabbit_channel每处理一条消息，都会向rabbit_reader进行一次确认（credit_flow:ack）。\",\"当rabbit_channel累计处理的消息数达到MoreCreditAfter值时，会授予rabbit_reader新的MoreCreditAfter点信用值。\",\"我们先来看一下ack函数的实现\",\"% credit_flow.erl ack(To, {_InitialCredit, MoreCreditAfter}) -> ?UPDATE({credit_to, To}, MoreCreditAfter, C, if C == 1 -> grant(To, MoreCreditAfter), MoreCreditAfter; true -> C - 1 end). \",\"rabbit_channel进程会记录它向特定的发送者（rabbit_reader）ack了多少条消息。在进程字典中用来保存ack消息数的 key 是{credit_to, To}，这里To是发送者（rabbit_reader）的进程号。\",\"当MoreCreditAfter条消息被ack，会调用grant方法授予rabbit_reader更多的信用值。\",\"% credit_flow.erl grant(To, Quantity) -> Msg = {bump_credit, {self(), Quantity}}, case blocked() of false -> To ! Msg; true -> ?UPDATE(credit_deferred, [], Deferred, [{To, Msg} | Deferred]) end. \",\"在这里，rabbit_channel将会发送一条{bump_credit, {self(), Quantity}}的消息给rabbit_reader来授予信用。其中self()指向rabbit_channel。\",\"当rabbit_reader进程收到bump_credit消息后，它需要将消息传入并调用credit_flow:handle_bump_msg/1方法来处理新增信用值。\",\"% credit_flow.erl handle_bump_msg({From, MoreCredit}) -> ?UPDATE({credit_from, From}, 0, C, if C =< 0 andalso C + MoreCredit > 0 -> unblock(From), C + MoreCredit; true -> C + MoreCredit end). \",\"我们访问rabbit_reader的进程字典，更新{credit_from, From}这个 key。如果信用值大于0，那么进程会解除阻塞。\"]},\"627\":{\"h\":\"4.4 进程解除阻塞\",\"t\":[\"% credit_flow.erl unblock(From) -> ?TRACE_UNBLOCKED(self(), From), ?UPDATE(credit_blocked, [], Blocks, Blocks -- [From]), case blocked() of false -> case erase(credit_deferred) of undefined -> ok; Credits -> _ = [To ! Msg || {To, Msg} <- Credits], ok end; true -> ok end. \",\"调用credit_flow:unblock/1会更新credit_blocked列表，将其清空。随后进程可以继续发送消息。\",\"同时，credit_flow:unblock/1将负责发送在credit_deferred列表中保存的所有消息。\",\"当unblock/1被调用时，rabbit_channel进程的ID将从credit_blocked的列表中删除。\",\"%% We are operating on process A dictionary. get(credit_blocked) => [B, C]. unblock(B). get(credit_blocked) => [C]. \",\"在这种情况下，A 仍然被阻塞，直到 C 授予它更多信用。当 A 的阻塞解除，它将处理它的 credit_deferred列表，发送bump_credit消息给列表中的进程。\"]},\"628\":{\"h\":\"5. 参考资料\",\"t\":[\"Flow Control\",\"Finding bottlenecks with RabbitMQ 3.3\",\"New Credit Flow Settings on RabbitMQ 3.5.5\",\"RABBITMQ INTERNALS - CREDIT FLOW FOR ERLANG PROCESSES\",\"Quorum Queues and Flow Control - The Concepts\",\"RabbitMQ实战指南\",\"RabbitMQ流量控制机制分析\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"629\":{\"h\":\"RabbitMQ Federation 插件使用\",\"t\":[\"原文地址：http://hscarb.github.io/rabbitmq/20220313-rabbitmq-federation-plugin.html\"]},\"630\":{\"h\":\"概述\",\"t\":[\"RabbitMQ Federation 插件可以将消息从一个 Exchange 复制到另一个 Exchange，或从一个 Queue 分发到另一个 Queue。\",\"复制的源端被称为 upstream，复制的目的端被称为 downstream。要使用 Federation 插件，需要在两个集群都开启 Federation 插件，并且在 downstream 集群创建 Federation，配置 upstream。\"]},\"631\":{\"h\":\"使用场景\",\"t\":[\"将多个集群的消息收集到一个集群\",\"将一个队列的压力分散到多个集群\",\"在不下线的情况下将数据从一个集群同步到另一个集群\",\"减少消息消费的时延\"]},\"632\":{\"h\":\"Federation 种类\",\"t\":[\"可以创建两种类型的 Federation，分别是 Exchange Federation 和 Queue Federation。\"]},\"633\":{\"h\":\"Exchange Federation\",\"t\":[\"简单说，它可以实现消息在 Exchange 间的复制（同步）。\",\"使用 Exchange Federation 可以将消息发到其他集群。效果是，当消息发送到被联邦的 Exchange 时，消息会被发送到本地的 Exchange 和 下游的集群。这样，你就可以在不同的集群多次消费消息。\"]},\"634\":{\"h\":\"Queue Federation\",\"t\":[\"Queue Federation 的效果是消息的负载均衡，它只会将消息发往有空闲消费者的下游集群。也就是说，消息不会被复制。\",\"常被用于分散压力和集群消息转移。\"]},\"635\":{\"h\":\"使用前提\",\"t\":[\"两个 RabbitMQ 服务器或集群\",\"在两个 RabbitMQ 上开启 Federation 插件\",\"（可选）为 Federation 的组件单独创建用户\",\"上下游 RabbitMQ 网络可以通过 AMQP 协议连接\"]},\"636\":{\"h\":\"Federation Exchange 使用\",\"t\":[\"满足使用前提\",\"在下游节点配置 Federation 的 upstream\",\"在下游节点配置 Policy，指定要被 Federate 的 Exchange 或 Queue\"]},\"637\":{\"h\":\"upstream 上游集群配置\",\"t\":[\"创建 Exchange\",\"1. 创建 Exchange\",\"创建 Queue\",\"2. 创建 Queue\",\"绑定 Exchange 和 Queue\",\"3. 绑定 Exchange 和 Queue\"]},\"638\":{\"h\":\"downstream 下游集群配置\",\"t\":[\"配置 upstream\",\"1. 配置 upstream\",\"创建 Federation policy\",\"2. 创建 Federation 的 policy\",\"检查 Federation 状态\",\"3. 检查 Federation 状态\"]},\"639\":{\"h\":\"测试\",\"t\":[\"在上游集群向 Exchange 发送消息\",\"在上游集群向 Exchange 发送消息\",\"在上下游集群的队列都可以收到消息\",\"在上下游集群的队列都可以收到消息\"]},\"640\":{\"h\":\"参考资料\",\"t\":[\"Federation Plugin\",\"FAQ: What is the RabbitMQ Federation plugin\",\"Setup RabbitMQ Exchange Federation\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"641\":{\"h\":\"RabbitMQ 3.7.x 版本 安装\",\"t\":[\"原文地址：http://hscarb.github.io/rabbitmq/20220408-rabbitmq-3.7-install.html\",\"本文讲解 Ubuntu 下 RabbitMQ 3.7 版本的安装。\"]},\"642\":{\"h\":\"1. Erlang 22.x 安装\",\"t\":[\"RabbitMQ 3.7 版本依赖 Erlang 21.3 ~ 22.x 版本。\",\"https://www.rabbitmq.com/which-erlang.html#eol-series\",\"首先需要安装 Erlang。\",\"最简单的 Erlang 安装方法是用 Erlang-Solution 提供的安装包。\",\"https://www.erlang-solutions.com/downloads/\"]},\"643\":{\"h\":\"1.1 .deb 安装包安装\",\"t\":[\"进入上述网页，选择 Erlang OTP\",\"在此处选择对应版本的 Erlang 安装包下载，并传到 Ubuntu 服务器目录。\",\"随后执行\",\"dpkg -i esl-erlang_22.3.4.9-1_ubuntu_focal_amd64.deb \",\"第一次执行会报如下错误\",\"Selecting previously unselected package esl-erlang. (Reading database ... 148404 files and directories currently installed.) Preparing to unpack esl-erlang_22.3.4.9-1_ubuntu_focal_amd64.deb ... Unpacking esl-erlang (1:22.3.4.9-1) ... dpkg: dependency problems prevent configuration of esl-erlang: esl-erlang depends on libncurses5; however: Package libncurses5 is not installed. esl-erlang depends on libwxbase2.8-0 | libwxbase3.0-0 | libwxbase3.0-0v5; however: Package libwxbase2.8-0 is not installed. Package libwxbase3.0-0 is not installed. Package libwxbase3.0-0v5 is not installed. esl-erlang depends on libwxgtk2.8-0 | libwxgtk3.0-0 | libwxgtk3.0-0v5 | libwxgtk3.0-gtk3-0v5; however: Package libwxgtk2.8-0 is not installed. Package libwxgtk3.0-0 is not installed. Package libwxgtk3.0-0v5 is not installed. Package libwxgtk3.0-gtk3-0v5 is not installed. esl-erlang depends on libsctp1; however: Package libsctp1 is not installed. dpkg: error processing package esl-erlang (--install): dependency problems - leaving unconfigured Errors were encountered while processing: esl-erlang \",\"这是因为缺少一些依赖包，执行如下命令安装。\",\"# sudo apt-get install -f Reading package lists... Done Building dependency tree Reading state information... Done Correcting dependencies... Done The following additional packages will be installed: libncurses5 libsctp1 libtinfo5 libwxbase3.0-0v5 libwxgtk3.0-gtk3-0v5 Suggested packages: lksctp-tools The following NEW packages will be installed: libncurses5 libsctp1 libtinfo5 libwxbase3.0-0v5 libwxgtk3.0-gtk3-0v5 0 upgraded, 5 newly installed, 0 to remove and 105 not upgraded. 1 not fully installed or removed. Need to get 5,521 kB/5,529 kB of archives. After this operation, 22.2 MB of additional disk space will be used. Do you want to continue? [Y/n] Y \",\"选择 Y 后，系统会自动安装依赖包。\",\"随后再执行\",\"dpkg -i esl-erlang_22.3.4.9-1_ubuntu_focal_amd64.deb \",\"安装 Erlang\"]},\"644\":{\"h\":\"1.2 apt 安装\",\"t\":[\"或者可以根据 Erlang-Solution 提供的 Installation using repository 指引进行安装。\",\"这里如果是 Ubuntu 20 版本，需要在 /etc/apt/sources.list 中添加\",\"deb https://packages.erlang-solutions.com/ubuntu focal contrib \",\"其中 focal 这些是 Ubuntu 的版本代号。\",\"随后更新 apt 缓存，安装 Erlang。注意此时需要指定安装 Erlang 的版本\",\"sudo apt-get update sudo apt-get install erlang=1:22.3.4.9-1 \"]},\"645\":{\"h\":\"2. 安装 RabbitMQ\",\"t\":[\"去 Github 发布页面下载对应的 RabbitMQ 版本的 .deb 安装包\",\"全部安装包列表\",\"https://github.com/rabbitmq/rabbitmq-server/tags\",\"3.7.27 版本\",\"https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.27\",\"下载后复制到服务器上安装\",\"# dpkg -i rabbitmq-server_3.7.27-1_all.deb (Reading database ... 153046 files and directories currently installed.) Preparing to unpack .../rabbitmq-server_3.7.27-1_all.deb ... Unpacking rabbitmq-server (3.7.27-1) over (3.7.27-1) ... dpkg: dependency problems prevent configuration of rabbitmq-server: rabbitmq-server depends on socat; however: Package socat is not installed. \",\"提示缺少 socat 这个包，于是手动安装\",\"apt-get install socat \",\"随后再次执行\",\"dpkg -i rabbitmq-server_3.7.27-1_all.deb \",\"RabbitMQ 被正确安装，运行\",\"rabbitmqctl cluster_status rabbitmqctl status \",\"查看当前节点状态\"]},\"646\":{\"h\":\"3. RabbitMQ 卸载\",\"t\":[\"https://stackoverflow.com/questions/39664283/how-to-remove-rabbitmq-so-i-can-reinstall\",\"sudo apt-get remove --auto-remove rabbitmq-server sudo apt-get purge --auto-remove rabbitmq-server \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"647\":{\"h\":\"RabbitMQ 镜像队列 使用和原理详解\",\"t\":[\"原文地址：http://hscarb.github.io/rabbitmq/20220409-rabbitmq-mirror-queue.html\"]},\"648\":{\"h\":\"1. 背景\",\"t\":[\"单节点的 RabbitMQ 存在性能上限，可以通过垂直或者水平扩容的方式增加 RabbitMQ 的吞吐量。垂直扩容指的是提高 CPU 和内存的规格；水平扩容指部署 RabbitMQ 集群。\",\"通过将单个节点的队列相对平均地分配到集群的不同节点，单节点的压力被分散，RabbitMQ 可以充分利用多个节点的计算和存储资源，以提升消息的吞吐量。\",\"但是多节点的集群并不意味着有更好的可靠性——每个队列仍只存在于一个节点，当这个节点故障，这个节点上的所有队列都不再可用。\",\"在 3.8 以前的版本，RabbitMQ 通过镜像队列（Classic Queue Mirroring）来提供高可用性。但镜像队列存在很大的局限性，在 3.8 之后的版本 RabbitMQ 推出了 Quorum queues 来替代镜像队列，在之后的版本中镜像队列将被移除。\",\"镜像队列通过将一个队列镜像（消息广播）到其他节点的方式来提升消息的高可用性。当主节点宕机，从节点会提升为主节点继续向外提供服务。\",\"本文将讲解镜像队列的使用方法和原理。\"]},\"649\":{\"h\":\"2. 镜像队列概述\",\"t\":[\"RabbitMQ 以队列维度提供高可用的解决方案——镜像队列。\",\"配置镜像队列规则后，新创建的队列按照规则成为镜像队列。每个镜像队列都包含一个主节点（Leader）和若干个从节点（Follower），其中只有主节点向外提供服务（生产消息和消费消息），从节点仅仅接收主节点发送的消息。\",\"从节点会准确地按照主节点执行命令的顺序执行动作，所以从节点的状态与主节点应是一致的。\"]},\"650\":{\"h\":\"3. 使用方法和注意事项\"},\"651\":{\"h\":\"3.1 配置方法\"},\"652\":{\"h\":\"3.1.1 管理界面配置\",\"t\":[\"使用策略（Policy）来配置镜像策略，策略使用正则表达式来配置需要应用镜像策略的队列名称，以及在参数中配置镜像队列的具体参数。\",\"按此步骤创建镜像策略，该策略为所有 mirror_ 开头的队列创建 3 副本镜像\",\"创建完的策略如下图显示\",\"参数解释：\",\"Name: policy的名称，用户自定义。\",\"Pattern: queue的匹配模式（正则表达式）。^表示所有队列都是镜像队列。\",\"Definition: 镜像定义，包括三个部分ha-sync-mode、ha-mode、ha-params。\",\"ha-mode: 指明镜像队列的模式，有效取值范围为all/exactly/nodes。 \",\"all：表示在集群所有的代理上进行镜像。\",\"exactly：表示在指定个数的代理上进行镜像，代理的个数由ha-params指定。\",\"nodes：表示在指定的代理上进行镜像，代理名称通过ha-params指定。\",\"ha-params: ha-mode模式需要用到的参数。\",\"ha-sync-mode: 表示镜像队列中消息的同步方式，有效取值范围为：automatic，manually。 \",\"automatic：表示自动向master同步数据。\",\"manually：表示手动向master同步数据。\",\"Priority: 可选参数， policy的优先级。\"]},\"653\":{\"h\":\"3.1.2 命令行\",\"t\":[\"rabbitmqctl set_policy [-p vhost] [--priority priority] [--apply-to apply-to] name pattern definition\",\"例如，对队列名称以“queue_”开头的所有队列进行镜像，并在集群的两个节点上完成进行，policy的设置命令为：\",\"rabbitmqctl set_policy --priority 0 --apply-to queues mirror_queue \\\"^mirror_\\\" '{\\\"ha-mode\\\":\\\"exactly\\\",\\\"ha-params\\\":3,\\\"ha-sync-mode\\\":\\\"automatic\\\"}' \"]},\"654\":{\"h\":\"3.1.3 HTTP API\",\"t\":[\"https://www.rabbitmq.com/ha.html#examples\",\"PUT /api/policies/%2f/ha-two { \\\"pattern\\\":\\\"^mirror_\\\", \\\"definition\\\": { \\\"ha-mode\\\":\\\"exactly\\\", \\\"ha-params\\\":3, \\\"ha-sync-mode\\\":\\\"automatic\\\" } } \"]},\"655\":{\"h\":\"3.2 镜像队列配置观测\",\"t\":[\"配置完 Policy 后，创建新的队列，或者原有的的队列，如果队列名称符合 Policy 的匹配规则，则该队列会自动创建为镜像队列。\",\"下图中 mirror_queue 匹配之前创建的镜像策略，为镜像队列。normal_queue 为普通队列\",\"镜像队列显示的蓝色 +2 表示同步副本数为 2 个。此处如果用红色显示，则表示为同步副本数\",\"显示的 mirror-policy 为该队列应用的镜像策略。\",\"点击队列名称可以进入查看队列详细信息，从中可以看出队列的主节点、从节点和镜像策略\"]},\"656\":{\"h\":\"3.3 配置参数\",\"t\":[\"镜像队列有许多配置参数，表达了镜像队列的镜像策略和异常后的晋升策略。\",\"下面来详细解释一下这些配置参数的意义\"]},\"657\":{\"h\":\"3.3.1 镜像策略\",\"t\":[\"ha-mode\",\"ha-params\",\"结果\",\"exactly\",\"count\",\"集群中队列副本的数量（主队列加上镜像）。count值为1表示一个副本：只有主节点。如果主节点不可用，则其行为取决于队列是否持久化。count值为2表示两个副本：一个队列主队列和一个队列镜像。换句话说:“镜像数=节点数-1”。如果运行队列主服务器的节点变得不可用，队列镜像将根据配置的镜像提升策略自动提升到主服务器。如果集群中的可用节点数少于count，则将队列镜像到所有节点。如果集群中有多个计数节点，并且一个包含镜像的节点宕机，那么将在另一个节点上创建一个新镜像。使用' exactly '模式和' ha-promot-on-shutdown ': ' always '可能是危险的，因为队列可以跨集群迁移，并在停机时变得不同步。\",\"all\",\"不设置\",\"队列跨集群中的所有节点镜像。当一个新节点被添加到集群中时，队列将被镜像到该节点。这个设置非常保守。建议设置的副本值为大多数节点N / 2 + 1。镜像到所有节点会给所有集群节点带来额外的负担，包括网络I/O、磁盘I/O和磁盘空间的使用。\",\"nodes\",\"节点名称\",\"队列被镜像到节点名中列出的节点。节点名是在rabbitmqctl cluster_status中出现的Erlang节点名；它们的形式通常是“rabbit@hostname”。如果这些节点名中有任何一个不是集群的一部分，则不构成错误。如果在声明队列时列表中的节点都不在线，则将在声明客户机连接的节点上创建队列。\"]},\"658\":{\"h\":\"3.3.2 新镜像同步策略\",\"t\":[\"ha-sync-mode\",\"说明\",\"manual\",\"这是默认模式。新队列镜像将不接收现有消息，它只接收新消息。一旦使用者耗尽了仅存在于主服务器上的消息，新的队列镜像将随着时间的推移成为主服务器的精确副本。如果主队列在所有未同步的消息耗尽之前失败，则这些消息将丢失。您可以手动完全同步队列，详情请参阅未同步的镜像部分。\",\"automatic\",\"当新镜像加入时，队列将自动同步。值得重申的是，队列同步是一个阻塞操作。如果队列很小，或者您在RabbitMQ节点和ha-sync-batch-size之间有一个快速的网络，那么这是一个很好的选择。\"]},\"659\":{\"h\":\"3.3.3 从节点晋升策略\",\"t\":[\"镜像队列主节点出现故障时，最老的从节点会被提升为新的主节点。如果新提升为主节点的这个副本与原有的主节点并未完成数据的同步，那么就会出现数据的丢失，而实际应用中，出现数据丢失可能会导致出现严重后果。\",\"rabbitmq 提供了 ha-promote-on-shutdown，ha-promote-on-failure 两个参数让用户决策是保证队列的可用性，还是保证队列的一致性；两个参数分别控制正常关闭、异常故障情况下从节点是否提升为主节点，其可设置的值为 when-synced 和 always。\",\"ha-promote-on-shutdown/ha-promote-on-failure\",\"说明\",\"when-synced\",\"从节点与主节点完成数据同步，才会被提升为主节点\",\"always\",\"无论什么情况下从节点都将被提升为主节点\",\"这里要注意的是ha-promote-on-failure设置为always，插拔网线模拟网络异常的两个测试场景：当网络恢复后，其中一个会重新变为mirror，具体是哪个变为mirror，受cluster_partition_handling处理策略的影响。\",\"例如两台节点A，B组成集群，并且cluster_partition_handling设置为autoheal，队列的master位于节点A上，具有全量数据，mirror位于节点B上，并且还未完成消息的同步，此时出现网络异常，网络异常后两个节点交互决策：如果节点A节点成为赢家，此时B节点内部会重启，这样数据全部保留不会丢失；相反如果B节点成为赢家，A需要重启，那么由于ha-prromote-on-failure设置为always，B节点上的mirror提升为master，这样就出现了数据丢失。\"]},\"660\":{\"h\":\"3.3.4 主队列选择策略\",\"t\":[\"RabbitMQ中的每个队列都有一个主队列。该节点称为队列主服务器。所有队列操作首先经过主队列，然后复制到镜像。这对于保证消息的FIFO排序是必要的。\",\"通过在策略中设置 queue-master-locator 键的方法可以定义主队列选择策略，这是常用的方法。\",\"此外，也可以用队列参数 x-queue-master-locator 或配置文件中定义 queue_master_locator 的方式指定，此处不再赘述。\",\"下面是该策略的可选参数列表\",\"queue-master-locator\",\"说明\",\"min-masters\",\"选择承载最小绑定主机数量的节点\",\"client-local\",\"选择客户机声明队列连接到的节点\",\"min-masters\",\"随机选择一个节点\"]},\"661\":{\"h\":\"3.4 注意事项\"},\"662\":{\"h\":\"3.4.1 多少个镜像才是最优的\",\"t\":[\"镜像到所有节点会增加所有集群节点的负载，包括网络 I/O、磁盘 I/O 和磁盘空间的使用。\",\"在大多数情况下，在每个节点上都有一个副本是不必要的。对于3个或更多节点的集群，建议复制到（N/2+1）个节点，例如 3 个节点集群中的 2 个节点或 5 个节点集群中的 3 个节点。\",\"由于某些数据可能天生是短暂的或对时间非常敏感，因此对某些队列使用较少的镜像（甚至不使用任何镜像）是完全合理的。\"]},\"663\":{\"h\":\"3.4.2 生产者确认和事务\",\"t\":[\"镜像队列同时支持生产者确认和事务机制。在事务机制中，只有当前事务在全部镜像中执行之后，客户端才会收到 Tx.Commit-OK 的消息。\",\"同样的，在生产者确认机制中，生产者进行当前消息确认的前提是该消息被全部镜像接收。\"]},\"664\":{\"h\":\"3.4.3 流控\",\"t\":[\"RabbitMQ 使用信用证机制限制消息生产的速度。当生产者收到队列的所有镜像授予的信用时，才允许发送新的消息。（这里的信用指的时发送许可。）如果有镜像没有授予生产者信用，会导致生产者生产阻塞。生产者会一直被阻塞，直到所有镜像都授予它信用值，或者有的镜像从集群中断开。\",\"Erlang 通过定时向所有节点发送心跳的方式检测断开的情况。发送心跳的间隔可以用 net_ticktime 来控制。\"]},\"665\":{\"h\":\"3.4.4 主节点失效和消费者取消\",\"t\":[\"从镜像队列中消费的客户端可能希望知道他们所消费的队列已经失败转移。当镜像队列发生故障时，哪些消息被发送到哪个消费者的信息就丢失了，因此所有未被确认的消息都会被重新发送，并设置了 redelivered 的标志。消费者可能希望知道这将会发生。\",\"如果是这样，他们可以使用参数 x-cancel-on-ha-failover 设置为 true。然后，它们的消费将在故障转移时被取消，并发送消费者取消通知。然后消费者就有责任重新发行基本版。消费来重新开始消费。\",\"Channel channel = ...; Consumer consumer = ...; Map<String, Object> args = new HashMap<String, Object>(); args.put(\\\"x-cancel-on-ha-failover\\\", true); channel.basicConsume(\\\"my-queue\\\", false, args, consumer); \",\"这将使用参数集创建一个新的消费者。\"]},\"666\":{\"h\":\"4. 镜像队列原理\"},\"667\":{\"h\":\"4.1 镜像队列的数据流\"},\"668\":{\"h\":\"4.1.1 客户端连接主节点\",\"t\":[\"首先看生产者消费者直接与主节点连接的情况。该情况下队列的主副本所在的节点与生产者/消费者直接连接，效率较高。\",\"生产者，消费者连接到 RabbitMQ 后，在 RabbitMQ 内部会创建对应的 Connection，Channel 进程。\",\"Connecton 进程从 socket 上接收生产者发送的消息后投递到 Channel 进程。\",\"在 Channel 进程中，根据消息发送的 exchange 与消息的 routing-key，在内部数据库的路由表中，查找所有匹配的 Queue 的进程 PID，然后将消息投递到Queue 的进程中。在镜像队列的情况下，Channel 进程除了将消息发送给队列的 Leader 进程外，还会将消息发送给队列所有的 Follower 进程，而 Follower 进程都在远端节点上，因此这里就多了一次集群间的网络交互。\",\"镜像队列的 Leader 进程收到消息后，需要将消息同步给所有的 Follower 进程。RabbitMQ 采用 GM（组播）算法实现，镜像队列中的 Leader 和所有 Follower 都会发送一次消息和接收一次消息，同时还会发送一次对消息的 ACK，和接收一次消息的 ACK。\",\"综上所述，生产者发送一条消息，队列 Leader 进程所在节点会收到两次：一次是生产者发送的，一次是队列 Follower 进程发送的；同样也会将消息对外发送两次：一次是生产者对应的 Channel 进程将消息发送给队列的 Follower 进程；一次是队列的 Leader 进程进行广播同步将消息发送给 Follower 进程。此外，镜像队列的GM算法实现 ，每条消息还会有额外的确认消息在集群间进行发送。\",\"再结合图中的情况，一条消息从生产者到消费，Node1节点是2进3出的流量，Node2节点是2进1出的流量。\"]},\"669\":{\"h\":\"4.1.2 客户端连接从节点\",\"t\":[\"如果生产者和消费者连接的是从节点，根据镜像队列的机制，只有主节点向外提供服务，所以镜像队列的消费需要由 node2 的队列消费消息。\",\"一条消息从生产到消费，生产者消费者连接的节点是3进3出，队列master进程所在的节点是2进2出。\"]},\"670\":{\"h\":\"4.2 镜像队列的实现原理\"},\"671\":{\"h\":\"4.2.1 普通队列结构\",\"t\":[\"通常队列由两部分组成\",\"amqqueue_process ，负责协议相关的消息处理，即接收生产者发布的消息、向消费者投递消息、处理消息 confirm、acknowledge 等等\",\"backing_queue，它提供了相关的接口供 amqqueue_process 调用，完成消息的存储以及可能的持久化工作等。\"]},\"672\":{\"h\":\"4.2.2 镜像队列结构\",\"t\":[\"镜像队列同样由这两部分组成，amqqueue_process 仍旧进行协议相关的消息处理，backing_queue 则是由 Leader 节点和 Follower 节点组成的一个特殊的 backing_queue。Leader 节点和 Follower 节点都由一组进程组成，一个负责消息广播的 GM，一个负责对 GM 收到的广播消息进行回调处理。\",\"在 Leader 节点上回调处理是 coordinator，在 Follower 节点上则是 mirror_queue_slave。mirror_queue_slave 中包含了普通的 backing_queue 进行消息的存储，Leader 节点中 backing_queue 包含在 mirror_queue_master 中由 amqqueue_process 进行调用。\"]},\"673\":{\"h\":\"4.2.3 GM(Guaranteed Multicast)\",\"t\":[\"GM 模块实现的是一种可靠的组播通信协议，该协议能够保证组播消息的原子性，即保证组中活着的节点要么都收到消息要么都收不到。\",\"它的实现大致为：将所有的节点形成一个循环链表，每个节点都会监控位于自己左右两边的节点，当有节点新增时，相邻的节点保证当前广播的消息会复制到新的节点上 : 当有节点失效时，相邻的节点会接管以保证本次广播的消息会复制到所有的节点。在 Leader 和 Follower 上的这些 GM 形成一个组 (gm_group) ，这个组的信息会记录在 Mnesia 中。不同的镜像队列形成不同的组。操作命令从 Leader 对应的 GM 发出后，顺着链表传送到所有的节点。由于所有节点组成了一个循环链表， Leader 对应的 GM 最终会收到自己发送的操作命令，这个时候 Leader 就知道该操作命令都同步到了所有的 Follower 上。\"]},\"674\":{\"h\":\"4.2.4 消息的广播\",\"t\":[\"消息从 Leader 节点发出，顺着节点链表发送。在这期间，所有的 Follower 节点都会对消息进行缓存，当 Leader 节点收到自己发送的消息后，会再次广播 ack 消息，同样 ack 消息会顺着节点链表经过所有的 Follower 节点，其作用是通知 Follower 节点可以清除缓存的消息，当 ack 消息回到 Leader 节点时对应广播消息的生命周期结束。\",\"下图为一个简单的示意图，A 节点为 Leader 节点，广播一条内容为 test 的消息。1 表示消息为广播的第一条消息；id=A表示消息的发送者为节点 A。右边是Follower 节点记录的状态信息。\",\"为什么所有的节点都需要缓存一份发布的消息呢？\",\"master发布的消息是依次经过所有slave节点，在这期间的任何时刻，有可能有节点失效，那么相邻的节点可能需要重新发送给新的节点。例如，A->B->C->D->A形成的循环链表，A为master节点，广播消息发送给节点B，B再发送给C，如果节点C收到B发送的消息还未发送给D时异常结束了，那么节点B感知后节点C失效后需要重新将消息发送给D。同样，如果B节点将消息发送给C后，B,C节点中新增了E节点，那么B节点需要再将消息发送给新增的E节点。\"]},\"675\":{\"h\":\"5. 镜像队列实践\",\"t\":[\"在 RabbitMQ 3.8 中发布了新的 Quorum Queues，旨在完全代替原有的镜像队列。\",\"在许多情况下，仲裁队列将是比传统队列镜像更好的选择。鼓励读者熟悉仲裁队列，并考虑它们而不是经典的镜像队列\"]},\"676\":{\"h\":\"5.1 镜像队列的缺点\",\"t\":[\"镜像队列最大的问题是其同步算法造成的低性能。镜像队列有如下几个设计缺陷\"]},\"677\":{\"h\":\"5.1.1 设计缺陷 1：broker 离线后重新上线\",\"t\":[\"基本的问题是，当 broker 离线并再次恢复时，它在镜像中的任何数据都将被丢弃。这是关键的设计缺陷。现在，镜像已恢复在线，但为空，管理员需要做出决定:是否同步镜像。“同步”意味着将当前消息从 leader 复制到镜像。\"]},\"678\":{\"h\":\"5.1.2 设计缺陷 2：同步阻塞\",\"t\":[\"此时第二个致命的设计缺陷显露了出来。如果要同步消息，会阻塞整个队列，让这个队列不可用。当队列比较短的时候这通常不是什么问题，但当队列很长或者消息总大小很大的时候，同步将会需要很长时间。不仅如此，同步会导致集群中与内存相关的问题，有时甚至会导致同步卡住，需要重新启动。\",\"默认情况下，所有镜像队列都会自动同步，但也有人用户不同步镜像。这样，所有新消息都将被复制，老消息都不会被复制，这将减少冗余，会使消息丢失的概率加大。\",\"这个问题也引发滚动升级的问题，因为重新启动的 broker 将丢弃其所有数据，并需要同步来恢复全部数据冗余。\"]},\"679\":{\"h\":\"参考资料\",\"t\":[\"RabbitMQ Doc - Classic Queue Mirroring\",\"RabbitMQ——镜像队列的数据流\",\"rabbitmq——镜像队列\",\"RabbitMQ——镜像队列Master故障后的处理\",\"RabbitMQ Mirrored Queues Gotchas\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"680\":{\"h\":\"RabbitMQ 存储机制\",\"t\":[\"原文地址：http://hscarb.github.io/rabbitmq/20220610-rabbitmq-store.html\"]},\"681\":{\"h\":\"1. 背景\",\"t\":[\"RabbitMQ 的存储设计与 Kafka、RocketMQ 等消息队列有较大的不同。RabbitMQ 在设计上更倾向于消息被及时消费，或者是存储在内存中以达到更高的生产和消费效率，而不是直接存储在磁盘中。\",\"当然，RabbitMQ 也支持通过配置队列和消息都持久化的方式，让消息必须保存在磁盘中，这样消息才会在重启之后仍然存在。但是，即使是保存到磁盘的消息，在内存中也会保留一份备份，以便将消息更快地发给消费者。这样就带来了较大且不稳定的内存消耗。如果希望消息直接被保存到磁盘中，可以设置队列为种惰性队列。\",\"RabbitMQ 的消息以队列维度存储，会随着系统的负载而在几种不同的存储状态中不断地流动。大致会经过从内存到磁盘再到内存的流程。\",\"本文将介绍 RabbitMQ 消息的存储机制。\"]},\"682\":{\"h\":\"2. 概述\"},\"683\":{\"h\":\"2.1 持久化\",\"t\":[\"持久化指的是数据保存在磁盘中，以防止异常关机、重启等情况下的数据丢失。 与存储相关的持久化包括队列的持久化和消息的持久化。\"]},\"684\":{\"h\":\"2.1.1 队列持久化\",\"t\":[\"通过将队列的 durable 属性设置为 true 的方式可以将队列设置为持久化。\",\"队列持久化仅仅指的是队列元数据持久化，即重启之后该队列还会存在，但队列中的消息会消失。\",\"如果队列为非持久化，则重启之后队列也会消失。\"]},\"685\":{\"h\":\"2.1.2 消息的持久化\",\"t\":[\"通过发送时设置消息的 BasicProperties#deliveryMode 的方式可以将消息设置为持久化的。\",\"只有将消息和队列都设置为持久化之后，消息才会在重启之后仍然存在。\"]},\"686\":{\"h\":\"2.2 存储机制\"},\"687\":{\"h\":\"2.2.1 存储结构\",\"t\":[\"RabbitMQ 的存储可以被分为两个部分：队列索引和消息存储。\",\"队列索引（rabbit_queue_index）：每个队列单独存储。负责维护队列中落盘消息的信息，包括消息的存储地点、是否已被交付给消费者、是否已被消费者 ack 等。\",\"消息存储（rabbit_msg_store）：每个 Broker 只有一个，所有队列共同使用。以键值对的形式存储消息。RabbitMQ 将持久化和非持久化的消息在磁盘中区分存储。 \",\"非持久化消息存储（msg_store_transient）：重启后清空\",\"持久化消息存储（msg_store_persistent）：重启后不会清空\",\"在消费消息时，会先查询队列索引，查询到消息在存储中的位置，然后再从消息存储中查询具体的消息。这样就会经历 2 次查询。为了优化消费性能，RabbitMQ 会将较小的消息体直接全量保存到队列索引，而不保存到消息存储中。较大的消息会保存在消息存储中，在队列索引中建立消息索引。这样在消费较小的消息时只需要查询 1 次。\",\"可以通过配置 queue_index_embed_msgs_below 的方式来指定消息整体大小小于某个值时会只保存到队列索引中。该值默认为 4096（byte）。\"]},\"688\":{\"h\":\"2.2.2 合并机制\",\"t\":[\"消息被消费后会被删除。删除消息时并不会直接删除消息所在的文件，而是先标记该消息为垃圾数据。当一个文件中都是垃圾数据是可以将这个文件删除。当检测到前后两个文件中的有效数据可以合并成一个文件，并且（垃圾数据大小/所有文件数据大小）的值超过 garbage_fraction（默认 0.5）时会触发垃圾回收，将这两个文件合并。这两个文件一定是逻辑上相邻的两个文件。\"]},\"689\":{\"h\":\"2.3 队列结构\",\"t\":[\"在RabbitMQ中，队列 主要由两部分组成 \",\"AMQPQueue：实现AMQP协议的逻辑功能，包括接收消息，投递消息，Confirm消息等；\",\"BackingQueue：提供AMQQueue调用的接口，完成消息的存储和持久化工作\"]},\"690\":{\"h\":\"RabbitMQ中队列的存储状态\",\"t\":[\"BackingQueue由Q1,Q2,Delta,Q3,Q4五个子队列构成，在BackingQueue中，消息的生命周期有4个状态：\",\"queue\",\"state\\\\store\",\"message itself\",\"message index(message position)\",\"q1,q4\",\"alpha\",\"RAM\",\"RAM\",\"q2,q3\",\"beta\",\"DISK\",\"RAM\",\"q2,q3\",\"gamma\",\"DISK\",\"RAM&DISK\",\"delta\",\"delta\",\"DISK\",\"DISK\",\"alpha: 消息的内容和消息索引都在RAM中。（Q1，Q4）\",\"beta: 消息的内容保存在Disk上，消息索引保存在RAM中。（Q2，Q3）\",\"gamma: 消息的内容保存在Disk上，消息索引在DISK和RAM上都有。（Q2，Q3）\",\"delta: 消息内容和索引都在Disk上。(Delta）\",\"5个内部队列\",\"q1和q4队列中只有alpha状态的消息；\",\"q2和q3包含beta和gamma状态的消息；\",\"delta队列是消息按序存盘后的一种逻辑队列，只有delta状态的消息。所以delta队列并不在内存中，其他4个队列则是由erlang queue模块实现。\",\"这里以持久化消息为例（可以看到非持久化消息的生命周期会简单很多），从Q1到Q4，消息实际经历了一个RAM->DISK->RAM这样的过程， BackingQueue的设计有点类似于Linux的虚拟内存Swap区，\",\"当队列负载很高时，通过将部分消息放到磁盘上来·节省内存空间`，\",\"当负载降低时，消息又从磁盘回到内存中，让整个队列有很好的弹性。 因此触发消息流动的主要因素是：\",\"消息被消费；\",\"内存不足。\",\"RabbitMQ会根据消息的传输速度来计算当前内存中允许保存的最大消息数量（Traget_RAM_Count），\",\"当内存中保存的消息数量 + 等待ACK的消息数量 > Target_RAM_Count时，RabbitMQ才会把消息写到磁盘上，\",\"所以说虽然理论上消息会按照Q1->Q2->Delta->Q3->Q4的顺序流动，但是并不是每条消息都会经历所有的子队列以及对应的生命周期。\",\"从RabbitMQ的Backing Queue结构来看，当内存不足时，消息要经历多个生命周期，在Disk和RAM之间置换，这实际会降低RabbitMQ的处理性能（后续的流控就是关联的解决方法）。\",\"对于持久化消息，RabbitMQ先将消息的内容和索引保存在磁盘中，然后才处于上面的某种状态（即只可能处于alpha、gamma、delta三种状态之一）。\",\"the term gamma seldom appears.\"]},\"691\":{\"h\":\"参考资料\",\"t\":[\"【RabbitMQ学习记录】- 消息队列存储机制源码分析\",\"RabbitMQ数据读写过程\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"692\":{\"h\":\"RabbitMQ 3.8 特性聚焦：仲裁队列（Quorum Queues）\",\"t\":[\"原文地址：http://hscarb.github.io/rabbitmq/20220714-rabbitmq-quorum-queues-feature-focus.html\",\"翻译自：https://www.cloudamqp.com/blog/rabbitmq-quorum-queues.html，写于 2019-03-28\",\"RabbitMQ 3.8 版本中最重要的改动那非仲裁队列（Quorum Queues）莫属。它提供队列复制的能力，保障数据的高可用和安全性。使用仲裁队列可以在 RabbitMQ 节点间进行队列数据的复制，从而达到在一个节点宕机时，队列仍然可以提供服务的效果。\",\"其实 RabbitMQ 已经有一个队列复制的实现，那就是镜像队列（Mirror Queues）。在 RabbitMQ 3.8 版本问世之前，镜像队列是实现数据高可用的唯一手段，但是它有一些设计上的缺陷，这也是 RabbitMQ 提供仲裁队列的原因。\"]},\"693\":{\"h\":\"镜像队列的设计缺陷\",\"t\":[\"镜像队列主要的问题是消息同步的性能。由于使用了一种低效的消息复制方法，镜像队列的性能会比较低下。\",\"镜像队列会选择一个主队列和多个从队列，主队列会将自己接收的读、写请求同步给所有从队列。当所有的从队列保存消息之后，主队列才会向生产者发送确认。如果主队列挂掉，其中一个从队列会晋升成主队列，让整个镜像队列仍然保持可用，避免消息丢失。\",\"图 1 - 主队列到从队列的复制\",\"当你有多个镜像队列时，主队列和从队列会分布在集群的不同节点上，每个节点可以承载多个主队列和从队列。\",\"图 2 - 主队列和从队列分布在集群上\",\"所有问题的源头来自于节点的宕机。当一个节点下线，然后恢复上线之后，它保存的所有从队列的镜像数据都会丢失。这就是第一个致命的设计缺陷。此时从队列重新上线，但是它是空的，运维人员必须做出选择，是否要将数据同步到这个队列。如果选择同步，那么就意味着要将当前所有的消息从主队列同步到从队列。\",\"这引出了第二个致命的设计缺陷：同步是阻塞的，它会让整个队列不可用。通常情况下，如果生产和消费的速度能够基本匹配，那么队列应该是没有消息堆积或者堆积非常少的，这样同步只会阻塞很短的时间。但是有时有些队列有时会存在大量堆积，可能是由于故意设计成这样，也可能是因为消费端或者下游服务非常慢或者挂掉，但是上游生产者仍然不停生产消息。\",\"如果队列的堆积少，那么同步的影响就比较小，同步很快结束，然后生产者可以重试之前阻塞的时候生产失败的消息。但是如果队列的消息堆积量很大，同步的影响就会抱很大，可能要消耗几分钟、几小时或者更多时间去同步消息，不仅如此，同步还会消耗内存，导致内存相关的问题，甚至可能造成节点需要重启。\",\"所以运维有时就不会选择进行消息同步，仅仅让新的消息复制到这个重新上线的镜像队列，老的消息不进行同步。但是这样的话会让消息丢失的风险增加。\",\"这个问题同样使节点的滚动升级存在很大的隐患，因为在滚动升级时，节点的重启会丢失所有数据，需要进行数据的同步或者恢复。\"]},\"694\":{\"h\":\"仲裁队列——下一代高可用队列\",\"t\":[\"仲裁队列旨在解决镜像队列的性能和同步问题。但是相对的，它没有包含队列的所有功能，并且有它自己的局限性。所以在仲裁队列和镜像队列之间的选择不是一个容易的事情。\",\"Raft 共识协议逐渐成为了工业上大量使用的分布式共识协议，仲裁队列就是基于 Raft 共识算法的一个变种。它比镜像队列更安全、性能更好。\"]},\"695\":{\"h\":\"Raft 协议下的消息复制\",\"t\":[\"每个仲裁队列都有多个副本，它包含一个主和多个从副本。replication factor 为 5 的仲裁队列将会有 1 个主副本和 4 个从副本。每个副本都在不通的 RabbitMQ 节点上。\",\"客户端（生产者和消费者）只会与主副本进行交互，主副本再将这些命令复制到从副本。与镜像队列类似，从副本不与客户端进行交互，它们仅仅作为一个冗余备份，在节点挂掉或重启时提供高可用的能力。当主副本所在的节点下线，其中一个在另外节点的从副本会被选举成为主副本，继续提供服务。\",\"图 3 - Raft 共识协议\",\"消息复制和主副本选举的操作，需要超过半数的副本同意，所以我管它叫做仲裁队列。当生产者发送一条消息，需要超过半数的队列副本都将消息写入磁盘以后才会向生产者进行确认。这意味着少部分比较慢的副本不会影响整个队列的性能。同样地，主副本的选举也需要超过半数的副本同意才行，这会避免出现网络分区时 2 个主副本，所以说仲裁队列相对于可用性更看重一致性。\"]},\"696\":{\"h\":\"仲裁队列的优势\",\"t\":[\"客户端不需要改变它们生产和订阅的方法，无需考虑队列类型。唯一的区别就是在客户端定义队列的时候需要定义成仲裁队列（代码中添加相关属性）\",\"同步的问题被解决，当节点重新上线时，不会丢数据，主副本会直接从从副本中断的地方开始复制消息。复制的过程是非阻塞的，所以整个队列不会因为新的副本加入而收到影响。唯一的影响是网络使用率。\",\"没有了同步问题，不仅让仲裁队列比镜像队列更可靠，同时，因为写入必须被超过半数的副本接受，所以不会因为脑裂而丢数据。\",\"Raft 协议比镜像队列的算法更有效率，可以提供更好的消息吞吐量。\",\"总结起来，仲裁队列可以提供更高的性能、更好的数据安全性、更容易进行节点的滚动升级。\"]},\"697\":{\"h\":\"仲裁队列的劣势\"},\"698\":{\"h\":\"特性更少\",\"t\":[\"这些特性在仲裁队列的第一个版本中不会提供\",\"非持久化消息\",\"排它队列\",\"队列/消息 TTL（超时时间）\",\"一些规则（Policy）不可用，只有死信队列、队列长度限制可用\",\"优先级\",\"惰性队列\",\"非全局的消息预取（Qos）\"]},\"699\":{\"h\":\"磁盘使用——写入放大\",\"t\":[\"仲裁队列的磁盘和内存配置与普通队列不同。\"]},\"700\":{\"h\":\"普通队列\",\"t\":[\"普通队列使用“共享”存储模型，对于一条要投递到多个队列的消息，只会存储一次，其他队列只会保存这条消息的引用。也就是说，在发布-订阅模型下，一条将要投递到多个队列的消息，它的存储大小不会随着投递到的队列变多而线性增长。\",\"举个例子，我们用一个 fanout 类型的 exchange，绑定 10 个队列。\",\"这 10 个队列每个都设置成 5 副本镜像队列。\",\"最终，发布一条消息后，只有 5 条消息存储到集群中，每个节点存储 1 条。所以在这个情况下的写入放大是 5 倍。\"]},\"701\":{\"h\":\"仲裁队列\",\"t\":[\"仲裁队列使用在内存中“共享”的存储模型，在磁盘中，每条消息都会分别被存储。所以发布-订阅模型会造成更严重的写入放大，可能导致更大的磁盘使用，甚至不得不放弃使用仲裁队列。\",\"还是上面那个例子，当每个队列都变成仲裁队列，并且复制因子为 5 时。\",\"最终集群中的磁盘上存储了 50 条消息，每条消息的写入放大是 50 倍。\",\"因此，把 fanout 交换器和仲裁队列一起使用不太合适。\"]},\"702\":{\"h\":\"内存使用——所有消息一直保存在内存中\",\"t\":[\"仲裁队列的所有消息一直会保存在内存中，这会增加内存的使用量，最终可能导致集群不可用。如果不进行一些检查和监控，队列消息不断堆积，可能会导致生产停止（内存高水位），直到消息被消费或者从内存中删除。所以当使用仲裁队列时，设置队列的长度限制非常重要。此外还有必要用惰性队列作为仲裁队列的死信队列，通过死信交换器将这些消息转发到死信队列中。\",\"因此，队列的规划和监控边得比普通场景下更为重要。下游（消费者和下游服务）的中断或者变慢可能导致多个队列消息堆积，需要有对应的规划和措施。你需要多少个仲裁队列、它们的写入速率时多少，当集群达到内存高水位时其他队列会不会收到影响？\"]},\"703\":{\"h\":\"失去多数节点时意味着队列不可用\",\"t\":[\"如果仲裁队列超过半数的副本永久丢失，那么队列数据就永久丢失了。即便有小部分的副本仍然可用，队列仍然没有办法恢复，只能被强制删除。虽然这种场景出现的可能性较小，但是仍有这样的危险存在。所以，推荐使用可靠的磁盘，并且把复制因子设置为 5 ~ 3。\"]},\"704\":{\"h\":\"延迟\",\"t\":[\"尽管仲裁队列的吞吐量更高，但是延迟也可能更高，这是由于使用了 Raft 协议。在仲裁队列中，所有消息都是持久化的，所有消息都会保存到每个副本的磁盘中。安全性是仲裁队列的主要目标。\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"705\":{\"h\":\"RabbitMQ 一致性哈希交换器 使用和原理\",\"t\":[\"原文地址：http://hscarb.github.io/rabbitmq/20231016-rabbitmq-consistent-hash-exchange.html\"]},\"706\":{\"h\":\"1. 背景\"},\"707\":{\"h\":\"1.1 使用场景\",\"t\":[\"在使用 RabbitMQ 集群时，我们常常遇到队列中消息不平衡的场景。即某个队列的消息或流量非常大，其他队列流量较小。由于 RabbitMQ 的队列只能存在于一个节点，就会导致节点间负载不均衡。\",\"在 CloudAMQP 的 RabbitMQ 高性能最佳实践 中提到了使用一致性哈希交换器（Consistent hash exchange plugin）来让消息在多个队列中负载均衡。有了它，我们就可以将一个队列拆分成多个子队列，平均地分布在每个节点上，让节点间负载均衡。\",\"将一个队列拆分成多个队列也可以摆脱单队列的性能瓶颈，获得更高的吞吐量。\"]},\"708\":{\"h\":\"1.2 一致性哈希\",\"t\":[\"一致性哈希交换器根据 routingKey 进行哈希，根据哈希结果将生产者发送的消息路由到哪个队列中。\",\"普通的哈希算法无法保证在增加或者减少队列绑定时，同样的 routingKey 的消息路由到相同的队列。一致性哈希就是为了解决这个问题。\"]},\"709\":{\"h\":\"2. 使用\"},\"710\":{\"h\":\"2.1 开启插件\",\"t\":[\"需要先开启一致性哈希交换器插件\",\"rabbitmq-plugins enable rabbitmq_consistent_hash_exchange \"]},\"711\":{\"h\":\"2.2 管理页面使用\",\"t\":[\"开启插件后，在 RabbitMQ 管理页面可以创建 x-consistent-hash 类型的交换器，即一致性哈希交换器。\",\"image-20231012004854125\",\"然后我们创建 3 个子队列\",\"image-20231012004951406\",\"进入 exchange 详情，将 3 个队列与 exchange 绑定。\",\"注意，这里的 Routing key 的含义是对应队列的权重，权重越高，消息路由到该队列的概率也越高。\",\"这里我们将 3 个队列的权重都设为 10。\",\"image-20231012005239630\",\"然后在 exchange 详情页面，手动发送消息，指定不同的 Routing key，观察消息在队列中的分布。\",\"这里我发送 9 条消息，Routing key 为 1~9。\",\"image-20231012005439516\",\"消息被分配到 3 个队列中。\",\"image-20231012005513363\",\"由于发送的消息较少，这里还不是非常平均。发送更多消息将会更平均。\",\"如何查看内核中的权重是否生效？可以用命令行提供的诊断命令查看一致性哈希交换器的哈希环节点分布：\",\"rabbitmq-diagnostics consistent_hash_exchange_ring_state -p {vhost} {exhcange} \"]},\"712\":{\"h\":\"2.3 Java SDK 使用\",\"t\":[\"下面以 Java SDK 为例，演示一致性哈希交换器的使用。先导入 maven 依赖。\",\"<!-- RabbitMQ Java client --> <dependency> <groupId>com.rabbitmq</groupId> <artifactId>amqp-client</artifactId> <version>5.13.0</version> </dependency> \",\"import com.rabbitmq.client.*; import java.io.IOException; import java.util.concurrent.TimeoutException; public class RabbitMQConsistentHashDemo { private static final String EXCHANGE_NAME = \\\"consistent_hash_exchange\\\"; private static final String[] QUEUE_NAMES = {\\\"queue1\\\", \\\"queue2\\\", \\\"queue3\\\"}; private static final int MESSAGE_COUNT = 300; public static void main(String[] args) throws IOException, TimeoutException { ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\\\"localhost\\\"); // 设置 rabbitmq 连接地址，如有必要，还需要设置端口（默认 5672）、用户名和密码 try (Connection connection = factory.newConnection(); Channel channel = connection.createChannel()) { // 定义交换器 channel.exchangeDeclare(EXCHANGE_NAME, \\\"x-consistent-hash\\\", true); // 定义 3 个子队列，并与交换器绑定 for (String queueName : QUEUE_NAMES) { channel.queueDeclare(queueName, true, false, false, null); channel.queueBind(queueName, EXCHANGE_NAME, \\\"10\\\"); // 这里的 bindingKey 为路由到该队列消息的权重，用整数字符串表示 } // 生产 300 条消息， for (int i = 0; i < MESSAGE_COUNT; i++) { String message = \\\"Message-\\\" + i; String routingKey = String.valueOf(i); // 用消息的序号作为 routingKey channel.basicPublish(EXCHANGE_NAME, \\\"\\\", null, message.getBytes()); } System.out.println(\\\"Sent \\\" + MESSAGE_COUNT + \\\" messages.\\\"); // 打印每个队列堆积的消息数量 for (String queueName : QUEUE_NAMES) { long count = channel.messageCount(queueName); System.out.println(\\\"Queue \\\" + queueName + \\\" has \\\" + count + \\\" messages.\\\"); } } } } \"]},\"713\":{\"h\":\"2.4 高级用法\"},\"714\":{\"h\":\"2.4.1 使用 Header 作为路由键\",\"t\":[\"在某些情况下，routingKey 需要被用于其他目的（如交换器间绑定）。在这种情况下可以配置一致性哈希交换器基于消息头进行路由。\",\"使用的方法是，在创建一致性哈希交换器时指定 hash-header 参数来声明需要作为路由键的 header。\",\"String EXCHANGE = \\\"e2\\\"; String EXCHANGE_TYPE = \\\"x-consistent-hash\\\"; Map<String, Object> args = new HashMap<>(); args.put(\\\"hash-header\\\", \\\"hash-on\\\"); ch.exchangeDeclare(EXCHANGE, EXCHANGE_TYPE, true, false, args); \",\"上面的代码创建了一个一致性哈希交换器，使用消息的 hash-on 这个 header 作为路由键。\",\"for (int i = 0; i < 100000; i++) { AMQP.BasicProperties.Builder bldr = new AMQP.BasicProperties.Builder(); Map<String, Object> hdrs = new HashMap<>(); hdrs.put(\\\"hash-on\\\", String.valueOf(i)); ch.basicPublish(EXCHANGE, \\\"\\\", bldr.headers(hdrs).build(), \\\"\\\".getBytes(\\\"UTF-8\\\")); } \",\"在发送消息时指定消息 header 中的 hash-on 属性，作为消息的路由键。\"]},\"715\":{\"h\":\"2.4.2 使用消息属性作为路由键\",\"t\":[\"还可以使用消息属性作为路由键，直接使用消息的 message_id、correlation_id 或 timestamp 属性来进行路由。\",\"使用的方法是在创建一致性哈希交换器时用 hash-property 参数指定消息的路由属性名称。\",\"String EXCHANGE = \\\"e3\\\"; String EXCHANGE_TYPE = \\\"x-consistent-hash\\\"; Map<String, Object> args = new HashMap<>(); args.put(\\\"hash-property\\\", \\\"message_id\\\"); ch.exchangeDeclare(EXCHANGE, EXCHANGE_TYPE, true, false, args); \",\"上面的代码将 message_id 作为路由键。\",\"for (int i = 0; i < 100000; i++) { AMQP.BasicProperties.Builder bldr = new AMQP.BasicProperties.Builder(); ch.basicPublish(EXCHANGE, \\\"\\\", bldr.messageId(String.valueOf(i)).build(), \\\"\\\".getBytes(\\\"UTF-8\\\")); } \",\"上面的代码在发送消息时设置消息的 message_id，被用作路由键。\"]},\"716\":{\"h\":\"3. 原理\",\"t\":[\"一致性哈希交换器的原理与普通的一致性哈希实现类似，可以看这篇文章：一致性哈希 原理和实现。\",\"简单地说是在 erlang 的分布式数据库 mnesia 中初始化了一个哈希环，每个队列在哈希环上对应多个虚拟节点（虚拟节点的个数就是绑定时指定的权重）。\",\"当新的队列（或其他绑定）被添加到交换器时，它将通过哈希值被映射到哈希环上。每个队列可能占据哈希环上的一个或多个位置点（由其权重决定），从而在消息分配时提供更多的均匀性。当消息进入交换器时，它也将哈希到这个环上，然后被路由到环上位置等于或顺时针最接近的队列。\",\"下图是权重为 1 时的路由场景：\",\"img\",\"但是哈希算法并不保证节点均匀分配到哈希换上，所以需要用更多地虚拟节点来让节点更均匀地分布。\",\"当权重为 3 时，每个节点（队列）会“分身“成多个虚拟节点，示意图如下：\",\"img\"]},\"717\":{\"h\":\"参考资料\",\"t\":[\"Part 2: RabbitMQ Best Practice for High Performance (High Throughput)\",\"RabbitMQ Consistent Hash Exchange Type\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"718\":{\"h\":\"rabbitmq\",\"t\":[\"RabbitMQ 进程内流控（Flow Control） 源码解析\",\"RabbitMQ Federation 插件使用\",\"RabbitMQ 3.7.x 版本 安装\",\"RabbitMQ 镜像队列 使用和原理详解\",\"RabbitMQ 存储机制\",\"RabbitMQ 3.8 特性聚焦：仲裁队列（Quorum Queues）\",\"RabbitMQ 一致性哈希交换器 使用和原理\"]},\"719\":{\"h\":\"RocketMQ 4.9.1 性能优化 源码剖析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220131-rocketmq-4.9.1-performance-improvement.html\"]},\"720\":{\"h\":\"概述\",\"t\":[\"RocketMQ 4.9.1 版本针对 Broker 做了一些性能优化，这一批 PR 都挂载 ISSUE#2883 下。\",\"和4.9.0版本相比，小消息实时生产的 TPS 提升了约 28%。\",\"I have some commit to Improve produce performance in M/S mode:\",\"Change log level to debug: \\\"Half offset {} has been committed/rolled back\\\"\",\"Optimise lock in WaitNotifyObject\",\"Remove lock in HAService\",\"Remove lock in GroupCommitService\",\"Eliminate array copy in HA\",\"Remove putMessage/putMessages method in CommitLog which has too many duplicated code.\",\"Change default value of some parameters: sendMessageThreadPoolNums/useReentrantLockWhenPutMessage/flushCommitLogTimed/endTransactionThreadPoolNums\",\"Optimise performance of asyncPutMessage (extract some code out of putMessage lock)\",\"extract generation of msgId out of lock in CommitLog (now only for single message processor)\",\"extract generation of topicQueueTable key out of sync code\",\"extract generation of msgId out of lock in CommitLog (for batch)\",\"fix ipv6 problem introduced in commit \\\"Optimise performance of asyncPutMessage (extract some code out of putMessage lock)\\\"\",\"Remove an duplicate MessageDecoder.string2messageProperties for each message, and prevent store \\\"WAIT=true\\\" property (in most case) to save 9 bytes for each message.\",\"Improve performance of string2messageProperties/messageProperties2String, and save 1 byte for each message.\",\"Optimise parse performance for SendMessageRequestHeaderV2\",\"下面会从源码层面来详细分析一下优化点和优化的原因。了解这些优化需要对 RocketMQ 源码比较熟悉，为了方便理解，会在讲解优化点前补充一些前置知识。\"]},\"721\":{\"h\":\"优化分析\"},\"722\":{\"h\":\"事务消息日志优化（1）\",\"t\":[\"Change log level to debug: \\\"Half offset {} has been committed/rolled back\\\"\",\"默认的配置下每条消息都会打出一条日志，改动主要移除了事务消息中的日志打印。\",\"while (true) { if (System.currentTimeMillis() - startTime > MAX_PROCESS_TIME_LIMIT) { log.info(\\\"Queue={} process time reach max={}\\\", messageQueue, MAX_PROCESS_TIME_LIMIT); break; } if (removeMap.containsKey(i)) { log.~~info~~(\\\"Half offset {} has been committed/rolled back\\\", i); Long removedOpOffset = removeMap.remove(i); doneOpOffset.add(removedOpOffset); } \",\"这个优化比较简单，从这当中可以学到的是在打印日志时需要谨慎，尤其是对于 RocketMQ 这种高性能中间件来说，日志的打印可能会占用较多 CPU 资源。\",\"此外，如果日志中涉及字符串拼接等操作，消耗会更大，应当避免。\"]},\"723\":{\"h\":\"主从复制和同步刷流程中锁的优化/移除（2-4）\",\"t\":[\"Improve produce performance in M/S mode\",\"Optimise lock in WaitNotifyObject\",\"Remove lock in HAService\",\"Remove lock in GroupCommitService\",\"在分析如何优化之前需要学习一些前置指示，看一下 RocketMQ 中主从复制和同步刷盘的原理。这两个操作原理基本相同。\"]},\"724\":{\"h\":\"前置知识：主从复制和同步刷盘中的生产消费模式\",\"t\":[\"在 RocketMQ 内部，主从复制和同步刷盘都是多线程协作处理的。以主从复制为例（GroupTransferService），消息处理线程（多个）不断接收消息，产生待复制的消息，另外有一个 ServiceThread 单线程处理复制结果，可以把前者看做数据生产者，后者看做数据消费者，RocketMQ 使用了双 Buffer 来达到批量处理的目的。\",\"如下图，消费者正在处理数据的同时，生产者可以不受影响的继续添加数据，第一阶段生产者 Buffer 有 3 条数据，消费者 Buffer 有 2 条数据，由于消费者是单线程，没有别的线程跟它竞争，所以它可以批量处理这 2 条数据，完成后它会交换这两个 Buffer 的引用，于是接下来的第二阶段它又可以批量处理 3 条数据。\",\"Untitled\"]},\"725\":{\"h\":\"优化1：主从复制和同步刷盘中重量级锁synchronized改为自旋锁\",\"t\":[\"之前 RocketMQ 在生产者写入 putRequest() 、交换 Buffer 引用 swapRequests() 、以及内部处理中都使用了重量级锁synchronized保证线程安全。\",\"实际 putRequest() 方法中只做了添加数据到列表的操作；swapRequests() 中做了交换操作，耗时都较小，故可以换成自旋锁。每次加解锁都只有 2 次 CAS 操作的开销，而不发生线程切换。\",\"Untitled\"]},\"726\":{\"h\":\"优化2：WaitNotifyObject 类\",\"t\":[\"WaitNotifyObject 被用于做线程之间的异步通知。在主从复制逻辑中被用到。用法类似 synchronized 的 wait() 和 nofityAll()，等待-通知机制。\",\"主从复制线程循环传输数据，如果没有数据则调用 WaitNotifyObject#allWaitForRunning() 方法等待。\",\"在CommitLog保存消息之后，调用 WaitNotifyObject#wakeUpAll() 方法唤醒主从复制线程。\",\"本次优化减少了需要进入同步代码块的次数。\",\"修改点：waitingThreadTable 改为 ConcurrentHashMap，然后可以将 waitingThreadTable 移出同步代码块。\",\"volatile boolean hasNotified 改为 AtomicBoolean hasNotified\",\"Untitled\"]},\"727\":{\"h\":\"消除主从复制中不必要的数组拷贝（5）\",\"t\":[\"Eliminate array copy in HA\",\"了解这个优化之前需要先学习一下前置知识，包括 RocketMQ 中 CommitLog 使用的内存映射文件，和主从复制的流程。\"]},\"728\":{\"h\":\"内存映射文件mmap\",\"t\":[\"RocketMQ 的 CommitLog 是内存映射文件（mmap）。下面这张图对比了普通 IO 和内存映射 IO 之间的区别。\",\"Untitled\",\"mmap 将文件直接映射到用户内存，使得对文件的操作不用再需要拷贝到PageCache，而是转化为对映射地址映射的PageCache的操作，使随机读写文件和读写内存拥有相似的速度（随机地址被映射到了内存）\"]},\"729\":{\"h\":\"主从复制流程概要\",\"t\":[\"RocketMQ 主从复制机制会在消息写入 CommitLog 之后，Master Broker 将消息发送到 Slave，达到消息不丢失。\",\"本次修改点是在主从复制的 Slave 处理过程当中。HAClient 是 Slave 连接 Master 的实现类。\",\"HAClient#run() 方法做了以下这些事：\",\"salve连接到master，向master上报slave当前的offset\",\"master收到后确认给slave发送数据的开始位置\",\"master查询开始位置对应的MappedFIle\",\"master将查找到的数据发送给slave\",\"slave收到数据后保存到自己的CommitLog\",\"其中4、5步，Slave 接收到的数据存在一个 ByteBuffer 里面，把它保存到 CommitLog 的时候，原来的代码会新建一个字节数组，然后把读到的 ByteBuffer 里的数据拷贝进去。\"]},\"730\":{\"h\":\"优化：减少字节数组拷贝\",\"t\":[\"原先在主从复制逻辑中的数组拷贝步骤其实是可以省略的，可以直接把从 Master 读到的 ByteBuffer 传到写 CommitLog 的方法中，并且一并传入数据的开始位置和长度，这样就可以在不重新复制字节数组的情况下传递 ByteBuffer 中的数据。\",\"Untitled\"]},\"731\":{\"h\":\"移除 CommitLog 中包含重复代码的 putMessage/putMessages 方法（6）\",\"t\":[\"Remove putMessage/putMessages method in CommitLog which has too many duplicated code.\",\"该优化主要是减少冗余代码\",\"原本 CommitLog 中有如下这些保存消息的方法\",\"putMessage：同步保存单条消息\",\"asyncPutMessage：异步保存单条消息\",\"putMessages：同步保存批量消息\",\"asyncPutMessages：异步保存批量消息\",\"其实同步保存和异步保存消息的逻辑差不多，但是原本并没有复用代码，而是每个方法都单独实现。这就导致同步和异步方法存在大量重复代码。\",\"这个 Patch 合并了 putMessage & asyncPutMessage 、putMessages & asyncPutMessages 方法，在同步方法中调用异步方法的等待方法，删除了大量重复代码。\",\"Untitled\",\"Untitled\"]},\"732\":{\"h\":\"调整消息发送几个参数的默认值（7）\",\"t\":[\"Change default value of some parameters: sendMessageThreadPoolNums/useReentrantLockWhenPutMessage/flushCommitLogTimed/endTransactionThreadPoolNums\"]},\"733\":{\"h\":\"消息保存/发送参数优化\",\"t\":[\"RocketMQ在保存消息时，由于要保证消息保存到 CommitLog 中是顺序的，写 CommitLog 只能单线程操作，写之前要先获取一个锁，这个锁也就是影响 RocketMQ 性能最关键的一个锁。\",\"最早之前 3.2.X 版本这个锁是 synchronized，从 RocketMQ4.X 开始引入了自旋锁并作为默认值，同时将参数 sendMessageThreadPoolNums（处理Client端发送消息线程池的线程数）改为了 1，这样处理每条消息写 CommitLog 的时候是一个线程在写，可以省下进出重量锁的开销。\",\"不过这个地方单线程处理，任务有点重，处理消息的逻辑并不是往 CommitLog 里面一写（无法并行）就完事的，还有一些 CPU 开销比较大的工作，多线程处理比较好，经过一些实践测试，4 个线程是比较合理的数值，因此这个参数默认值改为 MIN(逻辑处理器数, 4)。\",\"既然有 4 个线程，还用自旋锁可能就不合适了，因为拿不到锁的线程会让 CPU 白白空转。所以改用可重入锁，useReentrantLockWhenPutMessage 参数还是改为 true 比较好。\"]},\"734\":{\"h\":\"事务消息二阶段处理线程大小\",\"t\":[\"endTransactionThreadPoolNums 是事务消息二阶段处理线程大小，sendMessageThreadPoolNums 则指定一阶段处理线程池大小。如果二阶段的处理速度跟不上一阶段，就会造成二阶段消息丢失导致大量回查，所以建议 endTransactionThreadPoolNums 应该大于 sendMessageThreadPoolNums，建议至少 4 倍。\"]},\"735\":{\"h\":\"开启定时刷盘\",\"t\":[\"flushCommitLogTimed 参数表示是否定时刷盘，之前默认为 false，表示实时刷盘。\",\"本次对刷盘相关的参数也进行了调整。默认情况下，RocketMQ 是异步刷盘，但每次处理消息都会触发一个异步的刷盘请求。这次将 flushCommitLogTimed 这个参数改成 true，也就是定时刷盘（默认每 500ms），可以大幅降低对 IO 压力，在主从同步复制的场景下，可靠性也不会降低。\"]},\"736\":{\"h\":\"优化 putMessage 锁内操作 （8-12）\",\"t\":[\"Improve produce performance in M/S mode.\",\"Optimise performance of asyncPutMessage (extract some code out of putMessage lock)\",\"extract generation of msgId out of lock in CommitLog (now only for single message processor)\",\"extract generation of topicQueueTable key out of sync code\",\"extract generation of msgId out of lock in CommitLog (for batch)\",\"fix ipv6 problem introduced in commit \\\"Optimise performance of asyncPutMessage (extract some code out of putMessage lock)\\\"\",\"CommitLog 是 RocketMQ 消息存储文件。单个 Broker 上所有消息都顺序保存在 CommitLog 中。\",\"写 CommitLog 只能单线程操作，写之前要先获取一个锁，这个锁也就是影响 RocketMQ 性能最关键的一个锁。\",\"理论上这里只要往 MappedByteBuffer 写一下就好了，但实践往往要比理论复杂得多，因为各种原因，这个锁里面干的事情非常的多。\",\"由于当前代码的复杂性，这个优化是本批次修改里面改动最大的，但它的逻辑其实很简单，就是把锁内干的事情，尽量的放到锁的外面去做，能先准备好的数据就先准备好。它包括了以下改动：\",\"将 Buffer 的大部分准备工作（编码工作）放到了锁外，提前做好。\",\"将 MessageId 的做成了懒初始化（放到锁外），这个消息 ID 的生成涉及很多编解码和数据复制工作，实际上性能开销相当大。\",\"原来锁内用来查位点哈希表的 Key 是个拼接出来的字符串，这次也改到锁外先生成好。\",\"顺便补上了之前遗漏的关于 IPv6 的处理。\",\"删除了无用的代码。\"]},\"737\":{\"h\":\"优化 asyncPutMessage 性能，将准备工作放到锁外\",\"t\":[\"先看一下代码上的改动，右边绿色新增的代码是原先在锁中的操作，现在都移动到了锁外面。\",\"Untitled\",\"右边新增的的 putMessageThreadLocal.getEncode().encode(msg) 完成了大量预操作，将原先 CommitLog#DefaultAppendMessageCallback#doAppend() 方法中的操作移动到了锁外。\",\"下面的代码第一份是修改前的，doAppend() 方法是锁内操作；第二份是修改后的，encode() 方法抽到了加锁之前。\",\"// CommitLog.java 修改前 public AppendMessageResult doAppend(final long fileFromOffset, final ByteBuffer byteBuffer, final int maxBlank, final MessageExtBrokerInner msgInner) { // ... /** * Serialize message */ final byte[] propertiesData = msgInner.getPropertiesString() == null ? null : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8); final int propertiesLength = propertiesData == null ? 0 : propertiesData.length; if (propertiesLength > Short.MAX_VALUE) { log.warn(\\\"putMessage message properties length too long. length={}\\\", propertiesData.length); return new AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED); } final byte[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8); final int topicLength = topicData.length; final int bodyLength = msgInner.getBody() == null ? 0 : msgInner.getBody().length; final int msgLen = calMsgLength(msgInner.getSysFlag(), bodyLength, topicLength, propertiesLength); // Exceeds the maximum message if (msgLen > this.maxMessageSize) { CommitLog.log.warn(\\\"message size exceeded, msg total size: \\\" + msgLen + \\\", msg body size: \\\" + bodyLength + \\\", maxMessageSize: \\\" + this.maxMessageSize); return new AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED); } // ... Determines whether there is sufficient free space // Initialization of storage space this.resetByteBuffer(msgStoreItemMemory, msgLen); // 1 TOTALSIZE this.msgStoreItemMemory.putInt(msgLen); // 2 MAGICCODE this.msgStoreItemMemory.putInt(CommitLog.MESSAGE_MAGIC_CODE); // 3 BODYCRC this.msgStoreItemMemory.putInt(msgInner.getBodyCRC()); // 4 QUEUEID this.msgStoreItemMemory.putInt(msgInner.getQueueId()); // 5 FLAG this.msgStoreItemMemory.putInt(msgInner.getFlag()); // 6 QUEUEOFFSET this.msgStoreItemMemory.putLong(queueOffset); // 7 PHYSICALOFFSET this.msgStoreItemMemory.putLong(fileFromOffset + byteBuffer.position()); // 8 SYSFLAG this.msgStoreItemMemory.putInt(msgInner.getSysFlag()); // 9 BORNTIMESTAMP this.msgStoreItemMemory.putLong(msgInner.getBornTimestamp()); // 10 BORNHOST this.resetByteBuffer(bornHostHolder, bornHostLength); this.msgStoreItemMemory.put(msgInner.getBornHostBytes(bornHostHolder)); // 11 STORETIMESTAMP this.msgStoreItemMemory.putLong(msgInner.getStoreTimestamp()); // 12 STOREHOSTADDRESS this.resetByteBuffer(storeHostHolder, storeHostLength); this.msgStoreItemMemory.put(msgInner.getStoreHostBytes(storeHostHolder)); // 13 RECONSUMETIMES this.msgStoreItemMemory.putInt(msgInner.getReconsumeTimes()); // 14 Prepared Transaction Offset this.msgStoreItemMemory.putLong(msgInner.getPreparedTransactionOffset()); // 15 BODY this.msgStoreItemMemory.putInt(bodyLength); if (bodyLength > 0) this.msgStoreItemMemory.put(msgInner.getBody()); // 16 TOPIC this.msgStoreItemMemory.put((byte) topicLength); this.msgStoreItemMemory.put(topicData); // 17 PROPERTIES this.msgStoreItemMemory.putShort((short) propertiesLength); if (propertiesLength > 0) this.msgStoreItemMemory.put(propertiesData); \",\"// CommitLog.java 修改后 protected PutMessageResult encode(MessageExtBrokerInner msgInner) { /** * Serialize message */ final byte[] propertiesData = msgInner.getPropertiesString() == null ? null : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8); final int propertiesLength = propertiesData == null ? 0 : propertiesData.length; if (propertiesLength > Short.MAX_VALUE) { log.warn(\\\"putMessage message properties length too long. length={}\\\", propertiesData.length); return new PutMessageResult(PutMessageStatus.PROPERTIES_SIZE_EXCEEDED, null); } final byte[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8); final int topicLength = topicData.length; final int bodyLength = msgInner.getBody() == null ? 0 : msgInner.getBody().length; final int msgLen = calMsgLength(msgInner.getSysFlag(), bodyLength, topicLength, propertiesLength); // Exceeds the maximum message if (msgLen > this.maxMessageSize) { CommitLog.log.warn(\\\"message size exceeded, msg total size: \\\" + msgLen + \\\", msg body size: \\\" + bodyLength + \\\", maxMessageSize: \\\" + this.maxMessageSize); return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null); } // Initialization of storage space this.resetByteBuffer(encoderBuffer, msgLen); // 1 TOTALSIZE this.encoderBuffer.putInt(msgLen); // 2 MAGICCODE this.encoderBuffer.putInt(CommitLog.MESSAGE_MAGIC_CODE); // 3 BODYCRC this.encoderBuffer.putInt(msgInner.getBodyCRC()); // 4 QUEUEID this.encoderBuffer.putInt(msgInner.getQueueId()); // 5 FLAG this.encoderBuffer.putInt(msgInner.getFlag()); // 6 QUEUEOFFSET, need update later this.encoderBuffer.putLong(0); // 7 PHYSICALOFFSET, need update later this.encoderBuffer.putLong(0); // 8 SYSFLAG this.encoderBuffer.putInt(msgInner.getSysFlag()); // 9 BORNTIMESTAMP this.encoderBuffer.putLong(msgInner.getBornTimestamp()); // 10 BORNHOST socketAddress2ByteBuffer(msgInner.getBornHost() ,this.encoderBuffer); // 11 STORETIMESTAMP this.encoderBuffer.putLong(msgInner.getStoreTimestamp()); // 12 STOREHOSTADDRESS socketAddress2ByteBuffer(msgInner.getStoreHost() ,this.encoderBuffer); // 13 RECONSUMETIMES this.encoderBuffer.putInt(msgInner.getReconsumeTimes()); // 14 Prepared Transaction Offset this.encoderBuffer.putLong(msgInner.getPreparedTransactionOffset()); // 15 BODY this.encoderBuffer.putInt(bodyLength); if (bodyLength > 0) this.encoderBuffer.put(msgInner.getBody()); // 16 TOPIC this.encoderBuffer.put((byte) topicLength); this.encoderBuffer.put(topicData); // 17 PROPERTIES this.encoderBuffer.putShort((short) propertiesLength); if (propertiesLength > 0) this.encoderBuffer.put(propertiesData); encoderBuffer.flip(); return null; } \",\"然后把预编码的数据放到 MessageExtBrokerInner 中的 private ByteBuffer encodedBuff 字段，传到 doAppend() 方法中使用\",\"Untitled\"]},\"738\":{\"h\":\"MessageId 懒加载\",\"t\":[\"使用函数式接口 Supplier，将 MessageId 计算的逻辑放到 Supplier 中。创建结果对象时将 Supplier 传入，而不是直接计算 MessageId。\",\"当结果的 getMsgId() 方法被调用，才会执行 Supplier 中 MessageId 的计算方法。\",\"// CommitLog#DefaultAppendMessageCallback public AppendMessageResult doAppend(final long fileFromOffset, final ByteBuffer byteBuffer, final int maxBlank, final MessageExtBrokerInner msgInner, PutMessageContext putMessageContext) { // STORETIMESTAMP + STOREHOSTADDRESS + OFFSET <br> // PHY OFFSET long wroteOffset = fileFromOffset + byteBuffer.position(); Supplier<String> msgIdSupplier = () -> { int sysflag = msgInner.getSysFlag(); int msgIdLen = (sysflag & MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == 0 ? 4 + 4 + 8 : 16 + 4 + 8; ByteBuffer msgIdBuffer = ByteBuffer.allocate(msgIdLen); MessageExt.socketAddress2ByteBuffer(msgInner.getStoreHost(), msgIdBuffer); msgIdBuffer.clear();//because socketAddress2ByteBuffer flip the buffer msgIdBuffer.putLong(msgIdLen - 8, wroteOffset); return UtilAll.bytes2string(msgIdBuffer.array()); }; // ... AppendMessageResult result = new AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgIdSupplier, msgInner.getStoreTimestamp(), queueOffset, CommitLog.this.defaultMessageStore.now() - beginTimeMills); // ... return result; } \",\"// AppendMessageResult.java public String getMsgId() { // msgId懒加载 if (msgId == null && msgIdSupplier != null) { msgId = msgIdSupplier.get(); } return msgId; } \"]},\"739\":{\"h\":\"优化 消息 Header 解析的性能（13-15）\"},\"740\":{\"h\":\"去除字符串末尾占位符，节省消息传输大小\",\"t\":[\"优化字符串格式的属性存储。RocketMQ 在消息传输时用字符串存储一个 Map，接受消息后再解析成Map。\",\"字符串采用这种格式存储 Map：\",\"key1\\\\u0001value1\\\\u0002key2\\\\u0001value2\\\\u0002 \",\"Untitled\",\"该 Patch 优化掉了字符串末尾的\\\\u0002，为每个消息节省了1字节传输大小。\"]},\"741\":{\"h\":\"优化 string 和 map 互相解析的性能\",\"t\":[\"优化前后效果：\",\"Benchmark Mode Cnt Score Error Units(10000 loop in each op) TempTest.messageProperties2String thrpt 2 2257.276 ops/s TempTest.messageProperties2String_old thrpt 2 1464.342 ops/s TempTest.string2messageProperties thrpt 2 1590.499 ops/s TempTest.string2messageProperties_old thrpt 2 605.118 ops/s \",\"Untitled\",\"string 转 map 优化\",\"Untitled\",\"优化点主要是预先计算了需要解析成字符串的长度，然后为 StringBuilder 定义了初始长度。\",\"StringBuilder 是一个可以动态增加自身数据长度的类，其默认长度（capacity属性）为16。它的底层结构实际是 char[]。\",\"在 TPS 很高的场景下， StringBuilder 默认长度是 16，处理一个正常的消息，至少会内部扩展 2 次，白白产生 2 个对象和 2 次数组复制。\",\"所以优化方案就是先算好需要的长度，创建 StringBuffer 的时候直接就指定好。\",\"map 转 string 优化\",\"Untitled\",\"可以看到右边的代码使用了 indexOf 和 substring 方法替换原来的 split 方法\",\"其实 split 方法内部也是使用 indexOf 和 substring 方法的，但它内部新建了一个 ArrayList<String> 用来保存返回结果，在返回时将结果复制到 String[]。\",\"右边方法将切分后的字符串直接存到 map 中，免去了存到 ArrayList<String> 中的过程，减少了复制，也避免了 ArrayList 扩容的损耗。\"]},\"742\":{\"h\":\"优化 Broker 请求消息头解码性能（15）\",\"t\":[\"Optimise parse performance for SendMessageRequestHeaderV2\",\"RocketMQ 的通信协议定义了各种指令，它们的 Header 各不相同，共用了一个通用的解析方法，基于反射来解析和设置消息 Header。\",\"这个解析 Header 方法的效率很低，本次优化单独定义了解析发送消息请求头的方法，直接get Map 中的属性，提升效率。\",\"发送消息的请求header会类似如：\",\"{ \\\"code\\\":310, \\\"extFields\\\":{ \\\"f\\\":\\\"0\\\", \\\"g\\\":\\\"1482158310125\\\", \\\"d\\\":\\\"4\\\", \\\"e\\\":\\\"0\\\", \\\"b\\\":\\\"TopicTest\\\", \\\"c\\\":\\\"TBW102\\\", \\\"a\\\":\\\"please_rename_unique_group_name\\\", \\\"j\\\":\\\"0\\\", \\\"k\\\":\\\"false\\\", \\\"h\\\":\\\"0\\\", \\\"i\\\":\\\"TAGS\\\\u0001TagA\\\\u0002WAIT\\\\u0001true\\\\u0002\\\" }, \\\"flag\\\":0, \\\"language\\\":\\\"JAVA\\\", \\\"opaque\\\":206, \\\"version\\\":79 } \",\"public class SendMessageRequestHeaderV2 implements CommandCustomHeader { @CFNotNull private String a; // producerGroup; @CFNotNull private String b; // topic; @CFNotNull private String c; // defaultTopic; @CFNotNull private Integer d; // defaultTopicQueueNums; @CFNotNull private Integer e; // queueId; @CFNotNull private Integer f; // sysFlag; @CFNotNull private Long g; // bornTimestamp; @CFNotNull private Integer h; // flag; @CFNullable private String i; // properties; @CFNullable private Integer j; // reconsumeTimes; @CFNullable private boolean k; // unitMode = false; private Integer l; // consumeRetryTimes @CFNullable private boolean m; //batch \",\"接收消息时，会将 Header 解码成 SendMessageRequestHeaderV2 类\",\"public CommandCustomHeader decodeCommandCustomHeader(Class<? extends CommandCustomHeader> classHeader) throws RemotingCommandException { CommandCustomHeader objectHeader; try { objectHeader = classHeader.newInstance(); } catch (InstantiationException e) { return null; } catch (IllegalAccessException e) { return null; } if (this.extFields != null) { Field[] fields = getClazzFields(classHeader); for (Field field : fields) { if (!Modifier.isStatic(field.getModifiers())) { String fieldName = field.getName(); if (!fieldName.startsWith(\\\"this\\\")) { try { String value = this.extFields.get(fieldName); if (null == value) { Annotation annotation = getNotNullAnnotation(field); if (annotation != null) { throw new RemotingCommandException(\\\"the custom field <\\\" + fieldName + \\\"> is null\\\"); } continue; } field.setAccessible(true); String type = getCanonicalName(field.getType()); Object valueParsed; if (type.equals(StringCanonicalName)) { valueParsed = value; } else if (type.equals(IntegerCanonicalName1) || type.equals(IntegerCanonicalName2)) { valueParsed = Integer.parseInt(value); } else if (type.equals(LongCanonicalName1) || type.equals(LongCanonicalName2)) { valueParsed = Long.parseLong(value); } else if (type.equals(BooleanCanonicalName1) || type.equals(BooleanCanonicalName2)) { valueParsed = Boolean.parseBoolean(value); } else if (type.equals(DoubleCanonicalName1) || type.equals(DoubleCanonicalName2)) { valueParsed = Double.parseDouble(value); } else { throw new RemotingCommandException(\\\"the custom field <\\\" + fieldName + \\\"> type is not supported\\\"); } field.set(objectHeader, valueParsed); } catch (Throwable e) { } } } } objectHeader.checkFields(); } return objectHeader; } \",\"static SendMessageRequestHeaderV2 decodeSendMessageHeaderV2( RemotingCommand request) throws RemotingCommandException { SendMessageRequestHeaderV2 r = new SendMessageRequestHeaderV2(); HashMap<String, String> fields = request.getExtFields(); if (fields == null) { throw new RemotingCommandException(\\\"the ext fields is null\\\"); } String s = fields.get(\\\"a\\\"); checkNotNull(s, \\\"the custom field <a> is null\\\"); r.setA(s); s = fields.get(\\\"b\\\"); checkNotNull(s, \\\"the custom field <b> is null\\\"); r.setB(s); s = fields.get(\\\"c\\\"); checkNotNull(s, \\\"the custom field <c> is null\\\"); r.setC(s); s = fields.get(\\\"d\\\"); checkNotNull(s, \\\"the custom field <d> is null\\\"); r.setD(Integer.parseInt(s)); s = fields.get(\\\"e\\\"); checkNotNull(s, \\\"the custom field <e> is null\\\"); r.setE(Integer.parseInt(s)); s = fields.get(\\\"f\\\"); checkNotNull(s, \\\"the custom field <f> is null\\\"); r.setF(Integer.parseInt(s)); s = fields.get(\\\"g\\\"); checkNotNull(s, \\\"the custom field <g> is null\\\"); r.setG(Long.parseLong(s)); s = fields.get(\\\"h\\\"); checkNotNull(s, \\\"the custom field <h> is null\\\"); r.setH(Integer.parseInt(s)); s = fields.get(\\\"i\\\"); if (s != null) { r.setI(s); } s = fields.get(\\\"j\\\"); if (s != null) { r.setJ(Integer.parseInt(s)); } s = fields.get(\\\"k\\\"); if (s != null) { r.setK(Boolean.parseBoolean(s)); } s = fields.get(\\\"l\\\"); if (s != null) { r.setL(Integer.parseInt(s)); } s = fields.get(\\\"m\\\"); if (s != null) { r.setM(Boolean.parseBoolean(s)); } return r; } \",\"左边其实是一个通用的解码方法，右边是针对消息生产的指令 SendMessageRequestHeaderV2 优化的解码方法。这里不再使用共同的这个解析器，而是简单粗暴的直接一个一个去 set 每一个属性，这样这个方法获得了大约 4 倍性能的提升。\"]},\"743\":{\"h\":\"参考资料\",\"t\":[\"Apache RocketMQ 4.9.1 高性能优化之路\",\"RocketMQ这样做，离物理极限性能还差多远？\",\"寻找Java中String.split性能更好的方法\",\"RocketMQ——通信协议\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"744\":{\"h\":\"RocketMQ ConsumeQueue 消费队列文件\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220301-rocketmq-consumequeue.html\"]},\"745\":{\"h\":\"1. 概述\"},\"746\":{\"h\":\"1.1 ConsumeQueue 是什么\",\"t\":[\"ConsumeQueue，又称作消费队列，是 RocketMQ 存储系统的一部分，保存在磁盘中。\",\"该文件可以看作 CommitLog 关于消息消费的“索引”文件。\",\"ConsumeQueue 是一个 MappedFileQueue，即每个文件大小相同的内存映射文件队列。每个文件由大小和格式相同的索引项构成。\",\"每一个 Topic 的 Queue，都对应一个 ConsumeQueue。\"]},\"747\":{\"h\":\"1.2 ConsumeQueue 的作用\",\"t\":[\"引入 ConsumeQueue 的目的主要是适应消息的检索需求，提高消息消费的性能。\",\"Broker 中所有 Topic 的消息都保存在 CommitLog 中，所以同一 Topic 的消息在 CommitLog 中不是连续存储的。消费某一 Topic 消息时去遍历 CommitLog 是非常低效的，所以引入了 ConsumeQueue。\",\"一个 ConsumeQueue 保存了一个 Topic 的某个 Queue 下所有消息在 CommitLog 中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。当需要消费这个 Topic 时，只需要找到对应的 ConsumeQueue 开始遍历，根据消息在 CommitLog 中的偏移量即可找到消息保存的位置。\"]},\"748\":{\"h\":\"2. 概要设计\"},\"749\":{\"h\":\"2.1 文件结构\",\"t\":[\"ConsumeQueue 文件保存在 store 目录下的 consumequeue 目录中。\",\"会为每个 Topic 单独创建一个目录，随后为这个 Topic 中的每个 Queue 单独创建一个目录。\",\"storepath ├─commitlog │ 00000000000000000000 │ 00000000000000102400 │ 00000000000000204800 │ 00000000000000307200 │ ├─consumequeue │ └─b4b690a3-63b0-42b7-9c52-9e01a24a24d4 │ └─0 │ 00000000000000000000 │ 00000000000000001040 │ 00000000000000002080 │ 00000000000000003120 │ 00000000000000004160 │ 00000000000000005200 │ 00000000000000006240 │ 00000000000000007280 ...... \",\"ConsumeQueue 是数量可无限扩展的映射文件，每个文件大小固定。\",\"文件中的最小单元是索引项，包含\",\"消息在 CommitLog 中的物理偏移量\",\"消息大小\",\"消息的 Tag Hash 码\",\"可以把 ConsumeQueue 看作是索引项组成的数组\"]},\"750\":{\"h\":\"2.2 构建\",\"t\":[\"消息保存到 CommitLog 之后，会进行重投递。重投递消息的过程就是为了建立消息的索引文件（包括 ConsumeQueue 和 IndexFile）。\",\"重投递线程会扫描是否有新消息被保存到 CommitLog，如果有则将这条消息查出来，执行重投递逻辑，构建该消息的索引。\"]},\"751\":{\"h\":\"2.3 查询消息\",\"t\":[\"由于每个索引项的大小是固定的，所以只要知道消息在 Queue 中的逻辑偏移量，可以马上算出索引在 ConsumeQueue 中的位置。\",\"根据消费的 Topic 和 QueueId 查询出相应的 ConsumeQueue 消费队列。\",\"然后根据位置获取 ConsumeQueue 中的索引项，其中保存有消息在 CommitLog 中的偏移量和消息大小，进而到 CommitLog 中查询出消息。\",\"同时 ConsumeQueue 还支持通过消息存储时间来查询具体消息，内部使用二分查找算法。\"]},\"752\":{\"h\":\"2.4 刷盘\",\"t\":[\"由一个单独的线程进行持久化，每隔 1s 进行一次判断。\",\"当写入的索引数超过阈值，或刷盘间隔时间超过 60s，则进行一次刷盘。\"]},\"753\":{\"h\":\"2.5 恢复\",\"t\":[\"Broker启动时，遍历所有ConsumeQueue目录下的文件，加载这些文件。\",\"对每个ConsumeQueue执行恢复操作。\",\"从倒数第三个文件开始往后遍历，遍历文件的每个索引项进行校验，更新最大可用偏移量。\"]},\"754\":{\"h\":\"3. 详细设计\"},\"755\":{\"h\":\"3.1 文件结构\",\"t\":[\"ConsumeQueue 的文件结构可以看作是一个可以无限扩展的数组，每个数组元素是一个索引项，其格式和大小是固定的。\",\"Consume queue index item structure\",\"Consume queue index item structure\",\"索引项的结构很简单，如上图所示。其中 Tag HashCode 用作消息过滤。\",\"Untitled\",\"上图来自艾瑞克的技术江湖\",\"可以看到，对于同一个 Topic 的消息，首先保存到 CommitLog 中。每个 Topic 的 Queue 都会创建一个 ConsumeQueue，内部保存该 Queue 中所有消息的索引项。\"]},\"756\":{\"h\":\"3.2 构建\",\"t\":[\"https://raw.githubusercontent.com/HScarb/drawio-diagrams/main/rocketmq/store/rocketmq_consume_queue_build_sequence.drawio.svg\",\"消息会被先保存到 CommitLog 中，随后由一个独立线程DefaultMessageStore.ReputMessageService#doreput()对 CommitLog 进行扫描。\",\"当扫描到新消息被保存到 CommitLog 时，会执行 dispatch（转发） 操作，运行所有消息 Dispatcher，来构建 ConsumeQueue 和 IndexFile。\",\"其中 DefaultMessageStore.CommitLogDispatcherBuildConsumeQueue 就是用来创建 ConsumeQueue 的。其 dispatch() 方法将刚刚保存的消息存入 ConsumeQueue 中。\",\"内部调用了 ConsumeQueue#putMessagePositionInfo() 方法，写内存映射文件，将消息真正存入 ConsumeQueue。\"]},\"757\":{\"h\":\"3.3 查询消息\",\"t\":[\"客户端发起消息消费请求，请求码为RequestCode.PULL_MESSAGE，对应的处理类为PullMessageProcessor。Broker 在收到客户端的请求之后，会根据topic和queueId定位到对应的 ConsumeQueue。然后根据这条请求传入的offset消费队列偏移量，定位到对应消息。\",\"在存储层面查询消息的入口是 DefaultMessageStore#getMessage()。\",\"GetMessageResult getMessage(final String group, final String topic, final int queueId, final long offset, final int maxMsgNums, final MessageFilter messageFilter) \",\"这个方法中根据topic和queueId查询相应的ConsumeQueue，然后使用offset从ConsumeQueue中获取相应位置的索引信息。\",\"随后使用查出来的phyOffset和size到CommitLog中查询消息并返回。\"]},\"758\":{\"h\":\"3.4 刷盘\",\"t\":[\"由一个单独的线程FlushConsumeQueueService周期性检查和刷盘，检查周期flushIntervalConsumeQueue可配置，默认为 1s。\",\"执行刷盘有两个阈值\",\"flushConsumeQueueThoroughInterval（默认 60s）内如果没有执行过刷盘操作，则会执行一次刷盘\",\"需要刷盘的数据超过getFlushConsumeQueueLeastPages（默认2）个操作系统页\"]},\"759\":{\"h\":\"3.5 恢复\",\"t\":[\"Broker启动时，调用DefaultMessageStore#loadConsumeQueue()遍历所有ConsumeQueue目录下的文件，加载这些文件。\",\"随后进行恢复操作recoverConsumeQueue()遍历每个ConsumeQueue执行恢复recover()。\",\"从倒数第三个文件开始往后遍历，遍历文件的每个索引项进行校验，校验成功则更新当前文件的最大可用偏移量，否则直接退出。最后更新整个队列的可用偏移量，删除多余的文件。\"]},\"760\":{\"h\":\"4. 源码解析\",\"t\":[\"与 ConsumeQueue 相关的类有\",\"ConsumeQueue\",\"ConsumeQueueExt\",\"DefaultMessageStore\",\"下面分析 ConsumeQueue 相关操作的源码实现\"]},\"761\":{\"h\":\"4.1 构建\",\"t\":[\"ConsumeQueue 的构建入口是ReputMessageService#doReput()方法，它会从 CommitLog 中扫描新的消息，然后转发和构建 ConsumeQueue。\"]},\"762\":{\"h\":\"4.1.1 ReputMessageService#doReput\",\"t\":[\"当 CommitLog 可用，一直从上一条消息末尾位置开始循环扫描新消息\",\"如找到消息，将消息封装成DispatchRequest，分发给各个处理器（CommitLogDispatcher）\",\"private void doReput() { // ... // CommitLog可用则一直进行循环扫描 for (boolean doNext = true; this.isCommitLogAvailable() && doNext; ) { // 从上一条消息的结束位置开始获取下一条消息 SelectMappedBufferResult result = DefaultMessageStore.this.commitLog.getData(reputFromOffset); if (result != null) { try { // 更新分发的偏移量为当前分发消息的起始偏移量 this.reputFromOffset = result.getStartOffset(); for (int readSize = 0; readSize < result.getSize() && doNext; ) { // 检查消息，查询并解析消息，构建消息的DispatchRequest DispatchRequest dispatchRequest = DefaultMessageStore.this.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), false, false); int size = dispatchRequest.getBufferSize() == -1 ? dispatchRequest.getMsgSize() : dispatchRequest.getBufferSize(); if (dispatchRequest.isSuccess()) { if (size > 0) { // 将DispatchRequest分发给所有注册dispatcherList中的CommitLogDispatcher进行处理 DefaultMessageStore.this.doDispatch(dispatchRequest); // 通知消息消费长轮询线程，有新的消息落盘，立即唤醒挂起的消息拉取请求 if (BrokerRole.SLAVE != DefaultMessageStore.this.getMessageStoreConfig().getBrokerRole() && DefaultMessageStore.this.brokerConfig.isLongPollingEnable() && DefaultMessageStore.this.messageArrivingListener != null) { DefaultMessageStore.this.messageArrivingListener.arriving(dispatchRequest.getTopic(), dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + 1, dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(), dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap()); } // ... } \"]},\"763\":{\"h\":\"4.1.2 DefaultMessageStore#doDispatch\",\"t\":[\"在doReput方法中被调用\",\"内部遍历所有dispatcherList中的分发器，执行每个分发器的dispatch方法\",\"public void doDispatch(DispatchRequest req) { for (CommitLogDispatcher dispatcher : this.dispatcherList) { dispatcher.dispatch(req); } } \"]},\"764\":{\"h\":\"4.1.3 CommitLogDispatcherBuildConsumeQueue#dispatch\",\"t\":[\"判断消息的事务属性\",\"根据 Topic 和 queueId 查找 ConsumeQueue\",\"调用 ConsumeQueue 的保存方法\",\"public void dispatch(DispatchRequest request) { final int tranType = MessageSysFlag.getTransactionValue(request.getSysFlag()); switch (tranType) { // 非事务消息或Commit类型的事务消息才执行分发 case MessageSysFlag.TRANSACTION_NOT_TYPE: case MessageSysFlag.TRANSACTION_COMMIT_TYPE: // 将请求分发到 ConsumeQueue DefaultMessageStore.this.putMessagePositionInfo(request); break; case MessageSysFlag.TRANSACTION_PREPARED_TYPE: case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: break; } } \",\"/** * 将请求分发到具体的 ConsumeQueue * * @param dispatchRequest 消息的分发请求 */ public void putMessagePositionInfo(DispatchRequest dispatchRequest) { ConsumeQueue cq = this.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId()); cq.putMessagePositionInfoWrapper(dispatchRequest); } \"]},\"765\":{\"h\":\"4.1.4 ConsumeQueue#putMessagePosiitonInfo\",\"t\":[\"被putMessagePositionInfoWrapper调用\",\"用于往ConsumeQueue中写入索引项\",\"该函数的大致逻辑如下\",\"将索引项的三个参数写入 ByteBuffer\",\"计算应该写入 ConsumeQueue 的物理偏移量\",\"将 ByteBuffer 中的数据写入 ConsumeQueue 文件\",\"注意该函数的入参中有一个cqOffset，表示消息在该 ConsumeQueue 中的逻辑偏移量。那么消息索引都还没有被存入 ConsumeQueue，它在 ConsumeQueue 里的逻辑偏移量怎么已经被计算出来了？\",\"其实这个值在消息被保存到 CommitLog 时就已经计算出来并保存到 CommitLog 中了，计算的逻辑在 CommitLog#doAppend 方法中。\",\"具体的实现方法是：CommitLog 中的 topicQueueTable 变量保存着每个 ConsumeQueue 当前的最新逻辑偏移量。当应当保存在该 ConsumeQueue 的新消息被保存到 CommitLog，会从 topicQueueTable 获取最新的偏移量，并且将该偏移量加一。源码不在此处展示。\",\"/** * 往ConsumeQueue中写入索引项，putMessagePositionInfo只有一个线程调用，所以不需要加锁 * * @param offset CommitLog offset * @param size 消息在CommitLog存储的大小 * @param tagsCode 过滤tag的hashcode * @param cqOffset 消息在ConsumeQueue中的逻辑偏移量。在 {@link CommitLog#doAppend} 方法中已经生成并保存 * @return 是否成功 */ private boolean putMessagePositionInfo(final long offset, final int size, final long tagsCode, final long cqOffset) { // CommitLog offset + size 小于ConsumeQueue中保存的最大CommitLog物理偏移量，说明这个消息重复生成ConsumeQueue，直接返回 // 多见于关机恢复的场景。关机恢复从倒数第3个CommitLog文件开始重新转发消息生成ConsumeQueue if (offset + size <= this.maxPhysicOffset) { log.warn(\\\"Maybe try to build consume queue repeatedly maxPhysicOffset={} phyOffset={}\\\", maxPhysicOffset, offset); return true; } // NIO ByteBuffer 写入三个参数 this.byteBufferIndex.flip(); this.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE); this.byteBufferIndex.putLong(offset); this.byteBufferIndex.putInt(size); this.byteBufferIndex.putLong(tagsCode); // 计算本次期望写入ConsumeQueue的物理偏移量 final long expectLogicOffset = cqOffset * CQ_STORE_UNIT_SIZE; // 根据期望的偏移量找到对应的内存映射文件 MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile(expectLogicOffset); if (mappedFile != null) { // 纠正MappedFile逻辑队列索引顺序 // 如果MappedFileQueue中的MappedFile列表被删除 // 这时需要保证消息队列的逻辑位置和ConsumeQueue文件的起始文件的偏移量一致，要补充空的消息索引 if (mappedFile.isFirstCreateInQueue() && cqOffset != 0 && mappedFile.getWrotePosition() == 0) { this.minLogicOffset = expectLogicOffset; this.mappedFileQueue.setFlushedWhere(expectLogicOffset); this.mappedFileQueue.setCommittedWhere(expectLogicOffset); // 填充空的消息索引 this.fillPreBlank(mappedFile, expectLogicOffset); log.info(\\\"fill pre blank space \\\" + mappedFile.getFileName() + \\\" \\\" + expectLogicOffset + \\\" \\\" + mappedFile.getWrotePosition()); } if (cqOffset != 0) { // 当前ConsumeQueue被写过的物理offset = 该MappedFile被写过的位置 + 该MappedFile起始物理偏移量 // 注意：此时消息还没从内存刷到磁盘，如果是异步刷盘，Broker断电就会存在数据丢失的情况 // 此时消费者消费不到，所以在重要业务中使用同步刷盘确保数据不丢失 long currentLogicOffset = mappedFile.getWrotePosition() + mappedFile.getFileFromOffset(); // 如果期望写入的位置 < 当前ConsumeQueue被写过的位置，说明是重复写入，直接返回 if (expectLogicOffset < currentLogicOffset) { log.warn(\\\"Build consume queue repeatedly, expectLogicOffset: {} currentLogicOffset: {} Topic: {} QID: {} Diff: {}\\\", expectLogicOffset, currentLogicOffset, this.topic, this.queueId, expectLogicOffset - currentLogicOffset); return true; } // 期望写入的位置应该等于被写过的位置 if (expectLogicOffset != currentLogicOffset) { LOG_ERROR.warn( \\\"[BUG]logic queue order maybe wrong, expectLogicOffset: {} currentLogicOffset: {} Topic: {} QID: {} Diff: {}\\\", expectLogicOffset, currentLogicOffset, this.topic, this.queueId, expectLogicOffset - currentLogicOffset ); } } this.maxPhysicOffset = offset + size; // 将一个ConsumeQueue数据写盘，此时并未刷盘 return mappedFile.appendMessage(this.byteBufferIndex.array()); } return false; } \"]},\"766\":{\"h\":\"4.2 查询消息\",\"t\":[\"客户端发起消息消费请求，请求码为RequestCode.PULL_MESSAGE，对应的处理类为PullMessageProcessor，服务器在收到客户端的请求之后，会根据topic和queueId定位到对应的消费队列。然后根据这条请求传入的offset消费队列偏移量，定位到对应的消费队列文件。\",\"存储层查询消息的入口是 DefaultMessageStore#getMessage。\"]},\"767\":{\"h\":\"4.2.1 DefaultMessageStore#getMessage\",\"t\":[\"该方法的调用关系如下图所示\",\"Untitled\",\"根据 Topic 和 QueueId 查询 ConsumeQueue\",\"根据逻辑偏移量从 ConsumeQueue 中查出索引项\",\"使用索引项中的 CommitLog 物理 offset 和消息的 size，从 CommitLog 查询消息\",\"使用索引项中的 Tag HashCode 处理消息过滤的逻辑\",\"/** * 获取消息 * * @param group Consumer group that launches this query. 消费者组 * @param topic Topic to query. 主题 * @param queueId Queue ID to query. 队列ID * @param offset Logical offset to start from. 消息在队列中的逻辑偏移量 * @param maxMsgNums Maximum count of messages to query. 查询的最大消息数量 * @param messageFilter Message filter used to screen desired messages. 消息过滤器 * @return 查询消息结果 */ public GetMessageResult getMessage(final String group, final String topic, final int queueId, final long offset, final int maxMsgNums, final MessageFilter messageFilter) { // ... ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId); if (consumeQueue != null) { if (/*...*/) { // ... } else { // 根据逻辑偏移量从 ConsumeQueue 中查出索引项 SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset); if (bufferConsumeQueue != null) { try { // ... // 从消费队列中读取消息，直到读完或者读到查询消息数的最大值 for (; i < bufferConsumeQueue.getSize() && i < maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) { long offsetPy = bufferConsumeQueue.getByteBuffer().getLong(); int sizePy = bufferConsumeQueue.getByteBuffer().getInt(); long tagsCode = bufferConsumeQueue.getByteBuffer().getLong(); maxPhyOffsetPulling = offsetPy; // ... // 消息过滤 if (messageFilter != null && !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : null, extRet ? cqExtUnit : null)) { if (getResult.getBufferTotalSize() == 0) { status = GetMessageStatus.NO_MATCHED_MESSAGE; } continue; } // 根据消息的偏移量和消息的大小从 CommitLog 文件中取出一条消息 SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy); if (null == selectResult) { if (getResult.getBufferTotalSize() == 0) { status = GetMessageStatus.MESSAGE_WAS_REMOVING; } nextPhyFileStartOffset = this.commitLog.rollNextFile(offsetPy); continue; } // ... } \"]},\"768\":{\"h\":\"4.3 刷盘\",\"t\":[\"putMessagePositionInfo 中调用 MappedFile#appendMessage，但这并不表示消息会被立刻持久化到磁盘中。\",\"持久化的过程是通过后台服务 FlushConsumeQueueService 来定时持久化的，每隔1s检查一次。\"]},\"769\":{\"h\":\"4.3.1 FlushConsumeQueueService#doFlush\",\"t\":[\"该方法每隔 1s 执行一次。\",\"比较上次刷盘时间与当前时间差距，如果小于等于 60s，则执行刷盘\",\"遍历 ConsumeQueue 执行刷盘，每隔 ConsumeQueue 至少刷 2 个操作系统页\",\"更新 StoreCheckpoint 中的最新刷盘时间\",\"private void doFlush(int retryTimes) { // 变量含义：如果大于0，则标识这次刷盘必须刷多少个page，如果=0，则有多少刷多少。 // 默认为2，表示每次至少刷2个操作系统page int flushConsumeQueueLeastPages = DefaultMessageStore.this.getMessageStoreConfig().getFlushConsumeQueueLeastPages(); // 程序退出时强制刷盘 if (retryTimes == RETRY_TIMES_OVER) { flushConsumeQueueLeastPages = 0; } long logicsMsgTimestamp = 0; // 一定时间内未执行刷盘，会强制刷盘，默认60s int flushConsumeQueueThoroughInterval = DefaultMessageStore.this.getMessageStoreConfig().getFlushConsumeQueueThoroughInterval(); long currentTimeMillis = System.currentTimeMillis(); if (currentTimeMillis >= (this.lastFlushTimestamp + flushConsumeQueueThoroughInterval)) { // 当时间满足flushConsumeQueueThoroughInterval时，即使写入的数量不足flushConsumeQueueLeastPages，也进行flush this.lastFlushTimestamp = currentTimeMillis; flushConsumeQueueLeastPages = 0; logicsMsgTimestamp = DefaultMessageStore.this.getStoreCheckpoint().getLogicsMsgTimestamp(); } ConcurrentMap<String, ConcurrentMap<Integer, ConsumeQueue>> tables = DefaultMessageStore.this.consumeQueueTable; // 遍历ConsumeQueue刷盘 for (ConcurrentMap<Integer, ConsumeQueue> maps : tables.values()) { for (ConsumeQueue cq : maps.values()) { boolean result = false; for (int i = 0; i < retryTimes && !result; i++) { result = cq.flush(flushConsumeQueueLeastPages); } } } // 更新CheckPoint中ConsumeQueue最新刷盘时间 if (0 == flushConsumeQueueLeastPages) { if (logicsMsgTimestamp > 0) { DefaultMessageStore.this.getStoreCheckpoint().setLogicsMsgTimestamp(logicsMsgTimestamp); } DefaultMessageStore.this.getStoreCheckpoint().flush(); } } \"]},\"770\":{\"h\":\"4.4 恢复\",\"t\":[\"在Broker重新启动时会扫描ConsumeQueue的目录，尝试恢复这些文件。\"]},\"771\":{\"h\":\"4.4.1 ConsumeQueue#recover\",\"t\":[\"从倒数第三个文件开始往后遍历，遍历文件的每个索引项进行校验，校验成功则更新当前文件的最大可用偏移量，否则直接退出循环。\",\"最后更新整个队列的可用偏移量，删掉不可用的部分。\",\"public void recover() { final List<MappedFile> mappedFiles = this.mappedFileQueue.getMappedFiles(); if (!mappedFiles.isEmpty()) { // 从倒数第三个文件开始恢复 int index = mappedFiles.size() - 3; if (index < 0) index = 0; int mappedFileSizeLogics = this.mappedFileSize; MappedFile mappedFile = mappedFiles.get(index); ByteBuffer byteBuffer = mappedFile.sliceByteBuffer(); long processOffset = mappedFile.getFileFromOffset(); long mappedFileOffset = 0; long maxExtAddr = 1; while (true) { for (int i = 0; i < mappedFileSizeLogics; i += CQ_STORE_UNIT_SIZE) { long offset = byteBuffer.getLong(); int size = byteBuffer.getInt(); long tagsCode = byteBuffer.getLong(); // 说明当前存储单元有效 if (offset >= 0 && size > 0) { mappedFileOffset = i + CQ_STORE_UNIT_SIZE; this.maxPhysicOffset = offset + size; if (isExtAddr(tagsCode)) { maxExtAddr = tagsCode; } } else { log.info(\\\"recover current consume queue file over, \\\" + mappedFile.getFileName() + \\\" \\\" + offset + \\\" \\\" + size + \\\" \\\" + tagsCode); break; } } // 走到文件末尾，切换至下一个文件 if (mappedFileOffset == mappedFileSizeLogics) { index++; if (index >= mappedFiles.size()) { // 当前分支不可能发生 log.info(\\\"recover last consume queue file over, last mapped file \\\" + mappedFile.getFileName()); break; } else { mappedFile = mappedFiles.get(index); byteBuffer = mappedFile.sliceByteBuffer(); processOffset = mappedFile.getFileFromOffset(); mappedFileOffset = 0; log.info(\\\"recover next consume queue file, \\\" + mappedFile.getFileName()); } } else { log.info(\\\"recover current consume queue queue over \\\" + mappedFile.getFileName() + \\\" \\\" + (processOffset + mappedFileOffset)); break; } } processOffset += mappedFileOffset; this.mappedFileQueue.setFlushedWhere(processOffset); this.mappedFileQueue.setCommittedWhere(processOffset); this.mappedFileQueue.truncateDirtyFiles(processOffset); if (isExtReadEnable()) { this.consumeQueueExt.recover(); log.info(\\\"Truncate consume queue extend file by max {}\\\", maxExtAddr); this.consumeQueueExt.truncateByMaxAddress(maxExtAddr); } } } \"]},\"772\":{\"h\":\"5. 更多思考\"},\"773\":{\"h\":\"5.1 RocketMQ 5.x 版本中新的 Batch Consume Queue index\",\"t\":[\"在 RIP-26 中为了支持 Batch Message，引入了新的 ConsumeQueue 格式。\",\"这种 ConsumeQueue 元素更多（每个索引的大小也更大），支持了 Batch Message，且方便扩展（留了8字节的保留字段）。\",\"Untitled\",\"不出意外的话 RocketMQ 5.0 中将采用这种 ConsumeQueue 的格式。\"]},\"774\":{\"h\":\"参考资料\",\"t\":[\"1 消费队列ConsumeQueue——wuchanming.gitbook.com\",\"rocketmq源码分析_消息存储之概要设计——迦南地\",\"RocketMQ 设计(design)\",\"RocketMQ高性能之底层存储设计\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"775\":{\"h\":\"RocketMQ IndexFile 索引文件\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220301-rocketmq-indexfile.html\"]},\"776\":{\"h\":\"1. 概述\"},\"777\":{\"h\":\"1.1 索引文件是什么\",\"t\":[\"IndexFile，又可以称作索引文件，是 RocketMQ 保存在磁盘上的一种文件，属于 RocketMQ 存储的一部分。它的结构类似于类似 JDK中 HashMap。\",\"可以通过messageIndexEnable属性配置打开或关闭 IndexFile 存储功能。\"]},\"778\":{\"h\":\"1.2 索引文件作用\",\"t\":[\"索引文件的应用场景其实比较局限，是为了提供按照 Message Key 查询消息的能力。索引文件可以通过 Message Key，查询到消息在 CommitLog 中的物理偏移量，进而从 CommitLog 中查询消息。\"]},\"779\":{\"h\":\"2. 概要设计\"},\"780\":{\"h\":\"2.1 索引文件结构\",\"t\":[\"上面说它的逻辑结构类似 HashMap，HashMap 以 Key-Value 形式存储数据，那么索引文件的存储格式也是 Key-Value\",\"Key：Message Key。索引文件的 Key 其实是 Message Key 经过 hash 得到的一个 Integer，\",\"Value：physical offset。索引文件的 Value 主要是消息在 CommitLog 中的绝对物理偏移量。\",\"hash冲突时，Value以链表的方式存储，越新的消息在链表越前面。\",\"它可以包含多个文件，每个文件的大小是固定的。这就意味着每个 IndexFile 包含的最大索引数量是相同的。\"]},\"781\":{\"h\":\"2.2 如何构建\",\"t\":[\"消息保存到 CommitLog 之后，会进行重投递。重投递消息的过程就是为了建立消息的索引文件（包括 ConsumeQueue 和 IndexFile）。\",\"重投递线程会扫描是否有新消息被保存到 CommitLog，如果有则将这条消息查出来，执行重投递逻辑，构建该消息的索引。\"]},\"782\":{\"h\":\"2.3 如何查询消息\",\"t\":[\"索引文件中存储着 Message Key 对应消息在 CommitLog 中的偏移量，首先查询出这些偏移量信息，然后用偏移量从 CommitLog 中查询出消息。\"]},\"783\":{\"h\":\"2.4 刷盘机制\",\"t\":[\"索引文件的刷盘机制并不是采取定时刷盘机制，而是每写满一个索引文件时就新建一个文件，并且将上一个写满的索引文件刷盘。\"]},\"784\":{\"h\":\"3. 详细设计\"},\"785\":{\"h\":\"3.1 索引文件结构\",\"t\":[\"设计 IndexFile 最重要的是设计它的逻辑结构和文件存储结构。首先看一下 IndexFile 详细的逻辑结构\"]},\"786\":{\"h\":\"3.1.1 逻辑结构\",\"t\":[\"上面已经提到 IndexFile 是类似 JDK 的 HashMap 的结构。\",\"Key：由 IndexService#buildKey(String topic, String key)构建而成，具体为 topic + \\\"#\\\" + messageKey 经过hash（IndexFile#indexKeyHashMethod(String Key)）得到。\",\"注意：这里存在 Hash 冲突的可能，两个 Topic 和 Key 不同的消息可能得到相同的 Hash 值，会导致查询结果错误。社区已经提出这个错误 ISSUE#3613，但目前还并未解决。\",\"Untitled\",\"Value：Hash 冲突时变成链表结构，包含：\",\"消息在 CommitLog 中的物理偏移量，用于到 CommitLog 中查询消息\",\"IndexFile#indexKeyHashMethod(String Key)得到的整数 Hash 值\",\"消息保存时间与索引文件最早消息保存时间的差值，用于搜索时间范围内的消息\",\"指向下一条消息位置的指针（在时间上是前一条，越晚到达的消息在链表越前面）\"]},\"787\":{\"h\":\"3.1.2 存储结构\",\"t\":[\"索引文件底层使用 RocketMQ 的 MappedFile 来存储，索引文件可以有多个，可以无限扩展。\",\"每个索引文件以其创建的时间命名，举例：20211209174133951\",\"每个索引文件被设计为定长的，最多可以保存 500万个 Hash 槽和 2000万个索引项。当保存的数据超过上限时，会创建一个新的索引文件来保存。这就意味着同样 Hash 值的消息可能会被保存到不同的索引文件当中。\",\"RocketMQ的存储文件都遵循一种通用的数据存储格式定义实践：Header + Body，通常 Header 部分是定长的，存放一些基本信息，Body 存放数据。\",\"具体存储结构和内容如图所示：\",\"Untitled\",\"Header 固定大小，包含一些基本信息 \",\"beginTimestamp：最早的消息存储时间（消息存储到 CommitLog 的时间）\",\"endTimestamp：最晚的消息存储时间\",\"beginPhyoffset：存储的消息的最小物理偏移量（在 CommitLog 中的偏移量）\",\"endPhyoffset：存储的消息的最大物理偏移量\",\"hashSlotCount：最大可存储的 hash 槽个数\",\"indexCount：当前已经使用的索引条目个数。注意这个值是从 1 开始的\",\"Hash Slot 部分存储固定数量的 Message Key hash槽（500万个，该数值可以通过 Broker 配置项 maxHashSlotNum 来配置） \",\"存储的每个值是在索引文件中 索引的逻辑下标。因为索引文件的 Header 和 Hash Slot 部分长度都是固定的，每个索引的长度也是固定的，所以可以通过逻辑下标计算出索引项在索引文件中的绝对偏移量\",\"Index Item 部分存储固定数量的索引项（2000万个，该数值可以通过 Broker 配置项 maxIndexNum 来配置）。每个索引项包含如下信息 \",\"Key Hash：消息的 Topic 和 Message Key 经过哈希得到的整数\",\"Commit Log Offset：消息在 CommitLog 中的物理偏移量，用于到 CommitLog 中查询消息\",\"Time Diff：从该索引文件到消息保存时间的时间差（精确到秒），用于根据时间范围查询消息\",\"Next Index Offset：链表下一项的逻辑下标（这里的逻辑下标的含义跟 Hash Slot 中存储的逻辑下标含义相同） \",\"每次插入新的消息，都会从链表的头部插入。链表越往后，消息越老。因为一般来说消息队列会更关心新的消息。\"]},\"788\":{\"h\":\"3.2 索引文件涉及到的类\"},\"789\":{\"h\":\"IndexService\",\"t\":[\"索引服务，用于管理和控制所有索引文件。包括索引文件的加载、创建、刷盘、删除等。是索引文件操作的入口。\",\"private final ArrayList<IndexFile> indexFileList：索引文件列表。\",\"buildIndex(DispatchRequest req)：根据消息分发请求构建索引。注意这里会创建 msgId 的索引和消息 Key 的索引\",\"创建或获取最新的索引文件\",\"调用该索引文件的 IndexFile#putKey 方法创建索引\",\"queryOffset(String topic, String key, int maxNum, long begin, long end)：根据topic和message key，从IndexFile中查找消息。按时间查询：查询保存时间在 begin 到 end 内的消息\",\"从后往前遍历 indexFileList 列表中的索引文件，查找索引对应的 message 符合时间的 IndexFile（[beginTimestamp, endTimestamp] 与 [begin, end] 有交集的索引文件）\",\"调用符合条件的索引文件 IndexFile#selectPhyOffset() 方法查找所有 offset\",\"retryGetAndCreateIndexFile()：获取最新的索引文件，如果不存在，则创建一个新的索引文件。\",\"调用 getAndCreateLastIndexFile() 方法创建或者获取最新的索引文件\",\"创建新索引文件时如果创建失败，会重试创建3次\",\"getAndCreateLastIndexFile()：获取最后一个索引文件。如果没有索引文件或者最后一个索引文件满了，那么创建一个新的文件\",\"检查索引文件列表最后一个文件是否存在以及是否满\",\"如果不存在或者已经满了，创建新的文件，并且把上一个索引文件异步刷盘\",\"如果最后一个文件存在并且未满，直接返回该文件\",\"flush()：将一个索引文件强制刷盘，并且刷新 checkpoint 文件中的 indexMsgTimestamp，checkpoint文件刷盘。\",\"如果开启 MessageStoreConfig#messageIndexSafe 配置项，那么下次 Broker 异常恢复时，会从 checkpoint 保存的 indexMsgTimestamp 即索引文件记录的强制刷盘时间来恢复。\",\"当一个索引文件写满后创建新索引文件时调用，强制将写满的文件刷盘\",\"Untitled\"]},\"790\":{\"h\":\"IndexFile\",\"t\":[\"索引文件，包含索引文件的存储结构和一系列操作。\",\"底层使用内存映射文件 MappedFile 存储。\",\"MappedFile mappedFile：底层存储实现\",\"putKey(final String key, final long phyOffset, final long storeTimestamp)：添加一个索引到索引文件\",\"selectPhyOffset(final List<Long> phyOffsets, final String key, final int maxNum, final long begin, final long end, boolean lock)：从该索引文件中根据 Key 查找索引对应的 offset\"]},\"791\":{\"h\":\"4. 源码解析\"},\"792\":{\"h\":\"4.1 IndexService\"},\"793\":{\"h\":\"4.1.1 创建\",\"t\":[\"load：重新加载索引文件\",\"/** * 重新加载索引文件 * * @param lastExitOK 上次是否是正常退出 * @return 加载是否成功 */ public boolean load(final boolean lastExitOK) { File dir = new File(this.storePath); File[] files = dir.listFiles(); if (files != null) { // ascending order, 将索引文件按照创建时间升序排序 Arrays.sort(files); for (File file : files) { // 依次加载每个索引文件 try { IndexFile f = new IndexFile(file.getPath(), this.hashSlotNum, this.indexNum, 0, 0); f.load(); // 如果上一次是异常退出，则删除check point之后的所有索引文件 if (!lastExitOK) { if (f.getEndTimestamp() > this.defaultMessageStore.getStoreCheckpoint().getIndexMsgTimestamp()) { f.destroy(0); continue; } } this.indexFileList.add(f); } catch // ... } } return true; } \",\"getAndCreateLastIndexFile()：获取最后一个索引文件，如果集合为空或者最后一个文件写满了，则新建一个文件 \",\"先判断文件是否存在、是否写满\",\"如果不存在或者最后一个文件写满，则创建一个文件\",\"如果存在，直接返回该文件\",\"如果创建了新文件，启动一个线程将前一个写满的文件异步刷盘。 \",\"刷盘线程会将该文件刷盘\",\"然后更新 StoreCheckpoint#indexMsgTimestamp 为该写满的索引文件中 indexHeader 的 endTimestamp\",\"/** * 获取最后一个索引文件，如果集合为空或者最后一个文件写满了，则新建一个文件<br> * 只有一个线程调用，所以不存在写竟争问题 */ public IndexFile getAndCreateLastIndexFile() { IndexFile indexFile = null; IndexFile prevIndexFile = null; long lastUpdateEndPhyOffset = 0; long lastUpdateIndexTimestamp = 0; // 先尝试使用读锁 { this.readWriteLock.readLock().lock(); // 判断文件列表是否为空 if (!this.indexFileList.isEmpty()) { IndexFile tmp = this.indexFileList.get(this.indexFileList.size() - 1); // 判断最后一个文件是否写满 if (!tmp.isWriteFull()) { indexFile = tmp; } else { lastUpdateEndPhyOffset = tmp.getEndPhyOffset(); lastUpdateIndexTimestamp = tmp.getEndTimestamp(); prevIndexFile = tmp; } } this.readWriteLock.readLock().unlock(); } // 如果文件列表为空或者最后一个文件写满了，使用写锁创建文件 if (indexFile == null) { try { String fileName = this.storePath + File.separator + UtilAll.timeMillisToHumanString(System.currentTimeMillis()); indexFile = new IndexFile(fileName, this.hashSlotNum, this.indexNum, lastUpdateEndPhyOffset, lastUpdateIndexTimestamp); this.readWriteLock.writeLock().lock(); this.indexFileList.add(indexFile); } catch (Exception e) { log.error(\\\"getLastIndexFile exception \\\", e); } finally { this.readWriteLock.writeLock().unlock(); } // 每创建一个新文件，前一个文件异步刷盘 if (indexFile != null) { final IndexFile flushThisFile = prevIndexFile; Thread flushThread = new Thread(new Runnable() { @Override public void run() { IndexService.this.flush(flushThisFile); } }, \\\"FlushIndexFileThread\\\"); flushThread.setDaemon(true); flushThread.start(); } } return indexFile; } \"]},\"794\":{\"h\":\"4.1.2 插入和查询\",\"t\":[\"buildIndex(DispatchRequest req)：根据消息分发请求构建索引。注意这里会创建 msgId 的索引和消息 Key 的索引 \",\"创建或获取最新的索引文件\",\"调用该索引文件的 IndexFile#putKey 方法创建索引 \",\"获取 uniqKey（也就是 msgId），创建索引\",\"获取消息的所有 key，分别创建索引\",\"/** * 根据 DispatchRequest 构建索引 * * @param req 消息存入CommitLog之后重新分发到Index文件的 DispatchRequest */ public void buildIndex(DispatchRequest req) { IndexFile indexFile = retryGetAndCreateIndexFile(); if (indexFile != null) { long endPhyOffset = indexFile.getEndPhyOffset(); DispatchRequest msg = req; String topic = msg.getTopic(); String keys = msg.getKeys(); if (msg.getCommitLogOffset() < endPhyOffset) { return; } // 如果是事务消息的回滚消息，不需要创建索引，直接返回 final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag()); switch (tranType) { case MessageSysFlag.TRANSACTION_NOT_TYPE: case MessageSysFlag.TRANSACTION_PREPARED_TYPE: case MessageSysFlag.TRANSACTION_COMMIT_TYPE: break; case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE: return; } if (req.getUniqKey() != null) { // 创建UniqueKey的索引，也就是msgId的索引 indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey())); if (indexFile == null) { log.error(\\\"putKey error commitlog {} uniqkey {}\\\", req.getCommitLogOffset(), req.getUniqKey()); return; } } // 创建消息key的索引，这里key可以有多个 if (keys != null && keys.length() > 0) { String[] keyset = keys.split(MessageConst.KEY_SEPARATOR); for (int i = 0; i < keyset.length; i++) { String key = keyset[i]; if (key.length() > 0) { indexFile = putKey(indexFile, msg, buildKey(topic, key)); if (indexFile == null) { log.error(\\\"putKey error commitlog {} uniqkey {}\\\", req.getCommitLogOffset(), req.getUniqKey()); return; } } } } } else { log.error(\\\"build index error, stop building index\\\"); } } \",\"queryOffset(String topic, String key, int maxNum, long begin, long end)：根据topic和message key，从IndexFile中查找消息\",\"/** * 根据topic和message key，从IndexFile中查找消息 * * @param topic * @param key * @param maxNum 最大查找消息数量 * @param begin 查找消息最小时间 * @param end 查找消息最大时间 * @return */ public QueryOffsetResult queryOffset(String topic, String key, int maxNum, long begin, long end) { List<Long> phyOffsets = new ArrayList<Long>(maxNum); long indexLastUpdateTimestamp = 0; long indexLastUpdatePhyoffset = 0; maxNum = Math.min(maxNum, this.defaultMessageStore.getMessageStoreConfig().getMaxMsgsNumBatch()); try { this.readWriteLock.readLock().lock(); if (!this.indexFileList.isEmpty()) { // 从后往前遍历IndexFile，查找索引对应的message符合时间的IndexFile for (int i = this.indexFileList.size(); i > 0; i--) { IndexFile f = this.indexFileList.get(i - 1); boolean lastFile = i == this.indexFileList.size(); if (lastFile) { indexLastUpdateTimestamp = f.getEndTimestamp(); indexLastUpdatePhyoffset = f.getEndPhyOffset(); } if (f.isTimeMatched(begin, end)) { // 最后一个文件需要加锁 f.selectPhyOffset(phyOffsets, buildKey(topic, key), maxNum, begin, end, lastFile); } // 再往前遍历时间更不符合 if (f.getBeginTimestamp() < begin) { break; } if (phyOffsets.size() >= maxNum) { break; } } } } catch (Exception e) { log.error(\\\"queryMsg exception\\\", e); } finally { this.readWriteLock.readLock().unlock(); } return new QueryOffsetResult(phyOffsets, indexLastUpdateTimestamp, indexLastUpdatePhyoffset); } \"]},\"795\":{\"h\":\"4.1.3 过期删除\",\"t\":[\"deleteExpiredFile(long offset)：删除消息CommitLog偏移量offset之前的所有IndexFile文件\"]},\"796\":{\"h\":\"4.1.4 刷盘\",\"t\":[\"flush()：强制刷盘，会把内存映射文件中的数据强制写到磁盘。在一个索引文件写满后调用\",\"/** * 索引文件刷盘，在一个文件写满后调用 * * @param f 需要刷盘的索引文件 */ public void flush(final IndexFile f) { if (null == f) return; long indexMsgTimestamp = 0; if (f.isWriteFull()) { indexMsgTimestamp = f.getEndTimestamp(); } // 索引文件刷盘 f.flush(); // checkpoint文件刷盘 if (indexMsgTimestamp > 0) { this.defaultMessageStore.getStoreCheckpoint().setIndexMsgTimestamp(indexMsgTimestamp); this.defaultMessageStore.getStoreCheckpoint().flush(); } } \"]},\"797\":{\"h\":\"4.2 IndexFile\",\"t\":[\"putKey(final String key, final long phyOffset, final long storeTimestamp)：向索引文件插入新的索引项\",\"根据 key 的 Hash 值计算出 hash槽绝对位置 absSlotPos\",\"获取当前 hash槽的值，为该 hash槽对应的最新的索引的逻辑下标\",\"在 hash槽对应的链表头部插入索引\",\"hash槽指向最新创建的索引的逻辑下标\",\"更新文件头\",\"/** * 向索引文件插入新的索引项 * 如果返回false，表示需要创建新的索引文件 */ public boolean putKey(final String key, final long phyOffset, final long storeTimestamp) { // 判断当前索引数量是否小于最大索引数量，如果小于则直接退出，说明需要创建新的索引文件 if (this.indexHeader.getIndexCount() < this.indexNum) { // 计算key的hash值 int keyHash = indexKeyHashMethod(key); // 获取hash槽位置（下标）。通过 keyHash % hashSlotNum 的方式再次哈希，这里会加大查询消息错误的概率。 int slotPos = keyHash % this.hashSlotNum; // 通过hash槽下表计算出hash槽的绝对位置 int absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize; FileLock fileLock = null; try { // fileLock = this.fileChannel.lock(absSlotPos, hashSlotSize, // false); // 通过hash槽绝对位置，获取hash槽的值，如果有值说明这个hash key已经存在，如果不存在则需要填入 int slotValue = this.mappedByteBuffer.getInt(absSlotPos); if (slotValue <= invalidIndex || slotValue > this.indexHeader.getIndexCount()) { slotValue = invalidIndex; } long timeDiff = storeTimestamp - this.indexHeader.getBeginTimestamp(); timeDiff = timeDiff / 1000; if (this.indexHeader.getBeginTimestamp() <= 0) { timeDiff = 0; } else if (timeDiff > Integer.MAX_VALUE) { timeDiff = Integer.MAX_VALUE; } else if (timeDiff < 0) { timeDiff = 0; } // 计算放置索引的绝对偏移量 int absIndexPos = IndexHeader.INDEX_HEADER_SIZE + this.hashSlotNum * hashSlotSize + this.indexHeader.getIndexCount() * indexSize; // 在链表头部插入最新的索引项 // 将索引存入文件，最后一个是指针，指向下一个链表元素 this.mappedByteBuffer.putInt(absIndexPos, keyHash); this.mappedByteBuffer.putLong(absIndexPos + 4, phyOffset); this.mappedByteBuffer.putInt(absIndexPos + 4 + 8, (int) timeDiff); this.mappedByteBuffer.putInt(absIndexPos + 4 + 8 + 4, slotValue); // 写入hash槽，每个hash槽的值是最新写入的索引文件的逻辑下标 this.mappedByteBuffer.putInt(absSlotPos, this.indexHeader.getIndexCount()); if (this.indexHeader.getIndexCount() <= 1) { this.indexHeader.setBeginPhyOffset(phyOffset); this.indexHeader.setBeginTimestamp(storeTimestamp); } if (invalidIndex == slotValue) { this.indexHeader.incHashSlotCount(); } // 更新索引文件头，索引项个数+1 this.indexHeader.incIndexCount(); this.indexHeader.setEndPhyOffset(phyOffset); this.indexHeader.setEndTimestamp(storeTimestamp); return true; } catch (Exception e) { log.error(\\\"putKey exception, Key: \\\" + key + \\\" KeyHashCode: \\\" + key.hashCode(), e); } finally { if (fileLock != null) { try { fileLock.release(); } catch (IOException e) { log.error(\\\"Failed to release the lock\\\", e); } } } } else { log.warn(\\\"Over index file capacity: index count = \\\" + this.indexHeader.getIndexCount() + \\\"; index max num = \\\" + this.indexNum); } return false; } \",\"selectPhyOffset(final List<Long> phyOffsets, final String key, final int maxNum, final long begin, final long end, boolean lock)：从该索引文件中根据 Key 查找索引对应的 offset \",\"根据 key 的 Hash值计算 hash槽的绝对位置\",\"通过 hash槽中存储的索引逻辑下标，找到索引链表绝对位置\",\"遍历索引链表中的每个索引，获取索引数据，比较时间信息\",\"将时间信息符合搜索条件的索引加入到结果列表中\",\"/** * 从该索引文件中根据key查找offsets * * @param phyOffsets offsets结果列表 * @param key 查找的key * @param maxNum 最大返回结果数量 * @param begin 查找消息的开始时间 * @param end 查找消息的结束时间 * @param lock 查找时是否加锁（已废弃） */ public void selectPhyOffset(final List<Long> phyOffsets, final String key, final int maxNum, final long begin, final long end, boolean lock) { if (this.mappedFile.hold()) { // 根据key的hash值计算hash槽的绝对位置 int keyHash = indexKeyHashMethod(key); int slotPos = keyHash % this.hashSlotNum; int absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize; FileLock fileLock = null; try { if (lock) { // fileLock = this.fileChannel.lock(absSlotPos, // hashSlotSize, true); } // 获取hash槽的值 int slotValue = this.mappedByteBuffer.getInt(absSlotPos); // if (fileLock != null) { // fileLock.release(); // fileLock = null; // } // 如果该hash槽的值有效则查找，否则查找失败 if (slotValue <= invalidIndex || slotValue > this.indexHeader.getIndexCount() || this.indexHeader.getIndexCount() <= 1) { } else { for (int nextIndexToRead = slotValue; ; ) { if (phyOffsets.size() >= maxNum) { break; } int absIndexPos = IndexHeader.INDEX_HEADER_SIZE + this.hashSlotNum * hashSlotSize + nextIndexToRead * indexSize; int keyHashRead = this.mappedByteBuffer.getInt(absIndexPos); long phyOffsetRead = this.mappedByteBuffer.getLong(absIndexPos + 4); long timeDiff = (long) this.mappedByteBuffer.getInt(absIndexPos + 4 + 8); int prevIndexRead = this.mappedByteBuffer.getInt(absIndexPos + 4 + 8 + 4); if (timeDiff < 0) { break; } timeDiff *= 1000L; long timeRead = this.indexHeader.getBeginTimestamp() + timeDiff; boolean timeMatched = (timeRead >= begin) && (timeRead <= end); if (keyHash == keyHashRead && timeMatched) { phyOffsets.add(phyOffsetRead); } if (prevIndexRead <= invalidIndex || prevIndexRead > this.indexHeader.getIndexCount() || prevIndexRead == nextIndexToRead || timeRead < begin) { break; } nextIndexToRead = prevIndexRead; } } } catch (Exception e) { log.error(\\\"selectPhyOffset exception \\\", e); } finally { if (fileLock != null) { try { fileLock.release(); } catch (IOException e) { log.error(\\\"Failed to release the lock\\\", e); } } this.mappedFile.release(); } } \"]},\"798\":{\"h\":\"参考资料\",\"t\":[\"RocketMQ 文档：设计\",\"RocketMQ存储篇——IndexFile和IndexService\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"799\":{\"h\":\"RocketMQ 消息消费 轮询机制 PullRequestHoldService\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220301-rocketmq-longpolling-pullrequestholdservice.html\"]},\"800\":{\"h\":\"1. 概述\",\"t\":[\"先来看看 RocketMQ 消费过程中的轮询机制是啥。首先需要补充一点消费相关的前置知识。\"]},\"801\":{\"h\":\"1.1 消息消费方式\",\"t\":[\"RocketMQ 支持多种消费方式，包括 Push 模式和 Pull 模式\",\"Pull 模式：用户自己进行消息的拉取和消费进度的更新\",\"Push 模式：Broker 将新的消息自动发送给用户进行消费\"]},\"802\":{\"h\":\"1.2 Push 消费模式\",\"t\":[\"我们一般使用 RocketMQ 时用的是 Push 模式，因为比较方便，不需要手动拉取消息和更新消费进度。\",\"那么你有没有想过 Push 模式是如何做到能够立即消费新的消息？\"]},\"803\":{\"h\":\"1.2.1 Push 模式原理\",\"t\":[\"实际上，在 Push 消费时，消费者是在不断轮询 Broker，询问是否有新消息可供消费。一旦有新消息到达，马上拉取该消息。也就是说 Push 模式内部也用了 Pull 消息的模式，这样就可以立即消费到最新的消息。\"]},\"804\":{\"h\":\"1.3 如何进行轮询？\",\"t\":[\"那么 Push 模式或 Pull 模式如何进行消息的查询？\",\"能够想到的比较笨的方法是，每隔一定的时间（如1ms）就向 Broker 发送一个查询请求，如果没有新消息则立刻返回。可想而知这种方法非常浪费网络资源。\",\"RocketMQ 为了提高网络性能，在拉取消息时如果没有新消息，不会马上返回，而是会将该查询请求挂起一段时间，然后再重试查询。如果一直没有新消息，直到轮询时间超过设定的阈值才会返回。\",\"根据轮询设定的超时阈值大小的不同，RocketMQ 有两种轮询方式，分别为长轮询（默认）和短轮询。\"]},\"805\":{\"h\":\"1.4 长轮询和短轮询\",\"t\":[\"RocketMQ 的 Broker 端参数 longPollingEnable 可以配置轮询方式，默认为 true\",\"短轮询：longPollingEnable=false，轮询时间为 shortPollingTimeMills ，默认为 1s\",\"长轮询：longPollingEnable=true，轮询时间为 5s。拉取请求挂起时间：受 DefaultMQPullConsumer 的 brokerSuspendMaxTimeMillis 控制，默认push模式固定15s，pull模式固定20s。\"]},\"806\":{\"h\":\"2. 概要流程\",\"t\":[\"https://raw.githubusercontent.com/HScarb/drawio-diagrams/main/rocketmq/consume/long_polling_activity.drawio.svg\",\"根据上面的活动图来看一下 RocketMQ 消费时的轮询机制流程\",\"Consumer 发送拉取消息请求\",\"Broker 收到请求后交给请求处理模块处理\",\"尝试从存储的消息中拉取消息\",\"如果能够拉取消息，那么将拉取到的消息直接返回\",\"如果没有拉取到消息，那么根据 Broker 是否支持挂起和是否开启长轮询来判断是否要进行轮询以及进行哪种轮询。 \",\"如果支持挂起，那么会将该拉取请求挂起\",\"长轮询等待 5s\",\"短轮询等待 1s\",\"检查消费队列中是否有新消息到达，如果没有则继续等待，以此循环。如果有新消息，处理挂起的拉取消息请求并返回消费者。\",\"如果没有新消息到达，轮询后会检查每个挂起的拉取请求的挂起时间是否超过挂起时间阈值，如果超过那么也会直接返回消费者，否则继续循环进行轮询操作。\",\"那么按照上述流程，开启长轮询的情况下，如果一次轮询没有找到消息，要等待 5s 才能进行下一次查询。如果这 5s 当中有新的消息存入，如何保证能够立刻消费到？\",\"解决方案不难想到，就是新的消息写入后，主动进行通知，让挂起的拉取请求立刻进行拉取操作。\",\"RocketMQ 就是这么做的，在消息存入 CommitLog 后的 doReput 方法中，会判断是否是长轮询，如果是则会发送一个通知，让挂起的拉取请求立刻进行处理。\"]},\"807\":{\"h\":\"3. 详细流程\"},\"808\":{\"h\":\"3.1 涉及到的类\"},\"809\":{\"h\":\"3.1.1 PullMessageProcessor\",\"t\":[\"该类是 Broker 处理 Consumer 拉取清求的入口类。当 Broker 收到 Consumer 发送的拉取请求时，调用该类的 processRequest 方法\"]},\"810\":{\"h\":\"3.1.2 PullRequestHoldService\",\"t\":[\"长轮询请求管理线程，挂起的拉取请求会在这里进行保存。每等待一段时间（长轮询/短轮询等待时间）会检查挂起的请求中是否有可以进行拉取的数据。\"]},\"811\":{\"h\":\"3.1.3 DefaultMessageStore#ReputMessageService\",\"t\":[\"该线程负责将存储到 CommitLog 的消息重新转发，用以生成 ConsumeQueue 和 IndexFile 索引。在生成索引之后，会向长轮询线程发送提醒，立刻唤醒相应队列的拉取请求，执行消息拉取。\"]},\"812\":{\"h\":\"3.2 时序图\",\"t\":[\"https://raw.githubusercontent.com/HScarb/drawio-diagrams/main/rocketmq/consume/long_polling_sequence.drawio.svg\",\"着重体现了长轮询逻辑，其他逻辑有所省略\",\"消费者调用 pullKernelImpl() 发送拉取请求，调用时用 brokerSuspendMaxTimeMillis 指定了 Broker 挂起的最长时间，默认为 20s\",\"Broker 中 PullMessageProcess 处理拉取请求，从 ConsumeQueue 中查询消息\",\"如果没有查询到消息，判断是否启用长轮询，调用 PullRequestHoldService#suspendPullRequest() 方法将该请求挂起\",\"PullRequestHoldService 线程 run() 方法循环等待轮询时间，然后周期性调用 checkHoldRequest() 方法检查挂起的请求是否有消息可以拉取\",\"如果检查到有新消息可以拉取，调用 notifyMessageArriving() 方法\",\"ReputMessageService 的 doReput() 如果被调用，说明也有新消息到达，需要唤醒挂起的拉取请求。这里也会发送一个 notify，进而调用 notifyMessageArriving() 方法\",\"notifyMessageArriving() 方法中也会查询 ConsumeQueue 的最大 offset，如果确实有新消息，那么将唤醒对应的拉取请求，具体的方法是调用 executeRequestWhenWakeup() 方法\",\"executeRequestWhenWakeup() 方法唤醒拉取请求，调用 processRequest() 方法处理该请求\"]},\"813\":{\"h\":\"3.3 每个类的具体逻辑\"},\"814\":{\"h\":\"3.3.1 PullMessageProcessor\",\"t\":[\"Broker 处理 Consumer 拉取清求的入口类\",\"RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request)：处理 Consumer 拉取请求的入口方法，收到 Consumer 拉取请求时调用。该方法主要完成如下操作\",\"校验\",\"消息过滤\",\"从存储中查询消息\",\"返回响应给 Consumer\",\"如果从存储中没有查询到消息，会将响应码设置为 ResponseCode.PULL_NOT_FOUND，并且启动长轮询\",\"void executeRequestWhenWakeup(Channel channel, final RemotingCommand request)：将 Hold 的拉取请求唤醒，再次拉取消息\",\"该方法在长轮询收到新消息时调用，立即唤醒挂起的拉取请求，然后对这些请求调用 processRequest 方法\",\"何时需要提醒长轮询新消息已经到达？上面说到，在长轮询等待时如果有新消息到达，CommitLog 的 doReput 方法中会进行提醒，最终会调用 executeRequestWhenWakeup 方法\"]},\"815\":{\"h\":\"3.3.2 PullRequestHoldService\",\"t\":[\"该服务线程会从 pullRequestTable 本地缓存变量中取PullRequest请求，检查轮询条件“待拉取消息的偏移量是否小于消费队列最大偏移量”是否成立，如果条件成立则说明有新消息达到Broker端，则通过PullMessageProcessor的executeRequestWhenWakeup()方法重新尝试发起Pull消息的RPC请求\",\"pullRequestTable\",\"private ConcurrentMap<String/* topic@queueId */, ManyPullRequest/* 同一队列积累的拉取请求 */> pullRequestTable = new ConcurrentHashMap<>(1024) \",\"上面是挂起的消息拉取请求容器，它是一个 ConcurrentHashMap，key 是拉取请求的队列，value 是该队列挂起的所有拉取请求。其中 ManyPullRequest 底层是一个 ArrayList，它的 add 方法加了锁。\",\"suspendPullRequest(String topic, int queueId, PullRequest pullRequest)：将 Consumer 拉取请求暂时挂起，会将请求加入到 pullRequestTable 中\",\"checkHoldRequest()：检查所有挂起的拉取请求，如果有数据满足要求，就唤醒该请求，对其执行 PullMessageProcessor#processRequest 方法\",\"run()：线程主循环，每等待一段时间就调用 checkHoldRequest() 方法检查是否有请求需要唤醒。等待的时间根据长轮询/短轮询的配置决定，长轮询等待 5s，短轮询默认等待 1s\",\"notifyMessageArriving()：被 checkHoldRequest() 和 ReputMessageService#doReput() 调用，表示新消息到达，唤醒对应队列挂起的拉取请求\"]},\"816\":{\"h\":\"3.3.3 DefaultMessageStore#ReputMessageService\",\"t\":[\"该服务线程 doReput() 方法会在 Broker 端不断地从数据存储对象 CommitLog 中解析数据并分发请求，随后构建出 ConsumeQueue（逻辑消费队列）和 IndexFile（消息索引文件）两种类型的数据。\",\"同时从本地缓存变量 PullRequestHoldService#pullRequestTable 中，取出挂起的拉起请求并执行。\"]},\"817\":{\"h\":\"4. 源码解析\"},\"818\":{\"h\":\"4.1 PullMessageProcessor\"},\"819\":{\"h\":\"4.1.1 processRequest\",\"t\":[\"如果从存储中没有查询到消息，会将响应码设置为 ResponseCode.PULL_NOT_FOUND，并且启动长轮询\",\"以下三种情况会将响应码设置为ResponseCode.PULL_NOT_FOUND：\",\"NO_MESSAGE_IN_QUEUE：消费队列中没有任何消息\",\"OFFSET_FOUND_NULL：offset未找到任何数据\",\"OFFSET_OVERFLOW_ONE：待拉取偏移量等于队列最大偏移量\",\"/** * 处理客户端请求入口 * * @param channel 网络通道，通过该通道向消息拉取客户端发送响应结果 * @param request 消息拉取请求 * @param brokerAllowSuspend Broker端是否允许挂起，默认true。true：如果未找到消息则挂起。false：未找到消息直接返回消息未找到 * @return 响应 * @throws RemotingCommandException 当解析请求发生异常时 */ private RemotingCommand processRequest(final Channel channel, RemotingCommand request, boolean brokerAllowSuspend) throws RemotingCommandException { // ... switch (response.getCode()) { // ... // 如果从消费队列中未找到新的可以拉取的消息，判断并挂起该拉取请求 case ResponseCode.PULL_NOT_FOUND: // 长轮询 if (brokerAllowSuspend && hasSuspendFlag) { long pollingTimeMills = suspendTimeoutMillisLong; if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) { pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills(); } String topic = requestHeader.getTopic(); long offset = requestHeader.getQueueOffset(); int queueId = requestHeader.getQueueId(); PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills, this.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter); this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest); response = null; break; } // ... } \"]},\"820\":{\"h\":\"4.1.2 executeRequestWhenWakeup\",\"t\":[\"在PullMessageProcessor的executeRequestWhenWakeup()方法中，通过业务线程池pullMessageExecutor，异步提交重新Pull消息的请求任务，即为重新调了一次PullMessageProcessor业务处理器的processRequest()方法，来实现Pull消息请求的二次处理）。\",\"/** * 将Hold的拉取请求唤醒，再次拉取消息 * 该方法调用线程池，因此，不会阻塞 * * @param channel 通道 * @param request Consumer拉取请求 * @throws RemotingCommandException 当远程调用发生异常 */ public void executeRequestWhenWakeup(final Channel channel, final RemotingCommand request) throws RemotingCommandException { Runnable run = new Runnable() { @Override public void run() { try { // 处理Consumer拉取请求，获取返回体 final RemotingCommand response = PullMessageProcessor.this.processRequest(channel, request, false); if (response != null) { response.setOpaque(request.getOpaque()); response.markResponseType(); try { // 将返回体写入channel，返回给Consumer channel.writeAndFlush(response).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if (!future.isSuccess()) { log.error(\\\"processRequestWrapper response to {} failed\\\", future.channel().remoteAddress(), future.cause()); log.error(request.toString()); log.error(response.toString()); } } }); } catch (Throwable e) { log.error(\\\"processRequestWrapper process request over, but response failed\\\", e); log.error(request.toString()); log.error(response.toString()); } } } catch (RemotingCommandException e1) { log.error(\\\"excuteRequestWhenWakeup run\\\", e1); } } }; // 异步执行请求处理和返回 this.brokerController.getPullMessageExecutor().submit(new RequestTask(run, channel, request)); } \"]},\"821\":{\"h\":\"4.2 PullRequestHoldService\"},\"822\":{\"h\":\"4.2.1 suspendPullRequest\",\"t\":[\"/** * 挂起（保存）客户端请求，当有数据的时候触发请求 * * @param topic 主题 * @param queueId 队列编号 * @param pullRequest 拉取消息请求 */ public void suspendPullRequest(final String topic, final int queueId, final PullRequest pullRequest) { // 根据topic和queueId构造map的key String key = this.buildKey(topic, queueId); // map的key如果为空，创建一个空的request队列，填充key和value ManyPullRequest mpr = this.pullRequestTable.get(key); if (null == mpr) { mpr = new ManyPullRequest(); ManyPullRequest prev = this.pullRequestTable.putIfAbsent(key, mpr); if (prev != null) { mpr = prev; } } // 保存该次Consumer拉取请求 mpr.addPullRequest(pullRequest); } \"]},\"823\":{\"h\":\"4.2.2 checkHoldRequest\",\"t\":[\"/** * 检查所有已经挂起的长轮询请求 * 如果有数据满足要求，就触发请求再次执行 */ private void checkHoldRequest() { // 遍历拉取请求容器中的每个队列 for (String key : this.pullRequestTable.keySet()) { String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR); if (2 == kArray.length) { String topic = kArray[0]; int queueId = Integer.parseInt(kArray[1]); // 从store中获取队列的最大偏移量 final long offset = this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId); try { // 根据store中获取的最大偏移量，判断是否有新消息到达，如果有则执行拉取请求操作 this.notifyMessageArriving(topic, queueId, offset); } catch (Throwable e) { log.error(\\\"check hold request failed. topic={}, queueId={}\\\", topic, queueId, e); } } } } \"]},\"824\":{\"h\":\"4.2.3 run\",\"t\":[\"@Override public void run() { log.info(\\\"{} service started\\\", this.getServiceName()); while (!this.isStopped()) { try { // 等待一定时间 if (this.brokerController.getBrokerConfig().isLongPollingEnable()) { // 开启长轮询，每5s判断一次消息是否到达 this.waitForRunning(5 * 1000); } else { // 未开启长轮询，每1s判断一次消息是否到达 this.waitForRunning(this.brokerController.getBrokerConfig().getShortPollingTimeMills()); } long beginLockTimestamp = this.systemClock.now(); // 检查是否有消息到达，可以唤醒挂起的请求 this.checkHoldRequest(); long costTime = this.systemClock.now() - beginLockTimestamp; if (costTime > 5 * 1000) { log.info(\\\"[NOTIFYME] check hold request cost {} ms.\\\", costTime); } } catch (Throwable e) { log.warn(this.getServiceName() + \\\" service has exception. \\\", e); } } log.info(\\\"{} service end\\\", this.getServiceName()); } \"]},\"825\":{\"h\":\"4.2.4 notifyMessageArriving\",\"t\":[\"这个方法在两个地方被调用，如下图所示\",\"Untitled\",\"这个方法是重新唤醒拉取请求的核心方法。调用这个方法，提醒 PullRequestHoldService 线程有新消息到达\",\"我们来看看这个方法具体做了什么\",\"根据 topic 和 queueId 获取挂起的拉取请求列表\",\"从 store 中获取该队列消息的最大offset\",\"遍历该队列的所有拉取请求，符合以下两种条件之一的拉取请求会被处理并返回 \",\"消费队列最大offset比消费者拉取请求的offset大，说明有新的消息可以被拉取，处理该拉取请求\",\"拉取请求挂起时间超过阈值，直接返回消息未找到\",\"如果不满足以上两个条件，那么该拉取请求会重新放回 pullRequestTable，等待下次检查\",\"/** * 当有新消息到达的时候，唤醒长轮询的消费端请求 * * @param topic 消息Topic * @param queueId 消息队列ID * @param maxOffset 消费队列的最大Offset */ public void notifyMessageArriving(final String topic, final int queueId, final long maxOffset, final Long tagsCode, long msgStoreTime, byte[] filterBitMap, Map<String, String> properties) { // 根据topic和queueId从容器中取出挂起的拉取请求列表 String key = this.buildKey(topic, queueId); ManyPullRequest mpr = this.pullRequestTable.get(key); if (mpr != null) { // 获取挂起的拉取请求列表 List<PullRequest> requestList = mpr.cloneListAndClear(); if (requestList != null) { // 预先定义需要继续挂起的拉取请求列表 List<PullRequest> replayList = new ArrayList<PullRequest>(); for (PullRequest request : requestList) { long newestOffset = maxOffset; // 从store中获取该队列消息的最大offset if (newestOffset <= request.getPullFromThisOffset()) { newestOffset = this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId); } // 消费队列最大offset比消费者拉取请求的offset大，说明有新的消息可以被拉取 if (newestOffset > request.getPullFromThisOffset()) { // 消息过滤匹配 boolean match = request.getMessageFilter().isMatchedByConsumeQueue(tagsCode, new ConsumeQueueExt.CqExtUnit(tagsCode, msgStoreTime, filterBitMap)); // match by bit map, need eval again when properties is not null. if (match && properties != null) { match = request.getMessageFilter().isMatchedByCommitLog(null, properties); } if (match) { try { // 会调用PullMessageProcessor#processRequest方法拉取消息，然后将结果返回给消费者 this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(), request.getRequestCommand()); } catch (Throwable e) { log.error(\\\"execute request when wakeup failed.\\\", e); } continue; } } // 查看是否超时，如果Consumer请求达到了超时时间，也触发响应，直接返回消息未找到 if (System.currentTimeMillis() >= (request.getSuspendTimestamp() + request.getTimeoutMillis())) { try { this.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(), request.getRequestCommand()); } catch (Throwable e) { log.error(\\\"execute request when wakeup failed.\\\", e); } continue; } // 当前不满足要求，重新放回Hold列表中 replayList.add(request); } if (!replayList.isEmpty()) { mpr.addPullRequest(replayList); } } } } \"]},\"826\":{\"h\":\"4.3 DefaultMessageStore#ReputMessageService\"},\"827\":{\"h\":\"4.3.1 doReput\",\"t\":[\"private void doReput() { // ... DefaultMessageStore.this.doDispatch(dispatchRequest); // 通知消息消费长轮询线程，有新的消息落盘，立即唤醒挂起的消息拉取请求 if (BrokerRole.SLAVE != DefaultMessageStore.this.getMessageStoreConfig().getBrokerRole() && DefaultMessageStore.this.brokerConfig.isLongPollingEnable() && DefaultMessageStore.this.messageArrivingListener != null) { DefaultMessageStore.this.messageArrivingListener.arriving(dispatchRequest.getTopic(), dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + 1, dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(), dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap()); } \",\"这里调用了 NotifyMessageArrivingListener#arriving() 方法，进而调用 PullRequestHoldService.notifyMessageArriving()。\",\"为什么不直接调用 pullRequestHoldService.notifyMessageArriving() ？因为 doReput 所处的类所在的包是 store，存储包，而 PullRequestHoldService 在 broker 包中\",\"所以需要一个桥梁，就是 NotifyMessageArrivingListener。它在 Broker 初始化 DefaultMessageStore 时被写入 DefaultMessageStore\"]},\"828\":{\"h\":\"4.3.2 NotifyMessageArrivingListener#arriving\",\"t\":[\"public class NotifyMessageArrivingListener implements MessageArrivingListener { @Override public void arriving(String topic, int queueId, long logicOffset, long tagsCode, long msgStoreTime, byte[] filterBitMap, Map<String, String> properties) { // 提醒长轮询请求管理容器，新的消息到达，立刻拉取最新消息 this.pullRequestHoldService.notifyMessageArriving(topic, queueId, logicOffset, tagsCode, msgStoreTime, filterBitMap, properties); } } \"]},\"829\":{\"h\":\"参考资料\",\"t\":[\"源码分析RocketMQ消息PULL-长轮询模式\",\"消息中间件—RocketMQ 消息消费（二）（push 模式实现）\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"830\":{\"h\":\"RocketMQ 延迟消息（定时消息）源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220313-rocketmq-scheduled-message.html\"]},\"831\":{\"h\":\"1. 概述\"},\"832\":{\"h\":\"1.1 定时消息概念\",\"t\":[\"定时消息指发送一条消息，消费者不立即能够消费，而是需要在指定时间进行消费\",\"生产者在发送消息时为消息指定发送时间，或者延迟时间\",\"定时消息指消息发送后，不能立即被消费者消费\",\"当到达指定的发送时间或者延迟相应时间后，消费者才可消费\"]},\"833\":{\"h\":\"1.2 RocketMQ中的定时消息支持\",\"t\":[\"截至目前版本，RocketMQ 不支持任意时间的定时消息，而是提供了18个延迟等级。发送消息时可以从18个延迟等级中选一个，然后这条消息会延迟相应的时间发送。\",\"默认支持的延迟等级为：\",\"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h \",\"可在 Broker 端通过 messageDelayLevel 参数进行配置\",\"需要注意的是 RocketMQ 的定时消息受到 CommitLog 保存时间的限制。也就是说如果 CommitLog 最长保存3天，那么延迟时间最长为3天。\"]},\"834\":{\"h\":\"2. 概要流程\",\"t\":[\"下面讲一下RocketMQ中发送定时消息，Broker处理再到消息被消费的流程\",\"生产者 \",\"生产者发送消息时，用户需在消息属性中设置延迟等级\",\"Broker \",\"Broker 初始化时会创建一个 Topic，专门存放延迟消息。该 Topic 默认有18（延迟等级个数）个 Queue\",\"Broker 启动时，为每个延迟等级都创建一个处理线程。该线程扫描对应的延迟等级 Queue。\",\"Broker 收到消息后，查看属性中是否有延迟等级信息。如果有，则将该消息的 Topic 和 QueueId 分别替换成延迟消息对应的 Topic 和延迟等级对应的 QueueId。\",\"然后将消息真正的 Topic 和 QueueId 放到消息的 properties 属性中\",\"最后将消息保存到磁盘。\",\"延迟消息保存后，会在在其 ConsumeQueue 生成索引（上面说过，每个延迟等级都有一个 Queue）\",\"延迟等级处理线程周期性扫描对应的延迟等级 ConsumeQueue 中是否有到期的消息，如果有则将消息真正的 Topic 和 QueueId 恢复，然后重新投递，如果没有则继续循环扫描\",\"消费者 \",\"当延迟消息被延迟等级处理线程重新投递之后，消费者可以消费到该消息\"]},\"835\":{\"h\":\"3. 详细流程\",\"t\":[\"延迟消息在 Producer 端只需要在消息上额外设置延迟等级即可，所以这里只讨论 Broker 端的流程。\",\"// 在Producer端设置消息为定时消息 Message msg = new Message(); msg.setTopic(\\\"TopicA\\\"); msg.setTags(\\\"Tag\\\"); msg.setBody(\\\"this is a delay message\\\".getBytes()); // 设置延迟level为5，对应延迟1分钟 msg.setDelayTimeLevel(5); producer.send(msg); \"]},\"836\":{\"h\":\"3.1 定时消息涉及到的类\",\"t\":[\"我们先来看一下定时消息涉及到的类分别实现了什么功能\",\"SCHEDULE_TOPIC_XXXX：这是一个 RocketMQ 系统 Topic，在 Broker 启动时会自动创建，专门用来保存还没有到投递时间的定时消息。系统级别的 Topic 无法被消费者消费，所以在被重新投递之前，消费者无法消费到未到期的定时消息。 \",\"它默认有 18 个 Queue，对应18个延迟等级。每个 Queue 都保存所有对应延迟等级的定时消息。\",\"这么设计的原因：延迟消息每个消息的投递时间不确定，Broker 端需要将消息根据投递时间排序后投递。只支持指定时间延迟，并为每个延迟等级设计单独的 Queue 就是为了解决消息排序的问题。这样一来，每个 Queue 中的消息都是按照消息产生的时间顺序发送的。\",\"CommitLog：RocketMQ 消息存储的实现，在定时消息功能中，它主要负责在保存消息时将原消息的 Topic 和 QueueId 替换成定时消息对应的 Topic 和 QueueId。\",\"ConsumeQueue：RocketMQ 的消费队列，用于消费者消费消息。每个队列元素是一个消息的索引，该索引主要包含消息在 CommitLog 中的偏移量。 \",\"消费者消费时查询 ConsumeQueue，一旦发现新的索引项，就可以用该项中的偏移量从 CommitLog 中找到消息并消费。\",\"ScheduleMessageService：实现定时消息延迟投递的主要逻辑。为每个延迟等级的 Queue 创建一个线程，该线程循环扫描对应的 Queue，如果发现到投递时间的消息，则把消息的 Topic 和 QueueId 恢复，然后重新投递到 CommitLog 中。\"]},\"837\":{\"h\":\"3.2 定时消息时序图\",\"t\":[\"DefaultMessageStore 调用 putMessage 方法保存消息，内部调用 CommitLog 保存消息\",\"CommitLog 保存消息时检查是否是延迟消息（是否有 DelayLevel 属性） \",\"如果是，则修改消息的\"]},\"838\":{\"h\":\"3.3 每个类关于定时消息的具体逻辑\"},\"839\":{\"h\":\"3.3.1 CommitLog\",\"t\":[\"putMessage() / AsyncPutMessage()：同步和异步的消息存储函数，Broker 收到消息后存储消息时调用。 \",\"在存盘之前，中检查消息属性中delayLevel > 0来判断是否是定时消息\",\"如果是定时消息，将原消息的 Topic 和 QueueId 替换成定时消息对应的 Topic 和 QueueId；然后将消息真正的 Topic 和 QueueId 存放到消息 properties属性中\",\"将消息存储。之后会根据存储的消息构建消息的索引文件 ConsumeQueue 和 IndexFile\",\"重投递时，会计算出消息的真正投递时间，保存到 ConsumeQueue 索引的 tagsCode 位置。\"]},\"840\":{\"h\":\"3.3.2 ScheduleMessageService\",\"t\":[\"这个类扩展了 ConfigManager，ConfigManager 提供了管理一个配置文件的功能，包含配置文件持久化的函数和重新加载配置文件到内存的函数。\",\"ConcurrentMap<Integer /* level */, Long/* offset */> offsetTable：每个延迟等级扫描的逻辑 offset，会被作为配置文件保存，在启动时从磁盘中加载。\",\"start()：Broker 不为 SLAVE 时，在 Broker 启动时运行。 \",\"从磁盘中加载offsetTable\",\"为每个延迟等级创建一个DeliverDelayedMessageTimerTask，用于周期性扫描延迟等级的消息，将到期的消息重新投递\",\"创建一个周期性定时任务，定时将offsetTable持久化\",\"Timer timer：最初 RocketMQ 使用 Java 的 Timer 来执行定时任务，但是由于 Timer 内部只有一个线程同步执行，无法同时投递多个延迟等级的消息。在 PR#3287 中替换成了 ScheduledExecutorService，用以提高定时消息重投递的性能。\"]},\"841\":{\"h\":\"3.3.3 DeliverDelayedMessageTimerTask\",\"t\":[\"ScheduleMessageService的内部类，扩展了 TimerTask，用以被 Timer 定时调用。（后改成 Runnable，用以被ScheduledExecutorService定时调用）\",\"每个该类对应一个延迟等级的 Queue，负责周期性扫描该 Queue 中是否有到期消息，如果有则将到期消息都投递到 CommitLog，如果没有则等待 0.1s 继续下次扫描。\",\"run()：执行入口，这里没有用 while 循环或者是周期性定时任务来周期执行，而是每次 run() 里面都会执行一个新的定时任务（DeliverDelayedMessageTimerTask），以此来达到周期性执行该任务的效果。\",\"executeOnTimeup()：扫描消息并且检查是否到投递时间的主要逻辑都在这个函数里面，由run()调用\"]},\"842\":{\"h\":\"4. 源码解析\"},\"843\":{\"h\":\"4.1 CommitLog\",\"t\":[\"asyncPutMessage：消息异步保存\",\"在存盘之前，中检查消息属性中delayLevel > 0来判断是否是定时消息\",\"如果是定时消息，将原消息的 Topic 和 QueueId 替换成定时消息对应的 Topic 和 QueueId；然后将消息真正的 Topic 和 QueueId 存放到消息 properties属性中\",\"public CompletableFuture<PutMessageResult> asyncPutMessage(final MessageExtBrokerInner msg) { // ... String topic = msg.getTopic(); int queueId = msg.getQueueId(); final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag()); if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) { // Delay Delivery // 判断是否是定时消息 if (msg.getDelayTimeLevel() > 0) { if (msg.getDelayTimeLevel() > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) { msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()); } // 替换消息的Topic和QueueId为定时消息Topic和延迟等级对应的QueueId topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC; queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel()); // Backup real topic, queueId // 把真正的 Topic 和 QueueId 放到消息属性中 MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic()); MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId())); msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties())); msg.setTopic(topic); msg.setQueueId(queueId); } } // ...消息存储逻辑 } \",\"同步保存消息的方法即是异步方法调用get()，不再赘述\"]},\"844\":{\"h\":\"4.2 ScheduleMessageService\",\"t\":[\"start：延迟消息服务启动\",\"从磁盘中加载offsetTable\",\"为每个延迟等级创建一个DeliverDelayedMessageTimerTask，用于周期性扫描延迟等级的消息，将到期的消息重新投递\",\"创建一个周期性定时任务，定时将offsetTable持久化\",\"public void start() { if (started.compareAndSet(false, true)) { super.load(); this.timer = new Timer(\\\"ScheduleMessageTimerThread\\\", true); for (Map.Entry<Integer, Long> entry : this.delayLevelTable.entrySet()) { Integer level = entry.getKey(); Long timeDelay = entry.getValue(); Long offset = this.offsetTable.get(level); if (null == offset) { offset = 0L; } if (timeDelay != null) { this.timer.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME); } } this.timer.scheduleAtFixedRate(new TimerTask() { @Override public void run() { try { if (started.get()) { ScheduleMessageService.this.persist(); } } catch (Throwable e) { log.error(\\\"scheduleAtFixedRate flush exception\\\", e); } } }, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval()); } } \"]},\"845\":{\"h\":\"4.2.1 DeliverDelayedMessageTimerTask\",\"t\":[\"executeOnTimeup：延迟到期执行\",\"先获延迟等级取对应的 ConsumeQueue，然后根据 offsetTable 中获取的延迟等级对应的 offset（记录这个队列扫描的偏移量）开始扫描后面的消息\",\"从 ConsumeQueue 获取 tagsCode，这里面存的是真正投递时间，跟现在的时间戳比较，来判断该消息是否要投递 \",\"如果现在已经到了投递时间点，投递消息\",\"如果现在还没到投递时间点，继续创建一个定时任务，countdown 秒之后执行，然后 return\",\"等待 0.1s，执行一个新的 DeliverDelayedMessageTimerTask\",\"public void executeOnTimeup() { // 根据delayLevel查找对应的延迟消息ConsumeQueue ConsumeQueue cq = ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(TopicValidator.RMQ_SYS_SCHEDULE_TOPIC, delayLevel2QueueId(delayLevel)); long failScheduleOffset = offset; if (cq != null) { // 根据ConsumeQueue的有效延迟消息逻辑offset，获取所有有效的消息 SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset); if (bufferCQ != null) { try { long nextOffset = offset; int i = 0; ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit(); // 遍历ConsumeQueue中的所有有效消息 for (; i < bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) { // 获取ConsumeQueue索引的三个关键属性 long offsetPy = bufferCQ.getByteBuffer().getLong(); int sizePy = bufferCQ.getByteBuffer().getInt(); long tagsCode = bufferCQ.getByteBuffer().getLong(); if (cq.isExtAddr(tagsCode)) { if (cq.getExt(tagsCode, cqExtUnit)) { tagsCode = cqExtUnit.getTagsCode(); } else { //can't find ext content.So re compute tags code. log.error(\\\"[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}\\\", tagsCode, offsetPy, sizePy); long msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy); tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime); } } // ConsumeQueue里面的tagsCode实际是一个时间点（投递时间点） long now = System.currentTimeMillis(); long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode); nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE); long countdown = deliverTimestamp - now; // 如果现在已经到了投递时间点，投递消息 // 如果现在还没到投递时间点，继续创建一个定时任务，countdown秒之后执行 if (countdown <= 0) { MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset( offsetPy, sizePy); if (msgExt != null) { try { MessageExtBrokerInner msgInner = this.messageTimeup(msgExt); if (TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC.equals(msgInner.getTopic())) { log.error(\\\"[BUG] the real topic of schedule msg is {}, discard the msg. msg={}\\\", msgInner.getTopic(), msgInner); continue; } // 重新投递消息到CommitLog PutMessageResult putMessageResult = ScheduleMessageService.this.writeMessageStore .putMessage(msgInner); // 投递成功 if (putMessageResult != null && putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) { continue; // 投递失败 } else { // XXX: warn and notify me log.error( \\\"ScheduleMessageService, a message time up, but reput it failed, topic: {} msgId {}\\\", msgExt.getTopic(), msgExt.getMsgId()); ScheduleMessageService.this.timer.schedule( new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), DELAY_FOR_A_PERIOD); ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset); return; } } catch (Exception e) { /* * XXX: warn and notify me * msgExt里面的内容不完整 * ，如没有REAL_QID,REAL_TOPIC之类的 * ，导致数据无法正常的投递到正确的消费队列，所以暂时先直接跳过该条消息 */ log.error( \\\"ScheduleMessageService, messageTimeup execute error, drop it. msgExt=\\\" + msgExt + \\\", nextOffset=\\\" + nextOffset + \\\",offsetPy=\\\" + offsetPy + \\\",sizePy=\\\" + sizePy, e); } } } else { // 该条ConsumeQueue索引对应的消息如果未到投递时间，那么创建一个定时任务，到投递时间时执行 // 如果有还未投递的消息，创建定时任务后直接返回 ScheduleMessageService.this.timer.schedule( new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), countdown); ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset); return; } } // end of for // 如果所有消息都已经被投递，那么等待0.1s后重新执行该检查任务 nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE); ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask( this.delayLevel, nextOffset), DELAY_FOR_A_WHILE); ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset); return; } finally { bufferCQ.release(); } } // end of if (bufferCQ != null) else { /* * 索引文件被删除，定时任务中记录的offset已经被删除，会导致从该位置中取不到数据， * 这里直接纠正下一次定时任务的offset为当前定时任务队列的最小值 */ long cqMinOffset = cq.getMinOffsetInQueue(); if (offset < cqMinOffset) { failScheduleOffset = cqMinOffset; log.error(\\\"schedule CQ offset invalid. offset=\\\" + offset + \\\", cqMinOffset=\\\" + cqMinOffset + \\\", queueId=\\\" + cq.getQueueId()); } } } // end of if (cq != null) ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, failScheduleOffset), DELAY_FOR_A_WHILE); } \"]},\"846\":{\"h\":\"5. 更多思考\"},\"847\":{\"h\":\"5.1 为什么不实现任意时间的定时消息？\",\"t\":[\"实现有一定难度 \",\"受到 CommitLog 保存时间限制：现在的延迟消息机制基于 CommitLog，消息到期之后会从 CommitLog 把定时消息查出来重新投递，如果 CommitLog 被删除，那么无法重新投递。\",\"不愿意开源 \",\"为了提供差异化服务（云服务竞争力体现）\"]},\"848\":{\"h\":\"5.2 任意时间定时消息实现？\",\"t\":[\"社区有一个PR，可以实现在 CommitLog 保存时间之内任意时间的延迟消息实现。其实现了一个新的定时消息 Index 文件，用来根据投递时间查询该时间需要投递的消息，解决了定时消息排序的问题。\",\"PR#2290\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"849\":{\"h\":\"RocketMQ 延迟消息（定时消息）4.9.3 版本优化 异步投递支持\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220320-rocketmq-scheduled-message-4.9.3-improve.html\"]},\"850\":{\"h\":\"1. 概述\",\"t\":[\"在 RocketMQ 4.9.3 版本中，@Git-Yang 对延迟消息做了很大的优化，大幅度提升了延迟消息的性能。\",\"其中，PR#3287 将原先用来启动周期性任务的 Timer 改为使用 ScheduledExecutorService，将多延迟等级下同时发送延迟消息的性能提升了 3+ 倍。\",\"本文主要讲解的是另一个改动 PR#3458：支持延迟消息的异步投递。老版本中，延迟消息到期投递到 CommitLog 的动作是同步的，在 Dledger 模式下性能很差。新的改动将延迟消息的到期投递模式改为可配置，使用 BrokerConfig 的 enableScheduleAsyncDeliver 属性进行配置。改成异步投递后，在 Dledger 下的性能提升了 3 倍左右。\",\"本文着重讲解定时消息异步投递的逻辑，老版本的延迟消息流程和源码解析可以看这篇文章：RocketMQ 延迟消息（定时消息）\"]},\"851\":{\"h\":\"2. 改动解析\"},\"852\":{\"h\":\"2.1 将多延迟等级延迟消息扫描和投递的任务从单线程执行改为多线程\",\"t\":[\"这个改动将延迟消息的任务调度器从 Timer 改为 ScheduledExecutorService。\",\"在老版本中，所有 18 个延迟等级的定时消息扫描和投递任务都是由一个 Timer 启动定时任务执行的。Timer 中所有定时任务都是由一个工作线程单线程处理的，如果某个任务处理慢了，后续有新的任务进来，会导致新的任务需要等待前一个任务执行结束。\",\"改为 ScheduledExecutorService 线程池之后多线程处理任务，可以大幅度提高延迟消息处理速度，并且避免多延迟等级消息同时发送时造成的阻塞。\",\"改动后的性能变化，出处：https://github.com/apache/rocketmq/issues/3286\",\"改动前，同时向 4 个延迟等级发送延迟消息，TPS: 657 ​ \",\"改动后，同时向4个延迟等级发送延迟消息，TPS: 2453\",\"改动后，同时向4个延迟等级发送延迟消息\"]},\"853\":{\"h\":\"2.2 支持延迟消息异步投递，提升 Dledger 模式下的投递性能\",\"t\":[\"原本的定时消息投递为单线程同步投递，在 DLedger 模式下存在性能瓶颈。\",\"因为在 DLedger 模式下，主节点的角色会变为 SYNC_MASTER，同步复制。即需要足够多的从节点存储了该消息后，才会向主节点返回写入成功。\",\"本次改动将延迟消息的写入改成可配置同步或异步写入，异步写入在 DLedger 模式下性能提升了 3 倍左右。\"]},\"854\":{\"h\":\"2.2.1 异步投递的注意点\",\"t\":[\"异步投递的两个主要缺点是\",\"无法保证消息投递的顺序\",\"消息可能重复投递\",\"异步投递的注意点\",\"需要做流控，当写入 TPS 过高时，页缓存可能会繁忙；甚至节点内存会被打爆。\",\"可能存在消息可能丢失的情况，比如投递时页缓存繁忙或者其他原因导致一次投递失败。这时候的处理是对失败消息进行重新投递，重试 3 次失败后，阻塞当前延迟等级对应的线程，直到重新投递成功。\"]},\"855\":{\"h\":\"2.2.2 异步投递逻辑\",\"t\":[\"首先回顾一下同步投递的逻辑：每个延迟等级都分配一个线程，不断启动任务去扫描该等级对应的消费队列中是否有到期的消息。如果有则将到期的消息一个个同步投递，投递成功后更新该等级对应的 offset，下个任务从该 offset 开始扫描新的消息。\",\"异步投递的逻辑相比于同步投递有一些不同：\",\"异步投递采用了生产-消费模式，生产和消费的对象是异步投递的任务。生产者线程负责将到期的消息创建投递任务，消费者消费这些任务，根据任务的执行状态来更新 offset 或者重试。 这里引入了一个阻塞队列作为异步投递任务的容器，阻塞队列的大小可以配置，表示可以同时投递的消息数。当队列中投递任务满时触发流控。\",\"将对应延迟等级的消息异步投递时，需要将异步投递的任务放入处理队列。此时，可能由于流控等原因，投递任务未能放入队列，那么等待一会后再次执行扫描-投递逻辑。\",\"消息并不会直接投递成功，所以需要消费者线程从队列中消费并判断这些异步投递任务的状态。如果投递任务已完成，则更新 offset；如果投递异常，则等待一会后重新同步投递；投递成功则更新 offset，投递失败则继续重试。\"]},\"856\":{\"h\":\"3. 异步投递详解\",\"t\":[\"延迟消息的投递逻辑全部在 ScheduleMessageService 类中。\",\"下面以一个延迟等级的处理为例，用图展示一下消息投递线程和任务更新线程的工作流程。\",\"左边是定时消息到期投递线程，右边是投递过程状态更新线程。\"]},\"857\":{\"h\":\"3.1 定时消息投递线程\",\"t\":[\"延迟消息投递服务中维护了一个 offset 表offsetTable，表示每个延迟等级当前投递的消息在 ConsumeQuque 中的逻辑 offset。 它用来在关机恢复时标明扫描开始位置，所以这个表会定期持久化到磁盘中，并且从节点会定期从主节点拉去该表的最新值。\",\"延迟消息处理服务启动时会在 deliverExecutorService 线程池为每个延迟等级创建并执行一个 DeliverDelayedMessageTimerTask 任务，这个任务并不是周期性任务，而是在一个任务的末尾执行下一个任务。这个任务的 executeOnTimeup() 方法即消息投递的逻辑。上图展示的就是该方法中的逻辑。\",\"获取该等级的 ConsumeQueue，依次扫描消息是否到期\",\"如果消息到期，从 CommitLog 中查出该消息的完整信息，从属性中恢复它的真实 Topic 和 QueueId，然后投递。（根据配置同步或者异步投递，这里按异步讲解）\",\"异步消息投递后，投递的过程被放入阻塞队列 deliverPendingTable\",\"如果放入队列失败，表示此时出现流控或者阻塞，需要等待一会然后重新投递\",\"如果全部投递成功，将 offset 更新为当前投递消息的 offset + 1，表示下一次从下一个 offset 开始扫描\"]},\"858\":{\"h\":\"3.2 投递过程状态更新线程\",\"t\":[\"每个延迟等级在 handleExecutorService 线程池中启动了一个状态更新线程，每个线程执行 HandlePutResultTask 任务。同样，这个任务不是周期性任务，而是一个任务末尾启动一个新的任务。\",\"HandlePutResultTask 任务不断从阻塞队列头部获取异步投递过程对象，判断其状态\",\"如果投递成功，更新 offset 和统计数据，并从队列中移除投递任务\",\"如果投递中，无动作\",\"如果投递错误，根据是否配置自动重试来执行重试或者直接跳过\",\"重试投递时采用同步投递，投递成功则更新 offset 和统计数据，然后移除；否则继续重新投递\",\"全部任务扫描完毕后等待一会，执行新的HandlePutResultTask 任务。\"]},\"859\":{\"h\":\"4. 源码解析\"},\"860\":{\"h\":\"4.1 定时消息投递任务\",\"t\":[\"public void executeOnTimeup() { // 根据delayLevel查找对应的延迟消息ConsumeQueue ConsumeQueue cq = ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(TopicValidator.RMQ_SYS_SCHEDULE_TOPIC, delayLevel2QueueId(delayLevel)); if (cq == null) { this.scheduleNextTimerTask(this.offset, DELAY_FOR_A_WHILE); return; } // 根据ConsumeQueue的有效延迟消息逻辑offset，获取所有有效的消息 SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset); if (bufferCQ == null) { long resetOffset; if ((resetOffset = cq.getMinOffsetInQueue()) > this.offset) { log.error(\\\"schedule CQ offset invalid. offset={}, cqMinOffset={}, queueId={}\\\", this.offset, resetOffset, cq.getQueueId()); } else if ((resetOffset = cq.getMaxOffsetInQueue()) < this.offset) { log.error(\\\"schedule CQ offset invalid. offset={}, cqMaxOffset={}, queueId={}\\\", this.offset, resetOffset, cq.getQueueId()); } else { resetOffset = this.offset; } this.scheduleNextTimerTask(resetOffset, DELAY_FOR_A_WHILE); return; } long nextOffset = this.offset; try { int i = 0; ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit(); // 遍历ConsumeQueue中的所有有效消息 for (; i < bufferCQ.getSize() && isStarted(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) { // 获取ConsumeQueue索引的三个关键属性 long offsetPy = bufferCQ.getByteBuffer().getLong(); int sizePy = bufferCQ.getByteBuffer().getInt(); long tagsCode = bufferCQ.getByteBuffer().getLong(); if (cq.isExtAddr(tagsCode)) { if (cq.getExt(tagsCode, cqExtUnit)) { tagsCode = cqExtUnit.getTagsCode(); } else { //can't find ext content.So re compute tags code. log.error(\\\"[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}\\\", tagsCode, offsetPy, sizePy); long msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy); tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime); } } // ConsumeQueue里面的tagsCode实际是一个时间点（投递时间点） long now = System.currentTimeMillis(); long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode); nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE); // 如果现在已经到了投递时间点，投递消息 // 如果现在还没到投递时间点，继续创建一个定时任务，countdown秒之后执行 long countdown = deliverTimestamp - now; if (countdown > 0) { this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE); return; } MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(offsetPy, sizePy); if (msgExt == null) { continue; } MessageExtBrokerInner msgInner = ScheduleMessageService.this.messageTimeup(msgExt); if (TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC.equals(msgInner.getTopic())) { log.error(\\\"[BUG] the real topic of schedule msg is {}, discard the msg. msg={}\\\", msgInner.getTopic(), msgInner); continue; } // 重新投递消息到CommitLog boolean deliverSuc; if (ScheduleMessageService.this.enableAsyncDeliver) { // 异步投递 deliverSuc = this.asyncDeliver(msgInner, msgExt.getMsgId(), offset, offsetPy, sizePy); } else { // 同步投递 deliverSuc = this.syncDeliver(msgInner, msgExt.getMsgId(), offset, offsetPy, sizePy); } // 投递失败（流控、阻塞、投递异常等原因），等待0.1s再次执行投递任务 if (!deliverSuc) { this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE); return; } } nextOffset = this.offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE); } catch (Exception e) { log.error(\\\"ScheduleMessageService, messageTimeup execute error, offset = {}\\\", nextOffset, e); } finally { bufferCQ.release(); } // 该条ConsumeQueue索引对应的消息如果未到投递时间，那么创建一个定时任务，到投递时间时执行 // 如果有还未投递的消息，创建定时任务后直接返回 this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE); } \",\"private boolean asyncDeliver(MessageExtBrokerInner msgInner, String msgId, long offset, long offsetPy, int sizePy) { Queue<PutResultProcess> processesQueue = ScheduleMessageService.this.deliverPendingTable.get(this.delayLevel); //Flow Control 流控，如果阻塞队列中元素数量大于阈值则触发流控 int currentPendingNum = processesQueue.size(); int maxPendingLimit = ScheduleMessageService.this.defaultMessageStore.getMessageStoreConfig() .getScheduleAsyncDeliverMaxPendingLimit(); if (currentPendingNum > maxPendingLimit) { log.warn(\\\"Asynchronous deliver triggers flow control, \\\" + \\\"currentPendingNum={}, maxPendingLimit={}\\\", currentPendingNum, maxPendingLimit); return false; } //Blocked 阻塞，如果有一个投递任务重试 3 次以上，阻塞该延迟等级的消息投递，直到该任务投递成功 PutResultProcess firstProcess = processesQueue.peek(); if (firstProcess != null && firstProcess.need2Blocked()) { log.warn(\\\"Asynchronous deliver block. info={}\\\", firstProcess.toString()); return false; } PutResultProcess resultProcess = deliverMessage(msgInner, msgId, offset, offsetPy, sizePy, true); processesQueue.add(resultProcess); return true; } \"]},\"861\":{\"h\":\"4.2 异步投递过程状态更新任务\",\"t\":[\"public void run() { LinkedBlockingQueue<PutResultProcess> pendingQueue = ScheduleMessageService.this.deliverPendingTable.get(this.delayLevel); PutResultProcess putResultProcess; // 循环获取队列中第一个投递任务，查看其执行状态并执行对应操作 while ((putResultProcess = pendingQueue.peek()) != null) { try { switch (putResultProcess.getStatus()) { case SUCCESS: // 消息投递成功，从队列中移除该投递任务 ScheduleMessageService.this.updateOffset(this.delayLevel, putResultProcess.getNextOffset()); pendingQueue.remove(); break; case RUNNING: // 正在投递，不做操作 break; case EXCEPTION: // 投递出错 if (!isStarted()) { log.warn(\\\"HandlePutResultTask shutdown, info={}\\\", putResultProcess.toString()); return; } log.warn(\\\"putResultProcess error, info={}\\\", putResultProcess.toString()); // onException 方法执行重试 putResultProcess.onException(); break; case SKIP: // 跳过，直接从队列中移除 log.warn(\\\"putResultProcess skip, info={}\\\", putResultProcess.toString()); pendingQueue.remove(); break; } } catch (Exception e) { log.error(\\\"HandlePutResultTask exception. info={}\\\", putResultProcess.toString(), e); putResultProcess.onException(); } } // 等待0.01s，继续下一次扫描 if (isStarted()) { ScheduleMessageService.this.handleExecutorService .schedule(new HandlePutResultTask(this.delayLevel), DELAY_FOR_A_SLEEP, TimeUnit.MILLISECONDS); } } \",\"private void resend() { log.info(\\\"Resend message, info: {}\\\", this.toString()); // Gradually increase the resend interval. try { Thread.sleep(Math.min(this.resendCount++ * 100, 60 * 1000)); } catch (InterruptedException e) { e.printStackTrace(); } try { // 从 CommitLog 中查询消息完整信息 MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(this.physicOffset, this.physicSize); // 如果查询失败，检查重试次数，如果到达 6 次则打印日志并跳过该消息 if (msgExt == null) { log.warn(\\\"ScheduleMessageService resend not found message. info: {}\\\", this.toString()); this.status = need2Skip() ? ProcessStatus.SKIP : ProcessStatus.EXCEPTION; return; } MessageExtBrokerInner msgInner = ScheduleMessageService.this.messageTimeup(msgExt); // 同步投递 PutMessageResult result = ScheduleMessageService.this.writeMessageStore.putMessage(msgInner); // 根据结果更新状态 this.handleResult(result); if (result != null && result.getPutMessageStatus() == PutMessageStatus.PUT_OK) { log.info(\\\"Resend message success, info: {}\\\", this.toString()); } } catch (Exception e) { this.status = ProcessStatus.EXCEPTION; log.error(\\\"Resend message error, info: {}\\\", this.toString(), e); } } \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"862\":{\"h\":\"RocketMQ 过期文件删除机制 源码剖析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220328-rocketmq-expired-file-delete.html\"]},\"863\":{\"h\":\"1. 背景\",\"t\":[\"RocketMQ 的存储文件主要分三种：CommitLog、ConsumeQueue、IndexFile RocketMQ 的过期文件删除机制会定期删除已经过期的存储文件。当磁盘容量告急时，会立刻执行删除，释放磁盘空间。 本文详细分析一下三种存储文件的过期删除机制，避免一些坑。\"]},\"864\":{\"h\":\"2. 概述\",\"t\":[\"CommitLog、ConsumeQueue 和 IndexFile 的过期文件删除逻辑由一个线程统一处理。 这个线程每 10s 进行一次检查，如果符合删除条件，那么会删除这些文件。\",\"ConsumeQueue 和 IndexFile 的检查每 10s 都会进行，会删除 CommitLog 投递的偏移量之前的文件。\",\"CommitLog 的删除比较复杂，当到达每天的删除时间（4 点）或者磁盘空间告急（超过 75%）才会启动删除过期文件；磁盘空间超过 85% 时会强制删除文件，平时不会启动。\"]},\"865\":{\"h\":\"3. 详解\"},\"866\":{\"h\":\"3.1 CommitLog\",\"t\":[\"CommitLog 是一个由多个 1G 大小的内存映射文件组成的文件队列。\",\"CommitLog 每个文件有一个过期时间，由 broker.conf 文件中的 fileReservedTime 控制，默认是 72 小时，即 CommitLog 最后一次写入后 72 小时就过期。\",\"CommitLog 文件删除的条件有以下几种，符合任意一种都会执行删除逻辑\",\"时间到达 Broker 机器时间的 4 点，在 4 点 ~ 5 点这一小时中每 10s 都会进行检查和删除，删除过期的文件。\",\"这里的 4 点指的是 Broker 机器的时间，一些虚机的时间与现实时间不一致，或者时区不一致，导致删除时间并不是现实时间 4 点开始，需要注意。\",\"在磁盘容量达到 75% 时，开启文件删除。此时会删除过期的 CommitLog。一次最多删 10 个，如果删了之后磁盘容量小于 75%，那么等下次到达 75% 时删。\",\"磁盘容量达到 85% 时，开启强制删除，会把没有过期文件也删掉。同样一次最多删 10 个。 \",\"这里的强制删除并不会马上删除未过期的文件，而是先把 CommitLog 队列的第一个文件 shutdown，shutdown 之后的文件如果引用计数大于 0（被其他线程占用），则仍需要等待 intervalForcibly 时间（默认 2 分钟）后才会被删除。也就是说每 2 分钟才会强制删除 1 个文件。\",\"当磁盘容量达到 90% 时，将设置磁盘为不可写，此时会拒绝写入新的消息。\",\"手动删除。设计上预留了手动删除的接口，但实际没有命令能调用。\"]},\"867\":{\"h\":\"3.2 ConsumeQueue\",\"t\":[\"ConsumeQueue 是消费队列文件。每个 Topic 的每个 Queue 都会有一个消费队列（可能包含多个文件），用作保存消息在 CommitLog 中的位置以便消费。\",\"每隔 10s，文件删除线程就会检查所有 ConsumeQueue，删除该 ConsumeQueue 已经投递过的那些文件。\"]},\"868\":{\"h\":\"3.3 IndexFile\",\"t\":[\"IndexFile是消息索引文件，仅仅用于消息的查询。索引文件可以通过 Message Key，查询到消息在 CommitLog 中的物理偏移量，进而从 CommitLog 中查询消息。\",\"每隔 10s，文件删除线程会检查所有的 IndexFile，比较它的最大 offset 和当前已经投递的 CommitLog offset，把消息全部已经投递的 IndexFile 删除。\"]},\"869\":{\"h\":\"4. 源码解析\",\"t\":[\"清理 CommitLog 方法的类是 DefaultMessageStore#CleanCommitLogService，清理 ConsumeQueue 和 IndexFile 共用一个类 DefaultMessageStore#CleanConsumeQueueService，都是 DefaultMessageStore 的内部类。\",\"DefaultMessageStore 启动时调用 start() 方法，会启动过期文件清理的定时任务\",\"private void addScheduleTask() { // 启动定时清理过期文件线程 this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { DefaultMessageStore.this.cleanFilesPeriodically(); } // 初始延迟 60s，之后默认每 10s 执行一次 }, 1000 * 60, this.messageStoreConfig.getCleanResourceInterval(), TimeUnit.MILLISECONDS); // ... } \",\"其中 run() 方法调用 CommitLog 和 ConsumeQueue 的清理方法\",\"private void cleanFilesPeriodically() { this.cleanCommitLogService.run(); this.cleanConsumeQueueService.run(); } \"]},\"870\":{\"h\":\"4.1 CommitLog\",\"t\":[\"先来看一下删除 CommitLog 的条件检查逻辑，触发 CommitLog 清理的条件比较多，满足 3 个条件之一就会触发删除。\",\"且删除分\",\"非强制删除：只删除过期的文件（默认过期时间 72h，该文件最后一次写入过后 72h 过期）\",\"强制删除：会删除未过期的文件\",\"一次最多删除 10 个文件，也就是说每 10s 最多删除 10 个文件。 4 点 ~ 5 点这个小时都是删除文件的时间窗，并不是仅在 4 点删一次。\",\"private void deleteExpiredFiles() { // 本次删除的文件数量 int deleteCount = 0; // 文件保留时间，默认72h。如果超出该时间，则认为是过期文件，可以被删除 long fileReservedTime = DefaultMessageStore.this.getMessageStoreConfig().getFileReservedTime(); // 删除物理文件的时间间隔，默认100ms。在一次删除过程中，删除两个文件的间隔时间 int deletePhysicFilesInterval = DefaultMessageStore.this.getMessageStoreConfig().getDeleteCommitLogFilesInterval(); // 第一次拒绝删除之后能保留文件的最大时间，默认120s。 // 在删除文件时，如果该文件被其他线程占用，会阻止删除，同时在第一次试图删除该文件时记录当前时间戳。 // 在保留时间内，文件可以拒绝删除，超过该时间后，会将引用次数设置为负数，文件将被强制删除。 int destroyMapedFileIntervalForcibly = DefaultMessageStore.this.getMessageStoreConfig().getDestroyMapedFileIntervalForcibly(); // 是满足删除文件的时间（4点） boolean timeup = this.isTimeToDelete(); // 磁盘空间是否不足（75%） boolean spacefull = this.isSpaceToDelete(); // 手动删除是否被触发（触发则会设manualDeleteFileSeveralTimes为20，每执行一次删除方法减少一次） boolean manualDelete = this.manualDeleteFileSeveralTimes > 0; // 满足下列条件之一将继续删除 // 1. 到了设置的每天固定删除时间（4点） // 2. 磁盘空间不充足，默认为75% // 3. executeDeleteFilesManually方法被调用，手工删除文件 if (timeup || spacefull || manualDelete) { if (manualDelete) this.manualDeleteFileSeveralTimes--; // 是否立即强制删除文件（磁盘空间大于85%为true） boolean cleanAtOnce = DefaultMessageStore.this.getMessageStoreConfig().isCleanFileForciblyEnable() && this.cleanImmediately; log.info(\\\"begin to delete before {} hours file. timeup: {} spacefull: {} manualDeleteFileSeveralTimes: {} cleanAtOnce: {}\\\", fileReservedTime, timeup, spacefull, manualDeleteFileSeveralTimes, cleanAtOnce); // 文件保留时间，默认 72，这里转换成小时 fileReservedTime *= 60 * 60 * 1000; // 删除成功的文件数量 deleteCount = DefaultMessageStore.this.commitLog.deleteExpiredFile(fileReservedTime, deletePhysicFilesInterval, destroyMapedFileIntervalForcibly, cleanAtOnce); if (deleteCount > 0) { // 危险情况：磁盘满了，但是又无法删除文件 } else if (spacefull) { log.warn(\\\"disk space will be full soon, but delete file failed.\\\"); } } } \",\"其中 commitLog.deleteExpiredFile() 方法调用了 MappedFileQueue#deleteExpiredFileByTime() 方法\",\"/** * 根据文件过期时间来删除文件 * * @param expiredTime 文件过期时间（过期后保留的时间） * @param deleteFilesInterval 删除两个文件的间隔 * @param intervalForcibly 关闭文件过后多久才能强制删除，默认为2分钟 * @param cleanImmediately 是否强制删除文件 * @return 删除文件数量 */ public int deleteExpiredFileByTime(final long expiredTime, final int deleteFilesInterval, final long intervalForcibly, final boolean cleanImmediately) { Object[] mfs = this.copyMappedFiles(0); if (null == mfs) return 0; int mfsLength = mfs.length - 1; int deleteCount = 0; List<MappedFile> files = new ArrayList<MappedFile>(); if (null != mfs) { for (int i = 0; i < mfsLength; i++) { MappedFile mappedFile = (MappedFile) mfs[i]; // 计算文件应该被删除的时间，等于文件最后修改的时间 + 文件过期时间 long liveMaxTimestamp = mappedFile.getLastModifiedTimestamp() + expiredTime; // 如果文件过期，或开启强制删除，则删除文件 if (System.currentTimeMillis() >= liveMaxTimestamp || cleanImmediately) { if (mappedFile.destroy(intervalForcibly)) { files.add(mappedFile); deleteCount++; // 一次最多删除10个文件 if (files.size() >= DELETE_FILES_BATCH_MAX) { break; } // 每个文件删除间隔 if (deleteFilesInterval > 0 && (i + 1) < mfsLength) { try { Thread.sleep(deleteFilesInterval); } catch (InterruptedException e) { } } } else { break; } } else { //avoid deleting files in the middle break; } } } // 将删除的文件从mappedFiles中移除 deleteExpiredFile(files); return deleteCount; } \",\"其中，真正删除文件是调用了 MappedFile#destroy() 方法\",\"这个方法会先释放 MappedFile 上的引用，再关闭内存映射，然后关闭 fileChannel，最后才能删除该文件。\"]},\"871\":{\"h\":\"4.2 ConsumeQueue\",\"t\":[\"CleanConsumeQueueService 处理 ConsumeQueue 文件的过期删除\",\"先查出当前 CommitLog 的投递 Offset，然后遍历每个 ConsumeQueue，删除小于该 Offset 的 文件。\",\"private void deleteExpiredFiles() { int deleteLogicsFilesInterval = DefaultMessageStore.this.getMessageStoreConfig().getDeleteConsumeQueueFilesInterval(); long minOffset = DefaultMessageStore.this.commitLog.getMinOffset(); if (minOffset > this.lastPhysicalMinOffset) { this.lastPhysicalMinOffset = minOffset; // 删除逻辑队列文件 ConcurrentMap<String, ConcurrentMap<Integer, ConsumeQueue>> tables = DefaultMessageStore.this.consumeQueueTable; for (ConcurrentMap<Integer, ConsumeQueue> maps : tables.values()) { for (ConsumeQueue logic : maps.values()) { int deleteCount = logic.deleteExpiredFile(minOffset); if (deleteCount > 0 && deleteLogicsFilesInterval > 0) { try { Thread.sleep(deleteLogicsFilesInterval); } catch (InterruptedException ignored) { } } } } // 清理 IndexFile // ... } } \"]},\"872\":{\"h\":\"4.3 IndexFile\",\"t\":[\"IndexFile 的过期文件清理也由 CleanConsumeQueueService 处理，删除 CommitLog 偏移量 offset 之前的所有 IndexFile 文件\",\"private void deleteExpiredFiles() { int deleteLogicsFilesInterval = DefaultMessageStore.this.getMessageStoreConfig().getDeleteConsumeQueueFilesInterval(); long minOffset = DefaultMessageStore.this.commitLog.getMinOffset(); if (minOffset > this.lastPhysicalMinOffset) { // 清理 ConsumeQueue // ... // 清理 IndexFile DefaultMessageStore.this.indexService.deleteExpiredFile(minOffset); } } \",\"/** * 删除消息CommitLog偏移量offset之前的所有IndexFile文件 * * @param offset CommitLog偏移量 */ public void deleteExpiredFile(long offset) { Object[] files = null; try { this.readWriteLock.readLock().lock(); if (this.indexFileList.isEmpty()) { return; } // 比较第一个 IndexFile 的最大 offset， 如果小于 offset，说明不需要删除任何文件 long endPhyOffset = this.indexFileList.get(0).getEndPhyOffset(); if (endPhyOffset < offset) { files = this.indexFileList.toArray(); } } catch (Exception e) { log.error(\\\"destroy exception\\\", e); } finally { this.readWriteLock.readLock().unlock(); } // 有文件需要被删除，遍历所有文件，删除所有最大 offset 小于 CommitLog offset 的文件 if (files != null) { List<IndexFile> fileList = new ArrayList<IndexFile>(); for (int i = 0; i < (files.length - 1); i++) { IndexFile f = (IndexFile) files[i]; if (f.getEndPhyOffset() < offset) { fileList.add(f); } else { break; } } this.deleteExpiredFile(fileList); } } \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"873\":{\"h\":\"RocketMQ 如何实现高性能消息读写？\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220410-rocketmq-high-performance-io.html\"]},\"874\":{\"h\":\"背景\",\"t\":[\"RocketMQ 是一个低延迟、金融级稳定的高性能消息队列。它的性能处于消息队列的第一梯队，拥有接近 Kafka 的性能表现，每秒可以处理数十万的消息。那么 RocketMQ 是如何做到这么高的性能的呢？\",\"一方面，RocketMQ 借鉴了 Kafka 的实现，运用顺序读写、页缓存等方案加速了 IO 读写。另一方面，RocketMQ 也有许多不同于 Kafka 的设计，比如使用了内存映射文件的方案进行读写。\",\"下面来详细分析一下 RocketMQ 实现高性能 IO 的几种设计和原理。\"]},\"875\":{\"h\":\"实现现高性能 IO 的手段\"},\"876\":{\"h\":\"1. 顺序读写\",\"t\":[\"磁盘的顺序读写性能要远好于随机读写。因为每次从磁盘读数据时需要先寻址，找到数据在磁盘上的物理位置。对于机械硬盘来说，就是移动磁头，会消耗时间。 顺序读写相比于随机读写省去了大部分的寻址时间，它只需要寻址一次就可以连续读写下去，所以性能比随机读写好很多。\",\"RocketMQ 利用了这个特性。它所有的消息数据都存放在一个无限增长的文件队列 CommitLog 中，CommitLog 是由一组 1G 内存映射文件队列组成的。 写入时就从一个固定位置一直写下去，一个文件写满了就开启一个新文件顺序读写下去。\"]},\"877\":{\"h\":\"1.1 顺序写\",\"t\":[\"为了防止消息存储发生混乱，在多线程写 CommitLog 时会上锁，于是写 CommitLog 就变成了一个串行化的操作，对 CommitLog 完全是顺序写。\",\"RocketMQ 的 ConsumeQueue 按 Topic 和 Queue 维度来保存消息在 CommitLog 中的偏移量，由 CommitLog 文件异步生成。每一个 ConsumeQueue 也是顺序写。\"]},\"878\":{\"h\":\"1.2 读取消息\",\"t\":[\"消费消息时，先查询对应 Topic 和 Queue 的 ConsumeQueue，通过 ConsumeQueue 中保存的消息在 CommitLog 中的位置去 CommitLog 中查询消息。\",\"对于每个 ConsumeQueue 来说，消费的过程都是顺序读。\",\"对于 CommitLog 来说，由于它里面保存的每个 Topic 的消息不是连续的，实际上消费时是一个随机读的过程。\",\"虽然是随机读，但整体还是从旧到新有序读，只要随机的那块区域还在Page Cache的热点范围内，还是可以充分利用Page Cache。\",\"Image\"]},\"879\":{\"h\":\"2. 页缓存（Page Cache）\",\"t\":[\"Page Cache 是操作系统的特性，用于加速文件 I/O。通俗地说，Page Cache 就是操作系统在内存中给磁盘上的文件建立的缓存。无论我们使用什么语言编写的程序，在调用系统的 API 读写文件的时候，并不会直接去读写磁盘上的文件，应用程序实际操作的都是 Page Cache，也就是文件在内存中缓存的副本。\",\"Page Cache 使程序对文件的顺序读写速度几乎接近于内存，因为操作系统会将一部分物理内存用作 Page Cache。\",\"应用程序在写入文件的时候，操作系统会先把数据写入到内存中的 Page Cache，然后通过异步的方式由 pdflush 内核线程将 Cache 内的数据刷盘至物理磁盘上。\",\"读取文件的时候，也是从 Page Cache 中来读取数据，这时候会出现两种可能情况。\",\"Page Cache 中有数据，那就直接读取，这样就节省了从磁盘上读取数据的时间\",\"Page Cache 中没有数据，这时候操作系统会引发一个缺页中断，应用程序的读取线程会被阻塞，操作系统把数据从文件中复制到 Page Cache 中，然后应用程序再从 Page Cache 中继续把数据读出来，这时会真正读一次磁盘上的文件，这个读的过程就会比较慢。\",\"用户的应用程序在使用完某块 Page Cache 后，操作系统并不会立刻就清除这个 Page Cache，而是尽可能地利用空闲的物理内存保存这些 Page Cache，除非系统内存不够用，操作系统才会清理掉一部分 Page Cache。清理的策略一般是 LRU 或它的变种算法，它保留 Page Cache 的逻辑是：优先保留最近一段时间最常使用的那些 Page Cache。\",\"RocketMQ 充分利用了 Page Cache，它 CommitLog 和 ConsumeQueue 在整体上看都是顺序读写。这样，读和写的区域都是被OS智能Cache过的热点区域，不会产生大量缺页（Page Fault）中断而再次读取磁盘，文件的IO几乎等同于内存的IO。\",\"在一台真实的MQ上查看网络和磁盘，即使消息端一直从MQ读取消息，也几乎看不到RMQ进程从磁盘read数据，数据直接从Page Cache经由Socket发送给了Consumer。\"]},\"880\":{\"h\":\"3. MMap\",\"t\":[\"Page Cache 属于内核空间，在用户空间的应用程序无法直接访问，因此数据还需要从内核空间拷贝到用户空间才可以被应用程序访问。\",\"MMap 指内存映射文件，将磁盘上的物理文件直接映射到用户态的内存地址中。使用 MMap 可以减少传统 IO 将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销。\",\"程序虚拟页面直接映射到页缓存上，这样就无需有内核态再往用户态的拷贝，而且也避免了重复数据的产生。并且也不必再通过调用read或write方法对文件进行读写，可以通过映射地址加偏移量的方式直接操作。\",\"Java NIO 中的 FileChannel 提供了 map() 方法可以实现 mmap。FileChannel (文件通道)和 mmap (内存映射) 读写性能比较可以参照这篇文章。\",\"RocketMQ 中，CommitLog 和 ConsumeQueue 的底层都是 MappedFile，内存映射文件。\",\"// MappedFile.java private void init(final String fileName, final int fileSize) throws IOException { // ... try { // 创建 FileChannel this.fileChannel = new RandomAccessFile(this.file, \\\"rw\\\").getChannel(); // 内存映射 this.mappedByteBuffer = this.fileChannel.map(MapMode.READ_WRITE, 0, fileSize); TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize); TOTAL_MAPPED_FILES.incrementAndGet(); // ... } // ... } \"]},\"881\":{\"h\":\"4. 预分配文件\",\"t\":[\"每个 CommitLog 文件的大小默认是 1G，当超过大小限制的时候需要准备新的文件，而 RocketMQ 起了一个后台线程 AllocateMappedFileService，该线程应用了生产-消费模式，不断的消费 AllocateRequest。AllocateRequest 其实就是文件预分配的请求。\",\"AllocateMappedFileService 会提前准备好下一个文件的分配，包括预热该文件。防止在消息写入的过程中分配文件，产生抖动。其每次最多预分配 2 个文件。\"]},\"882\":{\"h\":\"5. 文件预热\",\"t\":[\"在预分配的 MappedFile 文件创建后，会对其进行预热。为什么需要预热该文件？ 因为通过 mmap 映射，只是建立了进程虚拟内存地址与物理内存地址之间的映射关系，并没有将 Page Cache 加载至内存。读写数据时如果没有命中写 Page Cache 则发生缺页中断，从磁盘重新加载数据至内存，这样会影响读写性能。为了防止缺页异常，阻止操作系统将相关的内存页调度到交换空间（swap space），RocketMQ 通过对文件预热。\",\"// org.apache.rocketmq.store.MappedFile::warmMappedFile public void warmMappedFile(FlushDiskType type, int pages) { ByteBuffer byteBuffer = this.mappedByteBuffer.slice(); int flush = 0; //通过写入 1G 的字节 0 来让操作系统分配物理内存空间，如果没有填充值，操作系统不会实际分配物理内存，防止在写入消息时发生缺页异常 for (int i = 0, j = 0; i < this.fileSize; i += MappedFile.OS_PAGE_SIZE, j++) { byteBuffer.put(i, (byte) 0); // force flush when flush disk type is sync if (type == FlushDiskType.SYNC_FLUSH) { if ((i / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE) >= pages) { flush = i; mappedByteBuffer.force(); } } //prevent gc if (j % 1000 == 0) { Thread.sleep(0); } } //force flush when prepare load finished if (type == FlushDiskType.SYNC_FLUSH) { mappedByteBuffer.force(); } ... // 通过jna将内存页锁定在物理内存中，防止被放入swap分区 this.mlock(); } // org.apache.rocketmq.store.MappedFile::mlock // LibC继承自com.sun.jna.Library，通过jna方法访问一些native的系统调用 public void mlock() { final long beginTime = System.currentTimeMillis(); final long address = ((DirectBuffer) (this.mappedByteBuffer)).address(); Pointer pointer = new Pointer(address); //通过系统调用 mlock 锁定该文件的 Page Cache，防止其被交换到 swap 空间 int ret = LibC.INSTANCE.mlock(pointer, new NativeLong(this.fileSize)); //通过系统调用 madvise 给操作系统建议，说明该文件在不久的将来要被访问 int ret = LibC.INSTANCE.madvise(pointer, new NativeLong(this.fileSize), LibC.MADV_WILLNEED); } \",\"MappedFile.warmMappedFile() 方法即实现文件预热的功能，每个 OS_PAGE 写入一个任意值(这里为0)，也就是说在初始化状态下，这样操作会给每个页产生恰好一次的缺页中断，这样操作系统会分配物理内存并且将物理地址与逻辑地址简历映射关系。\",\"最后配合 jna 方法，传入 mappedByteBuffer 的地址及文件长度，告诉内核即将要访问这部分文件，希望能将这些页面都锁定在物理内存中，不换进行 swapout，从而在后续实际使用这个文件时提升读写性能。\"]},\"883\":{\"h\":\"6. 内存级读写分离 TransientStorePool\",\"t\":[\"为了降低 Page Cache 的压力，RocketMQ 引入了 TransientStorePool 机制，实现了消息读写在内存级别的读写分离（写消息时写堆外内存，读消息时读 Page Cache）。TransientStorePool 作为一个配置开关，默认关闭，由用户配置开启。\",\"默认情况下 TransientStorePool 关闭，消息读写都通过 Page Cache，这样在高并发时 Page Cache 的压力会比较大，容易出现繁忙。\",\"开启 TransientStorePool 后，消息写入时将写入 ByteBuffer.allocateDirect 方式调用直接申请堆外内存中，由异步刷盘线程写入 fileChannel 中（Page Cache），最后进行进行刷盘。消息读取时，因为堆外内存中的数据未提交，被认为是不可信数据，所以只会从 Page Cache 读取。\",\"这样就实现了内存级别的读写分离，写入消息时主要面对堆外内存，读取消息时主要面对 Page Cache。\",\"优点 \",\"因为消息是先写入堆外内存，然后异步写入 Page Cache，此时就可以实现批量化写入\",\"写数据是完全写内存，速度相较于写文件对应的 Page Cache 更快\",\"减少锁的占用，提升效率\",\"缺点 \",\"在 Broker 出问题，异常退出时，已经放入 Page Cache 的数据不会丢失，存储在堆外内存的数据会丢失。所以该特性增大数据丢失的风险。\"]},\"884\":{\"h\":\"参考资料\",\"t\":[\"RocketMQ 官方文档\",\"RocketMQ高性能之底层存储设计\",\"Kafka 和 RocketMQ 底层存储之那些你不知道的事\",\"消息队列高手课——Kafka如何实现高性能IO？\",\"RocketMQ存储实现分析\",\"《RocketMQ 技术内幕：RocketMQ 架构设计与实现原理 第2版》\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"885\":{\"h\":\"RocketMQ 4.9.3 版本 性能优化 源码剖析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220412-rocketmq-4.9.3-performance-improvement.html\"]},\"886\":{\"h\":\"概述\",\"t\":[\"RocketMQ 4.9.1 版本 针对 Broker 做了一系列性能优化，提升了消息发送的 TPS。前文曾就 4.9.1 版本的优化做了深入分析。\",\"在 2022 年的 2 月底，RocketMQ 4.9.3 版本 发布，其对 Broker 做了更进一步的性能优化，本次优化中也包含了生产和消费性能的提升。\",\"本文将会详解 4.9.3 版本中的性能优化点。在 4.9.3 版本中对延迟消息的优化已经在另一篇文章中详解。\",\"本次和上次的性能优化主要由快手的黄理老师提交，在 ISSUE#3585 中集中记录。先来看一下本次性能优化的所有优化项\",\"We have some performance improvements based on 4.9.2\",\"[Part A] eliminate reverse DNS lookup in MessageExt\",\"[Part B] Improve header encode/decode performance\",\"[Part B] Improve RocketMQSerializable performance with zero-copy\",\"[Part C] cache result for parseChannelRemoteAddr()\",\"[Part D] improve performance of createUniqID()\",\"[Part E] eliminate duplicated getNamespace() call when where is no namespace\",\"[Part F] eliminate regex match in topic/group name check\",\"[Part G] [Work in progress] support send batch message with different topic/queue\",\"[Part H] eliminate StringBuilder auto resize in PullRequestHoldService.buildKey() when topic length is greater than 14, this method called twice for each message.\",\"[Part I] Avoid unnecessary StringBuffer resizing and String Formatting\",\"[Part J] Use mmap buffer instead of FileChannel when writing consume queue and slave commit log, which greatly speed up consume tps.\",\"Part K move execution of notifyMessageArriving() from ReputMessageService thread to PullRequestHoldService thread.\",\"These commits almost eliminate bad performance methods in the cpu flame graph in producer side.\",\"下面来逐条剖析\"]},\"887\":{\"h\":\"性能优化\",\"t\":[\"想要优化性能，首先需要找到 RocketMQ 的 Broker 在处理消息时性能损耗的点。使用火焰图可以清晰地看出当前耗时比较多的方法，从耗时较多的方法想办法入手优化，可以更大程度上提升性能。\",\"具体的做法是开启 Broker 的火焰图采样，然后对其进行压测（同时生产和消费），然后观察其火焰图中方法的时间占用百分比，优化占用时间高且可以优化的地方。\"]},\"888\":{\"h\":\"A. 移除 MessageExt 中的反向 DNS 查找\",\"t\":[\"eliminate reverse DNS lookup in MessageExt\",\"#3586\",\"image-20220411212011338\",\"inetAddress.getHostName() 方法中会有反向 DNS 查找，可能耗时较多。于是优化成没有反向 DNS 查找的 getHostString() 方法\",\"（MessageExt#getBornHostNameString() 方法在一个异常流程中被调用，优化此方法其实对性能没有什么提升）\"]},\"889\":{\"h\":\"B.1. 优化 RocketMQ 通信协议 Header 解码性能\",\"t\":[\"[Part B] Improve header encode/decode performance\",\"#3588\",\"（该提交未合入 4.9.3 版本，将于 4.9.4 版本发布）\",\"PartB 有两个提交，其实作用不同，但是由于第二个提交依赖第一个所以只能放到一起\"]},\"890\":{\"h\":\"寻找优化点\",\"t\":[\"RocketMQ 的通信协议定义了各种指令（消息发送、拉取等等）。其中 Header 是协议头，数据是序列化后的json。json 的每个 key 字段都是固定的，不同的通讯请求字段不一样，但是其中有一个 extField 是完全自定义的，每个指令都不一样。所有指令当前共用了一个通用的解析方法 RemotingCommand#decodeCommandCustomHeader，基于反射来解析和设置消息 Header。\",\"// SendMessageRequestHeaderV2 { \\\"code\\\":310, \\\"extFields\\\":{ \\\"f\\\":\\\"0\\\", \\\"g\\\":\\\"1482158310125\\\", \\\"d\\\":\\\"4\\\", \\\"e\\\":\\\"0\\\", \\\"b\\\":\\\"TopicTest\\\", \\\"c\\\":\\\"TBW102\\\", \\\"a\\\":\\\"please_rename_unique_group_name\\\", \\\"j\\\":\\\"0\\\", \\\"k\\\":\\\"false\\\", \\\"h\\\":\\\"0\\\", \\\"i\\\":\\\"TAGS\\\\u0001TagA\\\\u0002WAIT\\\\u0001true\\\\u0002\\\" }, \\\"flag\\\":0, \\\"language\\\":\\\"JAVA\\\", \\\"opaque\\\":206, \\\"version\\\":79 } \",\"上面是一个发送消息的请求 Header。由于各种指令对应的 Header 的 extField 不同，这个解析 Header 方法内部大量使用反射来设置属性，效率很低。而且这个解码方法应用广泛，在 RocketMQ 网络通信时都会用到（如发送消息、拉取消息），所以很有优化的必要。\"]},\"891\":{\"h\":\"优化方案\",\"t\":[\"优化的方案是尽量减少反射的使用，将常用的指令解码方法抽象出来。\",\"这里引入了 FastCodesHeader 接口，只要实现这个接口，解码时就走具体的实现类而不用反射。\",\"然后为生产消息和消费消息的协议单独实现解码方法，内部可以不用反射而是直接进行字段赋值，这样虽然繁琐但是执行速度最快。\",\"// SendMessageRequestHeaderV2.java @Override public void decode(HashMap<String, String> fields) throws RemotingCommandException { String str = getAndCheckNotNull(fields, \\\"a\\\"); if (str != null) { a = str; } str = getAndCheckNotNull(fields, \\\"b\\\"); if (str != null) { b = str; } str = getAndCheckNotNull(fields, \\\"c\\\"); if (str != null) { c = str; } str = getAndCheckNotNull(fields, \\\"d\\\"); if (str != null) { d = Integer.parseInt(str); } // ...... } \"]},\"892\":{\"h\":\"B.2. 提高编解码性能\",\"t\":[\"[Part B] Improve RocketMQSerializable performance with zero-copy\",\"#3588\",\"（该提交未合入 4.9.3 版本，将于 4.9.4 版本发布）\"]},\"893\":{\"h\":\"改动背景\",\"t\":[\"RocketMQ 的协议 Header 序列化协议有俩\",\"RemotingSerializable：内部用 fastjson 进行序列化反序列化，为当前版本使用的序列化协议。\",\"RocketMQSerializable：RocketMQ 实现的序列化协议，性能对比 fastjson 没有决定性优势，当前默认没有使用。\",\"// RemotingCommand.java private static SerializeType serializeTypeConfigInThisServer = SerializeType.JSON; private byte[] headerEncode() { this.makeCustomHeaderToNet(); if (SerializeType.ROCKETMQ == serializeTypeCurrentRPC) { return RocketMQSerializable.rocketMQProtocolEncode(this); } else { return RemotingSerializable.encode(this); } } \"]},\"894\":{\"h\":\"优化方法\",\"t\":[\"这个提交优化了 RocketMQSerializable 的性能，具体的方法是消除了 RocketMQSerializable 中多余的拷贝和对象创建，使用 Netty 的 ByteBuf 替换 Java 的 ByteBuffer，性能更高。\",\"对于写字符串：Netty 的 ByteBuf 有直接 put 字符串的方法 writeCharSequence(CharSequence sequence, Charset charset)，少一次内存拷贝，效率更高。\",\"对于写 Byte：Netty 的 writeByte(int value) 传入一个 int，Java 传入一个字节 put(byte b)。当前 CPU 都是 32 位、64 位的，对 int 处理更高效。\",\"（该改动要在 Producer 和 Consumer 设置使用 RocketMQ 序列化协议才能生效）\",\"System.setProperty(RemotingCommand.SERIALIZE_TYPE_PROPERTY, SerializeType.ROCKETMQ.name()); \",\"提交说明上的 zero-copy 说的不是操作系统层面上的零拷贝，而是对于 ByteBuf 的零拷贝。\",\"在 NettyEncoder 中用 fastEncodeHeader 替换原来的 encodeHeader 方法，直接传入 ByteBuf 进行操作，不需要用 Java 的 ByteBuffer 中转一下，少了一次拷贝。\",\"public void fastEncodeHeader(ByteBuf out) { int bodySize = this.body != null ? this.body.length : 0; int beginIndex = out.writerIndex(); // skip 8 bytes out.writeLong(0); int headerSize; // 如果是 RocketMQ 序列化协议 if (SerializeType.ROCKETMQ == serializeTypeCurrentRPC) { if (customHeader != null && !(customHeader instanceof FastCodesHeader)) { this.makeCustomHeaderToNet(); } // 调用 RocketMQ 序列化协议编码 headerSize = RocketMQSerializable.rocketMQProtocolEncode(this, out); } else { this.makeCustomHeaderToNet(); byte[] header = RemotingSerializable.encode(this); headerSize = header.length; out.writeBytes(header); } out.setInt(beginIndex, 4 + headerSize + bodySize); out.setInt(beginIndex + 4, markProtocolType(headerSize, serializeTypeCurrentRPC)); } \",\"rocketMQProtocolEncode 中直接操作 ByteBuf，没有拷贝和新对象的创建。\",\"public static int rocketMQProtocolEncode(RemotingCommand cmd, ByteBuf out) { int beginIndex = out.writerIndex(); // int code(~32767) out.writeShort(cmd.getCode()); // LanguageCode language out.writeByte(cmd.getLanguage().getCode()); // int version(~32767) out.writeShort(cmd.getVersion()); // int opaque out.writeInt(cmd.getOpaque()); // int flag out.writeInt(cmd.getFlag()); // String remark String remark = cmd.getRemark(); if (remark != null && !remark.isEmpty()) { writeStr(out, false, remark); } else { out.writeInt(0); } int mapLenIndex = out.writerIndex(); out.writeInt(0); if (cmd.readCustomHeader() instanceof FastCodesHeader) { ((FastCodesHeader) cmd.readCustomHeader()).encode(out); } HashMap<String, String> map = cmd.getExtFields(); if (map != null && !map.isEmpty()) { map.forEach((k, v) -> { if (k != null && v != null) { writeStr(out, true, k); writeStr(out, false, v); } }); } out.setInt(mapLenIndex, out.writerIndex() - mapLenIndex - 4); return out.writerIndex() - beginIndex; } \"]},\"895\":{\"h\":\"C. 缓存 parseChannelRemoteAddr() 方法的结果\",\"t\":[\"cache the result of parseChannelRemoteAddr()\",\"#3589\"]},\"896\":{\"h\":\"寻找优化点\",\"t\":[\"image-20220411213226971\",\"从火焰图中可以看到，parseChannelRemoteAddr() 这个方法占用了 5% 左右的总耗时。\",\"这个方法被客户端在发送消息时调用，每次发送消息都会调用到这个方法，这也是他占用如此高 CPU 耗时百分比的原因。\",\"那么这个方法做了什么？Netty 的 Channel 相当于一个 HTTP 连接，这个方法试图从 Channel 中获取远端的地址。\",\"从火焰图上看出，该方法的 toString占用大量时间，其中主要包含了复杂的 String 拼接和处理方法。\",\"那么想要优化这个方法最直接的方式就是——缓存其结果，避免多次调用。\"]},\"897\":{\"h\":\"具体优化方法\",\"t\":[\"Netty 提供了 AttributeKey 这个类，用于将 HTTP 连接的状态保存在 Channel 上。AttributeKey 相当于一个 Key-Value 对，用来存储状态。\",\"要使用 AttributeKey，需要先初始化它的 Key，这样它就可以预先计算 Key 的 HashCode，查询该 Key 的时候效率就很高了。\",\" private static final AttributeKey<String> REMOTE_ADDR_KEY = AttributeKey.valueOf(\\\"RemoteAddr\\\"); \",\"然后优化该方法，第一次调用该方法时尝试从 Channel 上获取属性RemoteAddr，如果获取不到，则调用原来的逻辑去获取并且缓存到该 AttributeKey 中。\",\"image-20220411215152793\",\"修改过后在火焰图上已经几乎看不到该方法的用时。\"]},\"898\":{\"h\":\"D. 提升 createUniqID() 的性能\",\"t\":[\"Improve performance of createUniqID().\",\"#3590\"]},\"899\":{\"h\":\"寻找优化点\",\"t\":[\"image-20220411222721408\",\"createUniqID() 这个方法用于创建消息的全局唯一 ID，在客户端每次发送消息时会调用，为每个消息创建全局唯一 ID。\",\"RocketMQ 中包含两个消息 ID，分别为全局唯一 ID（UNIQUE_ID，消息发送时由客户端生产）和偏移量 ID（offsetMsgId，Broker 保存消息时由保存的偏移量生成），关于这两个 ID 的生成方法和使用可以看丁威老师的 RocketMQ msgId与offsetMsgId释疑。\",\"原本生成全局 ID 的方法将客户端 IP、进程 ID 等信息组合计算生成一个字符串。方法逻辑里面包含了大量字符串和 ByteBuffer 操作，所以耗时较高。\"]},\"900\":{\"h\":\"优化方法\",\"t\":[\"原先的方法实现中，每次调用都会创建 StringBuilder 、ByteBuffer、多个字符串……包含大量字符串操作，字符串操作的 CPU 耗时开销很大。\",\"优化的方法主要通过字符数组运算替代字符串操作，避免多余的字符串对象产生；使用缓存，避免每次调用都重新计算和创建字符串对象。\",\"将原来的 FIX_STRING 字符串换成 char[] 字符数组，然后可以使用 System.arraycopy 替换原来的 StringBuilder 操作，避免多余对象产生。\",\"image-20220411221546009\",\"新增了 void writeInt(char[] buffer, int pos, int value) 和 writeShort(char[] buffer, int pos, int value) 方法，用于写入字符串数组。\",\"image-20220411222306938\",\"原先的 byte2string 方法创建了 char[] 对象和 String 对象，并且 String 对象构造时需要拷贝一遍 char[]。优化之后完全没有新对象产生。\",\"image-20220411222509675\"]},\"901\":{\"h\":\"E. 当没有用到 namespace 时，避免其被多次调用\",\"t\":[\"eliminate duplicated getNamespace() call when where is no namespace\",\"#3591\"]},\"902\":{\"h\":\"寻找优化点\",\"t\":[\"image-20220411223612434\",\"客户端在发送消息时会调用 getNamespace 方法。Namespace 功能在 RocketMQ 中用的很少，它在 4.5.1 版本中被引进，具体可以看 #1120。它的作用是引入 Namespace 的概念，相同名称的 Topic 如果 Namespace 不同，那么可以表示不同的 Topic。\"]},\"903\":{\"h\":\"优化方法\",\"t\":[\"由于大部分情况下都用不到 Namespace，所以可以增加一个判断，如果不用 Namespace，就不走 Namespace 的一些验证和匹配逻辑。\",\"具体的方法很简单，在 ClientConfig 设一个布尔值，用来表示 Namespace 是否初始化（是否使用），如果不使用，则跳过 getNamespace() 方法中后面的逻辑。\",\"image-20220411224424160\"]},\"904\":{\"h\":\"F. 去除 Topic/Group 名称的正则匹配检查\",\"t\":[\"eliminate regex match in topic/group name check\",\"#3594\",\"每次发消息时，无论是客户端还是服务端都需要检查一次这个消息的 Topic/Group 是否合法。检查通过正则表达式匹配来进行，匹配规则很简单，就是检查这个名称的字符是否在一些字符范围内 String VALID_PATTERN_STR = \\\"^[%|a-zA-Z0-9_-]+$\\\"。那么就可以把这个正则表达式匹配给优化掉，使用字符来匹配，将正则匹配简化成位图查表的过程，优化性能。\",\"因为正则表达式匹配的字符编码都在 128 范围内，所以先创建一个位图，大小为 128。\",\"public static final boolean[] VALID_CHAR_BIT_MAP = new boolean[128]; \",\"然后用位图匹配的方式替换正则匹配：检查的字符串的每一个字符是否在位图中。\",\"image-20220411231805018\",\"注意这里有一句\",\"// 将位图从堆复制到栈里（本地变量），提高下面循环的变量访问速度 boolean[] bitMap = VALID_CHAR_BIT_MAP; \",\"将静态变量位图复制到局部变量中，这样做的用意是将堆中的变量复制到栈上（因为局部变量都位于栈），提高下面循环中访问该位图的速度。\",\"栈上存储的数据，很大机会会被虚拟机分配至物理机器的高速寄存器中存储。因而读写效率比从堆内存中读写高很多。\",\"栈上分配的数据，释放时只需要通过移动栈顶指针，就可以随着栈帧出栈而自动销毁。而堆内存的释放由垃圾回收器负责完成，这一过程中整理和回收内存都需要消耗更多的时间。\",\"栈操作可以被 JIT 优化，得到 CPU 指令的加速\",\"栈没有碎片，寻址间距短，可以被 CPU 预测行为\",\"栈无需释放内存和进行随机寻址\"]},\"905\":{\"h\":\"G. 支持发送 batch 消息时支持不同的 Topic/Queue\",\"t\":[\"support send batch message with different topic/queue\",\"该改动依赖 Part.B ，还未提交 PR\"]},\"906\":{\"h\":\"H. 避免无谓的 StringBuilder 扩容\",\"t\":[\"eliminate StringBuilder auto resize in PullRequestHoldService.buildKey() when topic length is greater than 14, this method called twice for each message\",\"#3612\",\"在 Broker 处理消息消费逻辑时，如果长轮询被启用，PullRequestHoldService#buildKey 每条消息会被调用 2 次。长轮询相关逻辑请移步之前的分析\",\"该方法中初始化一个 StringBuilder，默认长度为 16。StringBuilder 会将 Topic 和 QueueId 进行拼接，如果 Topic 名称过长，会造成 StringBuilder 的扩容，内部包含字符串的拷贝。在比较坏的情况下，扩容可能会发生多次。\",\"那么既然已经直到 Topic 的长度，为什么不在 StringBuilder 初始化的时候就设定长度呢？这就是这个优化的改动。\",\"image-20220411232605135\",\"为什么这里是 toipic.length() + 5？因为一般 QueueId 不会超过 4 位数（一个 Topic 下面不会超过 9999 个队列），再加上一个分隔符，得到 5。\"]},\"907\":{\"h\":\"I. 避免无谓的 StringBuffer 扩容和 String 格式化\",\"t\":[\"Avoid unnecessary StringBuffer resizing and String Formatting\",\"#3619\"]},\"908\":{\"h\":\"寻找优化点\",\"t\":[\"从火焰图上看出，在 Broker 处理消息消费消息请求时，有许多 String.format 方法开销非常大，这些方法都是数据统计用的，用来拼接数据统计字典的 Key。可以想办法进行优化。\"]},\"909\":{\"h\":\"优化方法\",\"t\":[\"首先这里面有使用 StringBuffer 拼接的逻辑，也没有预先设定长度，存在扩容可能性。这里也没有多线程的情况，所以改成 StringBuilder，并且先计算好长度，避免扩容。\",\"image-20220411234502755\"]},\"910\":{\"h\":\"J. 在写 ConsumeQueue 和 从节点的 CommitLog 时，使用 MMap 而不是 FileChannel，提升消息消费 TPS\",\"t\":[\"Use MappedByteBuffer instead of FileChannel to write consume queue and slave commitlog.\",\"#3657\",\"当消费的 Queue 数量特别多时（ 600 个），消费的 TPS 跟不上。即在 Queue 比较少时（72 个）消费速度可以跟上生产速度（20W），但是当 Queue 比较多时，消费速度只有 7W。\",\"这个修改可以提升 Queue 特别多时的消费速度。\",\"72 个 Queue，消费速度从 7W 提升到 20W\",\"600 个 Queue，消费速度从 7W 提升到 11W\"]},\"911\":{\"h\":\"寻找优化点\",\"t\":[\"对 Broker 进行采样，发现创建消费索引的 reput 线程中有较大的耗时占比。\",\"从火焰图上可以看出，FileChannel 写数据的耗时占比比较大，有没有办法来优化一下？\"]},\"912\":{\"h\":\"优化方法\",\"t\":[\"我们知道 RocketMQ 写 CommitLog 是利用 MMap 来提升写入速度。但是在写 ConsumeQueue 时原先用的是 FileChannel 来写，于是这里改成也使用 MMap 来写入。\",\"MappedFile.java\",\"image-20220411235301250\",\"image-20220411235759752\",\"具体修改如上两图所示，这样修改之后会影响两个地方：ConsumeQueue （消费索引）的写入和 Slave 节点 CommitLog 的写入\",\"image-20220411235323472\",\"image-20220411235923338\",\"优化过后构建 ConsumeQueue 的时间占比大大减少\"]},\"913\":{\"h\":\"K. 将 notifyMessageArriving() 的调用从 ReputMessageService 线程移到 PullRequestHoldService 线程\",\"t\":[\"move execution of notifyMessageArriving() from ReputMessageService thread to PullRequestHoldService thread\",\"This commit speed up consume qps greatly, in our test up to 200,000 qps.\",\"#3659\",\"（该提交未合入 4.9.3 版本，当前仍未合入）\",\"这一部分其实也是为了优化 Part.J 中所说的消费速度所做的另一个改动。经过 Part.J 的修改，600 队列下的消费 TPS 能够达到 10w（生产 20w）。这个修改将消费 TPS 提升到 20w。\"]},\"914\":{\"h\":\"寻找优化点\",\"t\":[\"依然是通过查看火焰图的方法，查看到构造消费索引的方法中包含了 notifyMessageArriving() 这样一个方法，占用较大快的 CPU 时间。\",\"这个方法具体在 轮询机制 这篇文章中有详细解释。消息消费的轮询机制指的是在 Push 消费时，如果没有新消息不会马上返回，而是挂起一段时间再重试查询。\",\"notifyMessageArriving() 的作用是在收到消息时提醒消费者，有新消息来了可以消费了，这样消费者会马上解除挂起状态开始消费消息。\",\"这里的优化点就是想办法把这个方法逻辑从构建消费索引的逻辑中抽离出去。\"]},\"915\":{\"h\":\"优化方案 1\",\"t\":[\"首先想到的方法是将 notifyMessageArriving() 用一个单独的线程异步调用。于是在 PullRequestHoldService 里面采用生产-消费模式，启动了一个新的工作线程，将 notify 任务扔到一个队列中，让工作线程去处理，主线程直接返回。\",\"工作线程每次从队列中 poll 一批任务，批量进行处理（1000 个）。经过这个改动，TPS 可以上升到 20w，但这带来了另一个问题——消息消费的延迟变高，达到 40+ms。\",\"循环等待 0.1s 直到新消息来唤醒线程\",\"新消息来了创建异步任务并唤醒线程\",\"延迟变高的原因是—— RocketMQ 中 ServiceThread 工作线程的 wakeup() 和 waitForRunning() 是弱一致的，没有加锁而是采用 CAS 的方法，造成多线程情况下可能会等待直到超时。\",\"public void wakeup() { if (hasNotified.compareAndSet(false, true)) { waitPoint.countDown(); // notify } } protected void waitForRunning(long interval) { if (hasNotified.compareAndSet(true, false)) { this.onWaitEnd(); return; } //entry to wait waitPoint.reset(); try { waitPoint.await(interval, TimeUnit.MILLISECONDS); } catch (InterruptedException e) { log.error(\\\"Interrupted\\\", e); } finally { hasNotified.set(false); this.onWaitEnd(); } } \"]},\"916\":{\"h\":\"优化方案 2\",\"t\":[\"这个方案是实际提交的优化方案，方案比较复杂。主要的思想就是将原先的每条消息都通知一次转化为批通知，减少通知次数，减少通知开销以提升性能。\",\"同样用生产-消费模式，为了同时保证低延迟和高吞吐引入了 PullNotifyQueue。生产者和消费者仍然是操作通知任务\",\"生产者线程将消息 put 到队列中，消费者调用 drain 方法消费。\",\"drain 方法中根据消费 TPS 做了判断\",\"如果 TPS 小于阈值，则拉到一个任务马上进行处理\",\"如果 TPS 大于阈值（默认 10w），批量拉任务进行通知。一批任务只需要一次 notify（原先每个消息都会通知一次）。此时会略微增加消费时延，换来的是消费性能大幅提升。\"]},\"917\":{\"h\":\"小结\",\"t\":[\"本文介绍了 RocketMQ 4.9.3 版本中的性能优化，主要优化了消息生产的速度和大量队列情况下消息消费的速度。\",\"优化的步骤是根据 CPU 耗时进行采样形成火焰图，观察火焰图中时间占比较高的方法进行针对性优化。\",\"总结一下用到的优化方法主要有\",\"代码硬编码属性，用代码复杂度换性能\",\"对字符串和字节数组操作时减少创建和拷贝\",\"对于要多次计算的操作，缓存其结果\",\"锁内的操作尽量移动到锁外进行，提前进行计算或者用函数式接口懒加载\",\"使用更高效的容器，如 Netty ByteBuf\",\"使用容器时在初始化时指定长度，避免动态扩容\",\"主流程上的分支操作，使用异步而非同步\",\"对于磁盘 I/O，MMap 和 FileChannel 的选择，需要实际压测，大部分情况下 MMap 速度更快且更稳定；每次写入较大数据长度时（4k 左右） FileChannel 速度才更快。具体压测结果请看 java-io-benchmark\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"918\":{\"h\":\"RocketMQ 实现高性能定时消息\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220412-rocketmq-flexable-scheduled-message.html\"]},\"919\":{\"h\":\"背景\",\"t\":[\"RocketMQ 是阿里孵化的 Apache 顶级开源分布式高可用消息队列。在开源版本中支持延迟消息的功能，但是仅支持几个固定的延迟时间（1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h）。本文介绍如何在 RocketMQ 基础上实现高性能的、任意时间的定时消息。\"]},\"920\":{\"h\":\"定时消息和延迟消息是什么？\",\"t\":[\"定时消息和延迟消息是消息队列中对于消息的基本概念。\",\"定时消息：生产者将消息发送到消息队列服务端，但不期望这条消息马上被投递，而是在当前时间之后的某个时间投递，此时消费者才可以消费到这条消息。\",\"延迟消息：生产者将消息发送到消息队列服务端，但不期望这条消息马上被投递，而是延迟一定时间后投递。\",\"这两个概念虽然感觉起来不同，但是在实际使用中效果是完全相同的：消息到达消息队列服务端后不会马上投递，而是到达某个时间才投递给消费者。也就是说，实现其中一个，就可以达到另一个的效果。\",\"使用定时消息，将消息定时设置为当前时间往后的 X 时间，可以实现延迟消息的效果。 使用延迟消息，如果想要固定时间投递，可以计算投递时间到当前时间的时间差 X，然后设置这条消息延迟 X 时间。\",\"所以本文中所实现的定时消息效果也可以用作延迟消息使用。\"]},\"921\":{\"h\":\"定时消息的需求和应用场景\",\"t\":[\"定时消息在当前的互联网环境中有非常大的需求。\",\"例如电商/网约车等业务中都会出现的订单场景，客户下单后并不会马上付款，但是这个订单也不可能一直开着，因为订单会占用商品/网约车资源。这时候就需要一个机制，在比如 5 分钟后进行一次回调，回调关闭订单的方法。 这个回调的触发可以用分布式定时任务来处理，，但是更好的方法可以是使用消息队列发送一个延迟消息，因为一条消息会比一个分布式定时任务轻量得多。 开启一个消费者消费订单取消 Topic 的消息，收到消息后关闭订单，简单高效。\",\"当用户支付了订单，那么这个订单不再需要被取消，刚才发的延迟消息也不再需要被投递。当然，你可以在消费消息时判断一下订单的状态以确定是否需要关闭，但是这样做会有一次额外的数据库操作。如果可以取消定时消息，那么只要发送一条定时消息取消的命令就可以取消之前发送的定时消息投递。\",\"除此之外，定时消息还能用于更多其他场景，如定时任务触发、等待重试、事件预订等等。\"]},\"922\":{\"h\":\"各大消息队列对定时消息支持的现状\",\"t\":[\"当前各大消息队列和云厂商都对定时消息和延迟消息有一定程度上的支持，但是往往在精度、延迟时间、性能等方面无法都达到完美。\",\"消息队列 / 功能\",\"延迟时间\",\"精度\",\"性能\",\"是否支持取消\",\"Kafka\",\"×\",\"×\",\"×\",\"×\",\"RabbitMQ\",\"一个队列只支持一个延迟时间\",\"低于 RocketMQ\",\"×\",\"Pulser\",\"支持跨度很大的延迟消息\",\"1s\",\"无法支持大规模使用\",\"×\",\"RocketMQ\",\"仅支持固定等级的延迟消息，最大 2 h\",\"1s\",\"接近于 RocketMQ 普通消息性能\",\"×\",\"Amazon SQS\",\"15 分钟内\",\"？\",\"？\",\"×\",\"阿里云 RocketMQ\",\"40 天\",\"1s~2s的延迟误差\",\"接近于 RocketMQ 普通消息性能\",\"×\",\"腾讯云 CMQ\",\"1 小时内\",\"1s\",\"单队列处于飞行状态的消息数限制为2万条\",\"×\",\"华为云 RocketMQ\",\"1 年\",\"0.1s\",\"接近于 RocketMQ 普通消息性能\",\"√\",\"可以看到，4 大主流开源消息队列对定时消息的实现都有局限性，无法达到任意时间定时。\",\"各大云厂商将该功能作为一个竞争力项，支持比较灵活的延迟消息。其中华为云 RocketMQ 支持最长 1 年的延迟消息，且延迟精度能够达到 0.1s 内，同时还具备基本等同于普通消息的性能表现。此外，还支持延迟消息的取消，功能领先所有开源消息队列和云化消息队列。\",\"下面我们将揭开华为云 RocketMQ 任意时间定时消息的面纱，看一看它究竟是怎么实现的。\"]},\"923\":{\"h\":\"设计和实现\",\"t\":[\"在设计定时消息的实现方案前，我的设计目标是——构建定时消息底座，不仅能让业务使用，也能在其之上构建其他服务，如定时任务调度服务；甚至作为 RocketMQ 一些特性的基础，基于定时消息实现如消息重投等功能。作为一个底座，其必须有如下的特点：支持任意时间的定时、高精度、高性能、高可靠。\"]},\"924\":{\"h\":\"难点和取舍\",\"t\":[\"各大开源消息队列和云厂商没有实现完美的定时消息，因为在每个指标上要达到完美，都涉及到其他方面的一些取舍。\",\"延迟时间：一般来说，保存的消息数据都有一个过期时间，如 3 天过期清除，也就是说定时消息延迟时间最大也不能超过这个清除时间。支持更大的延迟时间意味着延迟消息更长的保存时间，也意味着需要单独对定时消息进行存储。\",\"精度：定时消息如何投递？势必会用到类似定时任务地机制。比如每 1s 执行一次定时任务投递这 1s 内的定时消息。定时消息的精度越高就意味着定时任务执行越频繁，计算压力越大，I/O 越频繁。\",\"性能和可靠性：这两个指标往往不能兼得。更高的可靠性意味着消息同步投递、主从同步，那么消息的 TPS 就不可避免地变低。\",\"对于这些取舍，我想说的是：我全都要！\"]},\"925\":{\"h\":\"站在巨人的肩膀上\",\"t\":[\"在实现“全都要” 的定时消息之前，我们先来看一下开源版本 RocketMQ 定时消息的实现，从中可以学习和借鉴需多东西。\",\"开源版本 RocketMQ 的定时消息也是取舍之后的产物。对于单队列支持任意时间定时消息的难点是消息的顺序问题。比如用户先发了一条延迟 1 分钟的消息，随后马上发一条延迟 3 秒的消息，显然延迟 3 秒的消息需要先被投递出去，那么服务端在收到消息后需要对消息进行排序再投递。在 RocketMQ 中，为了保证可靠性，消息是需要落盘的，且对性能和延迟的要求，决定了在服务端对消息进行排序是完全不可接受的。\",\"如何解决排序问题？开源版本的做法是：通过固定几个延迟等级的方式，绕过排序。开源 RocketMQ 设定了 18 个固定延迟时间的延迟等级：1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h。这样，对于每个延迟等级，他们之中的消息顺序就是固定的：先来先投递，后来后投递，从而绕过了排序这个问题。\",\"下面是开源 RocketMQ 延迟消息的流程图\",\"RocketMQ 延迟消息的流程图\",\"RocketMQ 为延迟消息创建了一个内部 Topic，下有 18 个 Queue，对应 18 个延迟等级。收到延迟消息后，不会立即投递到它本该去的 Topic 中，而是投递到延迟消息 Topic 中的对应 Queue。然后的实现十分简单粗暴：为每个 Queue 创建一个线程，循环扫描这个 Queue 里面的消息是否到达投递时间，如果到达则投递到它本该去的 Topic 中。由于每个 Queue 里面消息的延迟等级相同，那么他们的投递就是按顺序的，避免了对延迟消息重新排序。\",\"开源的延迟消息实现经过 4.9.3 版本的优化，已经支持了异步投递，拥有了不错的性能。\",\"但是它仍存在一个致命的问题：不支持 18 个等级之外的延迟时间。日益增长的客户诉求促使我们探究任意时间定时消息的实现。站在开源 RocketMQ 实现的肩膀上，只要能将 18 个等级改为定时任意时间，就可以实现高性能高可靠的定时消息，因为高可靠和高性能都可以依赖 RocketMQ 本身的机制达到。\"]},\"926\":{\"h\":\"存储设计\",\"t\":[\"想要实现任意时间的定时消息，存储设计是最重要的。存储设计面临的两个最大的问题就是\",\"定时消息的顺序：先发送的不一定先投递。\",\"消息存储过期：如果定时消息和普通消息存在一起，那么最大延迟时间还是会受到普通消息文件过期时间的限制。\",\"这两个问题可以通过精心的设计存储方案来解决。\"]},\"927\":{\"h\":\"使用索引文件解决定时消息顺序问题\",\"t\":[\"回想 RocketMQ 的索引文件 IndexFile，它提供了按照消息 Key 查找消息的能力。具体的做法是：它用类似 HashMap 的形式存储了每个消息 Key 下的消息的位置信息，当查询某个 Key 的消息时，可以马上定位到这个 Key 下存储的消息位置信息链表，然后通过位置信息从消息存储文件 CommitLog 中将消息全部信息查出来。\",\"对于定时消息，也可以构建这样一个索引文件，用来快速查找某一时刻需要投递的消息。这样一来，投递消息时只需要借助索引文件就可以查找所有该时刻需要投递的消息，免去了排序的步骤，解决了定时消息顺序问题。\",\"参照 IndexFile，定时消息索引的存储方案设计就变得很简单。索引文件的 Key 即投递的时间段，Value 即该时间段内要投递的所有消息位置信息。\",\"特别提需要确定的几个关键值\",\"索引每个 Key 的时间跨度：1s 的精度我认为太差，一些秒杀场景可能慢 1 秒就没货了，于是决定降低一个数量级—— 0.1s\",\"容量和时间跨度：RocketMQ 中文件存储为内存映射文件，最大不超过 2G，所以每个索引文件不应超过 2G。如果按 TPS 1w 来算，1 小时的索引文件大小就会达到 700M 左右。所以时间跨度定为 1 小时，容量为 3600w。如果超过 3600w 怎么办？把这个文件做成可扩展的文件队列即可。\"]},\"928\":{\"h\":\"消息存储的方案取舍\",\"t\":[\"想要摆脱消息默认过期时间的限制，达到更长的延迟时间，那么只能把定时消息单独存储，投递前永不删除。\",\"如果要单独存储，也有几个选择：使用第三方 K-V 数据库如 RocksDB，或者自研存储。下面来分析一下这几个方案的优缺点\",\"优点\",\"缺点\",\"与普通消息共用存储\",\"无需额外开发\",\"延迟时间受限\",\"RocksDB\",\"延迟时间不限。性能高，开发量较小\",\"引入第三方组件，增加维护成本\",\"自研存储\",\"延迟时间不限。性能高，易于管理，侵入小\",\"开发量大\",\"由前文所说，我们希望实现一个定时消息的底座，不希望将其他第三方组件引入开源 RocketMQ，于是毅然选择自研存储。\",\"自研的存储的目的是为了能够长期保存定时消息，但是一直存着不删也不行。很明显，已经投递的定时消息文件可以被删除，但是如何删除已经投递的定时消息成为一个问题：因为定时消息定时的时间不固定，一个消息文件中可能包含延迟 1s 的和延迟 1 年的消息，那这个文件的删除时间需要在延迟最大的消息投递之后，这显然不是一个好办法。\",\"借鉴之前索引文件的涉及，我们把定时消息存储文件也按投递时间段拆分，例如每一天需要投递的消息保存为一个文件队列，这样就可以在投递完后的第二天把整个文件队列删除。\"]},\"929\":{\"h\":\"存储最终方案\",\"t\":[\"经过上面的分析，最终的存储方案就很明确了：需要新增两种存储，分别是定时消息数据和定时消息索引，如图所示。\"]},\"930\":{\"h\":\"定时消息投递\",\"t\":[\"定时消息的处理逻辑主要分为两个部分：存储和投递。存储已经搞定了，下面我们看看投递的设计。\",\"投递即在定时消息到期后把消息重新投递到 RocketMQ 的普通消息存储 CommitLog 中，让消费者可以消费。为了追求更高的性能，定时消息的投递默认使用异步刷盘的方式。\",\"容易想到使用一个单独的线程来处理投递逻辑，整个流程如下图所示，其中 Scheduled Replay 即定时消息投递线程。\",\"其实在最初还实现了另一种方案：将定时消息直接投递到 ConsumeQueue 中，让其保存消息在定时消息存储中的位点。这样的好处是免去了一次 CommitLog 的存储，减少磁盘占用、性能也更好。但是这种方案在主从同步时会有消息顺序不同的问题：RocketMQ 主从同步只按顺序同步 CommitLog 中的消息，然后依靠 CommitLog 生成的索引顺序就会与 CommitLog 中消息顺序一致。如果直接投递到 ConsumeQueue，从节点上想要同步 ConsumeQueue 就需要在从节点也启动一个 Scheduled Replay 投递线程，在异步投递的情况下顺序可能与主节点不一致，这样就可能造成主从切换后丢失消息。\",\"投递一条消息的逻辑很简单：拿到一个索引项后从中获取定时消息存储位置，从定时消息存储中查出消息，然后保存到 CommitLog 中。但是要实现高性能的定时消息投递，如何处理索引的加载和投递的触发就成为需要深思熟虑的问题。\"]},\"931\":{\"h\":\"预加载到时间轮\",\"t\":[\"对于定时消息的投递，网络上的很多资料都指向一个方案——时间轮。\",\"箭头按顺时针方向以固定频率移动（我们要达到的定时精度为 0.1s，所以频率就是 0.1s 一次），每一次移动称为一个 tick。每个 tick 保存了一个链表，里面是该 tick 需要触发的所有任务。\",\"时间轮常被用做定时器的实现，它最大的优势就是，任务的新增和取消都是 O(1) 时间复杂度，而且只需要一个线程就可以驱动时间轮进行工作。\",\"有了时间轮，我们就可以把每个定时消息的投递作为一个任务，将该 tick 需要投递的消息都查出来放到时间轮里面，随着时间轮跳动就不断地触发投递任务。\",\"时间轮保存在内存里面，这么多消息要投递存不下怎么办？每小时加载下一个小时要投递的消息索引就好了！\",\"0.1s 一个 tick，需要的格子数太多怎么办？用分层时间轮或者哈希时间轮就好了！\",\"这样看来，时间轮看似一个完美的解决方案。那它真的完美吗？它在高性能和大量定时消息的情况下可能引发灾难。\",\"让我们来设想这两个场景\",\"发送了 1000w 某一时刻的定时消息，要同时投递\",\"定时消息和普通消息同时大量投递，导致 Page Cache 繁忙，定时消息投递失败。\",\"第一个场景下，如果按照上述方案，会将 1000w 个索引项加载进内存，内存无法承受会导致程序崩溃。\",\"第二个场景就需要对定时消息的投递做流控和失败重试。\",\"流控和重试意味着任务暂时等待，过一 tick 再执行。也就是说，要把这一 tick 中的任务拿出来放到下一 tick，如果此时流控还没有解除，那要继续进行任务的转移，这样就会造成很多额外的出入队操作。\",\"如果继续优化时间轮的方案未尝不可，但是会有很多工作量。有没有其他可取的方案？\"]},\"932\":{\"h\":\"周期性启动定时任务\",\"t\":[\"开源 RocketMQ 的定时消息实现为我们提供了很好的参照：在 4.9.3 版本的优化后不仅支持高性能异步投递，且实现了流控和投递失败的重投。\",\"在扫描每个延迟等级的队列时具体的逻辑是：\",\"有一个表记录每个队列当前的投递位移\",\"每次启动一个定时任务，从投递位移之后开始扫描消息，如果消息到期则直接投递，如果还未到期则该任务结束。在 0.1s 后会启动一个新的定时任务进行下一次扫描\",\"借鉴这个方法，对于任意时间定时消息的投递，也可以每 0.1s 启动一个新的定时任务，投递这 0.1s 内要投递的消息。这样就可以免去将投递任务加入到时间轮这个操作。对于流控也不需要重新投递这么多任务，而是只需要从上一次投递的时间和偏移量开始一个新的投递任务即可。\",\"如何解决某一时刻投递消息量太大导致的内存问题？限制每个投递任务投递的消息量即可。投递不完则到下个任务继续投。\",\"于是投递的逻辑变成这样：\",\"用[已投递时间]和[已投递位移]两个参数来记录当前投递状态\",\"如果投递速度能跟上，那么下任务会在上个任务 0.1s 后执行\",\"如果投递速度跟不上（某一时刻要投递的定时消息太多，0.1s 内投不完），则不等待直接进行第二个任务\",\"至此，还剩下最后的问题是流控和消息的重投。\"]},\"933\":{\"h\":\"流控\",\"t\":[\"这里需要引入第二个线程：投递任务状态更新线程。对于异步投递，实际上投递方法执行后可以抽象成一个投递任务，在内存中异步投递。那么这里就还需要一个投递任务状态更新线程，扫描投递任务的状态，当投递任务结束时进行一些状态更新。消息投递线程和任务状态更新线程是生产-消费模式的一个实现。\",\"异步投递任务由一个阻塞队列来承载，这个阻塞队列的长度就代表着同时可以的进行异步投递任务的数量。我们可以人为地为阻塞队列设置一个长度上限，当达到上限时说明有过多的异步投递任务还在执行，需要流控。此时，跳出该投递任务，等待一会再开始新一个投递任务。\"]},\"934\":{\"h\":\"重投\",\"t\":[\"如果消息投递失败了且不做任何处理，这条定时消息就会丢失。在 RocketMQ 这样高可靠的消息队列中，消息的丢失是不能被接收的，所以异常消息的重投就十分重要。\",\"当前的做法是在投递任务状态更新线程扫描到状态为失败的任务时就开始重新投递该消息，如果多次投递失败会阻塞其他消息的投递，不断重试重投，直到该消息投递成功。\",\"至此，我们完成了任意时间定时消息的设计旅程。在遇见和解决一个一个坑之后实现了高性能高可靠的任意时间定时消息。\"]},\"935\":{\"h\":\"定时消息取消\",\"t\":[\"支持定时也要支持取消，这样才是一个完整的功能。定时消息由于其延迟投递的特性，是有机会在其投递之前“反悔”的。\",\"对比定时消息的实现，取消功能的难度没有那么大，但也要考虑大消息量和高 TPS 下的影响。\",\"实现定时消息取消的实现要点是保存一个需要取消的定时消息 ID 的信息集，每次投递时查询该集来判断是否要投递该消息。这个集合保存在内存中可能会造成内存泄漏，所以保存在磁盘中为妙。但是为取消消息专门创建一个文件来存储又太多余，能不能在现有的消息存储中存储？\",\"当然可以！在每条消息中有一个字段来存储消息的 Flag，可以把取消消息的状态更新到该字段中存储。\",\"最后是取消的触发方式。\",\"在消息队列中，万物皆消息，任何功能都可以用消息来触发。\",\"于是最终决定采用发送一条“取消消息”的方式来触发定时消息的取消。\"]},\"936\":{\"h\":\"小结\",\"t\":[\"本文第一节从定时消息的定义和需求出发，说明了当今企业对消息队列定时消息能力的强烈需求和当下主流消息队列对定时消息能力支持不完美现状。\",\"在第二节中，首先分析了任意时间定时消息实现的难点，然后站在开源 RocketMQ 延迟消息实现的基础上，从存储和投递两个方面详解了华为云 RocketMQ 任意时间定时消息的设计和实现。最后讲解了定时消息取消的设计和实现。\"]},\"937\":{\"h\":\"华为云 RocketMQ 定时消息已经上线\",\"t\":[\"华为云已经上线分布式消息服务 RocketMQ 版任意时间定时消息特性。\",\"任意时间定时消息特性提供领先业界的定时消息体验：\",\"任意时间的定时消息或延迟消息，最长延迟可达 1 年\",\"支持取消已经发送的定时消息\",\"消息投递毫秒级精度\",\"请点击使用。\"]},\"938\":{\"h\":\"参考资料\",\"t\":[\"如何在MQ中实现支持任意延迟的消息？\",\"任意时间延时消息原理讲解：设计与实现\",\"如果有人再问你怎么实现分布式延时消息，这篇文章丢给他\",\"延时消息常见实现方案\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"939\":{\"h\":\"RocketMQ NameServer 详解 源码剖析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220502-rocketmq-nameserver.html\"]},\"940\":{\"h\":\"1. 概述\"},\"941\":{\"h\":\"1.1 NameServer 是什么\",\"t\":[\"NameServer 是组成 RocketMQ 的重要组件之一，是除了 Broker 之外另一个需要部署的服务。设想这样一个问题：RocketMQ 的 Topic 分布在不同的 Broker 上，作为消息的生产者和消费者，如何知道要从哪个 Broker 地址生产或消费消息？如果连接的 Broker 宕机了，如何在不重启的情况下感知？NameServer 就是为了解决这些问题设计的。\",\"NameServer 是一个简单的 Topic 路由注册中心，类似 Kafka、Dubbo 中的 Zookeeper，支持 Broker 的动态注册与发现。主要包含两个功能\",\"Broker 管理：NameServer 接受 Broker 集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查 Broker 是否还存活。\",\"路由信息管理：每个 NameServer 将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后 Producer 和 Conumser 通过 NameServer 就可以知道整个 Broker 集群的路由信息，从而进行消息的投递和消费。\",\"NameServer 通常以集群的方式部署，各实例间相互不进行信息通讯，只是互为备份，达到高可用的效果。RocketMQ 典型的双主双从部署方式如下图所示：\",\"Broker 定期向 NameServer 发送心跳，上报路由信息。客户端（生产者、消费者）定期请求 NameServer 获取最新的路由信息。\"]},\"942\":{\"h\":\"1.2 NameServer 与 Zookeeper\",\"t\":[\"Kafka 在老版本中使用 Zookeeper 作为路由中心，在 3.0 之后的版本也将 Zookeeper 的依赖移除。在早期版本的 RocketMQ 中据说也是使用 Zookeeper 作为路由中心，为什么主流消息队列都抛弃了 Zookeeper 选择自研路由中心呢？\",\"主要原因是 Zookeeper 运行机制复杂、对于 RocketMQ 来说依赖太重，维护和定位问题较困难；而 NameServer 的实现非常轻量级，且具备很高的可靠程度，用于路由发现的场景非常合适。此外还有以下一些原因：\",\"根据 CAP 理论，同时最多只能满足两个点，而 zookeeper 满足的是 CP，也就是说 zookeeper 并不能保证服务的可用性，zookeeper 在进行选举的时候，整个选举的时间太长，期间整个集群都处于不可用的状态，而这对于一个注册中心来说肯定是不能接受的，作为服务发现来说就应该是为可用性而设计。\",\"基于性能的考虑，NameServer 本身的实现非常轻量，而且可以通过增加机器的方式水平扩展，增加集群的抗压能力，而 zookeeper 的写是不可扩展的，而zookeeper 要解决这个问题只能通过划分领域，划分多个zookeeper集群来解决，首先操作起来太复杂，其次这样还是又违反了CAP中的A的设计，导致服务之间是不连通的。\",\"持久化的机制来带的问题，ZooKeeper 的 ZAB 协议对每一个写请求，会在每个 ZooKeeper 节点上保持写一个事务日志，同时再加上定期的将内存数据镜像（Snapshot）到磁盘来保证数据的一致性和持久性，而对于一个简单的服务发现的场景来说，这其实没有太大的必要，这个实现方案太重了。而且本身存储的数据应该是高度定制化的。\",\"消息发送应该弱依赖注册中心，而RocketMQ的设计理念也正是基于此，生产者在第一次发送消息的时候从 NameServer 获取到Broker地址后缓存到本地，如果 NameServer 整个集群不可用，短时间内对于生产者和消费者并不会产生太大影响。\"]},\"943\":{\"h\":\"2. 概要设计\",\"t\":[\"NameServer 仅仅处理其他模块的请求，而不会主动向其他模块发起请求。正如其名字 Server，它其实本质上就是一个 NettyServer。\"]},\"944\":{\"h\":\"2.1 模块\",\"t\":[\"NameServer 的代码并不多，如下所示\",\"它主要有 3 个模块：Topic 路由管理模块（RouteInfoManager）、通信模块（DefaultRequestProcessor、ClusterTestRequestProcessor）、KV 数据存储模块（KVConfigManager)。\",\"RouteInfoManager 中存储 5 个 HashMap，这就是 NameServer 中主要存储的数据。它们仅存在于内存中，并不会持久化。其中数据内容如下：\",\"topicQueueTable：保存 Topic 的队列信息，也是真正的路由信息。队列信息中包含了其所在的 Broker 名称和读写队列数量。\",\"brokerAddrTable：保存 Broker 信息，包含其名称、集群名称、主备 Broker 地址。\",\"clusterAddrTable：保存 Cluster信息，包含每个集群中所有的 Broker 名称列表。\",\"brokerLiveTable：Broker 状态信息，包含当前所有存活的 Broker，和它们最后一次上报心跳的时间。\",\"filterServerTable：Broker 上的 FilterServer 列表，用于类模式消息过滤，该机制在 4.4 版本后被废弃。\",\"RequestProcessor 继承了 AsyncNettyRequestProcessor。作为 NameServer 的请求处理器，根据不同种类的请求做不同类型的处理。 其中 KV_CONFIG 类型的请求用于 KVConfig 模块，当前不会用到。其他请求类型由 Broker 和 Producer、Consumer 发起。\",\"KVConfigManager 内部保存了一个二级 HashMap： configTable，并且会将该对象进行持久化。\"]},\"945\":{\"h\":\"2.2 交互\",\"t\":[\"上图为 NameServer 与其他组件交互的示意图。可以看到 Producer、Consumer、Broker 均每 30s 向 NameServer 发起一次请求，NameServer 中也有定时器，定期扫描和更新内部数据。\",\"Client\",\"生产者或消费者启动时，向 Broker 发送心跳，将客户端信息、生产者和消费者信息上报给 Broker。\",\"生产者第一次发送消息时，向 NameServer 拉取该 Topic 的路由信息。\",\"消费者启动过程中会向 NameServer 请求 Topic 路由信息。\",\"每隔 30s 向 NameServer 发送请求，获取它们要生产/消费的 Topic 的路由信息。\",\"Broker\",\"每隔 30s 向 NameServer 集群的每台机器都发送心跳包，包含自身 Topic 队列的路由信息。\",\"当有 Topic 改动（创建/更新），Broker 会立即发送 Topic 增量信息到 NameServer，同时触发 NameServer 的数据版本号发生变更（+1）。\",\"NameServer\",\"将路由信息保存在内存中。它只被其他模块调用（被 Broker 上传，被客户端拉取），不会主动调用其他模块。\",\"启动一个定时任务线程，每隔 10s 扫描 brokerAddrTable 中所有的 Broker 上次发送心跳时间，如果超过 120s 没有收到心跳，则从存活 Broker 表中移除该 Broker。\"]},\"946\":{\"h\":\"3. 详细设计\"},\"947\":{\"h\":\"3.1 NameServer 启动\",\"t\":[\"上图为 NameServer 启动流程的示意图。\",\"由启动脚本调用 NamesrvStartup#main 函数触发启动流程\",\"NamesrvStartup#createNamesrvController 函数中先解析命令行参数，然后初始化 NameServer 和 Netty remote server 配置，最后创建 NamesrvController 的实例。\",\"NamesrvStartup#start 初始化 NamesrvController；调用 NamesrvController#start() 方法，启动 Netty remoting server；最后注册关闭钩子函数，在 JVM 线程关闭之前，关闭 Netty remoting server 和处理线程池，关闭定时任务线程。\",\"NamesrvController 实例是 NameServer 的核心控制器，它的初始化方法 initialize() 先加载 KVConfig manager，然后初始化 Netty remoting server。最后添加 2 个定时任务：一个每 10s 打印一次 KV 配置，一个每 10s 扫描 Broker 列表，移除掉线的 Broker。\"]},\"948\":{\"h\":\"3.2 路由信息\"},\"949\":{\"h\":\"3.2.1 NameServer 端保存的路由信息\",\"t\":[\"NameServer 中的路由信息主要指的是前面说到的 RouteInfoManager 中的 5 个 HashMap。它们只会保存在内存中，不会被持久化。下面看一下它们的具体结构。\",\"// Topic 中 Queue 的路由表，消息发送时根据路由表进行 Topic 内的负载均衡 HashMap<String/* topic */, List<QueueData>> topicQueueTable; // Broker 基础信息表，包含 brokerName、所属集群名称、主备 Broker 地址 HashMap<String/* brokerName */, BrokerData> brokerAddrTable; // Broker 集群信息，存储集群中所有 Broker 的名称 HashMap<String/* clusterName */, Set<String/* brokerName */>> clusterAddrTable; // Broker 状态信息，NameServer 每次收到心跳包时会替换该信息 HashMap<String/* brokerAddr */, BrokerLiveInfo> brokerLiveTable; // Broker 上的 FilterServer 列表，用于类模式的消息过滤。（在 4.4 之后的版本被废弃） HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable; \"]},\"950\":{\"h\":\"3.2.2 客户端保存的路由信息\",\"t\":[\"客户端中的路由信息保存在 MQClientInstance 中，也仅保存在内存，不会持久化。\",\"MQClientInstance 是用来与 NameServer、Broker 交互的客户端实例，同时缓存了路由信息。\",\"/** * Topic 路由信息 * 从NameServer更新 */ ConcurrentMap<String/* Topic */, TopicRouteData> topicRouteTable = new ConcurrentHashMap<String, TopicRouteData>(); \",\"其中包含该 Topic 的队列列表、Broker 信息列表等数据。\",\"/** * Topic 路由信息，NameServer 返回给客户端 */ public class TopicRouteData extends RemotingSerializable { // 顺序消息的配置，来自 KvConfig private String orderTopicConf; // Topic 队列元数据 private List<QueueData> queueDatas; // Topic 分布的 Broker 元数据 private List<BrokerData> brokerDatas; // Topic 上 FilterServer 的地址列表 private HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable; // ... } \"]},\"951\":{\"h\":\"3.3 路由注册\",\"t\":[\"路由注册包含两个方面：Broker 上报路由信息，和 NameServer 处理 Broker 的请求，将 Broker 上报的路由信息存起来。\"]},\"952\":{\"h\":\"3.3.1 Broker 上报心跳和路由信息\",\"t\":[\"Broker 发送心跳包的定时任务在 BrokerController#start() 方法中启动，每隔 30s 调用 registerBrokerAll 方法发送一次心跳包（REGISTER_BROKER 请求），并将自身的 Topic 队列路由信息发送给 NameServer。主节点和从节点都会发送心跳和路由信息。 Broker 会遍历 NameServer 列表，向每个 NameServer 发送心跳包。\",\"另外一个触发 Broker 上报 Topic 配置的操作是修改 Broker 的 Topic 配置（创建/更新），由 TopicConfigManager 触发上报。\",\"心跳包的请求头中包含\",\"Broker 地址\",\"BrokerId，0 表示主节点，大于 0 表示从节点\",\"Broker 名称\",\"集群名称\",\"主节点地址\",\"请求体中包含\",\"topicConfigTable：包含了每个 Topic 的所有队列信息。\",\"dataVersion：Broker 中 Topic 配置的版本号，每当配置更新一次，版本号 +1\",\"上报的心跳包请求类型是:RequestCode.REGISTER_BROKER\"]},\"953\":{\"h\":\"3.3.2 NameServer 保存上报的路由信息\",\"t\":[\"NameServer 的 DefaultRequestProcessor 接收到 REGISTER_BROKER 类型的请求后，将上报的路由信息调用 RouteInfoManager#registerBroker() 写入内存中的路由表。\",\"写入过程首先会获取写锁，然后依次写入 RouteInfoManager 中的几个路由信息表。\",\"RouteInfoManager 加写锁\",\"更新 clusterAddrTable，更新集群信息\",\"更新 brokerAddrTable，更新 Broker 信息\",\"更新 topicQueueTable，更新 Topic 队列信息\",\"更新 brokerLiveTable，更新 Broker 存活状态\",\"更新 filterServerTable，注册 Broker 的过滤器 Server 地址列表\",\"释放写锁\"]},\"954\":{\"h\":\"3.4 路由删除\",\"t\":[\"如果 Broker 宕机，则无法向 NameServer 发送心跳包。NameServer 中有一个定时任务线程，每隔 10s 检查 Broker 存活状态，如果 Broker 已经 120s 没有上报心跳，则关闭与 Broker 的连接，同时更新路由信息表，将该 Broker 相关信息移除。\",\"每次扫描，都会遍历 brokerLiveTable，取每个 Broker 的 lastUpdateTimestamp 与当前时间对比，如果相差大于 120s，则执行路由删除逻辑 RouteInfoManager#onChannelDestroy()。 另一个触发路由删除逻辑的是 Broker 正常关闭，会调用 unregisterBroker 方法，删除 NameServer 上的 Broker 信息。\",\"路由删除逻辑如下\",\"RouteInfoManager 加写锁\",\"从 brokerAddrTable 找到对应的 Broker，移除\",\"从 clusterAddrTable 找到对应 Broker，移除\",\"根据 BrokerName，从 topicQueueTable 中移除该 Broker 的队列\",\"释放写锁\"]},\"955\":{\"h\":\"3.5 路由发现（客户端拉取路由信息）\",\"t\":[\"NameServer 不会主动将路由信息推送给客户端，客户端需要自己定时从 NameServer 拉取路由信息。客户端中会启动一个定时任务，每 30s 向 NameServer 发送请求获取最新的路由信息。\"]},\"956\":{\"h\":\"3.5.1 客户端请求路由信息\",\"t\":[\"客户端中注册定时任务的方法是 MQClientInstance#startScheduledTask()，每隔 30s 调用 updateTopicRouteInfoFromNameServer() 方法，更新路由信息。\",\"客户端只会获取它生产或者消费的 Topic 路由信息，更新之后保存到 MQClientInstance.topicRouteTable 中，它也仅保存在内存中。\"]},\"957\":{\"h\":\"3.5.2 NameServer 返回路由信息\",\"t\":[\"NameServer 收到客户端获取路由信息请求后，调用 DefaultRequestProcessor#getRouteInfoByTopic() 方法，返回 Topic 路由信息。该方法逻辑如下\",\"调用 RouteInfoManager#pickupTopicRouteData() 方法，从路由表 topicQueueTable、brokerAddrTable、filterServerTable 中获取信息，填充 TopicRouteData 对象。\",\"如果该主题为顺序消息，从 KVConfig 中获取顺序消息相关的配置，填充进 TopicRouteData 对象。\",\"将 TopicRouteData 对象编码，并返回给客户端。\"]},\"958\":{\"h\":\"4. 源码剖析\"},\"959\":{\"h\":\"4.1 NameServer 启动\"},\"960\":{\"h\":\"4.1.1 NemesrvStartup\",\"t\":[\"NamesrvStartup 类是 NameServer 的启动类，它会调用 NamesrvController 类的初始化和启动方法，执行 NameServer 具体模块的初始化和启动。\",\"NamesrvStartup#createNamesrvController 函数中先解析命令行参数，然后初始化 NameServer 和 Netty remote server 配置，最后启动 NamesrvController 的初始化\",\"public static NamesrvController createNamesrvController(String[] args) throws IOException, JoranException { System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION)); //PackageConflictDetect.detectFastjson(); // 解析命令行参数 Options options = ServerUtil.buildCommandlineOptions(new Options()); commandLine = ServerUtil.parseCmdLine( \\\"mqnamesrv\\\", args, buildCommandlineOptions(options), new PosixParser()); if (null == commandLine) { System.exit(-1); return null; } // 初始化 Name server 配置参数 final NamesrvConfig namesrvConfig = new NamesrvConfig(); // 初始化 Name server 网络配置（Netty 服务端配置） final NettyServerConfig nettyServerConfig = new NettyServerConfig(); nettyServerConfig.setListenPort(9876); // 使用 -c 指定配置文件路径 if (commandLine.hasOption('c')) { String file = commandLine.getOptionValue('c'); if (file != null) { InputStream in = new BufferedInputStream(new FileInputStream(file)); properties = new Properties(); properties.load(in); MixAll.properties2Object(properties, namesrvConfig); MixAll.properties2Object(properties, nettyServerConfig); namesrvConfig.setConfigStorePath(file); System.out.printf(\\\"load config properties file OK, %s%n\\\", file); in.close(); } } // 使用 -p 打印当前加载配置属性 if (commandLine.hasOption('p')) { InternalLogger console = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_CONSOLE_NAME); MixAll.printObjectProperties(console, namesrvConfig); MixAll.printObjectProperties(console, nettyServerConfig); System.exit(0); } // 加载命令行中指定的属性，形如 --listenPort 9876 MixAll.properties2Object(ServerUtil.commandLine2Properties(commandLine), namesrvConfig); if (null == namesrvConfig.getRocketmqHome()) { System.out.printf(\\\"Please set the %s variable in your environment to match the location of the RocketMQ installation%n\\\", MixAll.ROCKETMQ_HOME_ENV); System.exit(-2); } // 初始化 Logback LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory(); JoranConfigurator configurator = new JoranConfigurator(); configurator.setContext(lc); lc.reset(); configurator.doConfigure(namesrvConfig.getRocketmqHome() + \\\"/conf/logback_namesrv.xml\\\"); log = InternalLoggerFactory.getLogger(LoggerName.NAMESRV_LOGGER_NAME); // 打印 Name server 配置参数 MixAll.printObjectProperties(log, namesrvConfig); MixAll.printObjectProperties(log, nettyServerConfig); // 初始化 Name server 控制器 final NamesrvController controller = new NamesrvController(namesrvConfig, nettyServerConfig); // remember all configs to prevent discard controller.getConfiguration().registerConfig(properties); return controller; } \",\"NamesrvStartup#start 初始化 NamesrvController；调用 NamesrvController#start() 方法，启动 Netty remoting server；最后注册关闭钩子函数，在 JVM 线程关闭之前，关闭 Netty remoting server 和处理线程池，关闭定时任务线程。\",\"public static NamesrvController start(final NamesrvController controller) throws Exception { if (null == controller) { throw new IllegalArgumentException(\\\"NamesrvController is null\\\"); } // 初始化 NamesrvController：加载 KVConfig，初始化 Netty remoting server，添加定时任务 boolean initResult = controller.initialize(); if (!initResult) { controller.shutdown(); System.exit(-3); } // 注册 JVM 钩子函数，在 JVM 完全关闭之前，执行该方法，关闭 Name server Runtime.getRuntime().addShutdownHook(new ShutdownHookThread(log, new Callable<Void>() { @Override public Void call() throws Exception { controller.shutdown(); return null; } })); // 启动 NamesrvController，主要是启动 Netty remoting server controller.start(); return controller; } \"]},\"961\":{\"h\":\"4.1.2 NamesrvController 启动\",\"t\":[\"初始化方法 initialize() 先加载 KVConfig manager，然后初始化 Netty remoting server。最后添加 2 个定时任务：一个每 10s 打印一次 KV 配置，一个每 10s 扫描 Broker 列表，移除掉线的 Broker。\",\"public boolean initialize() { // 加载 KV 配置 this.kvConfigManager.load(); // 初始化通信层 this.remotingServer = new NettyRemotingServer(this.nettyServerConfig, this.brokerHousekeepingService); // 初始化线程池 this.remotingExecutor = Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), new ThreadFactoryImpl(\\\"RemotingExecutorThread_\\\")); this.registerProcessor(); // 增加定时任务，每 10s 扫描一次 Broker，移除未激活状态的 Broker this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { NamesrvController.this.routeInfoManager.scanNotActiveBroker(); } }, 5, 10, TimeUnit.SECONDS); // 增加定时任务，每 10min 打印一次 KV 配置 this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { NamesrvController.this.kvConfigManager.printAllPeriodically(); } }, 1, 10, TimeUnit.MINUTES); if (TlsSystemConfig.tlsMode != TlsMode.DISABLED) { // Register a listener to reload SslContext try { fileWatchService = new FileWatchService( new String[] { TlsSystemConfig.tlsServerCertPath, TlsSystemConfig.tlsServerKeyPath, TlsSystemConfig.tlsServerTrustCertPath }, new FileWatchService.Listener() { boolean certChanged, keyChanged = false; @Override public void onChanged(String path) { if (path.equals(TlsSystemConfig.tlsServerTrustCertPath)) { log.info(\\\"The trust certificate changed, reload the ssl context\\\"); reloadServerSslContext(); } if (path.equals(TlsSystemConfig.tlsServerCertPath)) { certChanged = true; } if (path.equals(TlsSystemConfig.tlsServerKeyPath)) { keyChanged = true; } if (certChanged && keyChanged) { log.info(\\\"The certificate and private key changed, reload the ssl context\\\"); certChanged = keyChanged = false; reloadServerSslContext(); } } private void reloadServerSslContext() { ((NettyRemotingServer) remotingServer).loadSslContext(); } }); } catch (Exception e) { log.warn(\\\"FileWatchService created error, can't load the certificate dynamically\\\"); } } return true; } \",\"start() 和 shutdown() 方法，分别是启动和关闭 Netty remoting server、fileWatchService。\",\"其中 fileWatchService 是用来监听文件变化执行回调函数的，这里的作用是：当文件变化时，重新加载 SslContext。\",\"public void start() throws Exception { this.remotingServer.start(); if (this.fileWatchService != null) { this.fileWatchService.start(); } } public void shutdown() { this.remotingServer.shutdown(); this.remotingExecutor.shutdown(); this.scheduledExecutorService.shutdown(); if (this.fileWatchService != null) { this.fileWatchService.shutdown(); } } \"]},\"962\":{\"h\":\"4.2 路由信息\"},\"963\":{\"h\":\"4.2.1 NameServer 路由信息\",\"t\":[\"下面以单个 Broker 上报的路由信息为例展示 NameServer 中路由信息的结构。\"]},\"964\":{\"h\":\"topicQueueTable\",\"t\":[\"HashMap<String/* topic */, Map<String /* brokerName */ , QueueData>> topicQueueTable; \",\"QueueData \",\"brokerName：所属 Broker 名\",\"readQueueNums：读队列数量\",\"writeQueueNums：写队列数量\",\"perm：读写权限\",\"topicSysFlag：Topic 同步标记\",\"当前没有注册自定义 Topic，只注册了默认 Topic\",\"{ \\\"RMQ_SYS_TRANS_HALF_TOPIC\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":6, \\\"readQueueNums\\\":1, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":1 } }, \\\"SCHEDULE_TOPIC_XXXX\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":6, \\\"readQueueNums\\\":18, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":18 } }, \\\"SELF_TEST_TOPIC\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":6, \\\"readQueueNums\\\":1, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":1 } }, \\\"broker-local\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":7, \\\"readQueueNums\\\":1, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":1 } }, \\\"TBW102\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":7, \\\"readQueueNums\\\":8, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":8 } }, \\\"BenchmarkTest\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":6, \\\"readQueueNums\\\":1024, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":1024 } }, \\\"DefaultCluster\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":7, \\\"readQueueNums\\\":16, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":16 } }, \\\"DefaultCluster_REPLY_TOPIC\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":6, \\\"readQueueNums\\\":1, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":1 } }, \\\"OFFSET_MOVED_EVENT\\\":{ \\\"broker-local\\\":{ \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":6, \\\"readQueueNums\\\":1, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":1 } } } \"]},\"965\":{\"h\":\"brokerAddrTable\",\"t\":[\"HashMap<String/* brokerName */, BrokerData> brokerAddrTable; \",\"brokerAddrs \",\"key：brokerId，0 表示 MASTER，大于 0 表示 SLAVE\",\"value：broker 地址\",\"{ \\\"broker-local\\\":{ \\\"brokerAddrs\\\":{ \\\"0\\\":\\\"127.0.0.1:10911\\\" }, \\\"brokerName\\\":\\\"broker-local\\\", \\\"cluster\\\":\\\"DefaultCluster\\\" } } \"]},\"966\":{\"h\":\"clusterAddrTable\",\"t\":[\"HashMap<String/* clusterName */, Set<String/* brokerName */>> clusterAddrTable; \",\"{ \\\"DefaultCluster\\\":[ \\\"broker-local\\\" ] } \"]},\"967\":{\"h\":\"brokerLiveTable\",\"t\":[\"HashMap<String/* brokerAddr */, BrokerLiveInfo> brokerLiveTable; \",\"BrokerLiveInfo：Broker 状态信息，由 Broker 心跳上报 \",\"lastUpdateTimestamp：上次更新时间戳\",\"dataVersion：元数据被更新的次数，在 Broker 中统计，每次更新 +1\",\"channel：Netty Channel\",\"haServerAddr：HA 服务器地址\",\"{ \\\"127.0.0.1:10911\\\":{ \\\"channel\\\":{ \\\"active\\\":true, \\\"inputShutdown\\\":false, \\\"open\\\":true, \\\"outputShutdown\\\":false, \\\"registered\\\":true, \\\"shutdown\\\":false, \\\"writable\\\":true }, \\\"dataVersion\\\":{ \\\"counter\\\":1, \\\"timestamp\\\":1651564857610 }, \\\"haServerAddr\\\":\\\"10.0.0.2:10912\\\", \\\"lastUpdateTimestamp\\\":1651564899813 } } \"]},\"968\":{\"h\":\"4.2.2 客户端路由信息\",\"t\":[\"ConcurrentMap<String/* Topic */, TopicRouteData> topicRouteTable = new ConcurrentHashMap<String, TopicRouteData>(); \",\"public class TopicRouteData extends RemotingSerializable { // 顺序消息的配置，来自 KvConfig private String orderTopicConf; // Topic 队列元数据 private List<QueueData> queueDatas; // Topic 分布的 Broker 元数据 private List<BrokerData> brokerDatas; // Topic 上 FilterServer 的地址列表 private HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable; // ... } \",\"{ \\\"%RETRY%benchmark_consumer\\\":{ \\\"brokerDatas\\\":[ { \\\"brokerAddrs\\\":{ \\\"0\\\":\\\"127.0.0.1:10911\\\" }, \\\"brokerName\\\":\\\"broker-local\\\", \\\"cluster\\\":\\\"DefaultCluster\\\" } ], \\\"filterServerTable\\\":{ }, \\\"queueDatas\\\":[ { \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":6, \\\"readQueueNums\\\":1, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":1 } ] }, \\\"TBW102\\\":{ \\\"brokerDatas\\\":[ { \\\"brokerAddrs\\\":{ \\\"0\\\":\\\"127.0.0.1:10911\\\" }, \\\"brokerName\\\":\\\"broker-local\\\", \\\"cluster\\\":\\\"DefaultCluster\\\" } ], \\\"filterServerTable\\\":{ }, \\\"queueDatas\\\":[ { \\\"brokerName\\\":\\\"broker-local\\\", \\\"perm\\\":7, \\\"readQueueNums\\\":8, \\\"topicSysFlag\\\":0, \\\"writeQueueNums\\\":8 } ] } } \"]},\"969\":{\"h\":\"4.3 路由注册\"},\"970\":{\"h\":\"4.3.1 Broker 上报心跳和路由信息\",\"t\":[\"BrokerController 最终会调用 BrokerOuterAPI#registerBrokerAll 上报心跳和路由信息。\",\"// BrokerOuterAPI.java /** * 向所有 Name server 发送心跳包 * @return 心跳包发送的响应列表 */ public List<RegisterBrokerResult> registerBrokerAll( final String clusterName, final String brokerAddr, final String brokerName, final long brokerId, final String haServerAddr, final TopicConfigSerializeWrapper topicConfigWrapper, final List<String> filterServerList, final boolean oneway, final int timeoutMills, final boolean compressed) { final List<RegisterBrokerResult> registerBrokerResultList = new CopyOnWriteArrayList<>(); List<String> nameServerAddressList = this.remotingClient.getNameServerAddressList(); if (nameServerAddressList != null && nameServerAddressList.size() > 0) { // 为所有心跳请求构造统一的请求头 final RegisterBrokerRequestHeader requestHeader = new RegisterBrokerRequestHeader(); requestHeader.setBrokerAddr(brokerAddr); requestHeader.setBrokerId(brokerId); requestHeader.setBrokerName(brokerName); requestHeader.setClusterName(clusterName); // 主节点地址，初次请求时为空，从节点向 Name server 注册后更新 requestHeader.setHaServerAddr(haServerAddr); requestHeader.setCompressed(compressed); // 构造统一的请求体 RegisterBrokerBody requestBody = new RegisterBrokerBody(); // Topic 配置，存储 Broker 启动时的一些默认 Topic requestBody.setTopicConfigSerializeWrapper(topicConfigWrapper); // 消息过滤服务器列表 requestBody.setFilterServerList(filterServerList); final byte[] body = requestBody.encode(compressed); final int bodyCrc32 = UtilAll.crc32(body); requestHeader.setBodyCrc32(bodyCrc32); final CountDownLatch countDownLatch = new CountDownLatch(nameServerAddressList.size()); // 遍历所有 Name server 地址，发送心跳请求 for (final String namesrvAddr : nameServerAddressList) { brokerOuterExecutor.execute(new Runnable() { @Override public void run() { try { RegisterBrokerResult result = registerBroker( namesrvAddr, oneway, timeoutMills, requestHeader, body); if (result != null) { registerBrokerResultList.add(result); } log.info(\\\"register broker[{}]to name server {} OK\\\", brokerId, namesrvAddr); } catch (Exception e) { log.warn(\\\"registerBroker Exception, {}\\\", namesrvAddr, e); } finally { countDownLatch.countDown(); } } }); } try { countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS); } catch (InterruptedException e) { } } return registerBrokerResultList; } \"]},\"971\":{\"h\":\"4.3.2 NameServer 保存上报的路由信息\",\"t\":[\"RouteInfoManager#registerBroker 将 Broker 上报的路由信息保存到 NameServer 上。\",\"RouteInfoManager 加写锁\",\"更新 clusterAddrTable，更新集群信息\",\"更新 brokerAddrTable，更新 Broker 信息\",\"更新 topicQueueTable，更新 Topic 队列信息\",\"更新 brokerLiveTable，更新 Broker 存活状态\",\"更新 filterServerTable，注册 Broker 的过滤器 Server 地址列表\",\"释放写锁\",\"/** * 处理 Broker 心跳信息，存到本地路由表 * 如果是 SLAVE，则返回 MASTER 的 HA 地址 */ public RegisterBrokerResult registerBroker( final String clusterName, final String brokerAddr, final String brokerName, final long brokerId, final String haServerAddr, final TopicConfigSerializeWrapper topicConfigWrapper, final List<String> filterServerList, final Channel channel) { RegisterBrokerResult result = new RegisterBrokerResult(); try { try { // 路由注册需要加写锁，防止并发修改 RouteInfoManager 中的路由表 this.lock.writeLock().lockInterruptibly(); // 更新集群信息表。判断 Broker 所属集群是否存在，不存在则创建集群，然后将 Broker 名加入集群信息表 Set<String> brokerNames = this.clusterAddrTable.get(clusterName); if (null == brokerNames) { brokerNames = new HashSet<String>(); this.clusterAddrTable.put(clusterName, brokerNames); } brokerNames.add(brokerName); boolean registerFirst = false; // 更新 Broker 地址表，更新主备信息 BrokerData brokerData = this.brokerAddrTable.get(brokerName); if (null == brokerData) { // 该 Broker 首次注册 registerFirst = true; brokerData = new BrokerData(clusterName, brokerName, new HashMap<Long, String>()); this.brokerAddrTable.put(brokerName, brokerData); } Map<Long, String> brokerAddrsMap = brokerData.getBrokerAddrs(); //Switch slave to master: first remove <1, IP:PORT> in namesrv, then add <0, IP:PORT> //The same IP:PORT must only have one record in brokerAddrTable Iterator<Entry<Long, String>> it = brokerAddrsMap.entrySet().iterator(); while (it.hasNext()) { Entry<Long, String> item = it.next(); if (null != brokerAddr && brokerAddr.equals(item.getValue()) && brokerId != item.getKey()) { it.remove(); } } String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr); registerFirst = registerFirst || (null == oldAddr); // 更新 Topic 信息表。只有主节点 Topic 配置信息发生变化或第一次注册才会更新 if (null != topicConfigWrapper && MixAll.MASTER_ID == brokerId) { if (this.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion()) || registerFirst) { ConcurrentMap<String, TopicConfig> tcTable = topicConfigWrapper.getTopicConfigTable(); if (tcTable != null) { for (Map.Entry<String, TopicConfig> entry : tcTable.entrySet()) { this.createAndUpdateQueueData(brokerName, entry.getValue()); } } } } // 更新 Broker 存活状态信息，包含最后更新时间 BrokerLiveInfo prevBrokerLiveInfo = this.brokerLiveTable.put(brokerAddr, new BrokerLiveInfo( System.currentTimeMillis(), topicConfigWrapper.getDataVersion(), channel, haServerAddr)); if (null == prevBrokerLiveInfo) { log.info(\\\"new broker registered, {} HAServer: {}\\\", brokerAddr, haServerAddr); } // 更新 Broker 的 FilterServer 列表，一个 Broker 可能有多个 Filter Server if (filterServerList != null) { if (filterServerList.isEmpty()) { this.filterServerTable.remove(brokerAddr); } else { this.filterServerTable.put(brokerAddr, filterServerList); } } if (MixAll.MASTER_ID != brokerId) { String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID); if (masterAddr != null) { BrokerLiveInfo brokerLiveInfo = this.brokerLiveTable.get(masterAddr); if (brokerLiveInfo != null) { result.setHaServerAddr(brokerLiveInfo.getHaServerAddr()); result.setMasterAddr(masterAddr); } } } } finally { this.lock.writeLock().unlock(); } } catch (Exception e) { log.error(\\\"registerBroker Exception\\\", e); } return result; } \"]},\"972\":{\"h\":\"4.4. 路由删除\",\"t\":[\"路由删除逻辑如下\",\"RouteInfoManager 加写锁\",\"从 brokerAddrTable 找到对应的 Broker，移除\",\"从 clusterAddrTable 找到对应 Broker，移除\",\"根据 BrokerName，从 topicQueueTable 中移除该 Broker 的队列\",\"释放写锁\",\"/** * Channel 被关闭，或者 Channel Idle 时间超限 * 关闭与 Broker 的连接，删除它的路由信息 */ public void onChannelDestroy(String remoteAddr, Channel channel) { String brokerAddrFound = null; if (channel != null) { try { try { this.lock.readLock().lockInterruptibly(); Iterator<Entry<String, BrokerLiveInfo>> itBrokerLiveTable = this.brokerLiveTable.entrySet().iterator(); while (itBrokerLiveTable.hasNext()) { Entry<String, BrokerLiveInfo> entry = itBrokerLiveTable.next(); if (entry.getValue().getChannel() == channel) { brokerAddrFound = entry.getKey(); break; } } } finally { this.lock.readLock().unlock(); } } catch (Exception e) { log.error(\\\"onChannelDestroy Exception\\\", e); } } if (null == brokerAddrFound) { brokerAddrFound = remoteAddr; } else { log.info(\\\"the broker's channel destroyed, {}, clean it's data structure at once\\\", brokerAddrFound); } if (brokerAddrFound != null && brokerAddrFound.length() > 0) { try { try { // 加写锁，删除该 Broker 的路由信息 this.lock.writeLock().lockInterruptibly(); this.brokerLiveTable.remove(brokerAddrFound); this.filterServerTable.remove(brokerAddrFound); // 移除 Broker 基础信息表中的该 Broker 信息 String brokerNameFound = null; boolean removeBrokerName = false; Iterator<Entry<String, BrokerData>> itBrokerAddrTable = this.brokerAddrTable.entrySet().iterator(); while (itBrokerAddrTable.hasNext() && (null == brokerNameFound)) { BrokerData brokerData = itBrokerAddrTable.next().getValue(); Iterator<Entry<Long, String>> it = brokerData.getBrokerAddrs().entrySet().iterator(); while (it.hasNext()) { Entry<Long, String> entry = it.next(); Long brokerId = entry.getKey(); String brokerAddr = entry.getValue(); if (brokerAddr.equals(brokerAddrFound)) { brokerNameFound = brokerData.getBrokerName(); it.remove(); log.info(\\\"remove brokerAddr[{}, {}] from brokerAddrTable, because channel destroyed\\\", brokerId, brokerAddr); break; } } if (brokerData.getBrokerAddrs().isEmpty()) { removeBrokerName = true; itBrokerAddrTable.remove(); log.info(\\\"remove brokerName[{}] from brokerAddrTable, because channel destroyed\\\", brokerData.getBrokerName()); } } // 从集群信息表中移除该 Broker if (brokerNameFound != null && removeBrokerName) { Iterator<Entry<String, Set<String>>> it = this.clusterAddrTable.entrySet().iterator(); while (it.hasNext()) { Entry<String, Set<String>> entry = it.next(); String clusterName = entry.getKey(); Set<String> brokerNames = entry.getValue(); boolean removed = brokerNames.remove(brokerNameFound); if (removed) { log.info(\\\"remove brokerName[{}], clusterName[{}] from clusterAddrTable, because channel destroyed\\\", brokerNameFound, clusterName); if (brokerNames.isEmpty()) { log.info(\\\"remove the clusterName[{}] from clusterAddrTable, because channel destroyed and no broker in this cluster\\\", clusterName); it.remove(); } break; } } } // 移除 TopicQueue 表中该 Broker 的队列 if (removeBrokerName) { Iterator<Entry<String, List<QueueData>>> itTopicQueueTable = this.topicQueueTable.entrySet().iterator(); while (itTopicQueueTable.hasNext()) { Entry<String, List<QueueData>> entry = itTopicQueueTable.next(); String topic = entry.getKey(); List<QueueData> queueDataList = entry.getValue(); Iterator<QueueData> itQueueData = queueDataList.iterator(); while (itQueueData.hasNext()) { QueueData queueData = itQueueData.next(); if (queueData.getBrokerName().equals(brokerNameFound)) { itQueueData.remove(); log.info(\\\"remove topic[{} {}], from topicQueueTable, because channel destroyed\\\", topic, queueData); } } if (queueDataList.isEmpty()) { itTopicQueueTable.remove(); log.info(\\\"remove topic[{}] all queue, from topicQueueTable, because channel destroyed\\\", topic); } } } } finally { this.lock.writeLock().unlock(); } } catch (Exception e) { log.error(\\\"onChannelDestroy Exception\\\", e); } } } \"]},\"973\":{\"h\":\"4.5 路由发现\",\"t\":[\"NameServer 收到客户端获取路由信息请求后，调用 DefaultRequestProcessor#getRouteInfoByTopic() 方法，返回 Topic 路由信息。该方法逻辑如下\",\"调用 RouteInfoManager#pickupTopicRouteData() 方法，从路由表 topicQueueTable、brokerAddrTable、filterServerTable 中获取信息，填充 TopicRouteData 对象。\",\"如果该主题为顺序消息，从 KVConfig 中获取顺序消息相关的配置，填充进 TopicRouteData 对象。\",\"将 TopicRouteData 对象编码，并返回给客户端。\",\"/** * 处理客户端拉取路由信息请求，返回包含 TopicRouteData 的返回体 */ public RemotingCommand getRouteInfoByTopic(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException { final RemotingCommand response = RemotingCommand.createResponseCommand(null); final GetRouteInfoRequestHeader requestHeader = (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader.class); // 根据请求的主题获取该主题的路由信息 TopicRouteData topicRouteData = this.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic()); // 如果该主题为顺序消息，则从 NameServer KvConfig 中获取顺序消息相关配置 if (topicRouteData != null) { if (this.namesrvController.getNamesrvConfig().isOrderMessageEnable()) { String orderTopicConf = this.namesrvController.getKvConfigManager().getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG, requestHeader.getTopic()); topicRouteData.setOrderTopicConf(orderTopicConf); } byte[] content = topicRouteData.encode(); response.setBody(content); response.setCode(ResponseCode.SUCCESS); response.setRemark(null); return response; } response.setCode(ResponseCode.TOPIC_NOT_EXIST); response.setRemark(\\\"No topic route info in name server for the topic: \\\" + requestHeader.getTopic() + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL)); return response; } \"]},\"974\":{\"h\":\"参考资料\",\"t\":[\"官方文档——架构设计\",\"深入剖析RocketMQ源码-NameServer\",\"Namesrv nearby route\",\"《RocketMQ 技术内幕 第2版》\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"975\":{\"h\":\"RocketMQ ACL 权限控制 详解 & 源码剖析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220515-rocketmq-acl.html\"]},\"976\":{\"h\":\"1. 背景\",\"t\":[\"很多网站、软件、应用都有自己的权限控制系统。一般来说用户会有自己的角色（用户组），每个角色有相应的权限集，只有拥有某种权限才能进行某些操作。随着消息队列的使用场景越来越广泛，消息队列的权限控制需求也也越来越迫切。\",\"RocketMQ 再 4.4.0 版本引入了 ACL 模块，开始支持访问权限控制。ACL（Access Control List），即访问控制列表。RocketMQ 的 ACL 模块实现了一套简单访问控制功能，它包含用户、角色、权限、资源的概念，还支持按客户端 IP 段进行白名单控制。\",\"如此一来，我们可以通过 ACL 来实现\",\"本文介绍 RocketMQ ACL 模块的使用和实现原理，最后进行源码的解析。\"]},\"977\":{\"h\":\"2. 概述\"},\"978\":{\"h\":\"2.1 基本概念\",\"t\":[\"先来了解一下 RocketMQ ACL 中的概念。\",\"我们设想这样一个场景：某公司运维团队维护了一个 RocketMQ 集群，为了保证集群的安全性，业务团队无法直接创建和修改 Topic，只能往自己申请的 Topic 上生产和消费。新建 Topic 需要提交申请由运维团队审批。这个简单的场景涉及了几个概念：用户（运维人员、开发人员）、角色（管理员、普通用户）、资源（Topic）、权限（修改 Topic 的权限、在 Topic 发送、接收消息的权限）\",\"由此可以引出 RocketMQ ACL 中支持的 4 种概念：\",\"用户：访问控制的基本要素，包含用户名（AccessKey）、密码（SecretKey）\",\"角色：用户权限的集合，RocketMQ ACL 中定义了 2 中角色：管理员 / 非管理员\",\"资源：需要进行访问控制的对象。RocketMQ 中的 Topic 和 ConsumerGroup。\",\"权限：针对资源能进行的操作。RocketMQ 中主要指对 Topic 和 ConsumserGroup 的操作，包含如下 4 种。\",\"权限\",\"含义\",\"DENY\",\"拒绝\",\"ANY\",\"PUB 或者 SUB 权限\",\"PUB\",\"发送权限\",\"SUB\",\"订阅权限\",\"此外，还包含白名单概念\",\"白名单：客户端 IP 地址白名单，有全局和用户 2 种作用域。如果 Broker 接收到来自白名单中 IP 的请求，则直接放行，不进行后续的其他权限校验。\"]},\"979\":{\"h\":\"2.2 基本流程\",\"t\":[\"RocketMQ 的权限控制由客户端和 Broker 端共同完成。\",\"Broker：Broker 端需要先在配置文件（conf/plain_acl.yml）中设置该 Broker 的访问权限配置。接收到客户端请求后根据配置的权限匹配，进行权限判断。\",\"客户端：客户端需要标明每个请求的用户，具体的方法是通过 RPCHook 指定用户名和密码。\",\"下面是 RocketMQ 进行权限控制的流程\"]},\"980\":{\"h\":\"2.2.1 初始化\",\"t\":[\"Broker 初始化\",\"Broker 初始化前，用户手动修改和配置 ACL 配置文件\",\"加载访问验证器 PlainAccessValidator\",\"读取配置文件，加载配置到内存。\",\"注册钩子函数，用作请求处理前的权限校验\",\"注意 Broker 会观察配置文件改动并且自动重新加载\",\"客户端初始化\",\"用户需手动配置一个 AclClientRPCHook，并指定用户名和密码参数。客户端初始化时注册该 AclClientRPCHook，用于在发送请求前在请求中加入验证信息。\"]},\"981\":{\"h\":\"2.2.2 发送 / 处理请求\",\"t\":[\"客户端发送请求\",\"创建请求\",\"发送请求前执行 AclClientRPCHook 钩子函数的 before 方法 \",\"对请求、用户名和密码进行签名\",\"将用户名和签名加入请求\",\"发送请求\",\"服务端处理请求 \",\"处理请求前执行注册的钩子函数，执行权限判断\",\"判断成功则正常返回，否则返回异常信息\"]},\"982\":{\"h\":\"2.3 使用方法\"},\"983\":{\"h\":\"2.3.1 Broker 端配置\",\"t\":[\"首先需要在 broker.conf 中启动 Broker 的 ACL 功能。\",\"aclEnable=true \",\"ACL 默认的配置文件名：plain_acl.yml，需要放在{ROCKETMQ_HOME}/store/config目录下。当前支持多配置文件，可以把不同业务的权限配置分别放在多个文件中。\",\"下面为示例配置文件\",\"globalWhiteRemoteAddresses: - 10.10.103.* - 192.168.0.* accounts: - accessKey: RocketMQ secretKey: 12345678 whiteRemoteAddress: admin: false defaultTopicPerm: DENY defaultGroupPerm: SUB topicPerms: - topicA=DENY - topicB=PUB|SUB - topicC=SUB groupPerms: # the group should convert to retry topic - groupA=DENY - groupB=PUB|SUB - groupC=SUB - accessKey: rocketmq2 secretKey: 12345678 whiteRemoteAddress: 192.168.1.* # if it is admin, it could access all resources admin: true \",\"可以看到配置文件主要分两个大项：\",\"globalWhiteRemoteAddresses：用于配置全局客户端 IP 白名单\",\"accounts：用来配置用户和用户权限\",\"下面是配置的具体取值\",\"字段\",\"取值\",\"含义\",\"globalWhiteRemoteAddresses\",\";192.168..*;192.168.0.1\",\"全局IP白名单\",\"accessKey\",\"字符串\",\"Access Key\",\"secretKey\",\"字符串\",\"Secret Key\",\"whiteRemoteAddress\",\";192.168..*;192.168.0.1\",\"用户IP白名单\",\"admin\",\"true;false\",\"是否管理员账户\",\"defaultTopicPerm\",\"DENY;PUB;SUB;PUB|SUB\",\"默认的Topic权限\",\"defaultGroupPerm\",\"DENY;PUB;SUB;PUB|SUB\",\"默认的ConsumerGroup权限\",\"topicPerms\",\"topic=权限\",\"各个Topic的权限\",\"groupPerms\",\"group=权限\",\"各个ConsumerGroup的权限\"]},\"984\":{\"h\":\"2.3.2 生产者使用\",\"t\":[\"生产者和消费者使用 ACL，都需要用用户名和密码新建一个 AclClientRPCHook 对象，然后注册到客户端中。\",\"public class ACLProducerTest { private static final String ACL_ACCESS_KEY = \\\"RocketMQ\\\"; private static final String ACL_SECRET_KEY = \\\"12345678\\\"; public static void main(String[] args) throws MQClientException { // 将 AclClientHook 注册到客户端 DefaultMQProducer producer = new DefaultMQProducer(\\\"ProducerGroupName\\\", getAclRPCHook()); producer.setNamesrvAddr(\\\"127.0.0.1:9876\\\"); producer.start(); for (int i = 0; i < 128; i++) try { { Message msg = new Message(\\\"topic0607\\\", \\\"TagA\\\", \\\"OrderID188\\\", \\\"Hello world\\\".getBytes(RemotingHelper.DEFAULT_CHARSET)); SendResult sendResult = producer.send(msg); System.out.printf(\\\"%s%n\\\", sendResult); } } catch (Exception e) { e.printStackTrace(); } producer.shutdown(); } // 新建 AclClientHook，配置用户名和密码 static RPCHook getAclRPCHook() { return new AclClientRPCHook(new SessionCredentials(ACL_ACCESS_KEY, ACL_SECRET_KEY)); } } \"]},\"985\":{\"h\":\"2.3.3 消费者使用\",\"t\":[\"public class ACLConsumerTest { private static final String ACL_ACCESS_KEY = \\\"RocketMQ\\\"; private static final String ACL_SECRET_KEY = \\\"12345678\\\"; public static void main(String[] args) throws MQClientException { // 将 AclClientHook 注册到客户端 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\\\"testGroup02\\\", getAclRPCHook(), new AllocateMessageQueueAveragely()); consumer.setNamesrvAddr(\\\"127.0.0.1:9876\\\"); consumer.subscribe(\\\"topic0607\\\", \\\"*\\\"); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) { System.out.printf(\\\"%s Receive New Messages: %s %n\\\", Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); consumer.start(); System.out.printf(\\\"Consumer Started.%n\\\"); } // 新建 AclClientHook，配置用户名和密码 static RPCHook getAclRPCHook() { return new AclClientRPCHook(new SessionCredentials(ACL_ACCESS_KEY,ACL_SECRET_KEY)); } } \"]},\"986\":{\"h\":\"3. 实现原理\",\"t\":[\"这部分开始讲解 RocketMQ ACL 模块的实现原理，将会按照请求处理的先后顺序分为\",\"客户端 AclClientRPCHook\",\"Broker 初始化 ACL 配置\",\"Broker 权限验证\",\"这几个部分。\"]},\"987\":{\"h\":\"3.1 客户端 AclClientRPCHook\",\"t\":[\"客户端使用 ACL 功能时必须用 AccessKey 和 SecretKey 新建一个 AclClientRPCHook，这个 RPCHook 用于在发送请求前将该账号的用户名和密码信息放入请求中，以便 Broker 获取账号信息进行权限判断。\"]},\"988\":{\"h\":\"3.1.1 注册 AclClientRPCHook\",\"t\":[\"我们首先看一下客户端如何注册 AclClientRPCHook，让他能够在发送请求时起作用。\",\"在 NettyRemotingClient 和 NettyRemotingServer 的抽象基类 NettyRemotingAbstract 中有一个 rpcHooks 列表，用于存放所有的 RPCHook。它会在处理请求的前后分别执行 RPCHook 的 before 和 after 方法。\",\"注册 AclClientRPCHook 的逻辑会把这个 RPCHook 加入到 rpcHooks 列表里面。\"]},\"989\":{\"h\":\"3.1.2 AclClientRPCHook 的逻辑\",\"t\":[\"这个类仅定义了 before 逻辑。它会将请求的参数（header）和用户名密码参数打包，排序，然后进行签名。\",\"相对应地，服务端收到请求后也会对请求参数进行排序，以同样的方法签名，通过比较签名的方式进行验证，防止请求数据被篡改。\",\"随后会将签名和用户名加入到请求扩展属性中，然后发送请求。\"]},\"990\":{\"h\":\"3.2 Broker 初始化 ACL 配置\",\"t\":[\"介绍 Broker 这边的 ACL 逻辑前，看一下 Broker ACL 相关的类。\",\"其中红色线为初始化的方法调用链。\",\"Broker 启动时会由 BrokerController 初始化 ACL 模块，加载所有的验证器。具体的方法是用 SPI 机制，读取 METAINF/service/org.apache.rocketmq.acl.AccessValidator 文件，加载 AccessValidator 的所有实现类。当前只有一个默认实现 PlainAccessValidator，用户也可以自己实现其他验证器。\",\"PlainAccessValidator 初始化时会创建 PlainPermissionManager 对象，用它来解析权限配置文件（plain_acl.yml）。\",\"PlainPermissionManager 会在初始化时加载目录中的所有配置文件，将权限配置信息加载到内存。同时，它会开启一个 FileWatchService 线程，用于每 0.5s 检测配置文件的变更，及时将变更加载到内存。\",\"最后 Broker 将注册一个 RPCHook，在请求处理前后增加方法。在请求之前注册 PlainAccessValidator 的 validate 方法。这个 validate 方法中就包含了权限验证的逻辑。\"]},\"991\":{\"h\":\"3.3 Broker 权限验证\",\"t\":[\"权限验证的逻辑在 PlainAccessValidator 的 validate 方法中，它会调用 PlainPermissionManager 的 validate 方法，传入的参数是客户端发送请求时指定的用户信息。下面是权限验证的步骤\",\"判断客户端 IP 是否在全局白名单中，如果匹配则直接放行\",\"判断该用户是否配置在权限控制列表中，如果不在则返回错误\",\"获取请求用户的访问控制权限，判断客户端 IP 是否在用户维度的白名单中，如果匹配则放行\",\"对请求参数验计算签名，验证与客户端计算的签名是否一致，不一致则返回异常\",\"验证资源访问权限，判断该用户是否有客户端请求的资源的相应操作权限\"]},\"992\":{\"h\":\"4. 源码解析\"},\"993\":{\"h\":\"4.1 客户端 AclClientRPCHook\"},\"994\":{\"h\":\"4.1.1 注册 AclClientRPCHook\",\"t\":[\"在 NettyRemotingClient 和 NettyRemotingServer 的抽象基类 NettyRemotingAbstract 中有一个 rpcHooks 列表，用于存放所有的 RPCHook。它会在处理请求的前后分别执行 RPCHook 的 before 和 after 方法。\",\"注册 AclClientRPCHook 的逻辑会把这个 RPCHook 加入到 rpcHooks 列表里面。\",\"// NettyRemotingAbstract.java protected List<RPCHook> rpcHooks = new ArrayList<RPCHook>(); \",\"// NettyRemotingClient.java @Override public void registerRPCHook(RPCHook rpcHook) { if (rpcHook != null && !rpcHooks.contains(rpcHook)) { rpcHooks.add(rpcHook); } } \",\"Producer 端调用底层 API 发送命令的前后，调用 RPCHook 上面的 doBeforeRequest 和 doAfterRequest 方法，便于在发送命令的前后拦截\",\"// NettyRemotingClient.java @Override public RemotingCommand invokeSync(String addr, final RemotingCommand request, long timeoutMillis) { doBeforeRpcHooks(addr, request); // ... doAfterRpcHooks(RemotingHelper.parseChannelRemoteAddr(channel), request, response); } protected void doBeforeRpcHooks(String addr, RemotingCommand request) { if (rpcHooks.size() > 0) { for (RPCHook rpcHook: rpcHooks) { rpcHook.doBeforeRequest(addr, request); } } } protected void doAfterRpcHooks(String addr, RemotingCommand request, RemotingCommand response) { if (rpcHooks.size() > 0) { for (RPCHook rpcHook: rpcHooks) { rpcHook.doAfterResponse(addr, request, response); } } } \"]},\"995\":{\"h\":\"4.1.2 AclClientRPCHook 的逻辑\",\"t\":[\"仅定义了 before 逻辑。它会将请求的参数（header）和用户名密码参数打包，排序，然后进行签名。\",\"首先 parseRequestContent 方法使用 SortedMap 将客户端的 AccessKey、SecurityToken 以及请求中 header 的属性进行排序\",\"然后 combineRequestContent 方法会将上一步返回的 map 以及请求合并成一个 byte 数组\",\"calSignature方法会根据客户端的 AccessKey 以及上一步返回的 byte 数组生成一个签名\",\"将生成的签名添加到请求的扩展属性中\",\"将 AccessKey 添加到请求的扩展属性中\",\"@Override public void doBeforeRequest(String remoteAddr, RemotingCommand request) { byte[] total = AclUtils.combineRequestContent(request, parseRequestContent(request, sessionCredentials.getAccessKey(), sessionCredentials.getSecurityToken())); String signature = AclUtils.calSignature(total, sessionCredentials.getSecretKey()); request.addExtField(SIGNATURE, signature); request.addExtField(ACCESS_KEY, sessionCredentials.getAccessKey()); // The SecurityToken value is unneccessary,user can choose this one. if (sessionCredentials.getSecurityToken() != null) { request.addExtField(SECURITY_TOKEN, sessionCredentials.getSecurityToken()); } } protected SortedMap<String, String> parseRequestContent(RemotingCommand request, String ak, String securityToken) { CommandCustomHeader header = request.readCustomHeader(); // Sort property SortedMap<String, String> map = new TreeMap<String, String>(); map.put(ACCESS_KEY, ak); if (securityToken != null) { map.put(SECURITY_TOKEN, securityToken); } try { // Add header properties if (null != header) { Field[] fields = fieldCache.get(header.getClass()); if (null == fields) { fields = header.getClass().getDeclaredFields(); for (Field field : fields) { field.setAccessible(true); } Field[] tmp = fieldCache.putIfAbsent(header.getClass(), fields); if (null != tmp) { fields = tmp; } } for (Field field : fields) { Object value = field.get(header); if (null != value && !field.isSynthetic()) { map.put(field.getName(), value.toString()); } } } return map; } catch (Exception e) { throw new RuntimeException(\\\"incompatible exception.\\\", e); } } \"]},\"996\":{\"h\":\"4.2 Broker 初始化 ACL 配置\",\"t\":[\"Broker 启动时会由 BrokerController 初始化 ACL 模块，加载所有的验证器。具体的方法是用 SPI 机制，读取 METAINF/service/org.apache.rocketmq.acl.AccessValidator 文件，加载 AccessValidator 的所有实现类。当前只有一个默认实现 PlainAccessValidator，用户也可以自己实现其他验证器。\",\"/** * ACL（访问控制列表）初始化 */ private void initialAcl() { if (!this.brokerConfig.isAclEnable()) { log.info(\\\"The broker dose not enable acl\\\"); return; } // 使用SPI机制加载配置的AccessValidator实现类 // 读取METAINF/service/org.apache.rocketmq.acl.AccessValidator文件中配置的访问验证器PlainAccessValidator List<AccessValidator> accessValidators = ServiceProvider.load(ServiceProvider.ACL_VALIDATOR_ID, AccessValidator.class); if (accessValidators == null || accessValidators.isEmpty()) { log.info(\\\"The broker dose not load the AccessValidator\\\"); return; } for (AccessValidator accessValidator: accessValidators) { final AccessValidator validator = accessValidator; accessValidatorMap.put(validator.getClass(),validator); // 向Broker处理服务启注册钩子函数 this.registerServerRPCHook(new RPCHook() { /** * 在服务端接收到请求并解码后、执行处理请求前被调用 */ @Override public void doBeforeRequest(String remoteAddr, RemotingCommand request) { //Do not catch the exception validator.validate(validator.parse(request, remoteAddr)); } /** * 在处理完请求后调用 */ @Override public void doAfterResponse(String remoteAddr, RemotingCommand request, RemotingCommand response) { } }); } } \",\"PlainAccessValidator 初始化时会创建 PlainPermissionManager 对象，用它来解析权限配置文件（plain_acl.yml）。\",\"PlainPermissionManager 会在初始化时加载目录中的所有配置文件，将权限配置信息加载到内存。同时，它会开启一个 FileWatchService 线程，用于每 0.5s 检测配置文件的变更，及时将变更加载到内存\",\"public PlainPermissionManager() { // 解析 yaml 文件，将配置加载到内存 load(); // 监听配置文件变化，如发生变化，重新加载配置 watch(); } \"]},\"997\":{\"h\":\"4.2.1 PlainPermissonManager 的字段含义\",\"t\":[\"其中红色线为初始化的方法调用链。下面看一下 PlainPermissonManager 中字段的含义，由于支持了从多文件加载权限配置，所以这些配置大多为 Map 类型，Key 是文件路径，Value 是文件中包含的权限配置。\",\"// PlainPermissionManager.java // 权限映射配置表，用来缓存所有ACL配置文件的权限数据 private Map<String/** fileFullPath **/, Map<String/** AccessKey **/, PlainAccessResource>> aclPlainAccessResourceMap = new HashMap<>(); // 用来缓存 AccessKey 和 ACL 配置文件的映射关系 private Map<String/** AccessKey **/, String/** fileFullPath **/> accessKeyTable = new HashMap<>(); // 用来缓存所有 ACL 配置文件的全局白名单 private List<RemoteAddressStrategy> globalWhiteRemoteAddressStrategy = new ArrayList<>(); // 远程 IP 解析策略工厂，用于解析白名单 IP 地址 private RemoteAddressStrategyFactory remoteAddressStrategyFactory = new RemoteAddressStrategyFactory(); // 缓存 ACL 配置文件和全局白名单的映射关系 private Map<String/** fileFullPath **/, List<RemoteAddressStrategy>> globalWhiteRemoteAddressStrategyMap = new HashMap<>(); // 是否监听 acl 配置文件。如果开启监听，一旦文件内容改变，可以在不重启服务的情况下自动生效 private boolean isWatchStart; // 配置文件版本号表 private Map<String/** fileFullPath **/, DataVersion> dataVersionMap = new HashMap<>(); \",\"aclPlainAccessResourceMap\",\"aclPlainAccessResourceMap是个Map类型，用来缓存所有ACL配置文件的权限数据，其中key表示ACL配置文件的绝对路径， value表示相应配置文件中的权限数据，需要注意的是value也是一个Map类型，其中key是String类型表示AccessKey，value是PlainAccessResource类型。\",\"accessKeyTable\",\"accessKeyTable是个Map类型，用来缓存AccessKey和ACL配置文件的映射关系，其中key表示AccessKey，value表示ACL配置文件的绝对路径。\",\"globalWhiteRemoteAddressStrategy\",\"globalWhiteRemoteAddressStrategy用来缓存所有ACL配置文件的全局白名单。\",\"globalWhiteRemoteAddressStrategyMap\",\"globalWhiteRemoteAddressStrategyMap是个Map类型，用来缓存ACL配置文件和全局白名单的映射关系\",\"dataVersionMap\",\"dataVersionMap是个Map类型，用来缓存所有ACL配置文件的DataVersion，其中key表示ACL配置文件的绝对路径，value表示该配置文件对应的DataVersion。\"]},\"998\":{\"h\":\"4.2.2 PlainPermissonManager#load\",\"t\":[\"它有两个 load 方法，分别用于重新加载全部文件，和重载一个文件的配置。\",\"load()\",\"load() 方法会获取 RocketMQ安装目录/conf 目录（包括该目录的子目录）和 rocketmq.acl.plain.file 下所有ACL配置文件，然后遍历这些文件读取权限数据和全局白名单。\",\"load(String aclFilePath)\",\"load(String aclFilePath) 方法完成加载指定ACL配置文件内容的功能，将配置文件中的全局白名单 globalWhiteRemoteAddresses 和用户权限 accounts 加载到缓存中， 这里需要注意以下几点：\",\"判断缓存中该配置文件的全局白名单 globalWhiteRemoteAddresses 和用户权限accounts 数据是否为空，如果不为空则需要注意删除文件原有数据\",\"相同的 accessKey 只允许存在在一个ACL配置文件中\",\"/** * 解析所有 ACL 配置文件，将 ACL 配置规则加载到内存 */ public void load() { if (fileHome == null || fileHome.isEmpty()) { return; } // 定义临时变量，用于暂存解析出来的 ACL 配置。这里没有直接覆盖全局配置，是为了防止全局配置在未解析完全的情况下被读取 Map<String, Map<String, PlainAccessResource>> aclPlainAccessResourceMap = new HashMap<>(); Map<String, String> accessKeyTable = new HashMap<>(); List<RemoteAddressStrategy> globalWhiteRemoteAddressStrategy = new ArrayList<>(); Map<String, List<RemoteAddressStrategy>> globalWhiteRemoteAddressStrategyMap = new HashMap<>(); Map<String, DataVersion> dataVersionMap = new HashMap<>(); // 获取所有 ACL 配置文件 fileList = getAllAclFiles(defaultAclDir); if (new File(defaultAclFile).exists() && !fileList.contains(defaultAclFile)) { fileList.add(defaultAclFile); } // 遍历 ACL 配置文件，解析配置 for (int i = 0; i < fileList.size(); i++) { JSONObject plainAclConfData = AclUtils.getYamlDataObject(fileList.get(i), JSONObject.class); if (plainAclConfData == null || plainAclConfData.isEmpty()) { throw new AclException(String.format(\\\"%s file is not data\\\", fileList.get(i))); } log.info(\\\"Broker plain acl conf data is : \\\", plainAclConfData.toString()); // 解析全局 IP 白名单配置 List<RemoteAddressStrategy> globalWhiteRemoteAddressStrategyList = new ArrayList<>(); JSONArray globalWhiteRemoteAddressesList = plainAclConfData.getJSONArray(\\\"globalWhiteRemoteAddresses\\\"); if (globalWhiteRemoteAddressesList != null && !globalWhiteRemoteAddressesList.isEmpty()) { for (int j = 0; j < globalWhiteRemoteAddressesList.size(); j++) { globalWhiteRemoteAddressStrategyList.add(remoteAddressStrategyFactory. getRemoteAddressStrategy(globalWhiteRemoteAddressesList.getString(j))); } } if (globalWhiteRemoteAddressStrategyList.size() > 0) { globalWhiteRemoteAddressStrategyMap.put(fileList.get(i), globalWhiteRemoteAddressStrategyList); globalWhiteRemoteAddressStrategy.addAll(globalWhiteRemoteAddressStrategyList); } // 解析账号权限配置 JSONArray accounts = plainAclConfData.getJSONArray(AclConstants.CONFIG_ACCOUNTS); Map<String, PlainAccessResource> plainAccessResourceMap = new HashMap<>(); if (accounts != null && !accounts.isEmpty()) { List<PlainAccessConfig> plainAccessConfigList = accounts.toJavaList(PlainAccessConfig.class); for (PlainAccessConfig plainAccessConfig : plainAccessConfigList) { PlainAccessResource plainAccessResource = buildPlainAccessResource(plainAccessConfig); //AccessKey can not be defined in multiple ACL files if (accessKeyTable.get(plainAccessResource.getAccessKey()) == null) { plainAccessResourceMap.put(plainAccessResource.getAccessKey(), plainAccessResource); accessKeyTable.put(plainAccessResource.getAccessKey(), fileList.get(i)); } else { log.warn(\\\"The accesssKey {} is repeated in multiple ACL files\\\", plainAccessResource.getAccessKey()); } } } if (plainAccessResourceMap.size() > 0) { aclPlainAccessResourceMap.put(fileList.get(i), plainAccessResourceMap); } // 解析数据版本 JSONArray tempDataVersion = plainAclConfData.getJSONArray(AclConstants.CONFIG_DATA_VERSION); DataVersion dataVersion = new DataVersion(); if (tempDataVersion != null && !tempDataVersion.isEmpty()) { List<DataVersion> dataVersions = tempDataVersion.toJavaList(DataVersion.class); DataVersion firstElement = dataVersions.get(0); dataVersion.assignNewOne(firstElement); } dataVersionMap.put(fileList.get(i), dataVersion); } if (dataVersionMap.containsKey(defaultAclFile)) { this.dataVersion.assignNewOne(dataVersionMap.get(defaultAclFile)); } // 刷新全局配置 this.dataVersionMap = dataVersionMap; this.globalWhiteRemoteAddressStrategyMap = globalWhiteRemoteAddressStrategyMap; this.globalWhiteRemoteAddressStrategy = globalWhiteRemoteAddressStrategy; this.aclPlainAccessResourceMap = aclPlainAccessResourceMap; this.accessKeyTable = accessKeyTable; } \"]},\"999\":{\"h\":\"4.2.3 PlainPermissonManager#watch\",\"t\":[\"watch() 方法用来监控 RocketMQ安装目录/conf 目录下所有ACL配置文件和 rocketmq.acl.plain.file 是否发生变化。\",\"变化考虑两种情况：\",\"ACL 配置文件的数量发生变化， 此时会调用 load() 方法重新加载所有配置文件的数据\",\"一种是配置文件的内容发生变化，调用 load(String aclFilePath) 加载单个文件的配置。\",\"具体完成监控ACL配置文件变化的是 AclFileWatchService 服务， 该服务是一个线程，当启动该服务后它会以 WATCH_INTERVAL（该参数目前设置为5秒，目前还不能在Broker配置文件中设置）的时间间隔来执行其核心逻辑。\",\"在该服务中会记录其监控的ACL配置文件目录 aclPath、 ACL配置文件的数量 aclFilesNum、所有ACL配置文件绝对路径 fileList 以及每个ACL配置文件最近一次修改的时间 fileLastModifiedTime （Map类型，key为ACL配置文件的绝对路径，value为其最近一次修改时间）。\",\"该服务的核心逻辑如下：\",\"获取ACL配置文件数量并和 aclFilesNum 进行比较是否相等 \",\"不相等则更新 aclFilesNum和fileList 并调用 load() 方法重新加载所有配置文件\",\"相等则遍历每个ACL配置文件，获取其最近一次修改的时间，并将该时间与 fileLastModifiedTime中记录的时间进行比较 \",\"不相等则表示该文件发生过修改， 此时调用 load(String aclFilePath) 方法重新加载该配置文件。\",\"// PlainPermissionManager.java /** * 监听ACL配置文件变化，重新load */ private void watch() { try { AclFileWatchService aclFileWatchService = new AclFileWatchService(defaultAclDir, defaultAclFile, new AclFileWatchService.Listener() { @Override public void onFileChanged(String aclFileName) { load(aclFileName); } @Override public void onFileNumChanged(String path) { load(); } }); aclFileWatchService.start(); log.info(\\\"Succeed to start AclFileWatchService\\\"); this.isWatchStart = true; } catch (Exception e) { log.error(\\\"Failed to start AclWatcherService\\\", e); } } \",\"// AclFileWatchService.java @Override public void run() { log.info(this.getServiceName() + \\\" service started\\\"); while (!this.isStopped()) { try { this.waitForRunning(WATCH_INTERVAL); if (fileList.size() > 0) { fileList.clear(); } getAllAclFiles(aclPath); if (new File(defaultAclFile).exists() && !fileList.contains(defaultAclFile)) { fileList.add(defaultAclFile); } int realAclFilesNum = fileList.size(); if (aclFilesNum != realAclFilesNum) { log.info(\\\"aclFilesNum: \\\" + aclFilesNum + \\\" realAclFilesNum: \\\" + realAclFilesNum); aclFilesNum = realAclFilesNum; log.info(\\\"aclFilesNum: \\\" + aclFilesNum + \\\" realAclFilesNum: \\\" + realAclFilesNum); Map<String, Long> fileLastModifiedTime = new HashMap<>(realAclFilesNum); for (int i = 0; i < realAclFilesNum; i++) { String fileAbsolutePath = fileList.get(i); fileLastModifiedTime.put(fileAbsolutePath, new File(fileAbsolutePath).lastModified()); } this.fileLastModifiedTime = fileLastModifiedTime; listener.onFileNumChanged(aclPath); } else { for (int i = 0; i < aclFilesNum; i++) { String fileName = fileList.get(i); Long newLastModifiedTime = new File(fileName).lastModified(); if (!newLastModifiedTime.equals(fileLastModifiedTime.get(fileName))) { fileLastModifiedTime.put(fileName, newLastModifiedTime); listener.onFileChanged(fileName); } } } } catch (Exception e) { log.warn(this.getServiceName() + \\\" service has exception. \\\", e); } } log.info(this.getServiceName() + \\\" service end\\\"); } \"]},\"1000\":{\"h\":\"4.3 Broker 权限验证\",\"t\":[\"Broker 权限验证主要逻辑都在 PlainPermissionManager#validate 方法中\",\"判断客户端 IP 是否在全局白名单中，如果匹配则直接放行\",\"判断该用户是否配置在权限控制列表中，如果不在则返回错误\",\"获取请求用户的访问控制权限，判断客户端 IP 是否在用户维度的白名单中，如果匹配则放行\",\"对请求参数验计算签名，验证与客户端计算的签名是否一致，不一致则返回异常\",\"验证资源访问权限，判断该用户是否有客户端请求的资源的相应操作权限\",\"public void validate(PlainAccessResource plainAccessResource) { // Check the global white remote addr for (RemoteAddressStrategy remoteAddressStrategy : globalWhiteRemoteAddressStrategy) { if (remoteAddressStrategy.match(plainAccessResource)) { return; } } if (plainAccessResource.getAccessKey() == null) { throw new AclException(String.format(\\\"No accessKey is configured\\\")); } if (!accessKeyTable.containsKey(plainAccessResource.getAccessKey())) { throw new AclException(String.format(\\\"No acl config for %s\\\", plainAccessResource.getAccessKey())); } // Check the white addr for accesskey String aclFileName = accessKeyTable.get(plainAccessResource.getAccessKey()); PlainAccessResource ownedAccess = aclPlainAccessResourceMap.get(aclFileName).get(plainAccessResource.getAccessKey()); if (ownedAccess.getRemoteAddressStrategy().match(plainAccessResource)) { return; } // Check the signature String signature = AclUtils.calSignature(plainAccessResource.getContent(), ownedAccess.getSecretKey()); if (!signature.equals(plainAccessResource.getSignature())) { throw new AclException(String.format(\\\"Check signature failed for accessKey=%s\\\", plainAccessResource.getAccessKey())); } // Check perm of each resource checkPerm(plainAccessResource, ownedAccess); } \",\"checkPerm(PlainAccessResource needCheckedAccess, PlainAccessResource ownedAccess) 方法完成验证账号是否有该资源访问权限的逻辑。\",\"/** * 验证是否有某资源的访问权限 * * @param needCheckedAccess 客户端请求需要的资源权限 * @param ownedAccess 该账号拥有的资源权限 */ void checkPerm(PlainAccessResource needCheckedAccess, PlainAccessResource ownedAccess) { if (Permission.needAdminPerm(needCheckedAccess.getRequestCode()) && !ownedAccess.isAdmin()) { throw new AclException(String.format(\\\"Need admin permission for request code=%d, but accessKey=%s is not\\\", needCheckedAccess.getRequestCode(), ownedAccess.getAccessKey())); } Map<String, Byte> needCheckedPermMap = needCheckedAccess.getResourcePermMap(); Map<String, Byte> ownedPermMap = ownedAccess.getResourcePermMap(); // 本次操作无需权限验证，直接通过 if (needCheckedPermMap == null) { // If the needCheckedPermMap is null,then return return; } // 该账号未设置任何访问规则，且用户是管理员，直接通过 if (ownedPermMap == null && ownedAccess.isAdmin()) { // If the ownedPermMap is null and it is an admin user, then return return; } // 遍历需要的权限与拥有的权限进行对比 for (Map.Entry<String, Byte> needCheckedEntry : needCheckedPermMap.entrySet()) { String resource = needCheckedEntry.getKey(); Byte neededPerm = needCheckedEntry.getValue(); boolean isGroup = PlainAccessResource.isRetryTopic(resource); if (ownedPermMap == null || !ownedPermMap.containsKey(resource)) { // Check the default perm byte ownedPerm = isGroup ? ownedAccess.getDefaultGroupPerm() : ownedAccess.getDefaultTopicPerm(); if (!Permission.checkPermission(neededPerm, ownedPerm)) { throw new AclException(String.format(\\\"No default permission for %s\\\", PlainAccessResource.printStr(resource, isGroup))); } continue; } if (!Permission.checkPermission(neededPerm, ownedPermMap.get(resource))) { throw new AclException(String.format(\\\"No default permission for %s\\\", PlainAccessResource.printStr(resource, isGroup))); } } } \"]},\"1001\":{\"h\":\"参考资料\",\"t\":[\"权限控制——官网文档\",\"RocketMQ_Multiple_ACL_Files_设计\",\"RocketMQ ACL使用指南\",\"源码分析RocketMQ ACL实现机制\",\"RocketMQ 源码分析之 ACL\",\"RocketMQ ACL 权限控制\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1002\":{\"h\":\"RocketMQ 消息轨迹\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220521-rocketmq-trace.html\"]},\"1003\":{\"h\":\"1. 背景\",\"t\":[\"发往消息队列中的消息存在一些可观测性上的问题。由于消息队列需要高性能、大量地处理消息，而在 Broker 端记录消息的方式（使用日志等）势必会对性能造成非常大的损耗，所以对于消息是否成功发送到 Broker、Broker 又是否成功将消息投递给消费者这些动作，缺乏观测手段。这样就会造成生产方和消费方互相“扯皮”的现象：一条消息没有被成功消费，到底是生产方没有发送，还是消费方没有消费成功。\",\"RocketMQ 在 4.4.0 版本正式引入了消息轨迹功能，它可以用来记录消息发送、消息消费的信息，详细记录消息各个处理环节的日志。\"]},\"1004\":{\"h\":\"2. 使用示例\",\"t\":[\"要使用消息轨迹，在 Broker 端和客户端都需要进行一些配置。更详细的消息轨迹使用方法请参考官方文档。\",\"rocketmq-spring 开启消息轨迹的文档。\",\"物理 IO 隔离模式\",\"对于消息轨迹数据量较大的场景，可以在RocketMQ集群中选择其中一个Broker节点专用于存储消息轨迹，使得用户普通的消息数据与消息轨迹数据的物理IO完全隔离，互不影响。在该模式下，RockeMQ集群中至少有两个Broker节点，其中一个Broker节点定义为存储消息轨迹数据的服务端。\"]},\"1005\":{\"h\":\"2.1 Broker 端配置\",\"t\":[\"在 broker.conf 中启用消息轨迹功能，该功能默认关闭。\",\"### if msg tracing is open,the flag will be true traceTopicEnable=true \",\"注意需要重启 Broker 才可以应用改动。\"]},\"1006\":{\"h\":\"2.2 生产者开启消息轨迹\",\"t\":[\"// 构建生产者。第二个参数即启用消息轨迹，第三个参数（可选）可以指定保存消息轨迹的 Topic DefaultMQProducer producer = new DefaultMQProducer(\\\"ProducerGroupName\\\", true); producer.setNamesrvAddr(\\\"XX.XX.XX.XX1\\\"); producer.start(); try { { // 建议为消息指定 Key，便于对消息进行高性能查询。这里的 OrderID188 即消息的 Key Message msg = new Message(\\\"TopicTest\\\", \\\"TagA\\\", \\\"OrderID188\\\", \\\"Hello world\\\".getBytes(RemotingHelper.DEFAULT_CHARSET)); SendResult sendResult = producer.send(msg); System.out.printf(\\\"%s%n\\\", sendResult); } } catch (Exception e) { e.printStackTrace(); } \"]},\"1007\":{\"h\":\"2.3 消费者开启消息轨迹\",\"t\":[\"// 构建消费者。第二个参数即启用消息轨迹，第三个参数（可选）可以指定保存消息轨迹的 Topic DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\\\"CID_JODIE_1\\\", true); consumer.subscribe(\\\"TopicTest\\\", \\\"*\\\"); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.setConsumeTimestamp(\\\"20181109221800\\\"); consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) { System.out.printf(\\\"%s Receive New Messages: %s %n\\\", Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); consumer.start(); System.out.printf(\\\"Consumer Started.%n\\\"); \"]},\"1008\":{\"h\":\"2.4 使用 mqadmin 查看消息轨迹\",\"t\":[\"查询轨迹\",\"./mqadmin QueryMsgTraceById -n 127.0.0.1:9876 -i \\\"message-id\\\" \",\"查询轨迹结果\",\"RocketMQLog:WARN No appenders could be found for logger (io.netty.util.internal.PlatformDependent0). RocketMQLog:WARN Please initialize the logger system properly. #Type #ProducerGroup #ClientHost #SendTime #CostTimes #Status Pub 1623305799667 xxx.xxx.xxx.xxx 2021-06-10 14:16:40 131ms success \"]},\"1009\":{\"h\":\"2.5 使用 rocketmq-dashboard 查看消息轨迹\",\"t\":[\"RocketMQ 的官方 DashBoard 支持消息轨迹的查询\"]},\"1010\":{\"h\":\"3. 概要设计\",\"t\":[\"在设计消息轨迹功能时，能想到的要点主要有如下几点\",\"如何采集轨迹数据\",\"采集的轨迹数据要包含哪些数据\",\"如何存储轨迹数据\",\"如何将轨迹数据发送至存储，而尽可能不影响正常消息发送的性能\",\"首先是如何采集数据。消息轨迹关注是否被生产和消费，以及消息生产、消费相关的数据，所以需要在消息生产和消费时采集一些数据。\",\"RocketMQ 提供了消息生产和消费的钩子，可以在消息生产、消费前后添加自定义的逻辑，于是轨迹数据的采集可以放在钩子函数中进行。\",\"对于消息的存储，处于不添加额外依赖的考虑，存储在 Broker 是最佳的选择。消息轨迹的数据可以封装成消息，与普通消息公用存储，存在 Broker 中。\",\"那么如何在发送普通消息的同时发送消息轨迹消息？为了保证普通消息发送的性能，势必使用异步发送。此外，由于消息轨迹数据没有普通消息那样强的实时性要求，所以可以通过批量发送的方式减少性能损耗。\"]},\"1011\":{\"h\":\"3.1 主要流程\",\"t\":[\"这里以生产者为例，生产者在发送消息前后的钩子函数中分别添加消息轨迹采集逻辑，随后将轨迹信息交给一个异步线程池处理。\",\"这个异步线程池批量将轨迹信息打包发送给 Broker，完成消息轨迹的保存。\"]},\"1012\":{\"h\":\"3.2 存储设计\",\"t\":[\"默认情况下，消息轨迹保存在一个默认的 Topic 中，RMQ_SYS_TRACE_TOPIC，这个 Topic 只有一个队列，所以只会存在一个 Broker。在使用时可以在生产者和消费者上指定消息轨迹发送的自定义 Topic。\",\"官方将消息轨迹存储的模式分为两种：普通模式和物理 IO 隔离模式。\",\"普通模式即集群中每个 Broker 都可以存储消息轨迹数据。\",\"物理 IO 隔离模式即单独选一个 Broker 只作为消息轨迹接收的节点，这样就不会增加其他 Broker 的负载。\"]},\"1013\":{\"h\":\"4. 详细设计\"},\"1014\":{\"h\":\"4.1 轨迹数据采集\",\"t\":[\"前面说到，采集消息轨迹数据的最佳方法就是在发送和消费时在钩子函数中进行。\",\"所以如果客户端创建时开启了消息轨迹功能，那么将新建处理轨迹的钩子，注册到生产者或消费者实例中去。\",\"生产者的钩子类是 SendMessageTraceHookImpl，消费者的钩子类是 ConsumeMessageTraceHookImpl。\",\"在 before 方法中，会构建一个轨迹上下文，将数据采集到该上下文中。\",\"在 after 方法中，采集数据并将该上下文信息交给轨迹数据异步发送线程池 AsyncTraceDispatcher 处理，将会保存到一个 BlockingQueue 中由工作线程消费。\"]},\"1015\":{\"h\":\"4.2 轨迹数据发送\",\"t\":[\"发送逻辑采用生产-消费模式，由 AsyncTraceDispatcher处理。 一个工作线程负责消费客户端实例提交过来的轨迹数据。\",\"工作线程每次消费一批轨迹数据，将轨迹数据打包后提交给发送线程池。发送线程池将这些轨迹消息发送给指定的 Broker。\"]},\"1016\":{\"h\":\"5. 源码解析\"},\"1017\":{\"h\":\"5.1 消息轨迹数据模型\",\"t\":[\"消息轨迹的模型类是 TraceContext，其中的 traceBeans 列表保存着具体消息的轨迹信息。\",\"该列表在消息生产时永远只有 1 条数据，即生产发送的消息。\",\"在消费时可能由多条数据，因为消费者每次会消费多条消息。\",\"/** * The context of Trace */ public class TraceContext implements Comparable<TraceContext> { // 轨迹类型。Pub：消息发送，SubBefore：消费者消费前，SubAfter：消费者消费后 private TraceType traceType; // 时间戳 private long timeStamp = System.currentTimeMillis(); // Broker 所在区域 ID，取自 BrokerConfig#regionId private String regionId = \\\"\\\"; private String regionName = \\\"\\\"; // 生产者或消费者组名称 private String groupName = \\\"\\\"; // 耗时 private int costTime = 0; // 发送/消费成功 private boolean isSuccess = true; // 在消费时使用，消费端的请求 ID private String requestId = MessageClientIDSetter.createUniqID(); // 消费状态码 private int contextCode = 0; // 消息的轨迹数据 private List<TraceBean> traceBeans; } \",\"public class TraceBean { private static final String LOCAL_ADDRESS = UtilAll.ipToIPv4Str(UtilAll.getIP()); private String topic = \\\"\\\"; private String msgId = \\\"\\\"; // 消息偏移量 ID，包含了 Broker 的 IP 和消息存储在 Broker 上的偏移量 private String offsetMsgId = \\\"\\\"; private String tags = \\\"\\\"; private String keys = \\\"\\\"; // 生产者采集时为 Broker 的 IP，消费者采集时为消费者 IP private String storeHost = LOCAL_ADDRESS; // 客户端 IP。生产者采集时为生产者的 IP，消费者采集时为消费者 IP private String clientHost = LOCAL_ADDRESS; // 存储时间 private long storeTime; private int retryTimes; // 消息体长度 private int bodyLength; // 消息类型 private MessageType msgType; private LocalTransactionState transactionState; private String transactionId; private boolean fromTransactionCheck; } \"]},\"1018\":{\"h\":\"5.2 消息轨迹数据采集\",\"t\":[\"这里以消费者为例\"]},\"1019\":{\"h\":\"5.2.1 注册消息轨迹采集钩子\",\"t\":[\"public DefaultMQPushConsumer(final String namespace, final String consumerGroup, RPCHook rpcHook, AllocateMessageQueueStrategy allocateMessageQueueStrategy, boolean enableMsgTrace, final String customizedTraceTopic) { this.consumerGroup = consumerGroup; this.namespace = namespace; this.allocateMessageQueueStrategy = allocateMessageQueueStrategy; defaultMQPushConsumerImpl = new DefaultMQPushConsumerImpl(this, rpcHook); // 如果开启消息轨迹 if (enableMsgTrace) { try { // 创建消息轨迹异步发送者 AsyncTraceDispatcher dispatcher = new AsyncTraceDispatcher(consumerGroup, TraceDispatcher.Type.CONSUME, customizedTraceTopic, rpcHook); dispatcher.setHostConsumer(this.getDefaultMQPushConsumerImpl()); traceDispatcher = dispatcher; // 注册消息轨迹采集钩子 this.getDefaultMQPushConsumerImpl().registerConsumeMessageHook( new ConsumeMessageTraceHookImpl(traceDispatcher)); } catch (Throwable e) { log.error(\\\"system mqtrace hook init failed ,maybe can't send msg trace data\\\"); } } } \"]},\"1020\":{\"h\":\"5.2.2 钩子方法中采集消息轨迹数据\",\"t\":[\"// ConsumeMessageTraceHookImpl.java /** * 消息消费前调用 * 收集将要消费消息的轨迹信息，存入调用上下文 * * @param context */ @Override public void consumeMessageBefore(ConsumeMessageContext context) { if (context == null || context.getMsgList() == null || context.getMsgList().isEmpty()) { return; } // 创建消息轨迹上下文 TraceContext traceContext = new TraceContext(); context.setMqTraceContext(traceContext); // 设置消息轨迹类型 traceContext.setTraceType(TraceType.SubBefore);// // 设置消费组名 traceContext.setGroupName(NamespaceUtil.withoutNamespace(context.getConsumerGroup()));// // 将消费到的消息构建 TraceBean 列表，采集每条消息的轨迹数据 List<TraceBean> beans = new ArrayList<TraceBean>(); for (MessageExt msg : context.getMsgList()) { if (msg == null) { continue; } String regionId = msg.getProperty(MessageConst.PROPERTY_MSG_REGION); String traceOn = msg.getProperty(MessageConst.PROPERTY_TRACE_SWITCH); if (traceOn != null && traceOn.equals(\\\"false\\\")) { // If trace switch is false ,skip it continue; } TraceBean traceBean = new TraceBean(); traceBean.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic()));// traceBean.setMsgId(msg.getMsgId());// traceBean.setTags(msg.getTags());// traceBean.setKeys(msg.getKeys());// traceBean.setStoreTime(msg.getStoreTimestamp());// traceBean.setBodyLength(msg.getStoreSize());// traceBean.setRetryTimes(msg.getReconsumeTimes());// traceContext.setRegionId(regionId);// beans.add(traceBean); } // 将消息轨迹交给异步发送者处理 if (beans.size() > 0) { traceContext.setTraceBeans(beans); traceContext.setTimeStamp(System.currentTimeMillis()); localDispatcher.append(traceContext); } } /** * 消息消费后调用 * 采集消费完成的消息轨迹数据，存入轨迹上下文，然后发送 * * @param context */ @Override public void consumeMessageAfter(ConsumeMessageContext context) { if (context == null || context.getMsgList() == null || context.getMsgList().isEmpty()) { return; } // 从轨迹上下文获取消费前的轨迹数据 TraceContext subBeforeContext = (TraceContext) context.getMqTraceContext(); if (subBeforeContext.getTraceBeans() == null || subBeforeContext.getTraceBeans().size() < 1) { // If subBefore bean is null ,skip it return; } // 构建消费后的轨迹数据 TraceContext subAfterContext = new TraceContext(); subAfterContext.setTraceType(TraceType.SubAfter);// subAfterContext.setRegionId(subBeforeContext.getRegionId());// subAfterContext.setGroupName(NamespaceUtil.withoutNamespace(subBeforeContext.getGroupName()));// subAfterContext.setRequestId(subBeforeContext.getRequestId());// subAfterContext.setSuccess(context.isSuccess());// // Calculate the cost time for processing messages int costTime = (int) ((System.currentTimeMillis() - subBeforeContext.getTimeStamp()) / context.getMsgList().size()); subAfterContext.setCostTime(costTime);// subAfterContext.setTraceBeans(subBeforeContext.getTraceBeans()); Map<String, String> props = context.getProps(); if (props != null) { String contextType = props.get(MixAll.CONSUME_CONTEXT_TYPE); if (contextType != null) { subAfterContext.setContextCode(ConsumeReturnType.valueOf(contextType).ordinal()); } } // 发给异步发送者处理 localDispatcher.append(subAfterContext); } \"]},\"1021\":{\"h\":\"5.3 消息轨迹数据发送\",\"t\":[\"AsyncTraceDispatcher 是专门用来异步发送轨迹消息的异步转发器，负责消息轨迹消息的转发。前面说到消息轨迹数据也以消息的形式发送到 Broker 中进行存储。\",\"AsyncTraceDispatcher 中有 1 个线程池 traceExecutor，负责异步发送轨迹数据，消息生产者 traceProducer 处理生产逻辑，1 个工作线程 worker 负责将 客户端采集到的轨迹上下文提交给线程池处理。\",\"/** * 消息轨迹异步转发器，异步实现消息轨迹数据的发送 */ public class AsyncTraceDispatcher implements TraceDispatcher { // 异步转发队列长度，默认 2048 private final int queueSize; // 一次发送的请求包含数据条数，默认 100 private final int batchSize; // 一次发送最大消息大小，默认 128k private final int maxMsgSize; // 发送消息轨迹的消息生产者 private final DefaultMQProducer traceProducer; // 异步发送线程池 private final ThreadPoolExecutor traceExecutor; // 丢弃的消息个数 // The last discard number of log private AtomicLong discardCount; // 工作线程，从追加队列中获取一批待发送的消息轨迹数据，提交到线程池中执行 private Thread worker; // 消息轨迹待发送数据队列，存储每个消息轨迹的上下文 private final ArrayBlockingQueue<TraceContext> traceContextQueue; // 线程池内部队列，存储线程池发送任务 private ArrayBlockingQueue<Runnable> appenderQueue; private volatile Thread shutDownHook; private volatile boolean stopped = false; private DefaultMQProducerImpl hostProducer; // 消费者信息，记录消费时的轨迹 private DefaultMQPushConsumerImpl hostConsumer; private volatile ThreadLocalIndex sendWhichQueue = new ThreadLocalIndex(); private String dispatcherId = UUID.randomUUID().toString(); // 消息轨迹存放的 Topic private String traceTopicName; private AtomicBoolean isStarted = new AtomicBoolean(false); private AccessChannel accessChannel = AccessChannel.LOCAL; private String group; private Type type; } \",\"worker 工作线程用一个死循环，不停地尝试从消息轨迹队列中获取一批数据，封装成一个发送任务提交给消息发送线程池处理。\",\"/** * 批量从待处理消息轨迹队列中取数据，封装成一个 {@link AsyncAppenderRequest} 异步发送请求，提交给发送线程池执行 * 批量发送机制是为了提高效率 */ class AsyncRunnable implements Runnable { private boolean stopped; @Override public void run() { while (!stopped) { List<TraceContext> contexts = new ArrayList<TraceContext>(batchSize); // 批量从等待处理的消息轨迹队列中获取数据，将一批数据封装成一个发送请求，提交给异步发送线程池执行 synchronized (traceContextQueue) { for (int i = 0; i < batchSize; i++) { TraceContext context = null; try { //get trace data element from blocking Queue - traceContextQueue context = traceContextQueue.poll(5, TimeUnit.MILLISECONDS); } catch (InterruptedException e) { } if (context != null) { contexts.add(context); } else { break; } } if (contexts.size() > 0) { AsyncAppenderRequest request = new AsyncAppenderRequest(contexts); traceExecutor.submit(request); } else if (AsyncTraceDispatcher.this.stopped) { // 同步 AsyncTraceDispatcher 的停止状态 this.stopped = true; } } } } } \",\"而真正的发送逻辑则在 AsyncAppenderRequest#run() 中执行的 sendTraceData 方法中执行\",\"/** * 一次发送一批消息轨迹数据 * * @param contextList 消息轨迹数据列表，本次要发送的数据 */ public void sendTraceData(List<TraceContext> contextList) { // 按 Topic 区分的消息轨迹数据表 Map<String, List<TraceTransferBean>> transBeanMap = new HashMap<String, List<TraceTransferBean>>(); for (TraceContext context : contextList) { if (context.getTraceBeans().isEmpty()) { continue; } // Topic value corresponding to original message entity content String topic = context.getTraceBeans().get(0).getTopic(); String regionId = context.getRegionId(); // 用原 Topic 和 regionId 组成 key // Use original message entity's topic as key String key = topic; if (!StringUtils.isBlank(regionId)) { key = key + TraceConstants.CONTENT_SPLITOR + regionId; } // 根据 Key 将消息轨迹数据分类，存入 map List<TraceTransferBean> transBeanList = transBeanMap.get(key); if (transBeanList == null) { transBeanList = new ArrayList<TraceTransferBean>(); transBeanMap.put(key, transBeanList); } // 按消息轨迹存储协议进行编码，当前为字符串拼接模式 TraceTransferBean traceData = TraceDataEncoder.encoderFromContextBean(context); transBeanList.add(traceData); } // 按 Topic 分批将消息发送到 Broker 中 for (Map.Entry<String, List<TraceTransferBean>> entry : transBeanMap.entrySet()) { String[] key = entry.getKey().split(String.valueOf(TraceConstants.CONTENT_SPLITOR)); String dataTopic = entry.getKey(); String regionId = null; if (key.length > 1) { dataTopic = key[0]; regionId = key[1]; } flushData(entry.getValue(), dataTopic, regionId); } } \"]},\"1022\":{\"h\":\"参考资料\",\"t\":[\"消息轨迹——官方文档\",\"RocketMQ消息轨迹-设计篇\",\"源码分析RocketMQ消息轨迹\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1023\":{\"h\":\"RocketMQ 消息发送设计和原理详解 源码剖析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220606-rocketmq-send-message.html\"]},\"1024\":{\"h\":\"1. 背景\",\"t\":[\"发送消息是 MQ 最基础的操作之一。RocketMQ 官方提供了多语言客户端支持消息的发送和消费操作。 当然，消息发送并不仅仅牵扯到客户端操作。客户端做的是向 Broker 发送请求，请求中包含了消息的全部信息。而 Broker 需要处理客户端发送来的生产请求，将消息存储起来。 在这篇文章中我将解析消息发送流程中生产者和 Broker 的处理流程，揭秘 RocketMQ 消息发送高性能、高可靠的原理。\"]},\"1025\":{\"h\":\"2. 概述\",\"t\":[\"RocketMQ 的 Java 客户端提供了丰富的消息发送 API，支持多种消息发送的方式和特殊消息的发送。 包括 3 种发送方式（同步、异步、单向）和多种特殊消息（顺序消息、延时消息、批量消息、过滤消息、事务消息）。 对于客户端消息发送 API 的具体使用方式，可以参考官方文档：https://github.com/apache/rocketmq/blob/develop/docs/cn/RocketMQ_Example.md。\"]},\"1026\":{\"h\":\"2.1 消息发送方式和特殊消息\"},\"1027\":{\"h\":\"2.1.1 三种消息发送方式\",\"t\":[\"RocketMQ 支持 3 种消息发送方式：同步、异步和单向。\",\"同步（Sync） \",\"发送消息时，同步等待，直到 Broker 返回发送结果。\",\"这种方式最为可靠，但是发送性能最差。\",\"在一些可靠性要求非常高的场景下，推荐使用同步方式。比如：重要的消息通知，短信通知。\",\"异步（Async） \",\"发送消息时，无需等待 Broker 返回发送结果，发送线程不阻塞。执行发送 API 时指定消息发送成功后的回调函数。\",\"这种方式相比于同步发送，性能可以提升多个数量级，但可靠性不如同步发送。\",\"在对响应时间敏感、流量较大的场景下，推荐使用异步方式。异步发送是使用最广泛的发送方式。\",\"单向（One-way） \",\"发送消息时，直接返回，不等待 Broker 返回发送结果，也不注册回调函数。\",\"这种发送方式性能最高，可靠性最差。它不关心发送结果，不在乎消息是否成功存储在 Broker 中。\",\"适用于消息丢失也没有太大影响的场景，例如发送日志。\",\"这三种发送方式中，异步发送是最为广泛使用的发送方式。配合一些重试和补偿机制，可以达成较高的可靠性和很高的性能。\"]},\"1028\":{\"h\":\"2.1.2 特殊消息类型\",\"t\":[\"下面简单介绍一下几种特殊消息类型。\",\"普通消息：发送效率最高、使用场景最广泛的消息类型。普通消息可以由客户端并发发送。不保证普通消息消费的顺序。单 Broker 性能可以达到十万级别。（视 Broker 配置而变）\",\"队列级别顺序消息：RocketMQ 将一个 Topic 分为多个队列，以提高消费速度。每隔分区内的消息遵循先生产先消费的顺序。\",\"Topic 级别顺序消息：如果把一个 Topic 的队列数量设为 1，那么该 Topic 中的消息也遵循先生产先消费。\",\"延迟消息：消息发送后，消费者并不马上收到消息，而是等待一段指定的时间之后才能消费到该消息。\",\"事务消息：提供分布式事务功能，可以保证发送消息和另外的操作同时成功或者同时失败。\",\"批量消息：将多个消息包装成一个批量消息，一起发送。降低网络传输次数，提升传输效率。\"]},\"1029\":{\"h\":\"2.2 路由机制\",\"t\":[\"RocketMQ 的 Topic 可以分为多个队列，每个队列可能分布在不同 Broker 上。\",\"消息的路由指的是发送消息时需要先获取 Topic 的路由信息（其中包含每个 Topic 的队列和它们所在的 Broker 地址），然后选择一个队列进行发送。\",\"具体选择队列的方式是轮询，但是如果上一次发送失败，下一次选择队列时会避开发送失败队列所在的 Broker。此外有一个故障延迟机制，它默认关闭，如果开启则会在一段时间内都规避发送失败的 Broker。\",\"消息发送的 API 提供了参数，可以传入要发送的队列信息，或者传入队列选择方法，以供用户选择发往某个 Broker 的具体队列。\"]},\"1030\":{\"h\":\"2.3 消息发送流程\",\"t\":[\"消息发送的流程涉及到 RocketMQ 的三个组件：生产者、Broker、NameServer。 其中生产者负责发送消息，Broker 负责处理消息发送请求，NameServer 负责更新和提供路由信息。\",\"如图所示\",\"生产者每 30 秒向 NameServer 拉取路由信息，Broker 每 30 秒向 NameServer 发送路由信息。\",\"生产者发送消息时，会先在本地查询 Topic 路由信息。\",\"如果查询不到，会请求 NameServer 查询。\",\"随后将消息发送给 Broker。\",\"Broker 也会在本地查询 Topic 路由信息来检查消息的 Topic 是否存在。\",\"随后保存消息，如果是异步发送则直接返回，如果同步发送则等待消息保存成功后返回。\"]},\"1031\":{\"h\":\"2.4 高可用设计\"},\"1032\":{\"h\":\"2.4.1 生产者高可用\",\"t\":[\"消息发送重试机制：生产者在消息发送时如果出现失败，默认会重试 2 次。\",\"故障规避机制：如果重试的消息仍发往同一个 Broker，发送大概率还是会失败，所以在重试时会尽量避开刚刚发送失败的 Broker。 \",\"可以通过配置故障延迟机制来指定是在本次消息发送时暂时避开发送失败的 Broker，还是在之后一段时间都避开该 Broker\"]},\"1033\":{\"h\":\"2.4.2 Broker 端高可用\",\"t\":[\"Broker 端的高可用是用数据同步的方式，将消息同步到备 Broker 上，当主 Broker 发生故障时，可以从备 Broker 上恢复数据。\"]},\"1034\":{\"h\":\"3. 详细设计\"},\"1035\":{\"h\":\"3.1 消息\",\"t\":[\"RocketMQ 中的消息类主要有 3 个\",\"Message 为客户端需要使用的消息类。\",\"MessageExt 为消息扩展属性类，它扩展了 Message，在 Broker 上产生此对象。\",\"MessageExtBrokerInner 是存储内部使用的 Message 对象，在 rocketmq-store 模块使用。\",\"在发送消息时，用到的是 Message，可以指定消息的属性、消息体和 flag。\"]},\"1036\":{\"h\":\"3.2 生产者类图\",\"t\":[\"DefaultMQProducer 是 RocketMQ 中默认的生产者实现，它实现了 MQAdmin 接口。\",\"DefaultMQProducer 内部包装了一个 DefaultMQProducerImpl 字段，它是生产者的具体实现类，DefaultMQProducer 调用它内部的 DefaultMQProducerImpl 来发送命令。\",\"DefaultMQProducerImpl 内部注册了一个 MQClientInstance 字段。MQClientInstance 是与 NameServer 和 Broker 通信的中介。 MQClientInstance 与 ClientId 一一对应，ClientId 由 clientIp、instanceName、unitName 组成。如果不手动修改，一般来说一个启动的客户端进程只有一个 MQClientInstance 实例，这样可以节省客户端资源。\",\"MQClientInstnace 内部的 producerTable 注册了 ClientId 和 DefaultMQProducerImpl 的对应关系\",\"MQClientAPIImpl 提供了发送消息的 API，它调用 RemotingClient 执行发送。\"]},\"1037\":{\"h\":\"3.3 生产者启动\",\"t\":[\"构造 DefaultMQProducer 实例，start() 启动\",\"初始化 DefaultMQProducerImpl，设置状态为 CREATE_JUST\",\"启动 DefaultMQProducerImpl\",\"检查配置\",\"根据 ClientId 获取或创建 MQClientInstance\",\"将 DefaultMQProducerImpl 注册到 MQClientInstance\",\"启动 MQClientInstance，MQClientInstance 启动定时任务，包括从 NameServer 拉取 Topic 路由信息、向 Broker 发送心跳\",\"MQClientInstance 启动 PullMessageService 和 RebalanceService\",\"设置服务状态为 RUNNING\"]},\"1038\":{\"h\":\"3.4 消息发送\",\"t\":[\"RocketMQ 的消息发送流程图如下图所示：\",\"其中 MQProducerImpl 负责执行核心的消息发送方法 sendDefaultImpl\",\"这个方法中包含了消息发送的核心逻辑\",\"查找 Topic 路由信息\",\"选择消息队列\",\"发送消息\"]},\"1039\":{\"h\":\"3.4.1 查找 Topic 路由信息\",\"t\":[\"指定 Topic 发送消息后，生产者需要知道消息要发往哪个 Broker 地址。于是需要获取 Topic 路由信息，查询 Topic 所在的 Broker，随后选择一个 Broker 进行发送。该逻辑在 DefaultMQProducerImpl#tryToFindTopicPublishInfo() 中执行。\",\"在第一次发送消息时，本地没有缓存 Topic 路由信息，所以需要主动从 NameServer 拉取，然后更新到本地路由表缓存。随后生产者会启动定时任务，每隔 30s 重新从 NameServer 拉取路由信息。\",\"注意，第一次查询 NameServer 时，如果没有拉取到 Topic 路由信息，则会使用默认 Topic（AUTO_CREATE_TOPIC_KEY_TOPIC）再次查询。\",\"默认 Topic 在 Broker 启动时创建，是为自动创建主题运用的。 它的目的是在主题没有被创建时，让生产者发送消息时也能够查询到 Broker 地址。 然后等消息真正发送到 Broker 时，会根据消息的 Topic 创建主题。\",\"如果最终都没有拉取到 Topic 路由信息，则会抛出异常。\"]},\"1040\":{\"h\":\"3.4.2 重试机制\",\"t\":[\"同步发送和异步发送的重试次数分别由 retryTimesWhenSendFailed 和 retryTimesWhenSendAsyncFailed 指定，默认都为 2 次（发送 1 次，重试 1 次）。\",\"同步发送的重试逻辑即在 sendDefaultImpl() 方法中循环发送执行发送逻辑。\",\"异步发送的重试逻辑在 MQClientAPIIpml() 的sendMessageAsync() 构造的回调方法中指定。它调用 onExceptionImpl() 方法，如果当前发送次数小于异步发送重试次数，则再次执行 sendMessageAsync() 重试发送。\"]},\"1041\":{\"h\":\"3.4.3 选择消息队列：故障延迟机制\",\"t\":[\"获取到 Topic 路由信息后，需要从中选择一个队列进行发送。选择队列的逻辑由 MQFaultStrategy#selectOneMessageQueue()处理，在正常情况下，会轮询所有队列进行发送；上一次发送异常的情况下它将执行 Broker 规避和故障延迟机制。\",\"默认机制\",\"默认机制下，按照轮询的方式选择队列。如果上一次发送成功，选择下一个队列。如果上一次发送失败，会规避上一次发送的 MessageQueue 所在的 Broker。\",\"故障延迟机制\",\"故障延迟机制是为了能够在消息发送的时候尽量避开上次发送失败的 Broker，它由 sendLatencyFaultEnable 参数来设置开启，默认为关闭状态。\",\"关闭：发送一次消息失败后，会在本次消息发送过程中避开该 Broker，但下次发送消息时还会继续尝试。\",\"开启：发送一次消息失败后，会悲观地认为 Broker 不可用，在接下来一段时间内都不再向其发送消息。随着发送失败次数的增多，规避时间将越来越长。\"]},\"1042\":{\"h\":\"3.4.4 发送消息\",\"t\":[\"消息发送逻辑由 DefaultMQProducerImpl#sendKernelImpl() 处理。\",\"先根据上一步选择的队列，查询 MQClientInstance 获取对应的 Broker 地址（先查本地缓存，如果没有则从 NameServer 拉取）。\",\"设置消息的全局唯一 ID，然后对于超过 4KB （默认）的消息执行 zip 压缩。\",\"执行发送之前的钩子函数 executeSendMessageHookBefore()，如消息轨迹的处理逻辑就在这里进行处理。\",\"构建消息请求（头）\",\"根据消息发送方式调用 MQClientAPIImpl 进行网络传输\",\"执行消息发送后的钩子函数\",\"MQClientAPIImpl 负责调用 NettyRemotingClient 将生产消息的请求发往 Broker。\"]},\"1043\":{\"h\":\"3.5 Broker 处理发送请求\",\"t\":[\"Broker 通过 SendMessageProcessor 处理生产者发来的消息生产请求。当前使用 asyncSendMessage() 异步处理生产者发送过来的请求。\",\"RocketMQ 的 Netty 请求处理机制会按照业务逻辑进行处理器的拆分。具体地说，RocketMQ 为不同的请求类型（请求码）注册不同的业务处理器和线程池去处理。比如消息生产的请求由 sendMessageExecutor 线程池处理，消费请求由 pullMessageExecutor 处理……\",\"Broker 处理消息生产请求逻辑如下：\",\"检查消息合理性\",\"如果消息重试次数超过允许的最大重试次数，将进入死信队列。\",\"调用存储模块将消息存储\"]},\"1044\":{\"h\":\"3.6 Batch 消息（批量消息）\",\"t\":[\"为了减少网络请求次数，RocketMQ 支持将统一主题的一批消息打包发送。对于每条消息较小且消息较多的场景，使用批量发送可以提升发送效率。\",\"批量消息 MessageBatch 类继承普通消息类 Message，内部仅仅多了消息列表 List<Message> messages。这样就可以像发送普通消息一样发送批量消息。发送前需要做的就是将多条普通消息体编码，放到 MessageBatch 的消息体中。\",\"服务端接收到后，按照相同规则对批量消息进行解码，即可解码出多条消息。\"]},\"1045\":{\"h\":\"4. 源码解析\"},\"1046\":{\"h\":\"4.1 生产者启动\"},\"1047\":{\"h\":\"4.1.1 DefaultMQProducerImpl#start\",\"t\":[\"// DefaultMQProducerImpl.java public void start(final boolean startFactory) throws MQClientException { switch (this.serviceState) { // 如果状态为 CREATE_JUST，执行启动逻辑。该对象创建时默认状态为 CREATE_JUST case CREATE_JUST: this.serviceState = ServiceState.START_FAILED; // 检查 producerGroup 是否合法 this.checkConfig(); // 改变生产者的 instanceName 为进程 ID，避免同一个服务器上的多个生产者实例名相同 if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) { this.defaultMQProducer.changeInstanceNameToPID(); } // 创建 MQClientInstance 实例 this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQProducer, rpcHook); // 向 MQClientInstance 注册服务，将当前生产者加入 MQClientInstance 管理（加入 MQClientInstance.producerTable） // 方便后续调用网络请求、进行心跳检测等 boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this); if (!registerOK) { this.serviceState = ServiceState.CREATE_JUST; throw new MQClientException(\\\"The producer group[\\\" + this.defaultMQProducer.getProducerGroup() + \\\"] has been created before, specify another name please.\\\" + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL), null); } this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo()); // 启动 MQClientInstance，如果已经启动，则不会执行 if (startFactory) { mQClientFactory.start(); } log.info(\\\"the producer [{}] start OK. sendMessageWithVIPChannel={}\\\", this.defaultMQProducer.getProducerGroup(), this.defaultMQProducer.isSendMessageWithVIPChannel()); // 设置服务状态为 RUNNING this.serviceState = ServiceState.RUNNING; break; case RUNNING: case START_FAILED: case SHUTDOWN_ALREADY: throw new MQClientException(\\\"The producer service state not OK, maybe started once, \\\" + this.serviceState + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK), null); default: break; } // 启动后马上向 NameServer 发送心跳 this.mQClientFactory.sendHeartbeatToAllBrokerWithLock(); RequestFutureHolder.getInstance().startScheduledTask(this); } \"]},\"1048\":{\"h\":\"4.1.2 MQClientException\",\"t\":[\"/** * 启动客户端代理 * * @throws MQClientException */ public void start() throws MQClientException { synchronized (this) { switch (this.serviceState) { case CREATE_JUST: this.serviceState = ServiceState.START_FAILED; // If not specified,looking address from name server if (null == this.clientConfig.getNamesrvAddr()) { this.mQClientAPIImpl.fetchNameServerAddr(); } // Start request-response channel this.mQClientAPIImpl.start(); // Start various schedule tasks this.startScheduledTask(); // Start pull service this.pullMessageService.start(); // Start rebalance service this.rebalanceService.start(); // Start push service // 当消费失败的时候，需要把消息发回去 this.defaultMQProducer.getDefaultMQProducerImpl().start(false); log.info(\\\"the client factory [{}] start OK\\\", this.clientId); this.serviceState = ServiceState.RUNNING; break; case START_FAILED: throw new MQClientException(\\\"The Factory object[\\\" + this.getClientId() + \\\"] has been created before, and failed.\\\", null); default: break; } } } /** * 启动定时任务 */ private void startScheduledTask() { if (null == this.clientConfig.getNamesrvAddr()) { this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { try { MQClientInstance.this.mQClientAPIImpl.fetchNameServerAddr(); } catch (Exception e) { log.error(\\\"ScheduledTask fetchNameServerAddr exception\\\", e); } } }, 1000 * 10, 1000 * 60 * 2, TimeUnit.MILLISECONDS); } /** * 默认每30s从nameserver获取Topic路由信息 * 包括 生产者和消费者 */ this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { try { MQClientInstance.this.updateTopicRouteInfoFromNameServer(); } catch (Exception e) { log.error(\\\"ScheduledTask updateTopicRouteInfoFromNameServer exception\\\", e); } } }, 10, this.clientConfig.getPollNameServerInterval(), TimeUnit.MILLISECONDS); /** * 每30s向Broker端发送心跳 * 1. 清除离线的Broker * 2. 汇报心跳给broker */ this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { try { MQClientInstance.this.cleanOfflineBroker(); MQClientInstance.this.sendHeartbeatToAllBrokerWithLock(); } catch (Exception e) { log.error(\\\"ScheduledTask sendHeartbeatToAllBroker exception\\\", e); } } }, 1000, this.clientConfig.getHeartbeatBrokerInterval(), TimeUnit.MILLISECONDS); /** * 每5s把消费者的offset持久化 */ this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { try { MQClientInstance.this.persistAllConsumerOffset(); } catch (Exception e) { log.error(\\\"ScheduledTask persistAllConsumerOffset exception\\\", e); } } }, 1000 * 10, this.clientConfig.getPersistConsumerOffsetInterval(), TimeUnit.MILLISECONDS); /** * 每60s调整线程池 */ this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { try { MQClientInstance.this.adjustThreadPool(); } catch (Exception e) { log.error(\\\"ScheduledTask adjustThreadPool exception\\\", e); } } }, 1, 1, TimeUnit.MINUTES); } \"]},\"1049\":{\"h\":\"4.2 消息发送\"},\"1050\":{\"h\":\"4.2.1 消息发送实现\",\"t\":[\"// DefaultMQProducerImpl.java /** * 发送消息实现 * - 验证合法性 checkMessage * - 查找主题路由信息 tryToFindTopicPublishInfo * - 选择消息队列 selectOneMessageQueue * - 发送消息 sendKernelImpl * * @param msg * @param communicationMode * @param sendCallback * @param timeout * @return * @throws MQClientException * @throws RemotingException * @throws MQBrokerException * @throws InterruptedException */ private SendResult sendDefaultImpl( Message msg, final CommunicationMode communicationMode, final SendCallback sendCallback, final long timeout ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { // 检查生产者处于运行状态 this.makeSureStateOK(); // 验证消息是否符合规范 Validators.checkMessage(msg, this.defaultMQProducer); final long invokeID = random.nextLong(); long beginTimestampFirst = System.currentTimeMillis(); long beginTimestampPrev = beginTimestampFirst; long endTimestamp = beginTimestampFirst; // 获取主题的路由信息 TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic()); if (topicPublishInfo != null && topicPublishInfo.ok()) { boolean callTimeout = false; MessageQueue mq = null; Exception exception = null; SendResult sendResult = null; int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1; int times = 0; String[] brokersSent = new String[timesTotal]; // 循环执行发送，处理同步发送重试。同步发送共重试timesTotal次，默认为2次，异步发送只执行一次 for (; times < timesTotal; times++) { String lastBrokerName = null == mq ? null : mq.getBrokerName(); // 选择消息队列 MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName); if (mqSelected != null) { mq = mqSelected; brokersSent[times] = mq.getBrokerName(); try { beginTimestampPrev = System.currentTimeMillis(); if (times > 0) { //Reset topic with namespace during resend. msg.setTopic(this.defaultMQProducer.withNamespace(msg.getTopic())); } long costTime = beginTimestampPrev - beginTimestampFirst; if (timeout < costTime) { callTimeout = true; break; } // 发送消息 sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime); endTimestamp = System.currentTimeMillis(); // 处理发送异常，更新失败条目 this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false); switch (communicationMode) { case ASYNC: return null; case ONEWAY: return null; case SYNC: if (sendResult.getSendStatus() != SendStatus.SEND_OK) { if (this.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) { continue; } } return sendResult; default: break; } } // catch ... } else { break; } } // 发送成功，返回发送结果 if (sendResult != null) { return sendResult; } // 发送失败，抛出异常 // ... // mqClientException.setResponseCode(...) throw mqClientException; } validateNameServerSetting(); throw new MQClientException(\\\"No route info of this topic: \\\" + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO), null).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION); } \"]},\"1051\":{\"h\":\"4.2.2 查找路由信息\",\"t\":[\"// DefaultMQProducerImpl.java private TopicPublishInfo tryToFindTopicPublishInfo(final String topic) { // 尝试获取缓存的路由信息 TopicPublishInfo topicPublishInfo = this.topicPublishInfoTable.get(topic); // 如果路由信息没有找到，则从NameServer上获取 if (null == topicPublishInfo || !topicPublishInfo.ok()) { this.topicPublishInfoTable.putIfAbsent(topic, new TopicPublishInfo()); this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic); topicPublishInfo = this.topicPublishInfoTable.get(topic); } if (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) { return topicPublishInfo; } else { // 如果第一次没有查询到，第二次使用默认主题查询 this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, true, this.defaultMQProducer); topicPublishInfo = this.topicPublishInfoTable.get(topic); return topicPublishInfo; } } \"]},\"1052\":{\"h\":\"4.2.3 选择消息队列\",\"t\":[\"默认机制，故障延迟机制关闭\",\"// TopicPublishInfo.java /** * 选择队列 * 上一次发送成功则选择下一个队列，上一次发送失败会规避上次发送的 MessageQueue 所在的 Broker * * @param lastBrokerName 上次发送的 Broker 名称，如果为空表示上次发送成功 * @return */ public MessageQueue selectOneMessageQueue(final String lastBrokerName) { if (lastBrokerName == null) { // 轮询队列，选择下一个队列 return selectOneMessageQueue(); } else { // 上次发送失败，规避上次发送的 MessageQueue 所在的 Broker for (int i = 0; i < this.messageQueueList.size(); i++) { int index = this.sendWhichQueue.incrementAndGet(); int pos = Math.abs(index) % this.messageQueueList.size(); if (pos < 0) pos = 0; MessageQueue mq = this.messageQueueList.get(pos); if (!mq.getBrokerName().equals(lastBrokerName)) { return mq; } } return selectOneMessageQueue(); } } \",\"故障延迟机制\",\"// MQFaultStrategy.java /** * 选择发送的队列，根据是否启用 Broker 故障延迟机制走不同逻辑 * * sendLatencyFaultEnable=false，默认不启用 Broker 故障延迟机制 * sendLatencyFaultEnable=true，启用 Broker 故障延迟机制 * * @param tpInfo * @param lastBrokerName * @return */ public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) { // 启用 Broker 故障延迟机制 if (this.sendLatencyFaultEnable) { try { // 轮询获取一个消息队列 int index = tpInfo.getSendWhichQueue().incrementAndGet(); for (int i = 0; i < tpInfo.getMessageQueueList().size(); i++) { int pos = Math.abs(index++) % tpInfo.getMessageQueueList().size(); if (pos < 0) pos = 0; MessageQueue mq = tpInfo.getMessageQueueList().get(pos); // 验证该消息队列是否可用，规避注册过不可用的 Broker。 if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) return mq; } // 如果没有可用的 Broker，尝试从规避的 Broker 中选择一个可用的 Broker，如果没有找到，返回 null final String notBestBroker = latencyFaultTolerance.pickOneAtLeast(); int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker); if (writeQueueNums > 0) { final MessageQueue mq = tpInfo.selectOneMessageQueue(); if (notBestBroker != null) { mq.setBrokerName(notBestBroker); mq.setQueueId(tpInfo.getSendWhichQueue().incrementAndGet() % writeQueueNums); } return mq; } else { latencyFaultTolerance.remove(notBestBroker); } } catch (Exception e) { log.error(\\\"Error occurred when selecting message queue\\\", e); } return tpInfo.selectOneMessageQueue(); } // 不启用 Broker 故障延迟机制 return tpInfo.selectOneMessageQueue(lastBrokerName); } \"]},\"1053\":{\"h\":\"4.2.4 发送消息 API 核心入口\",\"t\":[\"// DefaultMQProducerImpl.java /** * 消息发送 API 核心入口 * 1. 根据 MessageQueue 获取 Broker 地址 * 2. 为消息分配全局唯一 ID，执行消息压缩和事务 * 3. 如果注册了发送钩子函数，则执行发送之前的钩子函数 * 4. 构建消息发送请求包 * 5. 根据消息发送方式（同步、异步、单项）进行网络传输 * 6. 如果注册了发送钩子函数，执行发送之后的钩子函数 * * @param msg 待发送消息 * @param mq 发送的消息队列 * @param communicationMode 消息发送模式：SYNC、ASYNC、ONEWAY * @param sendCallback 异步发送回调函数 * @param topicPublishInfo 主题路由信息 * @param timeout 消息发送超时时间 * @return 消息发送结果 */ private SendResult sendKernelImpl(final Message msg, final MessageQueue mq, final CommunicationMode communicationMode, final SendCallback sendCallback, final TopicPublishInfo topicPublishInfo, final long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { long beginStartTime = System.currentTimeMillis(); // 根据 MessageQueue 获取 Broker 的网络地址 String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName()); if (null == brokerAddr) { // 如果 MQClientInstance 的 brokerAddrTable 未缓存该 Broker 信息，则从 NameServer 主动拉取 topic 路由信息 tryToFindTopicPublishInfo(mq.getTopic()); brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName()); } SendMessageContext context = null; // 找到 topic 的路由信息 if (brokerAddr != null) { brokerAddr = MixAll.brokerVIPChannel(this.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr); byte[] prevBody = msg.getBody(); try { // 设置消息的全局唯一 ID（UNIQUE_ID），对于批量消息，在生成过程中已经设置了 ID //for MessageBatch,ID has been set in the generating process if (!(msg instanceof MessageBatch)) { MessageClientIDSetter.setUniqID(msg); } // 处理命名空间逻辑 boolean topicWithNamespace = false; if (null != this.mQClientFactory.getClientConfig().getNamespace()) { msg.setInstanceId(this.mQClientFactory.getClientConfig().getNamespace()); topicWithNamespace = true; } // 处理压缩，默认消息体超过 4KB 的消息进行 zip 压缩，并设置压缩标识 int sysFlag = 0; boolean msgBodyCompressed = false; if (this.tryToCompressMessage(msg)) { sysFlag |= MessageSysFlag.COMPRESSED_FLAG; msgBodyCompressed = true; } // 处理事务 Prepared 消息，并设置事务标识 final String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED); if (Boolean.parseBoolean(tranMsg)) { sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE; } // CheckForbiddenHook ... // 执行消息发送前的钩子函数 if (this.hasSendMessageHook()) { context = new SendMessageContext(); context.setProducer(this); context.setProducerGroup(this.defaultMQProducer.getProducerGroup()); context.setCommunicationMode(communicationMode); context.setBornHost(this.defaultMQProducer.getClientIP()); context.setBrokerAddr(brokerAddr); context.setMessage(msg); context.setMq(mq); context.setNamespace(this.defaultMQProducer.getNamespace()); String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED); if (isTrans != null && isTrans.equals(\\\"true\\\")) { context.setMsgType(MessageType.Trans_Msg_Half); } if (msg.getProperty(\\\"__STARTDELIVERTIME\\\") != null || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != null) { context.setMsgType(MessageType.Delay_Msg); } // 执行所有 before 钩子函数 this.executeSendMessageHookBefore(context); } // 构建消息发送请求 SendMessageRequestHeader requestHeader = new SendMessageRequestHeader(); requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup()); requestHeader.setTopic(msg.getTopic()); requestHeader.setDefaultTopic(this.defaultMQProducer.getCreateTopicKey()); requestHeader.setDefaultTopicQueueNums(this.defaultMQProducer.getDefaultTopicQueueNums()); requestHeader.setQueueId(mq.getQueueId()); requestHeader.setSysFlag(sysFlag); requestHeader.setBornTimestamp(System.currentTimeMillis()); requestHeader.setFlag(msg.getFlag()); requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties())); requestHeader.setReconsumeTimes(0); requestHeader.setUnitMode(this.isUnitMode()); requestHeader.setBatch(msg instanceof MessageBatch); if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { String reconsumeTimes = MessageAccessor.getReconsumeTime(msg); if (reconsumeTimes != null) { requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes)); MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME); } String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg); if (maxReconsumeTimes != null) { requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes)); MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES); } } // 根据消息发送方式进行网络传输 SendResult sendResult = null; switch (communicationMode) { case ASYNC: Message tmpMessage = msg; boolean messageCloned = false; if (msgBodyCompressed) { //If msg body was compressed, msgbody should be reset using prevBody. //Clone new message using commpressed message body and recover origin massage. //Fix bug:https://github.com/apache/rocketmq-externals/issues/66 tmpMessage = MessageAccessor.cloneMessage(msg); messageCloned = true; msg.setBody(prevBody); } if (topicWithNamespace) { if (!messageCloned) { tmpMessage = MessageAccessor.cloneMessage(msg); messageCloned = true; } msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQProducer.getNamespace())); } long costTimeAsync = System.currentTimeMillis() - beginStartTime; if (timeout < costTimeAsync) { throw new RemotingTooMuchRequestException(\\\"sendKernelImpl call timeout\\\"); } sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage( brokerAddr, mq.getBrokerName(), tmpMessage, requestHeader, timeout - costTimeAsync, communicationMode, sendCallback, topicPublishInfo, this.mQClientFactory, this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), context, this); break; case ONEWAY: case SYNC: long costTimeSync = System.currentTimeMillis() - beginStartTime; if (timeout < costTimeSync) { throw new RemotingTooMuchRequestException(\\\"sendKernelImpl call timeout\\\"); } // 执行客户端同步发送方法 sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage( brokerAddr, mq.getBrokerName(), msg, requestHeader, timeout - costTimeSync, communicationMode, context, this); break; default: assert false; break; } if (this.hasSendMessageHook()) { context.setSendResult(sendResult); this.executeSendMessageHookAfter(context); } return sendResult; } // catch ... } finally { msg.setBody(prevBody); msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQProducer.getNamespace())); } } // 主动更新后还是找不到路由信息，则抛出异常 throw new MQClientException(\\\"The broker[\\\" + mq.getBrokerName() + \\\"] not exist\\\", null); } \"]},\"1054\":{\"h\":\"4.3 Broker 处理发送请求\"},\"1055\":{\"h\":\"4.3.1 Broker 注册发送消息处理器\",\"t\":[\"/** * 创建和注册Broker请求处理类 * RocketMQ按照业务逻辑区分请求处理器，每个类型的请求码对应一个业务处理器（NettyRequestProcessor） * 这样就实现了为不同请求码设置对应线程池，实现不同请求线程池的隔离 */ public void registerProcessor() { /** * SendMessageProcessor */ SendMessageProcessor sendProcessor = new SendMessageProcessor(this); sendProcessor.registerSendMessageHook(sendMessageHookList); sendProcessor.registerConsumeMessageHook(consumeMessageHookList); this.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendProcessor, this.sendMessageExecutor); this.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendProcessor, this.sendMessageExecutor); this.remotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendProcessor, this.sendMessageExecutor); this.remotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendProcessor, this.sendMessageExecutor); // ... } \",\"其中 sendMessageExecutor 是发送消息处理线程池，默认有 4 个线程。每个线程执行 SendMessageProcessor#processRequest() 方法\"]},\"1056\":{\"h\":\"4.3.2 发送消息处理器处理\",\"t\":[\"SendMessageProcessor#processRequest() 最终调用 asyncSendMessage() 方法处理发送请求\",\"// SendMessageProcessor.java /** * 处理客户端的发送消息请求 * 1. 检查消息合法性检查 * 2. 如果消息重试次数超过最大重试次数，消息将进入 DLQ 死信队列。 * 3. 将消息保存到存储 * * @param ctx * @param request * @param mqtraceContext * @param requestHeader * @return */ private CompletableFuture<RemotingCommand> asyncSendMessage(ChannelHandlerContext ctx, RemotingCommand request, SendMessageContext mqtraceContext, SendMessageRequestHeader requestHeader) { // 构造Response，包含消息合法性检查 final RemotingCommand response = preSend(ctx, request, requestHeader); final SendMessageResponseHeader responseHeader = (SendMessageResponseHeader)response.readCustomHeader(); if (response.getCode() != -1) { return CompletableFuture.completedFuture(response); } final byte[] body = request.getBody(); int queueIdInt = requestHeader.getQueueId(); TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic()); if (queueIdInt < 0) { queueIdInt = randomQueueId(topicConfig.getWriteQueueNums()); } // 构造存储用的Message对象 MessageExtBrokerInner msgInner = new MessageExtBrokerInner(); msgInner.setTopic(requestHeader.getTopic()); msgInner.setQueueId(queueIdInt); // 判断发过来的消息是否已经到达重新消费的重试最大次数，进入死信队列 if (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) { return CompletableFuture.completedFuture(response); } msgInner.setBody(body); msgInner.setFlag(requestHeader.getFlag()); Map<String, String> origProps = MessageDecoder.string2messageProperties(requestHeader.getProperties()); MessageAccessor.setProperties(msgInner, origProps); msgInner.setBornTimestamp(requestHeader.getBornTimestamp()); msgInner.setBornHost(ctx.channel().remoteAddress()); msgInner.setStoreHost(this.getStoreHost()); msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == null ? 0 : requestHeader.getReconsumeTimes()); String clusterName = this.brokerController.getBrokerConfig().getBrokerClusterName(); MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_CLUSTER, clusterName); if (origProps.containsKey(MessageConst.PROPERTY_WAIT_STORE_MSG_OK)) { // There is no need to store \\\"WAIT=true\\\", remove it from propertiesString to save 9 bytes for each message. // It works for most case. In some cases msgInner.setPropertiesString invoked later and replace it. String waitStoreMsgOKValue = origProps.remove(MessageConst.PROPERTY_WAIT_STORE_MSG_OK); msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties())); // Reput to properties, since msgInner.isWaitStoreMsgOK() will be invoked later origProps.put(MessageConst.PROPERTY_WAIT_STORE_MSG_OK, waitStoreMsgOKValue); } else { msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties())); } // 保存到消息存储 CompletableFuture<PutMessageResult> putMessageResult = null; String transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED); if (transFlag != null && Boolean.parseBoolean(transFlag)) { if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) { response.setCode(ResponseCode.NO_PERMISSION); response.setRemark( \\\"the broker[\\\" + this.brokerController.getBrokerConfig().getBrokerIP1() + \\\"] sending transaction message is forbidden\\\"); return CompletableFuture.completedFuture(response); } putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner); } else { putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner); } return handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt); } \"]},\"1057\":{\"h\":\"参考资料\",\"t\":[\"生产消息样例——官方文档\",\"RocketMQ 消息发送流程\",\"《RocketMQ 技术内幕 第二版》\",\"《RocketMQ 分布式消息中间件 核心原理与最佳实践》\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1058\":{\"h\":\"RocketMQ Memory Store\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220618-rocketmq-memory-store.html\"]},\"1059\":{\"h\":\"背景\"},\"1060\":{\"h\":\"概要设计\"},\"1061\":{\"h\":\"整体流程\",\"t\":[\"首先需要在 Broker 中创建 Topic，并指定为内存存储的 Topic。\",\"生产者发送生产请求\",\"SendMessageProcessor 处理生产请求 \",\"根据请求的 Topic 获取 TopicConfig\",\"判断该 Topic 是否是内存 Topic\",\"如果不是，走原有 DefaultMessageStore 存储\",\"如果是，走 MemoryMessageStore 存储\",\"消费者发送拉取消息请求\",\"PullMessageProcessor 处理拉取消息请求 \",\"根据请求的 Topic 获取 TopicConfig\",\"判断该 Topic 是否是内存 Topic\",\"如果不是，走原有 DefaultMessageStore 取消息\",\"如果是，走 MemoryMessageStore 取消息\"]},\"1062\":{\"h\":\"详细设计\"},\"1063\":{\"h\":\"整体流程顺序图\"},\"1064\":{\"h\":\"类设计\"},\"1065\":{\"h\":\"MemoryMessageStore\",\"t\":[\"为 MemoryMessageStore 设置一个存储阈值，为内存中存储的消息总大小，默认为可用内存的 75%\",\"messageQueueMap：一个 HashMap，Key 是 Topic 名称，Value 是 Disruptor 存储的 MessageExtBrokerInner 消息队列\",\"messageTotalSize：记录保存的消息总大小\",\"putMessage：将消息根据 Topic 放入指定队列，如果超过消息总大小阈值，则从该 Topic 中删除一条消息。如果该 Topic 为空，则删除一条保存最久的消息\"]},\"1066\":{\"h\":\"TopicConfig\",\"t\":[\"boolean memory：是否是内存 Topic\"]},\"1067\":{\"h\":\"BrokerController\",\"t\":[\"memoryTopicEnable：是否启动内存 Topic 功能，默认 false\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1068\":{\"h\":\"使用 Docker 和 docker-compose 快速部署 RocketMQ 集群 双主 / DLedger\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220724-rocketmq-docker-compose.html\"]},\"1069\":{\"h\":\"背景\",\"t\":[\"RocketMQ 的部署和配置较为复杂，有众多配置项和部署方式可以选择。用户往往难以快速部署 RocketMQ，进行开发和验证。\",\"rocketmq-docker 这个项目提供了 RocketMQ 的 docker 镜像打包实现，并且提供了常用的 docker-compose 模板，可以很快地用 Docker 启动 RocketMQ，并支持多种部署模式。\"]},\"1070\":{\"h\":\"环境准备\",\"t\":[\"需要安装完成 Docker，并且可以连接 Docker Hub。然后用 git 拉取 rocketmq-docker 仓库，并进入该仓库。\",\"git clone https://github.com/apache/rocketmq-docker.git cd rocketmq-docker \"]},\"1071\":{\"h\":\"镜像准备\",\"t\":[\"可以预先准备好 RocketMQ 的镜像。本地构建或者从 Docker Hub 拉取官方打包的镜像都可以\"]},\"1072\":{\"h\":\"本地构建 RocketMQ docker 镜像\",\"t\":[\"这一步不是必须要的，也可以从 Docker Hub 中拉取官方镜像。\",\"本地构建的最大意义在于，如果自己修改了 RocketMQ 的源码，则可以用这种方式构建自己的镜像。\",\"cd image-build sh build-image.sh RMQ-VERSION BASE-IMAGE \",\"运行脚本之后，会拉取相应版本的 RocketMQ 安装包到本地，然后构建镜像包。\",\"其中 RMQ-VERSION 是需要构建的 RocketMQ 版本，在 这个地方 查看可选版本列表。\",\"BASE-IMAGE 可以在 centos 和 alpine 中选择。比如当前最新版本为 4.9.4，那么可以用如下命令打镜像\",\"sh build-image.sh 4.9.4 alpine \",\"打包完成后可以用如下命令查看\",\"$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE apacherocketmq/rocketmq 4.9.4-alpine 58e1e7a5e556 16 hours ago 188MB \"]},\"1073\":{\"h\":\"拉取远程\",\"t\":[\"$ docker search rocketmq NAME DESCRIPTION STARS OFFICIAL AUTOMATED foxiswho/rocketmq rocketmq 77 rocketmqinc/rocketmq Image repository for Apache RocketMQ 54 styletang/rocketmq-console-ng rocketmq-console-ng 38 apache/rocketmq 25 apacherocketmq/rocketmq Docker Image for Apache RocketMQ 22 \",\"我们选择 apache/rocketmq，其他的版本已经跟不上时代了，年久失修。\",\"看一下它支持的版本号列表：\",\"选择最新的 4.9.4 版本拉取\",\"$ docker pull apache/rocketmq:4.9.4 \"]},\"1074\":{\"h\":\"Docker 启动 RocketMQ\",\"t\":[\"首先需要用版本号来创建一个 stage 文件夹，运行如下命令\",\"$ sh stage.sh 4.9.4 \",\"会在根目录下创建一个 stage 文件夹，进入到 stage/4.9.4/templates 目录下（有的 Linux 系统生成的路径是 stage/4.9.4/）\",\"$ cd stages/4.9.4/templates/ $ ls -l drwxrwxr-x 6 ubuntu ubuntu 4096 Jul 24 15:25 ./ drwxrwxr-x 3 ubuntu ubuntu 4096 Jul 24 15:23 ../ drwxrwxr-x 6 ubuntu ubuntu 4096 Jul 24 15:23 data/ drwxrwxr-x 4 ubuntu ubuntu 4096 Jul 24 15:26 docker-compose/ drwxrwxr-x 2 ubuntu ubuntu 4096 Jul 24 15:23 kubernetes/ -rwxrwxr-x 1 ubuntu ubuntu 902 Jul 24 15:23 play-consumer.sh* -rwxrwxr-x 1 ubuntu ubuntu 1497 Jul 24 15:23 play-docker-compose.sh* -rwxrwxr-x 1 ubuntu ubuntu 3201 Jul 24 15:23 play-docker-dledger.sh* -rwxrwxr-x 1 ubuntu ubuntu 2354 Jul 24 15:23 play-docker.sh* -rwxrwxr-x 1 ubuntu ubuntu 2271 Jul 24 15:23 play-docker-tls.sh* -rwxrwxr-x 1 ubuntu ubuntu 947 Jul 24 15:23 play-kubernetes.sh* -rwxrwxr-x 1 ubuntu ubuntu 901 Jul 24 15:23 play-producer.sh* drwxrwxr-x 2 ubuntu ubuntu 4096 Jul 24 15:23 ssl/ \",\"具体的原理是用原来 templates 下的模板，替换内容中的版本号，生成 4.9.4 版本的启动脚本。\",\"其中的多个 .sh 文件是用来以不同部署方式启动 RocketMQ\"]},\"1075\":{\"h\":\"用 docker-compose 以集群模式启动 RocketMQ\",\"t\":[\"如果是采用远程拉取的镜像，首选需要修改一下 docker-compose.yml 文件保证使用的镜像名称正确。\",\"最新的 rocketmq-docker 项目已经将 docker-compose.yml 中的镜像地址改为了官方镜像地址 apache/rocketmq，如果你拉取的版本没有改，需要进行修改。\",\"此外，RocketMQ 有 brokerIP 配置，该配置默认会自动获取主机 IP，但是在容器中获取的是容器的 IP，客户端去连接会发现连不上。所以需要提前手动修改 Broker 配置的 IP。\",\"$ pwd /home/ubuntu/workspace/rocketmq/rocketmq-docker/stages/4.9.4/templates $ vim docker-compose/data/broker/conf/broker.conf $ vim docker-compose/data1/broker/conf/broker.conf # broker.conf brokerClusterName = DefaultCluster brokerName = broker-a brokerId = 0 deleteWhen = 04 fileReservedTime = 48 brokerRole = ASYNC_MASTER flushDiskType = ASYNC_FLUSH # 改为宿主机的 IP brokerIP1={宿主机IP} \",\"改成宿主机 IP 之后，发现如果是用 2 个主节点，他们的监听 IP 都将会是 {宿主机IP}:10911，需要将 broker-b 映射的监听 port 修改一下。 修改 docker-compose.yml\",\" #Service for another broker -- broker1 broker1: image: apache/rocketmq:4.9.4 container_name: rmqbroker-b links: - namesrv ports: # 修改映射到宿主机的 port #- 10929:10909 #- 10931:10911 #- 10932:10912 - 10929:10929 - 10931:10931 - 10932:10932 environment: - NAMESRV_ADDR=namesrv:9876 volumes: - ./data1/broker/logs:/home/rocketmq/logs - ./data1/broker/store:/home/rocketmq/store - ./data1/broker/conf/broker.conf:/opt/rocketmq-4.9.4/conf/broker.conf command: sh mqbroker -c /opt/rocketmq-4.9.4/conf/broker.conf \",\"docker-compose.yml 文件映射端口改了之外，还要修改 Broker2 的监听端口\",\"$ pwd /home/ubuntu/workspace/rocketmq/rocketmq-docker/stages/4.9.4/templates $ vim docker-compose/data1/broker/conf/broker.conf # broker.conf brokerClusterName = DefaultCluster brokerName = broker-b brokerId = 0 deleteWhen = 04 fileReservedTime = 48 brokerRole = ASYNC_MASTER flushDiskType = ASYNC_FLUSH # 改为宿主机的 IP brokerIP1={宿主机IP} # 修改监听端口 listenPort=10931 fastListenPort=10929 haListenPort=10932 \",\"然后可以启动 RocketMQ 容器\",\"$ pwd /home/ubuntu/workspace/rocketmq/rocketmq-docker/stages/4.9.4/templates $ vim docker-compose/docker-compose.yml # （如果拉取远程镜像）把其中默认的 image 从 apacherocketmq/rocketmq:4.9.4 改成最新的官方镜像地址 apache/rocketmq:4.9.4 $ ./play-docker-compose.sh [+] Running 4/4 ⠿ Network docker-compose_default Created ⠿ Container rmqnamesrv Started ⠿ Container rmqbroker-b Started ⠿ Container rmqbroker Started \",\"运行之后会启动两个 broker 和一个 nameserver\",\"$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 722c5c14d3d0 apache/rocketmq:4.9.4 \\\"sh mqbroker -c /opt…\\\" About a minute ago Up About a minute 0.0.0.0:10909->10909/tcp, :::10909->10909/tcp, 9876/tcp, 0.0.0.0:10911-10912->10911-10912/tcp, :::10911-10912->10911-10912/tcp rmqbroker a7d0e64c5335 apache/rocketmq:4.9.4 \\\"sh mqbroker -c /opt…\\\" About a minute ago Up About a minute 9876/tcp, 0.0.0.0:10929->10909/tcp, :::10929->10909/tcp, 0.0.0.0:10931->10911/tcp, :::10931->10911/tcp, 0.0.0.0:10932->10912/tcp, :::10932->10912/tcp rmqbroker-b a210d64eddb5 apache/rocketmq:4.9.4 \\\"sh mqnamesrv\\\" About a minute ago Up About a minute 10909/tcp, 0.0.0.0:9876->9876/tcp, :::9876->9876/tcp, 10911-10912/tcp rmqnamesrv \"]},\"1076\":{\"h\":\"使用 docker 启动 RocketMQ-dashboard\",\"t\":[\"RocketMQ-dashboard 项目是 rocketmq 的控制台，可以可视化的查看 rocketmq 集群状态。也可以用 docker 启动。直接使用官方打包好的镜像，不本地构建了。\"]},\"1077\":{\"h\":\"用 docker 单独启动 rocketmq-dashboard\",\"t\":[\"需要先修改 start-dashboard.sh 文件\",\"$ pwd /home/ubuntu/workspace/rocketmq/rocketmq-docker $ vim product/start-dashboard.sh \",\"将镜像名称改成 apacherocketmq/rocketmq-dashboard\",\"# 修改后 ROCKETMQ_DASHBOARD_VERSION=$1 docker run -d -it --name rocketmq-dashboard -p 6765:8080 apacherocketmq/rocketmq-dashboard:${ROCKETMQ_DASHBOARD_VERSION} \",\"然后运行\",\"$ sh start-dashboard.sh 1.0.0 \",\"会启动 rocketmq-dashboard 的 container\",\"$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 433021cbeb23 apacherocketmq/rocketmq-dashboard:1.0.0 \\\"sh -c 'java $JAVA_O…\\\" 45 minutes ago Up 45 minutes 0.0.0.0:6765->8080/tcp, :::6765->8080/tcp rocketmq-dashboard \",\"这样启动之后，登录访问 host:6765 地址，设置集群的 nameserver 地址，但是与集群的网络不通。\"]},\"1078\":{\"h\":\"与集群一起用 docker-compose 启动 docker-dashboard\",\"t\":[\"还是要修改 docker-compose.yml 文件\",\"$ cd stages/4.9.4/templates $ vim docker-compose/docker-compose.yml \",\"在文件尾部添加如下配置，启动一个 rocketmq-dashboard 服务，并置于和集群同一个网络下\",\" # Service for dashboard dashboard: image: apacherocketmq/rocketmq-dashboard:1.0.0 container_name: rmq-dashboard ports: - 48080:8080 environment: - NAMESRV_ADDR=namesrv:9876 depends_on: - namesrv links: - namesrv \",\"然后访问 host:48080 地址，可以通过 dashboard 查看集群状态\"]},\"1079\":{\"h\":\"Docker 启动 DLedger 模式的 RocketMQ\",\"t\":[\"用 DLedger 模式前保证有足够的可用内存（8G 以上）\",\"也是有两种方法，用本地构建的镜像和 Docker Hub 中官方上传的镜像。如果用本地打包的镜像，直接运行如下命令\",\"$ cd stages/4.9.4/templates $ ./play-docker-dledger.sh \",\"如果要用 Docker Hub 中的镜像，则需要修改 play-docker-dledger.sh 中的镜像地址\",\"$ vim play-docker-dledger.sh :%s/apacherocketmq/apache/g $ ./play-docker-dledger.sh \",\"但是我运行时三个 Broker 都未启动成功，查看 Broker 日志，发现 broker.conf 文件未找到\",\"ubuntu@VM-4-14-ubuntu:~/workspace/rocketmq/rocketmq-docker/stages/4.9.4/templates$ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1ae8a853012b apache/rocketmq:4.9.4 \\\"sh mqbroker -c ../c…\\\" 2 seconds ago Up 1 second 9876/tcp, 10909/tcp, 0.0.0.0:30929->30929/tcp, :::30929->30929/tcp, 10911-10912/tcp, 0.0.0.0:30931->30931/tcp, :::30931->30931/tcp rmqbroker2 71da5cd67513 apache/rocketmq:4.9.4 \\\"sh mqnamesrv\\\" 4 seconds ago Up 3 seconds 10909/tcp, 0.0.0.0:9876->9876/tcp, :::9876->9876/tcp, 10911-10912/tcp rmqnamesrv 0e80d1d53112 redis:6.2 \\\"docker-entrypoint.s…\\\" 3 months ago Up 3 months 0.0.0.0:46379->6379/tcp, :::46379->6379/tcp redis-redis-1 ubuntu@VM-4-14-ubuntu:~/workspace/rocketmq/rocketmq-docker/stages/4.9.4/templates$ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 1ae8a853012b apache/rocketmq:4.9.4 \\\"sh mqbroker -c ../c…\\\" 8 seconds ago Exited (255) 6 seconds ago rmqbroker2 b959cf8b6542 apache/rocketmq:4.9.4 \\\"sh mqbroker -c ../c…\\\" 9 seconds ago Exited (255) 6 seconds ago rmqbroker1 919ce578e6db apache/rocketmq:4.9.4 \\\"sh mqbroker -c ../c…\\\" 10 seconds ago Exited (255) 7 seconds ago rmqbroker 71da5cd67513 apache/rocketmq:4.9.4 \\\"sh mqnamesrv\\\" 10 seconds ago Up 9 seconds 10909/tcp, 0.0.0.0:9876->9876/tcp, :::9876->9876/tcp, 10911-10912/tcp rmqnamesrv ubuntu@VM-4-14-ubuntu:~/workspace/rocketmq/rocketmq-docker/stages/4.9.4/templates$ docker logs -t rmqbroker --tail=100 2022-07-27T15:58:11.218761998Z java.io.FileNotFoundException: ../conf/dledger/broker.conf (No such file or directory) 2022-07-27T15:58:11.218878131Z at java.io.FileInputStream.open0(Native Method) 2022-07-27T15:58:11.218887204Z at java.io.FileInputStream.open(FileInputStream.java:195) 2022-07-27T15:58:11.218891884Z at java.io.FileInputStream.<init>(FileInputStream.java:138) 2022-07-27T15:58:11.218953791Z at java.io.FileInputStream.<init>(FileInputStream.java:93) 2022-07-27T15:58:11.218960481Z at org.apache.rocketmq.broker.BrokerStartup.createBrokerController(BrokerStartup.java:119) 2022-07-27T15:58:11.218965349Z at org.apache.rocketmq.broker.BrokerStartup.main(BrokerStartup.java:57) \",\"于是想办法修改 play-docker-dledger.sh 中的 Broker 配置文件路径，改成 /opt/rocketmq-4.9.4/conf/dledger/broker.conf，然后启动成功\"]},\"1080\":{\"h\":\"修改内存配置\",\"t\":[\"DLedger 模式默认配置下，每个节点会占用 2G 内存。如果是内存较小的机器则可以通过定义环境变量修改内存占用。\",\"RocketMQ 使用 runbroker.sh 启动，其中启动参数设置脚本如下：\",\"# runbroker.sh JAVA_OPT=\\\"${JAVA_OPT} -server -Xms8g -Xmx8g\\\" choose_gc_options JAVA_OPT=\\\"${JAVA_OPT} -XX:-OmitStackTraceInFastThrow\\\" JAVA_OPT=\\\"${JAVA_OPT} -XX:+AlwaysPreTouch\\\" JAVA_OPT=\\\"${JAVA_OPT} -XX:MaxDirectMemorySize=15g\\\" JAVA_OPT=\\\"${JAVA_OPT} -XX:-UseLargePages -XX:-UseBiasedLocking\\\" #JAVA_OPT=\\\"${JAVA_OPT} -Xdebug -Xrunjdwp:transport=dt_socket,address=9555,server=y,suspend=n\\\" JAVA_OPT=\\\"${JAVA_OPT} ${JAVA_OPT_EXT}\\\" JAVA_OPT=\\\"${JAVA_OPT} -cp ${CLASSPATH}\\\" \",\"这个脚本预留了定义额外的 Java 启动参数的环境变量，即 JAVA_OPT_EXT，于是将 play-docker-dledger.sh 文件做如下修改，添加 -e \\\"JAVA_OPT_EXT=-server -Xms128m -Xmx128m -Xmn128m\\\"（注意，这么小的内存无法生产消费消息，仅仅为了启动 Broker。需要同时改动 broker 配置中的 commitlog、consumequeue、indexfile 大小）\",\"docker run --net dledger-br --ip 172.18.0.12 -d -p 30911:30911 -p 30909:30909 -v `pwd`/data/broker0/logs:/home/rocketmq/logs -v `pwd`/data/broker0/store:/home/rocketmq/store -v `pwd`/data/broker0/conf/dledger:/opt/rocketmq-4.9.4/conf/dledger --name rmqbroker --link rmqnamesrv:namesrv -e \\\"NAMESRV_ADDR=namesrv:9876\\\" -e \\\"JAVA_OPT_EXT=-server -Xms128m -Xmx128m -Xmn128m\\\" apache/rocketmq:4.9.4 sh mqbroker -c /opt/rocketmq-4.9.4/conf/dledger/broker.conf docker run --net dledger-br --ip 172.18.0.13 -d -p 30921:30921 -p 30919:30919 -v `pwd`/data/broker1/logs:/home/rocketmq/logs -v `pwd`/data/broker1/store:/home/rocketmq/store -v `pwd`/data/broker1/conf/dledger:/opt/rocketmq-4.9.4/conf/dledger --name rmqbroker1 --link rmqnamesrv:namesrv -e \\\"NAMESRV_ADDR=namesrv:9876\\\" -e \\\"JAVA_OPT_EXT=-server -Xms128m -Xmx128m -Xmn128m\\\" apache/rocketmq:4.9.4 sh mqbroker -c /opt/rocketmq-4.9.4/conf/dledger/broker.conf docker run --net dledger-br --ip 172.18.0.14 -d -p 30931:30931 -p 30929:30929 -v `pwd`/data/broker2/logs:/home/rocketmq/logs -v `pwd`/data/broker2/store:/home/rocketmq/store -v `pwd`/data/broker2/conf/dledger:/opt/rocketmq-4.9.4/conf/dledger --name rmqbroker2 --link rmqnamesrv:namesrv -e \\\"NAMESRV_ADDR=namesrv:9876\\\" -e \\\"JAVA_OPT_EXT=-server -Xms128m -Xmx128m -Xmn128m\\\" apache/rocketmq:4.9.4 sh mqbroker -c /opt/rocketmq-4.9.4/conf/dledger/broker.conf \"]},\"1081\":{\"h\":\"DLedger 与 Dashboard 同时启动\",\"t\":[\"需要修改 play-docker-dleger.sh，在 broker 运行的脚本下面添加 dashboard 的 docker 运行脚本，并与 broker、nameserver 用同一个网络\",\"# Start brokers # ... # Start dashboard docker run --net dledger-br -d -p 48080:8080 --link rmqnamesrv:namesrv -e \\\"NAMESRV_ADDR=namesrv:9876\\\" --name rmq-dledger-dashboard apacherocketmq/rocketmq-dashboard:1.0.0 \",\"然后运行 ./play-docker-dledger.sh，可以访问 48080 端口进入 Dashboard\"]},\"1082\":{\"h\":\"以其他部署形式启动 RocketMQ\"},\"1083\":{\"h\":\"Docker 启动单节点 RocketMQ\",\"t\":[\"$ cd stages/4.9.4/templates $ sh play-docker.sh alpine \"]},\"1084\":{\"h\":\"Docker 启动带 TLS 的 RocketMQ\",\"t\":[\"$ cd stages/4.9.4/templates $ sh play-docker-tls.sh \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1085\":{\"h\":\"RocketMQ 消费者（1）概念和消费流程\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220820-rocketmq-consumer-1-summary.html\"]},\"1086\":{\"h\":\"1. 背景\",\"t\":[\"RocketMQ 的消费可以算是 RocketMQ 的业务逻辑中最复杂的一块。这里面涉及到许多消费模式和特性。本想一篇文章写完，写到后面发现消费涉及到的内容太多，于是决定分多篇来写。本文作为消费系列的第一篇，主要讲述 RocketMQ 消费涉及到的模式和特性，也会概括性地讲一下消费流程。\",\"我将 RocketMQ 的消费流程大致分成 4 个步骤\",\"重平衡\",\"消费者拉取消息\",\"Broker 接收拉取请求后从存储中查询消息并返回\",\"消费者消费消息\",\"每个步骤都会用一篇文章来讲解。\",\"先了解一下 RocketMQ 消费涉及到地概念\"]},\"1087\":{\"h\":\"2. 概念简述\"},\"1088\":{\"h\":\"2.1 消费组概念与消费模式\",\"t\":[\"和大多数消息队列一样，RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。在了解它们之前，需要先引入消费组的概念。\"]},\"1089\":{\"h\":\"2.1.1 消费组\",\"t\":[\"一个消费者实例即是一个消费者进程，负责消费消息。单个消费者速度有限，在实际使用中通常会采用多个消费者共同消费同样的 Topic 以加快消费速度。这多个消费同样 Topic 的消费者组成了消费者组。\",\"消费组是一个逻辑概念，它包含了多个同一类的消费者实例，通常这些消费者都消费同一类消息（都消费相同的 Topic）且消费逻辑一致。\",\"消费组的引入是用来在消费消息时更好地进行负载均衡和容错。\"]},\"1090\":{\"h\":\"2.1.2 广播消费模式（BROADCASTING）\",\"t\":[\"广播消费模式即全部的消息会广播分发到所有的消费者实例，每个消费者实例会收到全量的消息（即便消费组中有多个消费者都订阅同一 Topic）。\",\"如下图所示，生产者发送了 5 条消息，每个消费组中的消费者都收到全部的 5 条消息。\",\"广播模式使用较少，适合各个消费者都需要通知的场景，如刷新应用中的缓存。\",\"广播消费模式\",\"注意事项：\",\"广播消费模式下不支持 顺序消息。\",\"广播消费模式下不支持 重置消费位点。\",\"每条消息都需要被相同订阅逻辑的多台机器处理。\",\"消费进度在客户端维护，出现重复消费的概率稍大于集群模式。如果消费进度文件丢失，存在消息丢失的可能。\",\"广播模式下，消息队列 RocketMQ 版保证每条消息至少被每台客户端消费一次，但是并不会重投消费失败的消息，因此业务方需要关注消费失败的情况。\",\"广播模式下，客户端每一次重启都会从最新消息消费。客户端在被停止期间发送至服务端的消息将会被自动跳过，请谨慎选择。\",\"广播模式下，每条消息都会被大量的客户端重复处理，因此推荐尽可能使用集群模式。\",\"广播模式下服务端不维护消费进度，所以消息队列 RocketMQ 版控制台不支持消息堆积查询、消息堆积报警和订阅关系查询功能。\"]},\"1091\":{\"h\":\"2.1.3 集群消费模式（CLUSTERING）\",\"t\":[\"集群消费模式下，同一 Topic 下的一条消息只会被同一消费组中的一个消费者消费。也就是说，消息被负载均衡到了同一个消费组的多个消费者实例上。\",\"更具体一点，在同一消费组中的不同消费者会根据负载机制来平均地订阅 Topic 中的每个 Queue。（默认 AVG 负载方式）\",\"广播消费模式\",\"RocketMQ 默认使用集群消费模式，这也是大部分场景下会使用到的消费模式。\"]},\"1092\":{\"h\":\"2.2 消费者拉取消息模式\"},\"1093\":{\"h\":\"2.2.1 Pull\",\"t\":[\"指消费者主动拉取消息进行消费，主动从 Broker 拉取消息，主动权由消费者应用控制。\"]},\"1094\":{\"h\":\"2.2.2 Push\",\"t\":[\"指 Broker 主动将消息 Push 给消费者，Broker 收到消息就会主动推送到消费者端。该模式的消费实时性较高，也是主流场景中普遍采用的消费形式。\",\"消费者组中的消费者实例会根据预设的负载均衡算法对 Topic 中的 Queue 进行均匀的订阅，每个 Queue 最多只能被一个消费者订阅。\",\"在 RocketMQ 中，Push 消费其实也是由 Pull 消费（拉取）实现。Push 消费只是通过客户端 API 层面的封装让用户感觉像是 Broker 在推送消息给消费者。\"]},\"1095\":{\"h\":\"2.2.3 POP\",\"t\":[\"RocketMQ 5.0 引入的新消费形式，是 Pull 拉取的另一种实现。也可以在 Push 模式下使用 POP 拉取消息，甚至可以和 Push 模式共同使用（分别消费重试 Topic 和普通 Topic）。\",\"POP 与 Pull 可以通过一个开关实时进行切换。POP 模式下，Broker 来控制每个消费者消费的队列和拉取的消息，把重平衡逻辑从客户端移到了服务端。\",\"主要解决了原来 Push 模式消费的以下痛点：\",\"富客户端：客户端逻辑比较重，多语言支持不友好\",\"队列独占：Topic 中的一个 Queue 最多只能被 1 个 Push 消费者消费，消费者数量无法无限扩展。且消费者 hang 住时该队列的消息会堆积。\",\"消费后更新 offset：本地消费成功才会提交 offset\",\"RocketMQ 5.0 的轻量化 gRPC 客户端就是基于 POP 消费模式开发\"]},\"1096\":{\"h\":\"2.3 队列负载机制与重平衡\",\"t\":[\"在集群消费模式下，消费组中的消费者共同消费订阅的 Topic 中的所有消息，这里就存在 Topic 中的队列如何分配给消费者的问题。\"]},\"1097\":{\"h\":\"2.3.1 队列负载机制\",\"t\":[\"RocketMQ Broker 中的队列负载机制将一个 Topic 的不同队列按照算法尽可能平均地分配给消费者组中的所有消费者。RocketMQ 预设了多种负载算法供不同场景下的消费。\",\"AVG：将队列按数量平均分配给多个消费者，按 Broker 顺序先分配第一个 Broker 的所有队列给第一个消费者，然后给第二个。\",\"AVG_BY_CIRCLE：将 Broker 上的队列轮流分给不同消费者，更适用于 Topic 在不同 Broker 之间分布不均匀的情况。\",\"默认采用 AVG 负载方式。\"]},\"1098\":{\"h\":\"2.3.2 重平衡（Rebalance）\",\"t\":[\"为消费者分配队列消费的这一个负载过程并不是一劳永逸的，比如当消费者数量变化、Broker 掉线等情况发生后，原先的负载就变得不再均衡，此时就需要重新进行负载均衡，这一过程被称为重平衡机制。\",\"每隔 20s，RocketMQ 会进行一次检查，检查队列数量、消费者数量是否发生变化，如果变化则触发消费队列重平衡，重新执行上述负载算法。\"]},\"1099\":{\"h\":\"2.4 消费端高可靠\"},\"1100\":{\"h\":\"2.4.1 重试-死信机制\",\"t\":[\"在实际使用中，消息的消费可能出现失败。RocketMQ 拥有重试机制和死信机制来保证消息消费的可靠性。\",\"正常消费：消费成功则提交消费位点\",\"重试机制：如果正常消费失败，消息会被消费者发回 Broker，放入重试 Topic： %RETRY%消费者组。最多重试消费 16 次，重试的时间间隔逐渐变长。（消费者组会自动订阅重试 Topic）。\",\"这里地延迟重试采用了 RocketMQ 的延迟消息，重试的 16 次时间间隔为延迟消息配置的每个延迟等级的时间（从第三个等级开始）。如果修改延迟等级时间的配置，重试的时间间隔也会相应发生变化。但即便延迟等级时间间隔配置不足 16 个，仍会重试 16 次，后面按照最大的时间间隔来重试。\",\"死信机制：如果正常消费和重试 16 次均失败，消息会保存到死信 Topic %DLQ%消费者组 中，此时需人工介入处理\"]},\"1101\":{\"h\":\"2.4.2 队列负载机制与重平衡\",\"t\":[\"当发生 Broker 挂掉或者消费者挂掉时，会引发重平衡，可以自动感知有组件挂掉的情况并重新调整消费者的订阅关系。\"]},\"1102\":{\"h\":\"2.5 并发消费与顺序消费\",\"t\":[\"在消费者客户端消费时，有两种订阅消息的方式，分别是并发消费和顺序消费。广播模式不支持顺序消费，仅有集群模式能使用顺序消费。\",\"需要注意的是，这里所说的顺序消费指的是队列维度的顺序，即在消费一个队列时，消费消息的顺序和消息发送的顺序一致。如果一个 Topic 有多个队列， 是不可能达成 Topic 级别的顺序消费的，因为无法控制哪个队列的消息被先消费。Topic 只有一个队列的情况下能够实现 Topic 级别的顺序消费。\",\"具体顺序生产和消费代码见 官方文档。\",\"顺序生产的方式为串行生产，并在生产时指定队列。\",\"并发消费的方式是调用消费者的指定 MessageListenerConcurrently 作为消费的回调类，顺序消费则使用 MessageListenerOrderly 类进行回调。处理这两种消费方式的消费服务也不同，分别是 ConsumeMessageConcurrentlyService 和 ConsumeMessageOrderlyService。\",\"顺序消费的大致原理是依靠两组锁，一组在 Broker 端（Broker 锁），锁定队列和消费者的关系，保证同一时间只有一个消费者在消费；在消费者端也有一组锁（消费队列锁）以保证消费的顺序性。\"]},\"1103\":{\"h\":\"2.6 消费进度保存和提交\",\"t\":[\"消费者消费一批消息完成之后，需要保存消费进度。如果是集群消费模式，还需要将消费进度让其他消费者知道，所以需要提交消费进度。这样在消费者重启或队列重平衡时可以根据消费进度继续消费。\",\"不同模式下消费进度保存方式的不同：\",\"广播模式：保存在消费者本地。因为每个消费者都需要消费全量消息消息。在 LocalfileOffsetStore 当中。\",\"集群模式：保存在 Broker，同时消费者端缓存。因为一个 Topic 的消息只要被消费者组中的一个消费者消费即可，所以消息的消费进度需要统一保存。通过 RemoteBrokerOffsetStore 存储。\",\"集群模式下，消费者端有定时任务，定时将内存中的消费进度提交到 Broker，Broker 也有定时任务将内存中的消费偏移量持久化到磁盘。此外，消费者向 Broker 拉取消息时也会提交消费偏移量。注意，消费者线程池提交的偏移量是线程池消费的这一批消息中偏移量最小的消息的偏移量。\",\"消费完一批消息后将消息消费进度存在本地内存\",\"消费者中有一个定时线程，每 5s 将内存中所有队列的消费偏移量提交到 Broker\",\"Broker 收到消费进度先缓存到内存，有一个定时任务每隔 5s 将消息偏移量持久化到磁盘\",\"消费者向 Broker 拉取消息时也会将队列的消息偏移量提交到 Broker\"]},\"1104\":{\"h\":\"3. 消费流程\",\"t\":[\"这张图是阿里云的文章讲解消费时用到的，能够清晰地表示客户端 Push 模式并发消费流程。\",\"从左上角第一个方框开始看\",\"消费者启动时唤醒重平衡服务 RebalanceService，重平衡服务是客户端开始消费的起点。\",\"重平衡服务会周期性（每 20s）执行重平衡方法 doRebalance)，查询所有注册的 Broker，根据注册的 Broker 数量为自身分配负载的队列 rebalanceByTopic()\",\"分配完队列后，会为每个分配到的新队列创建一个消息拉取请求 pullRequest，这个拉取请求中保存一个处理队列 processQueue，即图中的红黑树（TreeMap），用来保存拉取到的消息。红黑树保存消息的顺序。\",\"消息拉取线程应用生产-消费模式，用一个线程从拉取请求队列 pullRequestQueue 中弹出拉取请求，执行拉取任务，将拉取到的消息放入处理队列。\",\"拉取请求在一次拉取消息完成之后会复用，重新被放入拉取请求队列 pullRequestQueue 中\",\"拉取完成后，在 NettyClientPublicExecutorThreadPool 线程池异步处理结果，将拉取到的消息放入处理队列，然后调用 consumeMessageService.submitConsumeRequest，将处理队列和 多个消费任务提交到消费线程池。每个消费任务消费 1 批消息（1 批默认为 1 条）\",\"每个消费者都有一个消费线程池 consumeMessageThreadPool ，默认有 20 个消费线程。\",\"消费线程池的每个消费线程会尝试从消费任务队列中获取消费请求，执行消费业务逻辑 listener.consumeMessage。\",\"消费完成后，如果消费成功，则更新偏移量 updateOffset（先更新到内存 offsetTable，定时上报到 Broker。Broker 端也先放到内存，定时刷盘）。\"]},\"1105\":{\"h\":\"参考资料\",\"t\":[\"官方文档——设计\",\"RocketMQ 实战与进阶——丁威\",\"RocketMQ消费消息——白云鹏\",\"消息中间件—RocketMQ消息消费（一）——癫狂侠\",\"RocketMQ 消息接受流程——赵坤\",\"RocketMQ 消息消费——贝贝猫\",\"RocketMQ 5.0 POP 消费模式探秘\",\"RocketMQ消息消费源码分析\",\"Rocketmq消费消息原理——服务端技术栈\",\"RocketMQ——4. Consumer 消费消息——Kong\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1106\":{\"h\":\"RocketMQ 消费者（2）客户端设计和启动流程详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220827-rocketmq-consumer-2-struct-and-init.html\"]},\"1107\":{\"h\":\"1. 背景\",\"t\":[\"本文是 RocketMQ 消费者系列的第二篇，介绍消费者相关类与调用关系，同时包含消费者启动流程。 看完本文能够对消息消费涉及到的相关类和消费流程有大体的了解。\"]},\"1108\":{\"h\":\"2. 概要设计\"},\"1109\":{\"h\":\"2.1 消费者客户端设计\",\"t\":[\"先看一下 RocketMQ 客户端代码中消费者相关的类图。\",\"其中 DefaultMQPullConsumer 和 DefaultMQPushConsumer 就是我们实际消费中需要新建的消费者对象。它们分别实现了消费者接口，扩展了客户端配置类。\",\"新建 DefaultXXXXConsumer 对象时会在内部一个创建 DefaultMQXXXXConsumerImpl 对象。这里使用了代理模式，DefaultXXXXConsumer 对象只是一个壳，内部的大部分方法都通过调用代理 DefaultMQXXXXConsumerImpl 来执行。\",\"DefaultMQXXXXConsumerImpl 实现类中包含了客户端实例 MQClientInstnace ，每个客户端进程一般只有一个这玩意。它的用处很多，比如保存路由和客户端信息，向 Broker 发送请求等。\"]},\"1110\":{\"h\":\"2.2 消费者客户端启动\",\"t\":[\"消费者的启动主要涉及上面讲到的 DefaultMQXXXXConsumer、DefaultMQXXXXConsumerImpl 和 MQClientInstnace 这三个类。\"]},\"1111\":{\"h\":\"2.2.1 新建消费者\",\"t\":[\"新建消费者时构造 DefaultMQXXXXConsumer 对象，指定队列负载算法，内部构造一个 DefaultMQXXXXConsumerImpl 对象。\",\"DefaultMQXXXXConsumerImpl 设为刚创建状态，并新建重平衡服务 RebalanceService\",\"在首次启动前，DefaultMQXXXXConsumerImpl 对象中的 MQClientInstance 对象还没有被创建出来。\"]},\"1112\":{\"h\":\"2.2.2 消费者启动\",\"t\":[\"启动命令也是在 DefaultMQXXXXConsumer 调用并代理到 DefaultMQXXXXConsumerImpl。\",\"此时 DefaultMQXXXXConsumerImpl 会初始化一些服务和参数，然后创建一个 MQClientInstance 对象。\",\"MQClientInstance 对象启动客户端的各种服务（Broker 通信、定时任务、消息拉取、重平衡……）\"]},\"1113\":{\"h\":\"3. 详细设计\"},\"1114\":{\"h\":\"3.1 消费者客户端类设计\"},\"1115\":{\"h\":\"3.1.1 整体类图\"},\"1116\":{\"h\":\"3.1.2 消费者接口\",\"t\":[\"由于需要支持拉和推两种消费模式，所以按通常的想法，消费者类的设计中将会有一个消费者接口，然后推消费者和拉消费者接口分别扩展消费者接口。消费者接口提供一些共用方法，拉和推消费者实现拉消费和推消费方法。RocketMQ 就是这样做的。其中 MQConsumer 即消费者接口，扩展 MQAdmin 在这显得有些多余。\",\"MQAdmin 接口提供了客户端的一些基本的管理接口，生产者、消费者和命令工具都扩展了它。\",\"MQConsumer 接口很简单，主要提供了通过 Topic 获取读队列的方法 Set<MessageQueue> fetchSubscribeMessageQueues(final String topic)。\"]},\"1117\":{\"h\":\"3.1.3 拉 & 推模式消费者接口\",\"t\":[\"接下来是拉消费者和推消费者接口。\",\"如果我们自己来设计拉 & 推模式消费者接口，需要定义哪些方法？可以想象一下消费时要做的操作，就可以定义出相应的方法。\",\"拉模式消费者的消费步骤为：拉取消息，执行消费逻辑，上报消费进度，如果有需要的话对于消费失败的消息还需要发回 Broker 重新消费。\",\"推模式消费者消费步骤更简单，只需要订阅一个 Topic，然后指定消费回调函数，即可在收到消息时自动消费。\",\"RocketMQ 的拉 & 推模式消费者接口就定义了这些方法，先来看一下类图：\",\"MQPullConsumer\",\"void registerMessageQueueListener(final String topic, final MessageQueueListener listener) 方法注册消息队列变更时的回调方法。\",\"PullResult pull 从 RocketMQ 服务器拉取一批消息。 \",\"MessageQueue：拉取的队列\",\"MessageSelector：消息过滤器\",\"offset：拉取的消息在消费队列中的偏移量\",\"maxNums：最大拉取消息条数\",\"timeout：拉取超时时间\",\"void pull 为异步拉取方法，拉取成功后调用 PullCallback\",\"updateConsumeOffset 更新消息消费偏移量\",\"fetchConsumeOffset 获取消息消费偏移量\",\"sendMessageBack 对于消费失败的消息，发回 Broker 重新消费\",\"MQPushConsumer\",\"subscribe：订阅主题，订阅之后可以收到来自该主题的消息。 \",\"topic：订阅的主题，可以多次调用该方法来订阅多个主题\",\"subExpression：消息过滤表达式\",\"messageSelector：消息选择器，提供了 SQL92 和 Tag 模式的过滤选择功能\",\"unsubscribe：取消订阅\",\"registerMessageListener：用来注册消费监听器，包含两种消费模式：并发消费和顺序消费\"]},\"1118\":{\"h\":\"3.1.4 消费者实现\",\"t\":[\"DefaultMQXXXXConsumer 是拉消费者接口 MQXXXXConsumer 的默认实现。这里用到了代理模式，将具体的方法实现都实现在 DefaultMQXXXXConsumerImpl 中，DefaultMQXXXXConsumer 保存了一个 DefaultMQXXXXConsumerImpl 的代理。\",\"DefaultMQXXXXConsumerImpl 实现了 MQConsumerInner 接口，提供了消费者实现的一些公用方法。\",\"DefaultMQXXXXConsumerImpl 中有一个客户端实例的引用 MQClientInstance mqClientFactory，用来与 Broker 通信、保存元数据。\",\"MQClientInstnace：客户端实例，每个客户端进程一般只有一个这玩意。它的用处很多，很多操作最终都是调用它来做的。\",\"保存路由信息\",\"保存生产者消费者组信息\",\"向 Broker 发送请求\",\"启动重平衡\"]},\"1119\":{\"h\":\"3.1.5 推模式消费者实现\",\"t\":[\"拉模式消费者需要手动拉取消息进行消费，平平无奇。推模式消费者自动监听推送过来的消息并进行消费，着重讲解。\",\"推模式消费者实际内部也是通过拉取消息的方式进行消息拉取，只不过封装了订阅和监听器这样的对外接口，让用户在使用时感觉像 Broker 主动推送消息到消费者。\",\"在拉消费者背后，有一个线程默默主动拉取消息，才能将拉转换为推，它就是 PullMessageService。此外，推消费者还支持并发消费和顺序消费，RocketMQ 定义了 ConsumeMessageService 接口来执行消息消费，ConsumeMessageConcurrentlyService 和 ConsumeMessageOrderlyService 分别是并发消费和顺序消费的实现。它们内部都定义了一个消费线程池 consumeExecutor 来执行最终的消息消费逻辑。而用户真正编写的只有最终的消费逻辑，即实现 MessageListener 接口的 consumeMessage 方法。\",\"推模式消费者实现相关的类图如下所示：\",\"在图中，展示了消息消费整个流程的调用关系。在系列后面的文章中会详细讲解。\",\"客户端实例中的重平衡服务进行重平衡，生成一个 PullRequest 并调用拉消费者实现类的 executePullRequestImmediately 方法\",\"DefaultMQPushConsumerImpl 调用 PullMessageService 线程的 executePullRequestImmediately 方法，\",\"该方法将 PullRequest 放入待执行的拉取请求队列\",\"PullMessageService 线程阻塞等待请求队列中的拉取请求\",\"收到拉去请求 PullRequest 后就执行拉取消息拉取方法 pullMessage 从 Broker 拉取消息，拉取后执行消费消息逻辑\",\"消费消息逻辑会调用 ConsumeMessageService 的 submitConsumeRequest 方法\",\"该方法将消费消息的请求提交到消费线程池 consumeExecutor\",\"消费线程池执行真正的消息消费逻辑，调用 MessageListener 接口的 consumeMessage 方法\",\"拉取一批消息成功后，将拉取请求 PullRequest 的拉取偏移量更新后再次调用 executePullRequestImmediately 方法，放入拉取队列，重新拉取\"]},\"1120\":{\"h\":\"3.2 消费者启动\",\"t\":[\"由于拉模式和推模式消费者的启动流程大致相同，所以只介绍推模式消费者的启动流程。\",\"DefaultMQPushConsumer 的启动方法内部实际是调用其代理类 DefaultMQPushConsumerImpl 的启动方法，他本身的启动方法并没有什么逻辑。\",\"DefaultMQPushConsumerImpl 的启动方法执行的动作如下：\",\"检查是否是刚创建状态，如果是才继续走启动流程\",\"检查消费者配置信息是否合法\",\"将用户的 Topic 订阅信息和重试 Topic 的订阅信息添加到 rebalanceImpl 中的 Map 中\",\"创建和初始化一些对象 \",\"创建或获取已经创建的客户端实例 MQClientInstance\",\"初始化消费者的重平衡实现 RebalanceImpl\",\"创建拉取消息接口调用包装类 PullApiWrapper\",\"注册消息过滤钩子函数列表（如果有的话）\",\"初始化消费进度 \",\"广播模式，消费进度保存在消费者本地 LocalFileOffsetStore\",\"集群模式，消费进度保存在 Broker RemoteBrokerOffsetStore\",\"初始化消息消费服务，消费服务内部维护一个线程池，负责消息消费\",\"将消费者注册到客户端实例对象\",\"启动客户端实例对象\",\"从 Name server 更新 Topic 路由信息（如果路由信息有变化）\",\"将客户端的信息（ID、生产者、消费者信息）上报给 Broker\",\"唤醒重平衡线程 RebalanceService 立即执行重平衡\",\"重平衡后调用拉取消息方法，生成拉取请求 PullRequest 并放入 PullMessageService，开始消费流程\",\"客户端实例 MQClientInstance 的启动流程如下：\",\"更新 Namesrv 地址\",\"启动通信模块 MQClientAPIImpl\",\"启动定时任务（从 Namesrv 拉取路由、向 Broker 发送心跳等）\",\"启动拉取消息服务 PullMessageService\",\"启动重平衡线程 RebalanceService\",\"启动默认生产者（用于将消费失败的消息重新生产到 Broker）\"]},\"1121\":{\"h\":\"4. 源码解析\"},\"1122\":{\"h\":\"4.1 DefaultMQProducerImpl 启动\",\"t\":[\"// DefaultMQProducerImpl /** * Push 消费者启动 * * @throws MQClientException */ public synchronized void start() throws MQClientException { switch (this.serviceState) { // 检查消费者状态。只有第一次启动才执行，如果二次调用 start 方法会报错 case CREATE_JUST: log.info(\\\"the consumer [{}] start beginning. messageModel={}, isUnitMode={}\\\", this.defaultMQPushConsumer.getConsumerGroup(), this.defaultMQPushConsumer.getMessageModel(), this.defaultMQPushConsumer.isUnitMode()); this.serviceState = ServiceState.START_FAILED; // 检查消费者配置是否合法 this.checkConfig(); // 将用户的 Topic 订阅信息和重试 Topic 的订阅信息添加到 RebalanceImpl 的容器中 this.copySubscription(); if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) { this.defaultMQPushConsumer.changeInstanceNameToPID(); } // 创建客户端实例 this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook); // 初始化 RebalanceImpl this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup()); this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel()); this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy()); this.rebalanceImpl.setmQClientFactory(this.mQClientFactory); // 创建拉取消息接口调用包装类 this.pullAPIWrapper = new PullAPIWrapper( mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode()); // 注册消息过滤钩子函数列表 this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList); // 初始化消费进度 if (this.defaultMQPushConsumer.getOffsetStore() != null) { this.offsetStore = this.defaultMQPushConsumer.getOffsetStore(); } else { switch (this.defaultMQPushConsumer.getMessageModel()) { case BROADCASTING: // 广播模式，消费进度保存在消费者本地 this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup()); break; case CLUSTERING: // 集群模式，消费进度保存在 Broker this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup()); break; default: break; } this.defaultMQPushConsumer.setOffsetStore(this.offsetStore); } this.offsetStore.load(); // 初始化消息消费服务 if (this.getMessageListenerInner() instanceof MessageListenerOrderly) { this.consumeOrderly = true; this.consumeMessageService = new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner()); } else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) { this.consumeOrderly = false; this.consumeMessageService = new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner()); } this.consumeMessageService.start(); // 注册消费者到客户端实例 boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this); if (!registerOK) { this.serviceState = ServiceState.CREATE_JUST; this.consumeMessageService.shutdown(defaultMQPushConsumer.getAwaitTerminationMillisWhenShutdown()); throw new MQClientException(\\\"The consumer group[\\\" + this.defaultMQPushConsumer.getConsumerGroup() + \\\"] has been created before, specify another name please.\\\" + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL), null); } // 启动客户端实例 mQClientFactory.start(); log.info(\\\"the consumer [{}] start OK.\\\", this.defaultMQPushConsumer.getConsumerGroup()); this.serviceState = ServiceState.RUNNING; break; case RUNNING: case START_FAILED: case SHUTDOWN_ALREADY: throw new MQClientException(\\\"The PushConsumer service state not OK, maybe started once, \\\" + this.serviceState + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK), null); default: break; } // 从 Namesrv 更新路由信息 this.updateTopicSubscribeInfoWhenSubscriptionChanged(); this.mQClientFactory.checkClientInBroker(); // 将客户端信息上报给 Broker this.mQClientFactory.sendHeartbeatToAllBrokerWithLock(); // 唤醒重平衡线程，立即执行重平衡 this.mQClientFactory.rebalanceImmediately(); } \"]},\"1123\":{\"h\":\"4.2 MQClientInstance 启动\",\"t\":[\"// MQClientInstance.java /** * 启动客户端代理 * * @throws MQClientException */ public void start() throws MQClientException { synchronized (this) { switch (this.serviceState) { case CREATE_JUST: this.serviceState = ServiceState.START_FAILED; // If not specified,looking address from name server if (null == this.clientConfig.getNamesrvAddr()) { this.mQClientAPIImpl.fetchNameServerAddr(); } // 启动通信模块 this.mQClientAPIImpl.start(); // 启动定时任务（从 Namesrv 拉取路由、向 Broker 发送心跳等） this.startScheduledTask(); // 启动拉取消息服务 this.pullMessageService.start(); // 启动重平衡线程 this.rebalanceService.start(); // 启动默认生产者（用于将消费失败的消息重新生产到 Broker） this.defaultMQProducer.getDefaultMQProducerImpl().start(false); log.info(\\\"the client factory [{}] start OK\\\", this.clientId); this.serviceState = ServiceState.RUNNING; break; case START_FAILED: throw new MQClientException(\\\"The Factory object[\\\" + this.getClientId() + \\\"] has been created before, and failed.\\\", null); default: break; } } } \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1124\":{\"h\":\"RocketMQ 消费者（3）重平衡 流程详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220830-rocketmq-consumer-3-rebalance.html\"]},\"1125\":{\"h\":\"1. 背景\",\"t\":[\"本文是 RocketMQ 消费者系列的第三篇，介绍消费者重平衡。\",\"我把 RocketMQ 消费分成如下几个步骤\",\"重平衡\",\"消费者拉取消息\",\"Broker 接收拉取请求后从存储中查询消息并返回\",\"消费者消费消息\",\"其中重平衡是消费者开始消费的起点。\"]},\"1126\":{\"h\":\"1.1 重平衡的含义\",\"t\":[\"RocketMQ 的 Topic 设计成有多个 Queue，被多个消费者同时消费来加快消费速率。\",\"在多个消费者同时消费一个 Topic 时，其中的每个 Queue 只能同时被一个消费者消费。在消费者数量变化时，将 Queue 分配给消费者进行消费的动作即重平衡。\"]},\"1127\":{\"h\":\"2. 概要设计\",\"t\":[\"RocketMQ 的重平衡大致实现方式为：在消费者端用一个固定的分配策略将所有的消费队列分配给所有的消费者。通过将每个消费者的分配策略设置成一致，并且将消费者和消费队列排序的方法，保证每个消费者的分配的结果幂等。\"]},\"1128\":{\"h\":\"2.1 重平衡的触发\",\"t\":[\"RocketMQ 的重平衡在消费端完成。唯一的触发点是一个重平衡线程，触发方式分主动触发和定时触发。\",\"主动触发：消费者数量发生变化\",\"推模式消费者启动或恢复时，唤醒本地的重平衡线程，立即重平衡。在这之前还上报心跳让 Broker 感知到新消费者启动，发送请求让所有消费者重平衡。\",\"消费者关机时，向 Broker 发请求解除注册。Broker 收到请求后发送请求让其他消费者重平衡。\",\"主动触发模式可以通过以下配置来关闭，当消费者数量很多，或者频繁上下线时，为了防止频繁进行重平衡，建议关闭主动触发。 \",\"Broker 级别配置：notifyConsumerIdsChangedEnable（broker.conf）\",\"消费组级别配置：notifyConsumerIdsChangedEnable（通过 updateSubGroup 命令设置）\",\"只要有一个为 false，就不会进行对应消费组的重平衡主动触发。\",\"定时触发：重平衡线程每 20s 触发一次重平衡。\"]},\"1129\":{\"h\":\"2.2 重平衡类设计\",\"t\":[\"重平衡主要涉及两个类：重平衡实现 RebalanceImpl 和重平衡线程 RebalanceService\",\"重平衡线程：客户端实例持有，每个客户端进程一般只有一个，负责定时或者立即触发重平衡。但它只负责触发，重平衡的实际逻辑在实现类中。\",\"重平衡实现： \",\"RebalanceImpl 中保存了消费者负载的消息队列、重分配策略，并实现了重分配的方法（调用重平衡策略）。\",\"每个消费者持有一个重平衡实现，根据推和拉模式的不同，分别在 RebalanceImpl 的基础上新实现了推模式和拉模式的重平衡实现。\"]},\"1130\":{\"h\":\"2.3 重平衡流程\",\"t\":[\"消费者按 Topic 维度进行重平衡。\",\"从本地缓存中获取 Topic 的所有 Queue\",\"向 Broker 获取所有消费者\",\"按预设的策略将队列分配给消费者\",\"判断自己分配到的队列是否变化 \",\"如果变化则丢弃老队列，开始拉取新队列，并将订阅关系上报到 Broker\",\"RocketMQ 的重平衡流程在消费者端完成，但是由 Broker 端发送信号给所有消费者触发。\"]},\"1131\":{\"h\":\"3. 详细设计\",\"t\":[\"RocketMQ 的重平衡在客户端（即消费者端）完成。\",\"RocketMQ 5.0 中的 POP 消费者特性 支持将重平衡流程在服务端实现，解决了消费端异常 Hang 住时其负载的队列可能会堆积的问题。\"]},\"1132\":{\"h\":\"3.1 重平衡实现类 RebalanceImpl\",\"t\":[\"RebalanceImpl 类中实现了整个重平衡流程。\"]},\"1133\":{\"h\":\"3.1.1 域\",\"t\":[\"RabalanceImpl 类保存一些重平衡需要的基本信息。\",\"subscriptionInner：消费者订阅的所有 Topic。重平衡时遍历这些 Topic 进行重平衡。\",\"topicSubscribeInfoTable：Topic 下的所有队列。重平衡时对这些队列应用重分配策略进行分配。\",\"processQueueTable：该消费者负载的所有消息队列。重平衡完成后，对比之前的负载来判断是否要改变队列进行消息拉取。\",\"此外还有一个重要的域即重分配策略类 allocateMessageQueueStrategy，同一消费组中的每个消费者应保持一致，以保证重分配的结果一致。\"]},\"1134\":{\"h\":\"3.1.2 方法\",\"t\":[\"重平衡实现类中包含重平衡的一系列逻辑，由抽象类直接实现。\",\"重平衡方法 doRebalance\",\"重平衡方法会可以细分为对每个 Topic 进行重平衡的方法 rebalanceByTopic\",\"对 Topic 进行重平衡后需要判断并更新消费者的负载，方法为 updateProcessQueueTableInRebalance\",\"此外还包含了一些抽象方法，根据消费者类型不同有着不同的实现。\",\"messageQueueChange：负载的消息队列发生变化时调用\",\"dispatchPullRequest：分发拉取请求到消息拉取服务，开始拉取消息\",\"removeUnnecessaryMessageQueue：将重平衡后丢弃的消费队列移除\"]},\"1135\":{\"h\":\"3.2 重平衡流程\"},\"1136\":{\"h\":\"3.2.1 重平衡触发\",\"t\":[\"我把重平衡的触发分为主动触发和被动触发，主动触发是由消费者的启动和停止触发的；而被动触发一般是其他消费者每 20s 进行检查或者是收到 Broker 发送的重平衡请求时触发。\",\"上图中标识了 4 个触发点。黄色为主动触发，蓝色为被动触发。\",\"消费者启动时（ start() ）先向 Broker 发送心跳（触发点 4），然后调用 rebalanceImmediately() 方法，立即唤醒重平衡线程执行本地重平衡。\",\"消费者停止时（shutdown()） \",\"Broker 发送请求解除注册\",\"Broker 处理之后再向每个消费者发送消费者数量变化消息\",\"所有消费者收到后唤醒重平衡线程进行重平衡\",\"被动触发，重平衡线程 RebalanceService 每等待 20s 进行一次重平衡\",\"其他消费者收到消费者数量变化请求时进行重平衡。与触发点 2 类似，都是消费者收到 Broker 请求后触发。\",\"RocketMQ 中主要有 3 种消费者实现，它们的重平衡触发也不太相同。上面主要讲的是推模式消费者 DefaultMQPushConsumer 的重平衡触发流程。此外还有两个拉模式消费者。\",\"DefaultMQPullConsumer：封装很原始的消费者，已经被标记为 @Deprecated。只有指定队列进行拉取的接口。\",\"它没有订阅 Topic 的方法，在启动和停止时也不会向 Broker 发送心跳标识消费者的数量变化。\",\"在每次拉取消息时（pull()）会更新订阅的 Topic，也会启动重平衡线程每 20s 进行重平衡。也就是说在第一次拉取消息之后的 20s 内可能会进行重平衡。\",\"一般不会用到该消费者的重平衡机制。\",\"DefaultLitePullConsumer：仿照 kafka 消费者的 API 实现的新消费者，后台有线程拉取消息进行缓存，可以做到比推模式消费者更高的拉取效率。\",\"在订阅 Topic 时（subscribe()）会向 Broker 发送心跳请求，此时就开始重平衡。\",\"在停止时（shutdown()）向 Broker 发送注销请求，此时也会触发重平衡。\",\"重平衡线程每 20s 进行重平衡的检查。\",\"可以看出该拉模式消费者与推模式消费者的重平衡机制比较类似，可以进行重平衡。\"]},\"1137\":{\"h\":\"3.2.2 重平衡流程\",\"t\":[\"重平衡线程调用客户端实例的重平衡方法 doRebalance 进行重平衡，客户端实例的该方法没有具体逻辑，仅仅是遍历客户端上注册的所有消费者，获取它们的重平衡实现并且调用 RebalanceImpl#doRebalance 方法。\",\"该方法逻辑如下：\",\"rebalanceByTopic：从本地缓存中获取该消费者订阅的所有 Topic，对每个 Topic 进行重平衡 \",\"从本地缓存中获取该 Topic 的所有消息队列\",\"发送请求到 Broker，获取该消费组下所有的消费者（ID）\",\"将消息队列和消费者 ID 排序（用来保证每个消费者执行同样的重平衡流程得到的结果一致，刚好能完全分配队列给所有消费者）\",\"执行分配策略的重分配方法，获取自己分配到的消息队列\",\"updateProcessQueueTableInRebalance：更新自己需要拉取的处理队列 \",\"遍历本地缓存的消费者分到的消息队列，判断要丢弃的队列并丢弃\",\"computePullFromWhereWithException：计算并从偏移量存储中读取下次拉取的偏移量\",\"遍历新分配的消息队列，对于新分配的，添加处理队列并创建 PullRequest 启动拉取\",\"dispatchPullRequest：将新建的 PullRequest 加入消息拉取线程 PullMessageService，开始拉取\",\"messageQueueChanged：将新的队列订阅关系通过发送心跳请求上报给 Broker \",\"更新订阅数据版本号\",\"设置 Topic 维度拉取流控\",\"发送心跳给 Broker 更新队列订阅关系\",\"重新分配之后，移除不再属于当前实例的消息队列和处理队列\",\"这里的处理队列指 ProcessQueue，用来临时存放拉取到待消费的消息，与消息队列一一对应。\",\"拉取请求 PullRequest，每个队列只会新建一个，重复使用。每次拉取完一次后将拉取请求重新放入拉取服务的等待队列 pullRequestQueue，进行下一次拉取。初始化 PullRequest 的地方只有一个，就是重平衡实现 RebalanceImpl，也就是说重平衡是消息拉取唯一的起点。\"]},\"1138\":{\"h\":\"3.3 重平衡队列分配策略\",\"t\":[\"RocketMQ 提供了 6 中重平衡策略（队列分配策略）\",\"AllocateMessageQueueAveragely：（默认）平均分配，推荐使用。\",\"AllocateMessageQueueAveragelyByCircle：环形寻论平均分配，推荐使用。\",\"AllocateMessageQueueConsistentHash：一致性哈希。\",\"AllocateMessageQueueByConfig：根据配置，为每个消费者配置固定的消息队列。\",\"AllocateMessageQueueByMachineRoom：根据 Broker 配置的机房名，对每隔消费者负载不同 Broker 上的队列。\"]},\"1139\":{\"h\":\"4. 源码解析\"},\"1140\":{\"h\":\"4.1 RebalanceService 重平衡线程\",\"t\":[\"public class RebalanceService extends ServiceThread { // ... @Override public void run() { log.info(this.getServiceName() + \\\" service started\\\"); while (!this.isStopped()) { // 等待 20s，调用 ServiceThread#wakeup() 方法可以直接跳过等待 this.waitForRunning(waitInterval); // 每隔 20s 对所有消费者执行一次重平衡检查 this.mqClientFactory.doRebalance(); } log.info(this.getServiceName() + \\\" service end\\\"); } } \"]},\"1141\":{\"h\":\"4.2 RebalanceImpl 重平衡实现\"},\"1142\":{\"h\":\"4.2.1 doRebalance 重平衡入口\",\"t\":[\"/** * 消费者重平衡 * 获取全部的订阅信息，从订阅信息中找到所有的 Topic，每一个 Topic 的队列进行重平衡 */ public void doRebalance(final boolean isOrder) { Map<String, SubscriptionData> subTable = this.getSubscriptionInner(); if (subTable != null) { // 遍历每个 Topic 的订阅信息 for (final Map.Entry<String, SubscriptionData> entry : subTable.entrySet()) { final String topic = entry.getKey(); try { // 对每个主题的队列进行重平衡 this.rebalanceByTopic(topic, isOrder); } catch (Throwable e) { if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { log.warn(\\\"rebalanceByTopic Exception\\\", e); } } } } // 重新分配之后，移除不再属于当前实例的MessageQueue和ProcessQueue this.truncateMessageQueueNotMyTopic(); } \"]},\"1143\":{\"h\":\"4.2.2 rebalanceByTopic 对 Topic 进行重平衡\",\"t\":[\"/** * 根据 Topic 重新进行 MessageQueue 负载（重平衡） * * @param topic */ private void rebalanceByTopic(final String topic, final boolean isOrder) { switch (messageModel) { case BROADCASTING: { Set<MessageQueue> mqSet = this.topicSubscribeInfoTable.get(topic); if (mqSet != null) { boolean changed = this.updateProcessQueueTableInRebalance(topic, mqSet, isOrder); if (changed) { this.messageQueueChanged(topic, mqSet, mqSet); log.info(\\\"messageQueueChanged {} {} {} {}\\\", consumerGroup, topic, mqSet, mqSet); } } else { log.warn(\\\"doRebalance, {}, but the topic[{}] not exist.\\\", consumerGroup, topic); } break; } case CLUSTERING: { // 从客户端缓存表中获取 Topic 对应的队列信息 Set<MessageQueue> mqSet = this.topicSubscribeInfoTable.get(topic); // 从 Broker 获取当前消费组内所有消费者的客户端 ID List<String> cidAll = this.mQClientFactory.findConsumerIdList(topic, consumerGroup); if (null == mqSet) { if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { log.warn(\\\"doRebalance, {}, but the topic[{}] not exist.\\\", consumerGroup, topic); } } if (null == cidAll) { log.warn(\\\"doRebalance, {} {}, get consumer id list failed\\\", consumerGroup, topic); } if (mqSet != null && cidAll != null) { // Topic 下的所有队列 List<MessageQueue> mqAll = new ArrayList<MessageQueue>(); mqAll.addAll(mqSet); // 对该 Topic 下的所有队列和消费者列表进行排序，保证所有消费者分配的结果一致 Collections.sort(mqAll); Collections.sort(cidAll); // 分配策略 AllocateMessageQueueStrategy strategy = this.allocateMessageQueueStrategy; // 按策略分配，得到分配给当前消费者实例的队列列表 List<MessageQueue> allocateResult = null; try { allocateResult = strategy.allocate(// this.consumerGroup, // 消费组 this.mQClientFactory.getClientId(), // 当前消费者ID mqAll,// Topic下所有的MessageQueue cidAll); //当前Topic下，当前消费组中所有的消费者ID } catch (Throwable e) { log.error(\\\"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName={}\\\", strategy.getName(), e); return; } // 得到重平衡后的该消费者分到的消息队列 Set Set<MessageQueue> allocateResultSet = new HashSet<MessageQueue>(); if (allocateResult != null) { allocateResultSet.addAll(allocateResult); } // 对比分配给自己的消息队列是否发生变化 boolean changed = this.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder); if (changed) { log.info( \\\"rebalanced result changed. allocateMessageQueueStrategyName={}, group={}, topic={}, clientId={}, mqAllSize={}, cidAllSize={}, rebalanceResultSize={}, rebalanceResultSet={}\\\", strategy.getName(), consumerGroup, topic, this.mQClientFactory.getClientId(), mqSet.size(), cidAll.size(), allocateResultSet.size(), allocateResultSet); // 回调 MessageQueue 变化事件， this.messageQueueChanged(topic, mqSet, allocateResultSet); } } break; } default: break; } } \"]},\"1144\":{\"h\":\"4.2.3 updateProcessQueueTableInRebalance 重平衡后更新订阅的队列和处理队列表\",\"t\":[\"/** * 重平衡后更新 ProcessQueue 表 * 丢弃不再消费的队列，为新增的队列新建 ProcessQueue 和 PullRequest * * @param topic 主题 * @param mqSet 重平衡后该消费者新分配到的的消息队列 * @param isOrder * @return */ private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet, final boolean isOrder) { boolean changed = false; // 遍历本地缓存的消费者分到的消息队列，判断要丢弃的队列并丢弃 Iterator<Entry<MessageQueue, ProcessQueue>> it = this.processQueueTable.entrySet().iterator(); while (it.hasNext()) { Entry<MessageQueue, ProcessQueue> next = it.next(); MessageQueue mq = next.getKey(); ProcessQueue pq = next.getValue(); if (mq.getTopic().equals(topic)) { // 如果新分配到的消息队列集合中不含有老的消息队列，丢弃老的处理队列 if (!mqSet.contains(mq)) { // 该 ProcessQueue 中不会有消息被消费 pq.setDropped(true); // 移除消费队列，移除前持久化 if (this.removeUnnecessaryMessageQueue(mq, pq)) { it.remove(); changed = true; log.info(\\\"doRebalance, {}, remove unnecessary mq, {}\\\", consumerGroup, mq); } } else if (pq.isPullExpired()) { /** * 如果Reblance之后的mq集合包含该MessageQueue,但是ProcessQueue已经太久没有拉取数据（上次拉取消息的时间距离现在超过设置时间） */ switch (this.consumeType()) { case CONSUME_ACTIVELY: break; case CONSUME_PASSIVELY: /** * PushConsumer为被动消费 * 如果是PUSH，则丢弃ProcessQueue * 同时删除MessageQueue */ pq.setDropped(true); if (this.removeUnnecessaryMessageQueue(mq, pq)) { it.remove(); changed = true; log.error(\\\"[BUG]doRebalance, {}, remove unnecessary mq, {}, because pull is pause, so try to fixed it\\\", consumerGroup, mq); } break; default: break; } } } } // 遍历新分配的 MessageQueue，对于新分配的，创建 PullRequest 启动拉取 List<PullRequest> pullRequestList = new ArrayList<PullRequest>(); // 为每个 MessageQueue 新建一个 PullRequest for (MessageQueue mq : mqSet) { if (!this.processQueueTable.containsKey(mq)) { // 本地缓存的 ProcessQueue 中不包含，表示新增队列 if (isOrder && !this.lock(mq)) { log.warn(\\\"doRebalance, {}, add a new mq failed, {}, because lock failed\\\", consumerGroup, mq); continue; } // 从内存中移除该 MessageQueue 的消费进度（老的进度不需要） this.removeDirtyOffset(mq); ProcessQueue pq = new ProcessQueue(); // 计算当前 MessageQueue 应该从哪里开始拉取消息 long nextOffset = -1L; try { // 计算并从偏移量存储中读取下次拉取的偏移量 nextOffset = this.computePullFromWhereWithException(mq); } catch (Exception e) { log.info(\\\"doRebalance, {}, compute offset failed, {}\\\", consumerGroup, mq); continue; } if (nextOffset >= 0) { // 添加 MessageQueue 和 ProcessQueue 的映射关系 ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq); if (pre != null) { log.info(\\\"doRebalance, {}, mq already exists, {}\\\", consumerGroup, mq); } else { // 添加成功，创建新的 PullRequest // 唯一的创建 PullRequest 的地方 log.info(\\\"doRebalance, {}, add a new mq, {}\\\", consumerGroup, mq); PullRequest pullRequest = new PullRequest(); pullRequest.setConsumerGroup(consumerGroup); pullRequest.setNextOffset(nextOffset); pullRequest.setMessageQueue(mq); pullRequest.setProcessQueue(pq); pullRequestList.add(pullRequest); changed = true; } } else { log.warn(\\\"doRebalance, {}, add new mq failed, {}\\\", consumerGroup, mq); } } } // 将新建的 PullRequest 加入消息拉取线程 PullMessageService，开始拉取 this.dispatchPullRequest(pullRequestList); return changed; } \"]},\"1145\":{\"h\":\"4.2.4 MessageQueueChanged\",\"t\":[\"// RebalancePushImpl.java /** * 如果消费的 MessageQueue 变化，上报 Broker，将订阅关系发送给 Broker * @param topic * @param mqAll * @param mqDivided */ @Override public void messageQueueChanged(String topic, Set<MessageQueue> mqAll, Set<MessageQueue> mqDivided) { /** * When rebalance result changed, should update subscription's version to notify broker. * Fix: inconsistency subscription may lead to consumer miss messages. */ SubscriptionData subscriptionData = this.subscriptionInner.get(topic); long newVersion = System.currentTimeMillis(); log.info(\\\"{} Rebalance changed, also update version: {}, {}\\\", topic, subscriptionData.getSubVersion(), newVersion); subscriptionData.setSubVersion(newVersion); int currentQueueCount = this.processQueueTable.size(); if (currentQueueCount != 0) { // Topic 维度流控，默认为 -1，即不流控 int pullThresholdForTopic = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getPullThresholdForTopic(); if (pullThresholdForTopic != -1) { int newVal = Math.max(1, pullThresholdForTopic / currentQueueCount); log.info(\\\"The pullThresholdForQueue is changed from {} to {}\\\", this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getPullThresholdForQueue(), newVal); // 设置每个队列的拉取流控 this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().setPullThresholdForQueue(newVal); } // Topic 维度拉取大小流控 int pullThresholdSizeForTopic = this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getPullThresholdSizeForTopic(); if (pullThresholdSizeForTopic != -1) { int newVal = Math.max(1, pullThresholdSizeForTopic / currentQueueCount); log.info(\\\"The pullThresholdSizeForQueue is changed from {} to {}\\\", this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getPullThresholdSizeForQueue(), newVal); this.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().setPullThresholdSizeForQueue(newVal); } } // notify broker this.getmQClientFactory().sendHeartbeatToAllBrokerWithLock(); } \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1146\":{\"h\":\"RocketMQ 消费者（4）消息拉取 流程详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220904-rocketmq-consumer-4-pull-message.html\"]},\"1147\":{\"h\":\"1. 背景\",\"t\":[\"本文是 RocketMQ 消费者系列的第四篇，介绍消息拉取的流程。\",\"RocketMQ 的消费主要分推和拉两个模式，拉模式主动拉取消息，整个逻辑比较简单。本文着重介绍推模式下，消费者客户端如何实现通过拉取来模拟推的效果，让消息看似主动从 Broker 推送到客户端。\",\"我把 RocketMQ 消费分成如下几个步骤\",\"重平衡\",\"消费者拉取消息\",\"Broker 接收拉取请求后从存储中查询消息并返回\",\"消费者消费消息\",\"本文会涉及 2 和 3 这两个步骤。\"]},\"1148\":{\"h\":\"2. 概要设计\"},\"1149\":{\"h\":\"2.1 交互流程\",\"t\":[\"异步拉取消息的流程主要分为 3 步\",\"消费者组装拉取请求（包含队列信息、要拉取的逻辑偏移量、最大拉取的消息数量），发送给 Broker 端\",\"Broker 处理拉取请求，从存储中查询要被拉取的消息返回相应给消费者\",\"消费者的处理线程池处理拉取完成的回调，将消息从拉取到的响应中解码出来，放入消费队列，让消费服务消费。\"]},\"1150\":{\"h\":\"2.2 客户端拉取流程设计\"},\"1151\":{\"h\":\"2.2.1 拉模式消费者拉取\",\"t\":[\"拉模式消费者由于需要主动进行拉取，所以拉取流程并不复杂。\",\"拉取模式消费者提供了同步和异步的拉取方法，用户主动发起拉取，并对拉取到的消息进行消费处理。\"]},\"1152\":{\"h\":\"2.2.2 推模式消费者拉取\",\"t\":[\"推模式消费也是通过拉取消息请求来拉取消息，通过客户端的封装让用户使用时感觉像是 Broker 主动将消息推给消费者。\",\"客户端实例包含一个消息拉取线程，客户端实例中的所有推模式消费者共用这个拉取线程。\",\"消息拉取线程用了生产-消费模式，内部有一个阻塞队列，存放消费者的拉取请求；运行的时候不断尝试从队列中取出拉取请求执行消息拉取动作。\",\"拉取请求从哪放入阻塞队列？上一篇重平衡篇有提到，重平衡将为消费者负载的队列创建拉取请求并放入队列，后续不会新建而是重复使用这个拉取请求，取出执行一次，拉取完成之后更新拉取偏移量，再将它重新放入队列。\",\"拉取到的消息存放在哪？每个消息队列会对应创建一个处理队列，拉取成功后将拉取到的消息存入处理队列，然后提交给消息消费服务处理。\"]},\"1153\":{\"h\":\"2.3 Broker 端拉取流程设计\",\"t\":[\"Broker 端收到拉取请求后要做的就是将消息从磁盘中查询出来，封装后返回给客户端。\",\"根据队列找到对应的消费队列，读取消费队列判断是否有消息可以消费，如果有则根据消费队列中的索引项，用物理偏移量从消息存储中查找消息。\"]},\"1154\":{\"h\":\"3. 详细设计\"},\"1155\":{\"h\":\"3.1 相关类设计\",\"t\":[\"以下为推模式下消息消费者端拉取相关类设计，拉模式不涉及自动拉取消息。\",\"在消费者端需要处理拉取请求的发送和 Broker 端拉取结果的响应。\",\"RocketMQ 用单独的一个拉取消息线程 PullMessageService 来处理消息拉取，这个线程仅仅是异步发送自动拉取请求，并不负责请求处理，所以整个客户端实例只需要一个共用线程就足够了。拉取消息服务最终会调用 DefaultMQPushConsumerImpl 中的拉取方法实现 pullMessage 来真正发送拉取请求。\",\"消费者收到 Broker 端响应后会调用 PullCallback 接口，该逻辑由 NettyRemotingClient 的 publicExecutor 线程池执行，默认有 4 个线程。\",\"为了能够先后分别处理多个队列的拉取，拉取线程中应用了生产-消费模式，用阻塞队列 pullRequestQueue 存放其他地方（重平衡、上次拉取完成）用 executePullRequestImmediately() 提交的拉取请求 PullRequest。内部不断尝试从阻塞队列中获取拉去请求进行拉取操作。\",\"由于每个队列每次拉取所需要的元信息几乎没什么变化，只需要改变下次拉取的偏移量即可，所以并没有选择每次都创建新的 PullRequest ，而是不断重用在重平衡中创建的同一个 PullRequest 进行拉取。\",\"拉取到的消息会暂存在处理队列 ProcessQueue 中，其内用 TreeMap 保存这些消息，key 是消息在队列中的逻辑偏移量，value 是拉取到的消息。这样可以保证消息的顺序。\",\"消息消费服务从处理队列中获取消息并消费。\"]},\"1156\":{\"h\":\"3.2 整体流程\",\"t\":[\"下图表示推模式消费者的消息拉取流程。整个流程分 3 个步骤\",\"左边 Client 部分为客户端发送拉取请求\",\"右边 Broker 部分为 Broker 端处理拉取请求从存储中查询消息返回\",\"橙色 PullCallback 部分为 客户端处理返回的消息\"]},\"1157\":{\"h\":\"3.2.1 消费者拉取消息\"},\"1158\":{\"h\":\"3.2.1.1 PullMessageService\",\"t\":[\"消费者使用消息拉取线程 PullMessageService 拉取消息，该线程中用生产-消费模式，run 方法不断从阻塞队列中读取拉取请求来执行拉取。每个拉取请求对应拉取一个消息队列的消息。\",\"拉取请求放入阻塞队列的时机主要有三个\",\"重平衡会创建拉取请求\",\"消息拉取逻辑处理完成会更新拉取请求下次拉取的偏移量，然后重新放入队列\",\"消费速度太慢，消息拉取被流控，会等待一段时间后将拉取请求放入队列\"]},\"1159\":{\"h\":\"3.2.1.2 DefaultMQPushConsumerImpl\",\"t\":[\"从阻塞队列中获取拉取请求之后，会调用 DefaultMQPushConsumerImpl#pullMessage() 方法\",\"从拉取请求中获取处理队列 ProcessQueue，检查队列是否被丢弃和消费者是否挂起\",\"消息拉取流控检查，检查处理队列中还未被消费的消息，从待消费消息数量、大小和待消费消息偏移量差来判断。如果需要流控则延迟 50ms 后将拉取请求重新放入队列\",\"获取队列的订阅信息，准备构造拉取请求\",\"创建拉取消息成功的回调\",\"判断是否需要提交偏移量，查询偏移量\",\"构造消息拉取系统标记\",\"调用 PullAPIWrapper#pullKernelImpl 与服务端交互拉取消息\"]},\"1160\":{\"h\":\"3.2.1.3 PullApiWrapper\",\"t\":[\"根据消息队列从本地缓存查询对应的 Broker 地址，如果查不到则请求 Name server 查询\",\"构造查询请求\",\"调用客户端 API 实现发送请求\"]},\"1161\":{\"h\":\"3.2.1.4 MQClientAPIImpl\",\"t\":[\"根据请求发送的交互模式（单向/同步/异步）发送请求。\",\"推模式消费者的拉取为异步调用\"]},\"1162\":{\"h\":\"3.2.2 Broker 端处理拉取请求\"},\"1163\":{\"h\":\"3.2.2.1 PullMessageProcessor\",\"t\":[\"processRequest 方法处理客户端的消息拉取请求\",\"前置检查\",\"消息过滤相关逻辑\",\"从消息存储查询消息\",\"计算下次拉取建议的 Broker 地址，设置到返回体\",\"根据从存储查询消息的结果 \",\"如果找到消息，将消息放入返回体\",\"如果没有找到，执行长轮询逻辑，长轮询相关介绍见本文\",\"如果没有这个队列，发送异常消息\",\"执行消息轨迹的消费钩子\",\"存储消费者消费进度：如果 CommitLog 可用且当前节点为主节点，则更新消费进度\"]},\"1164\":{\"h\":\"3.2.2.2 DefaultMessageStore\",\"t\":[\"从消息存储中查询需要拉取的一批消息\",\"找到对应的消费队列索引\",\"获取消费队列最大和最小的逻辑偏移量\",\"将要拉取的偏移量与上述偏移量比较，判断拉取结果。只有拉取偏移量大于等于最小偏移量、小于最大偏移量时才能正常拉取，否则返回错误\",\"遍历消费队列索引，最多遍历 maxNum 个（消息拉取最大数量）\",\"根据消费队列索引从 CommitLog 中查询消息\",\"返回查询结果\"]},\"1165\":{\"h\":\"3.2.3 消费者拉取成功结果处理\",\"t\":[\"在 NettyRemotingClient 的处理线程池中处理异步请求完成的回调，默认有 4 个线程。\",\"将拉取到的消息解码，过滤\",\"根据拉取的状态进行判断，如果拉取成功才执行下述操作\",\"为拉取请求设置下次拉取的偏移量\",\"更新统计数据\",\"将拉取到的消息放入处理队列\",\"将处理队列让消息消费服务处理\",\"将拉取请求放入拉取线程继续下次拉取\"]},\"1166\":{\"h\":\"4. 源码解析\"},\"1167\":{\"h\":\"4.1 消费者拉取消息\"},\"1168\":{\"h\":\"4.1.1 PullMessageService 消息拉取线程\",\"t\":[\"RocketMQ 封装的服务线程，不断执行 run() 方法\",\"// 拉取请求队列，阻塞队列 private final LinkedBlockingQueue<PullRequest> pullRequestQueue = new LinkedBlockingQueue<PullRequest>(); /** * 立即执行拉取消息请求（立即将拉取请求放入队列） * 每个 MessageQueue 复用一个拉取请求 PullRequest * 在如下位置被调用 * - 重平衡完 * - 一次拉取任务执行完 * * @param pullRequest */ public void executePullRequestImmediately(final PullRequest pullRequest) { try { this.pullRequestQueue.put(pullRequest); } catch (InterruptedException e) { log.error(\\\"executePullRequestImmediately pullRequestQueue.put\\\", e); } } public void run() { log.info(this.getServiceName() + \\\" service started\\\"); // 如果是启动状态，无限循环。stopped 是 volatile 的变量 while (!this.isStopped()) { try { // 从拉取请求队列中获取一个拉取请求 PullRequest pullRequest = this.pullRequestQueue.take(); // 执行拉取消息请求，拉取消息 this.pullMessage(pullRequest); } catch (InterruptedException ignored) { } catch (Exception e) { log.error(\\\"Pull Message Service Run Method exception\\\", e); } } log.info(this.getServiceName() + \\\" service end\\\"); } \"]},\"1169\":{\"h\":\"4.1.2 PullRequest 消息拉取请求\",\"t\":[\"消息拉取请求主要包含拉取消息所需要的元数据\",\"/** * 拉取请求，为推模式消费者服务，在 {@link PullMessageService} 中保存和指定 */ public class PullRequest { // 消费者组 private String consumerGroup; // 待拉取的消费队列 private MessageQueue messageQueue; // 消息处理队列，从 Broker 中拉取到的消息会先存入 ProcessQueue，再提交到消费者消费线程池进行消费 private ProcessQueue processQueue; // 待拉取的 MessageQueue 偏移量 private long nextOffset; // ... } \"]},\"1170\":{\"h\":\"4.1.3 DefaultMQPushConsumerImpl\",\"t\":[\"推消费者实现\",\"/** * 拉取消息入口 * * @param pullRequest 拉取请求，包含需要拉取的消费队列信息 */ public void pullMessage(final PullRequest pullRequest) { // 获取待拉取的消费队列 final ProcessQueue processQueue = pullRequest.getProcessQueue(); // 如果该队列被丢弃，返回 if (processQueue.isDropped()) { log.info(\\\"the pull request[{}] is dropped.\\\", pullRequest.toString()); return; } // 设置该队列的最新拉取时间为当前时间 pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis()); try { this.makeSureStateOK(); } catch (MQClientException e) { log.warn(\\\"pullMessage exception, consumer state not ok\\\", e); this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); return; } // 如果当前消费者被挂起，延迟1s后再拉取 if (this.isPause()) { log.warn(\\\"consumer was paused, execute pull request later. instanceName={}, group={}\\\", this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup()); this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND); return; } // ====== 流控 begin ====== long cachedMessageCount = processQueue.getMsgCount().get(); long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024); // 消息消费数量流控，当前处理消息数量大于1000，触发流控 if (cachedMessageCount > this.defaultMQPushConsumer.getPullThresholdForQueue()) { // 放弃本次拉取，延迟50ms之后重新拉取 this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); if ((queueFlowControlTimes++ % 1000) == 0) { log.warn( \\\"the cached message count exceeds the threshold {}, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}\\\", this.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes); } return; } // 消息消费大小流控，当前消费消息超过100MB，触发流控 if (cachedMessageSizeInMiB > this.defaultMQPushConsumer.getPullThresholdSizeForQueue()) { // 放弃本次拉取，延迟50ms之后重新拉取 this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); if ((queueFlowControlTimes++ % 1000) == 0) { log.warn( \\\"the cached message size exceeds the threshold {} MiB, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}\\\", this.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes); } return; } if (!this.consumeOrderly) { // 消息消费偏移量间隔流控，大于2000，触发流控 if (processQueue.getMaxSpan() > this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) { this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL); if ((queueMaxSpanFlowControlTimes++ % 1000) == 0) { log.warn( \\\"the queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, pullRequest={}, flowControlTimes={}\\\", processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(), pullRequest, queueMaxSpanFlowControlTimes); } return; } } else { // 处理顺序消费 if (processQueue.isLocked()) { if (!pullRequest.isPreviouslyLocked()) { long offset = -1L; try { offset = this.rebalanceImpl.computePullFromWhereWithException(pullRequest.getMessageQueue()); } catch (Exception e) { this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); log.error(\\\"Failed to compute pull offset, pullResult: {}\\\", pullRequest, e); return; } boolean brokerBusy = offset < pullRequest.getNextOffset(); log.info(\\\"the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}\\\", pullRequest, offset, brokerBusy); if (brokerBusy) { log.info(\\\"[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}\\\", pullRequest, offset); } pullRequest.setPreviouslyLocked(true); pullRequest.setNextOffset(offset); } } else { this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); log.info(\\\"pull message later because not locked in broker, {}\\\", pullRequest); return; } } // ====== 流控 end ====== // 拉取该主题订阅信息 final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic()); // 如果为空，延迟3s后拉取 // 由于并发关系，即使找不到订阅关系，也要重试下，防止丢失PullRequest if (null == subscriptionData) { this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); log.warn(\\\"find the consumer's subscription failed, {}\\\", pullRequest); return; } final long beginTimestamp = System.currentTimeMillis(); // 从Broker拉取完成的回调函数 PullCallback pullCallback = new PullCallback() { // ... }; // 偏移量提交计算 boolean commitOffsetEnable = false; long commitOffsetValue = 0L; if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) { commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY); if (commitOffsetValue > 0) { commitOffsetEnable = true; } } // ====== 消息过滤相关 ====== String subExpression = null; boolean classFilter = false; // 获取订阅数据，包含过滤信息 SubscriptionData sd = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic()); if (sd != null) { // 如果不是类过滤模式，设置过滤表达式 if (this.defaultMQPushConsumer.isPostSubscriptionWhenPull() && !sd.isClassFilterMode()) { subExpression = sd.getSubString(); } classFilter = sd.isClassFilterMode(); } // 根据过滤类型构建拉取时的系统标记 int sysFlag = PullSysFlag.buildSysFlag( commitOffsetEnable, // commitOffset true, // suspend subExpression != null, // subscription classFilter // class filter ); // 从服务端拉取 try { this.pullAPIWrapper.pullKernelImpl( pullRequest.getMessageQueue(), // 从那个消费队列拉取消息 subExpression, // 消息过滤表达式 subscriptionData.getExpressionType(), // 消息表达式类型：TAG/SQL92 subscriptionData.getSubVersion(), // pullRequest.getNextOffset(), // 消息拉取偏移量 this.defaultMQPushConsumer.getPullBatchSize(), // 消息拉取最大条数，32 sysFlag, // 拉取系统标记 commitOffsetValue, // 内存中当前消费队列的消费进度 BROKER_SUSPEND_MAX_TIME_MILLIS, // 15000 CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND, // 30000 CommunicationMode.ASYNC, // 消息拉取模式，异步 pullCallback // 拉取消息成功后的回调方法 ); } catch (Exception e) { log.error(\\\"pullKernelImpl exception\\\", e); this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); } } \"]},\"1171\":{\"h\":\"4.1.4 PullAPIWrapper\",\"t\":[\"/** * 向 Broker 发送请求，拉取消息 * * @param mq 消息队列 * @param subExpression 过滤表达式 * @param expressionType 过滤类型 * @param subVersion 订阅关系版本号 * @param offset 拉取偏移量 * @param maxNums 拉取最大数量 * @param sysFlag 标志位 * @param commitOffset 提交偏移量 * @param brokerSuspendMaxTimeMillis Broker 挂起最大时间 * @param timeoutMillis 客户端拉取超时 * @param communicationMode 交互模式：单向/异步/同步 * @param pullCallback 拉取成功回调函数 * @return 拉取结果 * @throws MQClientException * @throws RemotingException * @throws MQBrokerException * @throws InterruptedException */ public PullResult pullKernelImpl( final MessageQueue mq, final String subExpression, final String expressionType, final long subVersion, final long offset, final int maxNums, final int sysFlag, final long commitOffset, final long brokerSuspendMaxTimeMillis, final long timeoutMillis, final CommunicationMode communicationMode, final PullCallback pullCallback ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { // 根据brokerName、brokerId从MQClientInstance中获取Broker地址。先从内存查找，找不到则从 NameServer 更新。 FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), this.recalculatePullFromWhichNode(mq), false); if (null == findBrokerResult) { this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic()); findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), this.recalculatePullFromWhichNode(mq), false); } if (findBrokerResult != null) { { // check version if (!ExpressionType.isTagType(expressionType) && findBrokerResult.getBrokerVersion() < MQVersion.Version.V4_1_0_SNAPSHOT.ordinal()) { throw new MQClientException(\\\"The broker[\\\" + mq.getBrokerName() + \\\", \\\" + findBrokerResult.getBrokerVersion() + \\\"] does not upgrade to support for filter message by \\\" + expressionType, null); } } int sysFlagInner = sysFlag; // 如果是子节点，把CommitOffset位去掉 // 因为子节点不保存消费者的Offset值，只有主节点才保存，所以如果是从子节点拉消息，就不能把这个位设为有效 if (findBrokerResult.isSlave()) { sysFlagInner = PullSysFlag.clearCommitOffsetFlag(sysFlagInner); } PullMessageRequestHeader requestHeader = new PullMessageRequestHeader(); requestHeader.setConsumerGroup(this.consumerGroup); requestHeader.setTopic(mq.getTopic()); requestHeader.setQueueId(mq.getQueueId()); requestHeader.setQueueOffset(offset); requestHeader.setMaxMsgNums(maxNums); requestHeader.setSysFlag(sysFlagInner); // 消费的当前队列的已经消费的最大的Offset值 requestHeader.setCommitOffset(commitOffset); requestHeader.setSuspendTimeoutMillis(brokerSuspendMaxTimeMillis); requestHeader.setSubscription(subExpression); requestHeader.setSubVersion(subVersion); requestHeader.setExpressionType(expressionType); String brokerAddr = findBrokerResult.getBrokerAddr(); // 如果过滤模式为类过滤，根据主题名称、Broker地址找到注册在Broker上的FilterServer地址，从FilterServer上拉取消息 if (PullSysFlag.hasClassFilterFlag(sysFlagInner)) { brokerAddr = computePullFromWhichFilterServer(mq.getTopic(), brokerAddr); } // 从Broker拉取消息 PullResult pullResult = this.mQClientFactory.getMQClientAPIImpl().pullMessage( brokerAddr, requestHeader, timeoutMillis, communicationMode, pullCallback); return pullResult; } throw new MQClientException(\\\"The broker[\\\" + mq.getBrokerName() + \\\"] not exist\\\", null); } \"]},\"1172\":{\"h\":\"4.1.5 MQClientInstance\",\"t\":[\"public PullResult pullMessage( final String addr, final PullMessageRequestHeader requestHeader, final long timeoutMillis, final CommunicationMode communicationMode, final PullCallback pullCallback ) throws RemotingException, MQBrokerException, InterruptedException { RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.PULL_MESSAGE, requestHeader); switch (communicationMode) { case ONEWAY: assert false; return null; case ASYNC: this.pullMessageAsync(addr, request, timeoutMillis, pullCallback); return null; case SYNC: return this.pullMessageSync(addr, request, timeoutMillis); default: assert false; break; } return null; } \"]},\"1173\":{\"h\":\"4.1.6 PullMessageProcessor\",\"t\":[\"/** * 处理客户端拉取请求入口 * * @param channel 网络通道，通过该通道向消息拉取客户端发送响应结果 * @param request 消息拉取请求 * @param brokerAllowSuspend Broker端是否允许挂起，默认true。true：如果未找到消息则挂起。false：未找到消息直接返回消息未找到 * @return 响应 * @throws RemotingCommandException 当解析请求发生异常时 */ private RemotingCommand processRequest(final Channel channel, RemotingCommand request, boolean brokerAllowSuspend) throws RemotingCommandException { final long beginTimeMills = this.brokerController.getMessageStore().now(); RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class); final PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader(); final PullMessageRequestHeader requestHeader = (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class); // 设置ID，用于响应和请求的匹配 response.setOpaque(request.getOpaque()); log.debug(\\\"receive PullMessage request command, {}\\\", request); // 判断Broker权限，broker是否可读 if (!PermName.isReadable(this.brokerController.getBrokerConfig().getBrokerPermission())) { response.setCode(ResponseCode.NO_PERMISSION); response.setRemark(String.format(\\\"the broker[%s] pulling message is forbidden\\\", this.brokerController.getBrokerConfig().getBrokerIP1())); return response; } // 校验ConsumerGroup配置是否存在 SubscriptionGroupConfig subscriptionGroupConfig = this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup()); if (null == subscriptionGroupConfig) { response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST); response.setRemark(String.format(\\\"subscription group [%s] does not exist, %s\\\", requestHeader.getConsumerGroup(), FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST))); return response; } // 校验ConsumerGroup配置是否可消费 if (!subscriptionGroupConfig.isConsumeEnable()) { response.setCode(ResponseCode.NO_PERMISSION); response.setRemark(\\\"subscription group no permission, \\\" + requestHeader.getConsumerGroup()); return response; } // 是否挂起 final boolean hasSuspendFlag = PullSysFlag.hasSuspendFlag(requestHeader.getSysFlag()); // 客户端是否提交了消费进度 final boolean hasCommitOffsetFlag = PullSysFlag.hasCommitOffsetFlag(requestHeader.getSysFlag()); final boolean hasSubscriptionFlag = PullSysFlag.hasSubscriptionFlag(requestHeader.getSysFlag()); // 计算挂起时间 final long suspendTimeoutMillisLong = hasSuspendFlag ? requestHeader.getSuspendTimeoutMillis() : 0; // 查找Topic配置信息 TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic()); if (null == topicConfig) { log.error(\\\"the topic {} not exist, consumer: {}\\\", requestHeader.getTopic(), RemotingHelper.parseChannelRemoteAddr(channel)); response.setCode(ResponseCode.TOPIC_NOT_EXIST); response.setRemark(String.format(\\\"topic[%s] not exist, apply first please! %s\\\", requestHeader.getTopic(), FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL))); return response; } // 判断Topic是否可读 if (!PermName.isReadable(topicConfig.getPerm())) { response.setCode(ResponseCode.NO_PERMISSION); response.setRemark(\\\"the topic[\\\" + requestHeader.getTopic() + \\\"] pulling message is forbidden\\\"); return response; } // 请求的队列ID是否合法 // >= 0 && < 已知的最大队列数量 if (requestHeader.getQueueId() < 0 || requestHeader.getQueueId() >= topicConfig.getReadQueueNums()) { String errorInfo = String.format(\\\"queueId[%d] is illegal, topic:[%s] topicConfig.readQueueNums:[%d] consumer:[%s]\\\", requestHeader.getQueueId(), requestHeader.getTopic(), topicConfig.getReadQueueNums(), channel.remoteAddress()); log.warn(errorInfo); response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(errorInfo); return response; } // ====== 消息过滤 ====== // 判断客户端是否传过来了SubscriptionData，即过滤数据 SubscriptionData subscriptionData = null; ConsumerFilterData consumerFilterData = null; if (hasSubscriptionFlag) { try { // true，则根据客户端传过来的数据构造subscriptionData subscriptionData = FilterAPI.build( requestHeader.getTopic(), requestHeader.getSubscription(), requestHeader.getExpressionType() ); if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) { // 如果不是 TAG 类型的过滤，则是 SQL92 过滤，构建过滤数据 ConsumerFilterData consumerFilterData = ConsumerFilterManager.build( requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getSubscription(), requestHeader.getExpressionType(), requestHeader.getSubVersion() ); assert consumerFilterData != null; } } catch (Exception e) { log.warn(\\\"Parse the consumer's subscription[{}] failed, group: {}\\\", requestHeader.getSubscription(), requestHeader.getConsumerGroup()); response.setCode(ResponseCode.SUBSCRIPTION_PARSE_FAILED); response.setRemark(\\\"parse the consumer's subscription failed\\\"); return response; } } else { // false，则通过服务端数据构造subscriptionData ConsumerGroupInfo consumerGroupInfo = this.brokerController.getConsumerManager().getConsumerGroupInfo(requestHeader.getConsumerGroup()); if (null == consumerGroupInfo) { log.warn(\\\"the consumer's group info not exist, group: {}\\\", requestHeader.getConsumerGroup()); response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST); response.setRemark(\\\"the consumer's group info not exist\\\" + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC)); return response; } if (!subscriptionGroupConfig.isConsumeBroadcastEnable() && consumerGroupInfo.getMessageModel() == MessageModel.BROADCASTING) { response.setCode(ResponseCode.NO_PERMISSION); response.setRemark(\\\"the consumer group[\\\" + requestHeader.getConsumerGroup() + \\\"] can not consume by broadcast way\\\"); return response; } subscriptionData = consumerGroupInfo.findSubscriptionData(requestHeader.getTopic()); if (null == subscriptionData) { log.warn(\\\"the consumer's subscription not exist, group: {}, topic:{}\\\", requestHeader.getConsumerGroup(), requestHeader.getTopic()); response.setCode(ResponseCode.SUBSCRIPTION_NOT_EXIST); response.setRemark(\\\"the consumer's subscription not exist\\\" + FAQUrl.suggestTodo(FAQUrl.SAME_GROUP_DIFFERENT_TOPIC)); return response; } // 判断Broker的订阅关系版本是否最新 if (subscriptionData.getSubVersion() < requestHeader.getSubVersion()) { log.warn(\\\"The broker's subscription is not latest, group: {} {}\\\", requestHeader.getConsumerGroup(), subscriptionData.getSubString()); response.setCode(ResponseCode.SUBSCRIPTION_NOT_LATEST); response.setRemark(\\\"the consumer's subscription not latest\\\"); return response; } if (!ExpressionType.isTagType(subscriptionData.getExpressionType())) { consumerFilterData = this.brokerController.getConsumerFilterManager().get(requestHeader.getTopic(), requestHeader.getConsumerGroup()); if (consumerFilterData == null) { response.setCode(ResponseCode.FILTER_DATA_NOT_EXIST); response.setRemark(\\\"The broker's consumer filter data is not exist!Your expression may be wrong!\\\"); return response; } if (consumerFilterData.getClientVersion() < requestHeader.getSubVersion()) { log.warn(\\\"The broker's consumer filter data is not latest, group: {}, topic: {}, serverV: {}, clientV: {}\\\", requestHeader.getConsumerGroup(), requestHeader.getTopic(), consumerFilterData.getClientVersion(), requestHeader.getSubVersion()); response.setCode(ResponseCode.FILTER_DATA_NOT_LATEST); response.setRemark(\\\"the consumer's consumer filter data not latest\\\"); return response; } } } if (!ExpressionType.isTagType(subscriptionData.getExpressionType()) && !this.brokerController.getBrokerConfig().isEnablePropertyFilter()) { response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(\\\"The broker does not support consumer to filter message by \\\" + subscriptionData.getExpressionType()); return response; } // 构建消息过滤器 MessageFilter messageFilter; if (this.brokerController.getBrokerConfig().isFilterSupportRetry()) { // 支持对重试主题的属性进行过滤 messageFilter = new ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData, this.brokerController.getConsumerFilterManager()); } else { // 不支持对重试主题的属性进行过滤 messageFilter = new ExpressionMessageFilter(subscriptionData, consumerFilterData, this.brokerController.getConsumerFilterManager()); } // 根据消费组、Topic、QueueID、队列Offset、拉取消息数量、订阅信息查找消息 final GetMessageResult getMessageResult = this.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), messageFilter); if (getMessageResult != null) { // 填充responseHeader response.setRemark(getMessageResult.getStatus().name()); responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset()); responseHeader.setMinOffset(getMessageResult.getMinOffset()); responseHeader.setMaxOffset(getMessageResult.getMaxOffset()); // 如果允许从SLAVE拉数据，根据主从同步延迟计算下一次从主或从节点拉取 if (getMessageResult.isSuggestPullingFromSlave()) { // 消费较慢，重定向到另外一台机器 responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly()); } else { // 消费正常，按照订阅组配置重定向 responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID); } switch (this.brokerController.getMessageStoreConfig().getBrokerRole()) { case ASYNC_MASTER: case SYNC_MASTER: break; case SLAVE: if (!this.brokerController.getBrokerConfig().isSlaveReadEnable()) { response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY); responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID); } break; } if (this.brokerController.getBrokerConfig().isSlaveReadEnable()) { // consume too slow ,redirect to another machine if (getMessageResult.isSuggestPullingFromSlave()) { responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly()); } // consume ok else { responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId()); } } else { responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID); } // 根据GetMessageResult状态码推算Response状态码 switch (getMessageResult.getStatus()) { case FOUND: response.setCode(ResponseCode.SUCCESS); break; case MESSAGE_WAS_REMOVING: response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY); break; // 这两个返回值都表示服务器暂时没有这个队列，应该立刻将客户端Offset重置为0 case NO_MATCHED_LOGIC_QUEUE: case NO_MESSAGE_IN_QUEUE: if (0 != requestHeader.getQueueOffset()) { response.setCode(ResponseCode.PULL_OFFSET_MOVED); // XXX: warn and notify me log.info(\\\"the broker store no queue data, fix the request offset {} to {}, Topic: {} QueueId: {} Consumer Group: {}\\\", requestHeader.getQueueOffset(), getMessageResult.getNextBeginOffset(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getConsumerGroup() ); } else { response.setCode(ResponseCode.PULL_NOT_FOUND); } break; case NO_MATCHED_MESSAGE: response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY); break; case OFFSET_FOUND_NULL: response.setCode(ResponseCode.PULL_NOT_FOUND); break; case OFFSET_OVERFLOW_BADLY: response.setCode(ResponseCode.PULL_OFFSET_MOVED); // XXX: warn and notify me log.info(\\\"the request offset: {} over flow badly, broker max offset: {}, consumer: {}\\\", requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress()); break; case OFFSET_OVERFLOW_ONE: response.setCode(ResponseCode.PULL_NOT_FOUND); break; case OFFSET_TOO_SMALL: response.setCode(ResponseCode.PULL_OFFSET_MOVED); log.info(\\\"the request offset too small. group={}, topic={}, requestOffset={}, brokerMinOffset={}, clientIp={}\\\", requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueOffset(), getMessageResult.getMinOffset(), channel.remoteAddress()); break; default: assert false; break; } // 消息轨迹：记录客户端拉取的消息记录（不表示消费成功） if (this.hasConsumeMessageHook()) { // 执行hook ConsumeMessageContext context = new ConsumeMessageContext(); context.setConsumerGroup(requestHeader.getConsumerGroup()); context.setTopic(requestHeader.getTopic()); context.setQueueId(requestHeader.getQueueId()); String owner = request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER); switch (response.getCode()) { case ResponseCode.SUCCESS: int commercialBaseCount = brokerController.getBrokerConfig().getCommercialBaseCount(); int incValue = getMessageResult.getMsgCount4Commercial() * commercialBaseCount; context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_SUCCESS); context.setCommercialRcvTimes(incValue); context.setCommercialRcvSize(getMessageResult.getBufferTotalSize()); context.setCommercialOwner(owner); break; case ResponseCode.PULL_NOT_FOUND: if (!brokerAllowSuspend) { context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS); context.setCommercialRcvTimes(1); context.setCommercialOwner(owner); } break; case ResponseCode.PULL_RETRY_IMMEDIATELY: case ResponseCode.PULL_OFFSET_MOVED: context.setCommercialRcvStats(BrokerStatsManager.StatsType.RCV_EPOLLS); context.setCommercialRcvTimes(1); context.setCommercialOwner(owner); break; default: assert false; break; } this.executeConsumeMessageHookBefore(context); } switch (response.getCode()) { case ResponseCode.SUCCESS: // 统计 this.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(), getMessageResult.getMessageCount()); this.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(), getMessageResult.getBufferTotalSize()); this.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount()); if (this.brokerController.getBrokerConfig().isTransferMsgByHeap()) { final byte[] r = this.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId()); this.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), (int) (this.brokerController.getMessageStore().now() - beginTimeMills)); response.setBody(r); } else { try { FileRegion fileRegion = new ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult); channel.writeAndFlush(fileRegion).addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { getMessageResult.release(); if (!future.isSuccess()) { log.error(\\\"transfer many message by pagecache failed, {}\\\", channel.remoteAddress(), future.cause()); } } }); } catch (Throwable e) { log.error(\\\"transfer many message by pagecache exception\\\", e); getMessageResult.release(); } response = null; } break; case ResponseCode.PULL_NOT_FOUND: // 长轮询 // 如果当前没有消息，并且本次拉取是由客户端触发，而非挂起请求触发的话，那么挂起当前拉取请求 if (brokerAllowSuspend && hasSuspendFlag) { // 最大挂起时间，push模式固定15s，pull模式固定20s long pollingTimeMills = suspendTimeoutMillisLong; if (!this.brokerController.getBrokerConfig().isLongPollingEnable()) { // 如果不启用长轮询，则使用短轮询，1s检查一次是否有新消息。默认启用长轮询 pollingTimeMills = this.brokerController.getBrokerConfig().getShortPollingTimeMills(); } // 构造一个PullRequest并交给PullRequestHoldService线程 String topic = requestHeader.getTopic(); long offset = requestHeader.getQueueOffset(); int queueId = requestHeader.getQueueId(); PullRequest pullRequest = new PullRequest(request, channel, pollingTimeMills, this.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter); this.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest); response = null; // 将相应置为空，意味着暂时不返回给客户端 break; } // 向Consumer返回应答 case ResponseCode.PULL_RETRY_IMMEDIATELY: break; case ResponseCode.PULL_OFFSET_MOVED: if (this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE || this.brokerController.getMessageStoreConfig().isOffsetCheckInSlave()) { MessageQueue mq = new MessageQueue(); mq.setTopic(requestHeader.getTopic()); mq.setQueueId(requestHeader.getQueueId()); mq.setBrokerName(this.brokerController.getBrokerConfig().getBrokerName()); OffsetMovedEvent event = new OffsetMovedEvent(); event.setConsumerGroup(requestHeader.getConsumerGroup()); event.setMessageQueue(mq); event.setOffsetRequest(requestHeader.getQueueOffset()); event.setOffsetNew(getMessageResult.getNextBeginOffset()); this.generateOffsetMovedEvent(event); log.warn( \\\"PULL_OFFSET_MOVED:correction offset. topic={}, groupId={}, requestOffset={}, newOffset={}, suggestBrokerId={}\\\", requestHeader.getTopic(), requestHeader.getConsumerGroup(), event.getOffsetRequest(), event.getOffsetNew(), responseHeader.getSuggestWhichBrokerId()); } else { responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId()); response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY); log.warn(\\\"PULL_OFFSET_MOVED:none correction. topic={}, groupId={}, requestOffset={}, suggestBrokerId={}\\\", requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueOffset(), responseHeader.getSuggestWhichBrokerId()); } break; default: assert false; } } else { response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(\\\"store getMessage return null\\\"); } // 存储Consumer消费进度：如果CommitLog可用且当前节点为主节点，则更新消费进度 boolean storeOffsetEnable = brokerAllowSuspend; // 说明是首次调用，相对于长轮询通知 storeOffsetEnable = storeOffsetEnable && hasCommitOffsetFlag; // 说明Consumer设置了标志位 storeOffsetEnable = storeOffsetEnable // 只有Master支持存储offset && this.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE; if (storeOffsetEnable) { this.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel), requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset()); } return response; } \"]},\"1174\":{\"h\":\"4.1.7 DefaultMessageStore\",\"t\":[\"/** * 获取消息 * * @param group Consumer group that launches this query. 消费者组 * @param topic Topic to query. 主题 * @param queueId Queue ID to query. 队列ID * @param offset Logical offset to start from. 消息在队列中的逻辑偏移量 * @param maxMsgNums Maximum count of messages to query. 查询的最大消息数量 * @param messageFilter Message filter used to screen desired messages. 消息过滤器 * @return 查询消息结果 */ public GetMessageResult getMessage(final String group, final String topic, final int queueId, final long offset, final int maxMsgNums, final MessageFilter messageFilter) { if (this.shutdown) { log.warn(\\\"message store has shutdown, so getMessage is forbidden\\\"); return null; } if (!this.runningFlags.isReadable()) { log.warn(\\\"message store is not readable, so getMessage is forbidden \\\" + this.runningFlags.getFlagBits()); return null; } if (MixAll.isLmq(topic) && this.isLmqConsumeQueueNumExceeded()) { log.warn(\\\"message store is not available, broker config enableLmq and enableMultiDispatch, lmq consumeQueue num exceed maxLmqConsumeQueueNum config num\\\"); return null; } long beginTime = this.getSystemClock().now(); GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE; long nextBeginOffset = offset; long minOffset = 0; long maxOffset = 0; // lazy init when find msg. GetMessageResult getResult = null; final long maxOffsetPy = this.commitLog.getMaxOffset(); ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId); if (consumeQueue != null) { minOffset = consumeQueue.getMinOffsetInQueue(); maxOffset = consumeQueue.getMaxOffsetInQueue(); if (maxOffset == 0) { status = GetMessageStatus.NO_MESSAGE_IN_QUEUE; nextBeginOffset = nextOffsetCorrection(offset, 0); } else if (offset < minOffset) { status = GetMessageStatus.OFFSET_TOO_SMALL; nextBeginOffset = nextOffsetCorrection(offset, minOffset); } else if (offset == maxOffset) { status = GetMessageStatus.OFFSET_OVERFLOW_ONE; nextBeginOffset = nextOffsetCorrection(offset, offset); } else if (offset > maxOffset) { status = GetMessageStatus.OFFSET_OVERFLOW_BADLY; if (0 == minOffset) { nextBeginOffset = nextOffsetCorrection(offset, minOffset); } else { nextBeginOffset = nextOffsetCorrection(offset, maxOffset); } } else { // 根据逻辑偏移量从 ConsumeQueue 中查出索引项 SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset); if (bufferConsumeQueue != null) { try { status = GetMessageStatus.NO_MATCHED_MESSAGE; long nextPhyFileStartOffset = Long.MIN_VALUE; long maxPhyOffsetPulling = 0; int i = 0; final int maxFilterMessageCount = Math.max(16000, maxMsgNums * ConsumeQueue.CQ_STORE_UNIT_SIZE); final boolean diskFallRecorded = this.messageStoreConfig.isDiskFallRecorded(); getResult = new GetMessageResult(maxMsgNums); ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit(); // 从消费队列中读取消息，直到读完或者读到查询消息数的最大值 for (; i < bufferConsumeQueue.getSize() && i < maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) { long offsetPy = bufferConsumeQueue.getByteBuffer().getLong(); int sizePy = bufferConsumeQueue.getByteBuffer().getInt(); long tagsCode = bufferConsumeQueue.getByteBuffer().getLong(); maxPhyOffsetPulling = offsetPy; // 物理文件正在被删除 if (nextPhyFileStartOffset != Long.MIN_VALUE) { if (offsetPy < nextPhyFileStartOffset) continue; } // 判断是否拉磁盘数据 boolean isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy); // 此批消息到达上限 if (this.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(), isInDisk)) { break; } boolean extRet = false, isTagsCodeLegal = true; if (consumeQueue.isExtAddr(tagsCode)) { extRet = consumeQueue.getExt(tagsCode, cqExtUnit); if (extRet) { tagsCode = cqExtUnit.getTagsCode(); } else { // can't find ext content.Client will filter messages by tag also. log.error(\\\"[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}, topic={}, group={}\\\", tagsCode, offsetPy, sizePy, topic, group); isTagsCodeLegal = false; } } // 消息过滤，先根据 ConsumeQueue 条目中的哈希码进行过滤，不匹配则直接跳过该条消息 if (messageFilter != null && !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : null, extRet ? cqExtUnit : null)) { if (getResult.getBufferTotalSize() == 0) { status = GetMessageStatus.NO_MATCHED_MESSAGE; } continue; } // 根据消息的偏移量和消息的大小从 CommitLog 文件中取出一条消息 SelectMappedBufferResult selectResult = this.commitLog.getMessage(offsetPy, sizePy); if (null == selectResult) { if (getResult.getBufferTotalSize() == 0) { status = GetMessageStatus.MESSAGE_WAS_REMOVING; } nextPhyFileStartOffset = this.commitLog.rollNextFile(offsetPy); continue; } // 如果消息通过了 ConsumeQueue 的哈希码过滤，要从 CommitLog 中加载整个消息体，根据属性进行过滤 if (messageFilter != null && !messageFilter.isMatchedByCommitLog(selectResult.getByteBuffer().slice(), null)) { if (getResult.getBufferTotalSize() == 0) { status = GetMessageStatus.NO_MATCHED_MESSAGE; } // release... selectResult.release(); continue; } this.storeStatsService.getGetMessageTransferedMsgCount().add(1); getResult.addMessage(selectResult); status = GetMessageStatus.FOUND; nextPhyFileStartOffset = Long.MIN_VALUE; } if (diskFallRecorded) { long fallBehind = maxOffsetPy - maxPhyOffsetPulling; brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind); } nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE); long diff = maxOffsetPy - maxPhyOffsetPulling; long memory = (long) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE * (this.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / 100.0)); getResult.setSuggestPullingFromSlave(diff > memory); } finally { bufferConsumeQueue.release(); } } else { status = GetMessageStatus.OFFSET_FOUND_NULL; nextBeginOffset = nextOffsetCorrection(offset, consumeQueue.rollNextFile(offset)); log.warn(\\\"consumer request topic: \\\" + topic + \\\"offset: \\\" + offset + \\\" minOffset: \\\" + minOffset + \\\" maxOffset: \\\" + maxOffset + \\\", but access logic queue failed.\\\"); } } } else { status = GetMessageStatus.NO_MATCHED_LOGIC_QUEUE; nextBeginOffset = nextOffsetCorrection(offset, 0); } if (GetMessageStatus.FOUND == status) { this.storeStatsService.getGetMessageTimesTotalFound().add(1); } else { this.storeStatsService.getGetMessageTimesTotalMiss().add(1); } long elapsedTime = this.getSystemClock().now() - beginTime; this.storeStatsService.setGetMessageEntireTimeMax(elapsedTime); // lazy init no data found. if (getResult == null) { getResult = new GetMessageResult(0); } getResult.setStatus(status); getResult.setNextBeginOffset(nextBeginOffset); getResult.setMaxOffset(maxOffset); getResult.setMinOffset(minOffset); return getResult; } public long getMaxOffsetInQueue(String topic, int queueId) { ConsumeQueue logic = this.findConsumeQueue(topic, queueId); if (logic != null) { long offset = logic.getMaxOffsetInQueue(); return offset; } return 0; } \"]},\"1175\":{\"h\":\"4.1.8 PullCallback\",\"t\":[\"// DefaultMQPushConsumerImpl.java @Override public void onSuccess(PullResult pullResult) { if (pullResult != null) { // 将消息字节数组解码成消息列表并填充msgFoundList；对消息进行TAG模式过滤 pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult, subscriptionData); switch (pullResult.getPullStatus()) { // 找到对应消息 case FOUND: // 上次请求偏移量 long prevRequestOffset = pullRequest.getNextOffset(); // 更新下一次拉取的偏移量 pullRequest.setNextOffset(pullResult.getNextBeginOffset()); // 计算和记录拉取用时 long pullRT = System.currentTimeMillis() - beginTimestamp; DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(), pullRequest.getMessageQueue().getTopic(), pullRT); // 如果msgFoundList为空，马上进行下次拉取 // msgFoundList为空的情况：因为根据TAG过滤时在服务端只验证了TAG的哈希码，客户端要再次对消息进行了过滤（见上），可能会出现为空的情况 long firstMsgOffset = Long.MAX_VALUE; if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) { DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest); } else { // 获取返回结果中第一条消息的消费队列offset firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset(); DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(), pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size()); // 将拉取到的消息存入ProcessQueue boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList()); // 将拉取到的消息提交到ConsumeMessageService中供消费者消费（异步） DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest( pullResult.getMsgFoundList(), processQueue, pullRequest.getMessageQueue(), dispatchToConsume); // 等待pullInterval毫秒后重新拉取，或立即重新拉取 if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() > 0) { DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval()); } else { DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest); } } if (pullResult.getNextBeginOffset() < prevRequestOffset || firstMsgOffset < prevRequestOffset) { log.warn( \\\"[BUG] pull message result maybe data wrong, nextBeginOffset: {} firstMsgOffset: {} prevRequestOffset: {}\\\", pullResult.getNextBeginOffset(), firstMsgOffset, prevRequestOffset); } break; // 没有新消息，对应服务端结果：OFFSET_FOUND_NULL/OFFSET_OVERFLOW_ONE case NO_NEW_MSG: // 没有匹配的消息 case NO_MATCHED_MSG: pullRequest.setNextOffset(pullResult.getNextBeginOffset()); // 使用服务器端校正的偏移量进行下一次消息的拉取 DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest); DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest); break; // 偏移量非法，对应服务端结果：NO_MATCHED_LOGIC_QUEUE/NO_MESSAGE_IN_QUEUE/OFFSET_OVERFLOW_BADLY/OFFSET_TOO_SMALL case OFFSET_ILLEGAL: log.warn(\\\"the pull request offset illegal, {} {}\\\", pullRequest.toString(), pullResult.toString()); pullRequest.setNextOffset(pullResult.getNextBeginOffset()); // 丢弃该消费队列，意味着ProcessQueue中拉取的消息将停止消费 pullRequest.getProcessQueue().setDropped(true); DefaultMQPushConsumerImpl.this.executeTaskLater(new Runnable() { @Override public void run() { try { // 根据服务端下一次校对的偏移量尝试更新消息消费进度（内存中） DefaultMQPushConsumerImpl.this.offsetStore.updateOffset(pullRequest.getMessageQueue(), pullRequest.getNextOffset(), false); // 尝试持久化消息消费进度 DefaultMQPushConsumerImpl.this.offsetStore.persist(pullRequest.getMessageQueue()); // 将该消息队列从RebalanceImpl的处理队列中移除，意味着暂停该消息队列的消息拉取，等待下一次消息队列重新负载 DefaultMQPushConsumerImpl.this.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue()); log.warn(\\\"fix the pull request offset, {}\\\", pullRequest); } catch (Throwable e) { log.error(\\\"executeTaskLater Exception\\\", e); } } }, 10000); break; default: break; } } } @Override public void onException(Throwable e) { if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { log.warn(\\\"execute the pull request exception\\\", e); } DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); } \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1176\":{\"h\":\"RocketMQ 消费者（5）消息消费、消费进度上报 流程详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220912-rocketmq-consumer-5-message-consume.html\"]},\"1177\":{\"h\":\"1. 背景\",\"t\":[\"本文是 RocketMQ 消费者系列的第五篇，主要介绍并发消费者的消费和消费进度上报的流程。\",\"我把 RocketMQ 消费分成如下几个步骤\",\"重平衡\",\"消费者拉取消息\",\"Broker 接收拉取请求后从存储中查询消息并返回\",\"消费者消费消息\",\"本文介绍的是步骤 4。RocketMQ 的消费还分并发消费和顺序消费，顺序消费将会在下一篇进行讲解。\"]},\"1178\":{\"h\":\"2. 概要设计\"},\"1179\":{\"h\":\"2.1 推模式并发消费交互流程\",\"t\":[\"RocketMQ 推模式下有并发消费和顺序消费两种消费模式。并发消费，顾名思义，将由一个消费线程池并行处理消费逻辑，消费速度较快。\",\"默认为消费线程池设置 20 个线程。从上一步拉取消息到消费者后，将拉取到的一批消息提交给并发消费服务，并发消费服务将消息封装成一个个消费请求（每个消费请求将消费一批消息，默认一批只包含一条消息）提交给消费线程池进行消费。\",\"消费时将会调用订阅时注册的消费监听器中的业务方法，执行真正的业务逻辑，然后处理消费结果。\",\"如果消费成功，则更新消费进度。如果消费失败，则需要将失败的消息发回 Broker，一段时间后进行重新消费。\",\"总结一下，推模式并发消费主要的步骤为：\",\"从拉取到的消息保存的处理队列获取消息，封装成消费请求，提交到消费线程池进行并发消费\",\"调用注册的监听器执行消费逻辑\",\"消费结果处理 \",\"消费成功则将这批消息从处理队列中移除，并更新消费进度\",\"消费失败则将失败的消息发回 Broker，利用延迟消息特性，过一段时间将会再次收到这些消息进行消费\"]},\"1180\":{\"h\":\"2.2 重试消费设计\",\"t\":[\"为了保证消息消费的高可靠性，RocketMQ 默认提供了重试消费和死信队列功能。消费失败的消息将会过一段时间后重新消费，每次重新消费的时间间隔将会逐渐增加。当重新消费次数超过最大阈值时，消息将会被放入死信队列，为用户提供了主动处理这些消费多次失败的消息的可能。\",\"重试消费需要在消费结果处理的步骤中进行判断，如果消息消费失败，则将消息发回给 Broker。\",\"Broker 收到请求后用延迟消息机制，用该消息重新消费的次数计算延迟等级，生成一个新消息，将重新消费次数 + 1，作为延迟消息放入消息存储。\",\"延迟到期后该消息将被重新投递到消费者。\",\"初始的延迟为 30s，每次重试消费失败后延迟等级会增加，最后一次延迟 2 小时。如果仍然消费失败，则会被放入死信 Topic。\"]},\"1181\":{\"h\":\"2.3 消费进度管理设计\",\"t\":[\"广播模式下，每个消费者都要消费全量消息，消费者之间不需要共享消费进度，所以消费进度可以存在本地。\",\"集群模式下，多个消费者共同消费一个 Topic，还存在重平衡的可能性，所以需要共享消费进度，这样的话消费进度存在 Broker 端比较好。\",\"RocketMQ 为广播模式和集群模式分别创建了消费进度存储类。\"]},\"1182\":{\"h\":\"2.3.1 广播模式消费进度管理\",\"t\":[\"广播模式的消费者本地存储进度比较简单，它包含一个内存中的消费进度缓存表，用来实时更新。客户端实例启动时会启动定时任务，每 5s 将内存中的消费进度持久化到磁盘。\"]},\"1183\":{\"h\":\"2.3.2 集群模式消费进度管理\",\"t\":[\"集群模式的消费进度管理涉及到消费者端和 Broker 端，每端都有一个消费进度管理器。消费者端仅保存一个消费进度内存缓存表，用来让消费者实时上报消费进度。客户端实例启动时的定时任务每 5s 会让消费者端的管理器向 Broker 端发送持久化请求。\",\"Broker 端也包含一个消费进度内存缓存表，每 5s 会收到消费者端的请求，更新内存缓存表。Broker 启动时也会启动定时任务，每 10s 将消费进度管理器的内存缓存持久化到磁盘。\"]},\"1184\":{\"h\":\"2.3.3 消费者更新消费进度\",\"t\":[\"推模式消费者在处理消费结果的逻辑中，如果消费成功则会更新消费进度。\",\"拉模式消费者则需要用户自行调用消费者的方法触发消费进度更新。\"]},\"1185\":{\"h\":\"3. 详细设计\"},\"1186\":{\"h\":\"3.1 推模式并发消费\"},\"1187\":{\"h\":\"3.1.1 消息消费类设计\",\"t\":[\"由于 RocketMQ 有两种消费方式：并发消费和顺序消费，这两种消费方式的流程又比较类似——都是构建消费请求，提交到消费线程池进行处理。\",\"所以定义了一个消费消息服务接口 ConsumeMessageService，然后并发消费和顺序消费分别实现该接口。\",\"消费消息服务接口定义了\",\"consumeMessageDirectly：直接消费消息的方法，主要用于管理命令触发的消息消费。\",\"submitConsumeRequest：提交消费请求到消费线程池，这个方法用于推模式的消费。\",\"两个消费服务实现中都包含了\",\"consumeRequestQueue：消费请求队列，生产-消费模式用的阻塞队列。\",\"consumeExecutor：消费线程池，默认 20 个线程。并发模式下，表示最多同时消费 20 批消息；顺序模式下，可以同时处理 20 个队列。\",\"messageListener：消息消费监听器，用于注册和执行消息消费的真正逻辑。\",\"顺序消费服务中还包含了消费队列锁。\",\"两个消费服务都实现了\",\"processConsumeResult：消费结果处理方法，处理消费结果。消费成功则更新消费进度；消费失败则将消息发回 Broker 重试消费。\",\"sendMessageBack：将消息发回给 Broker 的方法。\"]},\"1188\":{\"h\":\"3.1.2 推模式并发消费流程\",\"t\":[\"推模式消费逻辑从消息拉取开始\",\"消息拉取到后存入处理队列，然后调用并发消费服务 ConsumeMessageConcurrentlyService 的 submitConsumeRequest 方法将拉取到消息的处理队列提交消费服务处理。\",\"将消息分批打包成消费请求 ConsumeRequest，默认每批 1 条消息\",\"将消费请求提交给消费线程池\",\"消费线程池从阻塞队列 consumeRequestQueue 中不断获取消费请求，执行消费请求的 run 方法执行消费逻辑\",\"先检查处理队列是否被丢弃，被丢弃则放弃消费\",\"检查消息是否含有重试 Topic 属性，如果有则将真正 Topic 从属性中获取，然后复原\",\"执行消费前钩子函数\",\"调用 messageListener 执行真正消费业务逻辑\",\"根据消费状态判定返回结果\",\"执行消费后钩子函数\",\"最后判断一次队列是否被丢弃，如果没有则进行结果处理\",\"执行结果处理函数 processConsumeResult\",\"检查消费成功与否\",\"处理消费失败的消息，如果是广播模式，只打印日志。如果是集群模式，5s 后将消费失败的消息发回 Broker。\",\"更新统计数据\",\"从处理队列中移除这批已经处理过的消息，返回移除这批消息的最小的偏移量\",\"用该偏移量更新消费进度（后面讲解）\",\"如果消费成功，则消费逻辑已经结束。如果消费失败，还需要重试消费，重试消费需要消费者将消费失败的消息发回给 Broker，调用 sendMessageBack 方法\",\"调用消费者 DefaultMQPushConsumerImpl 的 sendMessageBack 方法，先找到 Broker 地址，然后调用 API 发送请求给 Broker。\",\"Broker 由 SendMessageprossor 的 aynscConsumerSendMsgBack 处理重试消息请求\",\"执行消息消费后钩子函数\",\"获取订阅关系\",\"获取或创建重试 Topic，重试 Topic 名称为 %RETRY%{消费组名称}\",\"根据消息发回请求中带的物理偏移量，从消息存储 CommitLog 中查询出发回的消息。可以看出消费者发回消息并没有将整个消息都发回去，也没有这个必要，因为 Broker 端存储着所有的消息。只需要发回偏移量，Broker 就可以通过偏移量查询到这条消息的完整信息。\",\"如果是重试消息且第一次重试，将真正的 Topic 存入属性。因为延迟重试消息依赖延迟消息能力，该消息之后会发送到延迟消息的 Topic 中，所以需要一个地方保存真正的 Topic 信息。\",\"处理消息重新消费次数，\",\"如果大于重新消费次数阈值，则放进死信队列（先获取或创建死信队列）。死信队列名称为 %DLQ%{消费组名称}。\",\"如果在重新消费次数阈值之内，则为其设置延迟等级，延迟指定时间后投递。\",\"创建一个新的消息对象，有新的消息 ID，将它作为重新消费的消息存入消息存储 CommitLog。\",\"为什么已经保存过的消息还要重新建一个并且保存，这样不是很占用存储吗？\",\"由于 RocketMQ 同步消息的基准是 CommitLog，所以即便是已经保存在 CommitLog 的消息，如果要再次消费，也依然需要创建一个新的消息保存到 CommitLog 中。这样 CommitLog 会被同步到从 Broker 节点，从 Broker 节点也会收到该重试消息。\",\"新创建的重试消息是定时消息，它的 Topic 是定时消息 Topic，定时消息的机制会不停扫描定时消息 Topic 中的队列，看该消息是否到期，如果到期则投递。定时消息更详细的原理可以看这篇文章。该消息投递之后消费者会收到并重试消费\"]},\"1189\":{\"h\":\"3.2 消费进度管理\"},\"1190\":{\"h\":\"3.2.1 消费进度管理类设计\",\"t\":[\"消费者端，实现了 OffsetStore 接口，定义了更新、查询和持久化消费进度的方法。\",\"有两个实现类，这里都使用了内存缓存，定时持久化的设计方法。保存一个缓存表 offsetTable，用来快速更新和查询。\",\"LocalFileOffsetStore ：消费者本地进度存储，持久化时保存到消费者本地\",\"RemoteBrokerOffset：Broker 端存储，持久化时先保存到本地缓存，然后发送请求给 Broker，保存到 Broker 缓存。Broker 再定时持久化\",\"Broker 端也有一个对应的消费进度管理器 ConsumerOffsetManager，同样也是缓存 + 定时持久化的设计。\",\"它扩展了 ConfigManager，ConfigManager 是用来管理配置的，它定义了持久化和加载的接口。\",\"ConsumerOffsetManager 负责接收消费者的消费进度更新请求，然后定时持久化到磁盘。\"]},\"1191\":{\"h\":\"3.2.2 消费进度更新流程\",\"t\":[\"这里讲解集群模式下消费进度的更新流程\",\"每个消费者都会有一个消费进度管理器 RemoteBrokerOffsetStore，在消费者启动时创建。\",\"Broker 端也有一个消费进度管理器 ConsumerOffsetManager，在 Broker 启动时创建。\",\"这两个消费进度管理器都保存一个消费进度缓存表 offsetStore 在内存中，用于快速更新和查询。Broker 端消费进度管理器会定时将消费进度表持久化到磁盘。\",\"客户端实例 MQClientInstance 启动时，创建定时任务，每 5s 触发消费进度管理器的持久化方法。\",\"消费流程最后，如果消费请求被消费成功，将会调用 RemoteBrokerOffsetStore 的 updateOffset 方法，更新消费进度缓存\",\"persistAll() 方法会遍历消费进度缓存表 offsetStore，为每个消息队列都向 Broker 发送消费进度更新和持久化的请求。\",\"updateConsumeOffsetToBroker 构造一个消息队列的消费进度更新请求，发送给 Broker\",\"Broker 的 ConsumerManagerProcess 处理请求，调用 updateConsumerOffset 方法，让消费进度管理器更新消费进度\",\"消费进度管理器的 commitOffset 方法将消费进度更新到其内存缓存表 offsetStore\",\"BrokerController 启动时启动定时任务，每 10s 调用 ConsumerOffsetManager 的 persist() 方法，持久化消费进度\"]},\"1192\":{\"h\":\"4. 源码解析\"},\"1193\":{\"h\":\"4.1 推模式并发消费\"},\"1194\":{\"h\":\"4.1.1 并发消费服务提交消费请求\",\"t\":[\"// ConsumeMessageConcurrentlyService.java /** * 构造消费请求（多批）并提交，拉取到消息之后调用 * * @param msgs 每次拉取到的消息 * @param processQueue 消息处理队列 * @param messageQueue 消息队列 * @param dispatchToConsume */ @Override public void submitConsumeRequest( final List<MessageExt> msgs, final ProcessQueue processQueue, final MessageQueue messageQueue, final boolean dispatchToConsume) { // 每批次消费消息数量，默认为 1 final int consumeBatchSize = this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize(); if (msgs.size() <= consumeBatchSize) { // 拉取的一批消息总数小于每批次可以消费的消息数，直接将所有拉取的消息构造成一个消费请求并提交 ConsumeRequest consumeRequest = new ConsumeRequest(msgs, processQueue, messageQueue); try { this.consumeExecutor.submit(consumeRequest); } catch (RejectedExecutionException e) { // 拒绝提交，延迟 5s 再提交 this.submitConsumeRequestLater(consumeRequest); } } else { // 如果这批消息数量大于每批次可以消费的消息，那么进行分页。每页包装可消费消息数量（1条）消息，构造多个消费请求提交消费 for (int total = 0; total < msgs.size(); ) { List<MessageExt> msgThis = new ArrayList<MessageExt>(consumeBatchSize); for (int i = 0; i < consumeBatchSize; i++, total++) { if (total < msgs.size()) { msgThis.add(msgs.get(total)); } else { break; } } ConsumeRequest consumeRequest = new ConsumeRequest(msgThis, processQueue, messageQueue); try { // 提交给消费线程池消费 this.consumeExecutor.submit(consumeRequest); } catch (RejectedExecutionException e) { // 拒绝提交，延迟 5s 后再提交 for (; total < msgs.size(); total++) { msgThis.add(msgs.get(total)); } this.submitConsumeRequestLater(consumeRequest); } } } } \"]},\"1195\":{\"h\":\"4.1.2 消费请求运行、处理结果\",\"t\":[\"// ConsumeMessageConcurrentlyService.java /** * 消费请求运行，执行消费逻辑 */ @Override public void run() { // 检查 processQueue 是否丢弃，重平衡时可能将队列分配给组内其他消费者会设置。如果丢弃，停止消费 if (this.processQueue.isDropped()) { log.info(\\\"the message queue not be able to consume, because it's dropped. group={} {}\\\", ConsumeMessageConcurrentlyService.this.consumerGroup, this.messageQueue); return; } MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.this.messageListener; ConsumeConcurrentlyContext context = new ConsumeConcurrentlyContext(messageQueue); ConsumeConcurrentlyStatus status = null; // 恢复重试消息的主题名 defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, defaultMQPushConsumer.getConsumerGroup()); // 执行消费前钩子函数 ConsumeMessageContext consumeMessageContext = null; if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) { consumeMessageContext = new ConsumeMessageContext(); consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace()); consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup()); consumeMessageContext.setProps(new HashMap<String, String>()); consumeMessageContext.setMq(messageQueue); consumeMessageContext.setMsgList(msgs); consumeMessageContext.setSuccess(false); ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext); } // 执行具体消费逻辑 long beginTimestamp = System.currentTimeMillis(); boolean hasException = false; ConsumeReturnType returnType = ConsumeReturnType.SUCCESS; try { // 设置消费开始时间戳 if (msgs != null && !msgs.isEmpty()) { for (MessageExt msg : msgs) { MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis())); } } // 消费逻辑，消息调用监听器的方法进行消费 status = listener.consumeMessage(Collections.unmodifiableList(msgs), context); } catch (Throwable e) { log.warn(String.format(\\\"consumeMessage exception: %s Group: %s Msgs: %s MQ: %s\\\", RemotingHelper.exceptionSimpleDesc(e), ConsumeMessageConcurrentlyService.this.consumerGroup, msgs, messageQueue), e); hasException = true; } long consumeRT = System.currentTimeMillis() - beginTimestamp; // 判断消费结果 if (null == status) { if (hasException) { returnType = ConsumeReturnType.EXCEPTION; } else { returnType = ConsumeReturnType.RETURNNULL; } } else if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) { returnType = ConsumeReturnType.TIME_OUT; } else if (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) { // 消费失败，需要重试 returnType = ConsumeReturnType.FAILED; } else if (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) { // 消费成功 returnType = ConsumeReturnType.SUCCESS; } if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) { consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name()); } if (null == status) { log.warn(\\\"consumeMessage return null, Group: {} Msgs: {} MQ: {}\\\", ConsumeMessageConcurrentlyService.this.consumerGroup, msgs, messageQueue); status = ConsumeConcurrentlyStatus.RECONSUME_LATER; } // 执行消费后钩子函数 if (ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.hasHook()) { consumeMessageContext.setStatus(status.toString()); consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status); ConsumeMessageConcurrentlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext); } ConsumeMessageConcurrentlyService.this.getConsumerStatsManager() .incConsumeRT(ConsumeMessageConcurrentlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT); // 消费后，验证队列是否丢弃，如果丢弃则不处理结果，此时其他消费者会重新消费该消息 if (!processQueue.isDropped()) { // 处理消费结果，成功则更新统计数据；失败则重试，将消息发回 Broker，延迟一段时间后再次进行消费 ConsumeMessageConcurrentlyService.this.processConsumeResult(status, context, this); } else { log.warn(\\\"processQueue is dropped without process consume result. messageQueue={}, msgs={}\\\", messageQueue, msgs); } } \",\"// ConsumeMessageConcurrentlyService.java /** * 处理消费结果 * * @param status 消费状态，成功或失败 * @param context 消费上下文信息 * @param consumeRequest 消费请求 */ public void processConsumeResult( final ConsumeConcurrentlyStatus status, final ConsumeConcurrentlyContext context, final ConsumeRequest consumeRequest ) { // 用来标记消费成功失败的位置，默认为 Integer.MAX_VALUE，表示拉取的一批消息都消费成功 // 消费时可以通过设置 context 的 ackIndex 来标记哪些消息成功了，哪些失败了 // ackIndex 位置之前的消息都是消费成功的，index 大于 ackIndex 的后面的数据都是处理失败的 int ackIndex = context.getAckIndex(); // 如果没有消息则不处理 if (consumeRequest.getMsgs().isEmpty()) return; // 消费状态判断和处理 switch (status) { case CONSUME_SUCCESS: // 消费成功，设置 ackIndex 为 size - 1（消费成功的消息数量的 index，为下面失败处理逻辑使用） if (ackIndex >= consumeRequest.getMsgs().size()) { ackIndex = consumeRequest.getMsgs().size() - 1; } // 成功数量 int ok = ackIndex + 1; // 失败数量 int failed = consumeRequest.getMsgs().size() - ok; // 更新统计数据 this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok); this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed); break; case RECONSUME_LATER: // 消费失败，ackIndex 设为 -1，为下面的失败处理逻辑使用 ackIndex = -1; // 消费失败统计数据更新 this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), consumeRequest.getMsgs().size()); break; default: break; } // 处理消费失败的消息 switch (this.defaultMQPushConsumer.getMessageModel()) { case BROADCASTING: // 广播模式，对消费失败的消息不会重复消费，只会打印警告日志，输出消息内容 // ackIndex 后面的 index 都是消费失败的 for (int i = ackIndex + 1; i < consumeRequest.getMsgs().size(); i++) { MessageExt msg = consumeRequest.getMsgs().get(i); log.warn(\\\"BROADCASTING, the message consume failed, drop it, {}\\\", msg.toString()); } break; case CLUSTERING: List<MessageExt> msgBackFailed = new ArrayList<MessageExt>(consumeRequest.getMsgs().size()); // 集群模式，处理消费失败的消息。将消费失败的消息发回 Broker // ackIndex 后面的消息（index 大于 ackIndex）都是消费失败的 for (int i = ackIndex + 1; i < consumeRequest.getMsgs().size(); i++) { MessageExt msg = consumeRequest.getMsgs().get(i); // 将消息发回 Broker boolean result = this.sendMessageBack(msg, context); if (!result) { // 如果发回失败，加入失败列表 msg.setReconsumeTimes(msg.getReconsumeTimes() + 1); msgBackFailed.add(msg); } } // 5 秒后重新消费发回失败的消息 if (!msgBackFailed.isEmpty()) { consumeRequest.getMsgs().removeAll(msgBackFailed); this.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue()); } break; default: break; } // 从 ProcessQueue 中移除这批已经处理过的消息 long offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs()); if (offset >= 0 && !consumeRequest.getProcessQueue().isDropped()) { // 更新消费进度 this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, true); } } \"]},\"1196\":{\"h\":\"4.2 重试消费\"},\"1197\":{\"h\":\"4.2.1 消费者消费失败，将消息发回 Broker\",\"t\":[\"// ConsumeMessageConcurrentlyService.java /** * 把消费失败的消息发回 Broker * * @param msg * @param context * @return */ public boolean sendMessageBack(final MessageExt msg, final ConsumeConcurrentlyContext context) { // 获取延迟等级，默认为 0，表示由 Broker 端控制延迟等级 // Broker 端将延迟等级设置为重试消费次数 + 3 int delayLevel = context.getDelayLevelWhenNextConsume(); // Wrap topic with namespace before sending back message. msg.setTopic(this.defaultMQPushConsumer.withNamespace(msg.getTopic())); try { this.defaultMQPushConsumerImpl.sendMessageBack(msg, delayLevel, context.getMessageQueue().getBrokerName()); return true; } catch (Exception e) { log.error(\\\"sendMessageBack exception, group: \\\" + this.consumerGroup + \\\" msg: \\\" + msg.toString(), e); } return false; } \",\"// DefaultMQPushConsumerImpl.java /** * 把消费失败的消息发回 Broker * * @param msg * @param delayLevel * @param brokerName * @throws RemotingException * @throws MQBrokerException * @throws InterruptedException * @throws MQClientException */ public void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName) throws RemotingException, MQBrokerException, InterruptedException, MQClientException { try { // 查找 Broker 地址，如果知道 Broker 名称，根据名称查询主节点地址；否则使用消息存储的地 host 为 Broker 地址 String brokerAddr = (null != brokerName) ? this.mQClientFactory.findBrokerAddressInPublish(brokerName) : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost()); this.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg, this.defaultMQPushConsumer.getConsumerGroup(), delayLevel, 5000, getMaxReconsumeTimes()); } catch (Exception e) { // 发回 Broker 失败，将消息发送回重试 Topic 中，设置延迟等级，等待重新消费 log.error(\\\"sendMessageBack Exception, \\\" + this.defaultMQPushConsumer.getConsumerGroup(), e); Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody()); String originMsgId = MessageAccessor.getOriginMessageId(msg); MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId); newMsg.setFlag(msg.getFlag()); MessageAccessor.setProperties(newMsg, msg.getProperties()); MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic()); // 重新消费次数 +1 MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + 1)); MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes())); MessageAccessor.clearProperty(newMsg, MessageConst.PROPERTY_TRANSACTION_PREPARED); newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes()); this.mQClientFactory.getDefaultMQProducer().send(newMsg); } finally { msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace())); } } \"]},\"1198\":{\"h\":\"4.2.2 Broker 端处理客户端发回的消息\",\"t\":[\"// SendMessageProcessor.java /** * Broker 处理消费者消费失败发回的消息 * * @param ctx * @param request * @return * @throws RemotingCommandException */ private CompletableFuture<RemotingCommand> asyncConsumerSendMsgBack(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException { final RemotingCommand response = RemotingCommand.createResponseCommand(null); final ConsumerSendMsgBackRequestHeader requestHeader = (ConsumerSendMsgBackRequestHeader)request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class); String namespace = NamespaceUtil.getNamespaceFromResource(requestHeader.getGroup()); // 消息轨迹：记录消费失败的消息 if (this.hasConsumeMessageHook() && !UtilAll.isBlank(requestHeader.getOriginMsgId())) { ConsumeMessageContext context = buildConsumeMessageContext(namespace, requestHeader, request); this.executeConsumeMessageHookAfter(context); } // 获取消费组的订阅配置 SubscriptionGroupConfig subscriptionGroupConfig = this.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup()); if (null == subscriptionGroupConfig) { // 订阅配置不存在，返回错误 response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST); response.setRemark(\\\"subscription group not exist, \\\" + requestHeader.getGroup() + \\\" \\\" + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST)); return CompletableFuture.completedFuture(response); } if (!PermName.isWriteable(this.brokerController.getBrokerConfig().getBrokerPermission())) { // Broker 不可写 response.setCode(ResponseCode.NO_PERMISSION); response.setRemark(\\\"the broker[\\\" + this.brokerController.getBrokerConfig().getBrokerIP1() + \\\"] sending message is forbidden\\\"); return CompletableFuture.completedFuture(response); } // 如果重试队列数量为 0，说明该消费组不支持重试，返回成功并丢弃消息 if (subscriptionGroupConfig.getRetryQueueNums() <= 0) { response.setCode(ResponseCode.SUCCESS); response.setRemark(null); return CompletableFuture.completedFuture(response); } String newTopic = MixAll.getRetryTopic(requestHeader.getGroup()); int queueIdInt = ThreadLocalRandom.current().nextInt(99999999) % subscriptionGroupConfig.getRetryQueueNums(); // 如果是单元化模式，对 Topic 进行设置 int topicSysFlag = 0; if (requestHeader.isUnitMode()) { topicSysFlag = TopicSysFlag.buildSysFlag(false, true); } // 创建重试主题 %RETRY%{消费组名称}，构建主题配置 TopicConfig topicConfig = this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod( newTopic, subscriptionGroupConfig.getRetryQueueNums(), PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag); // 检查 Topic 是否存在 if (null == topicConfig) { response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(\\\"topic[\\\" + newTopic + \\\"] not exist\\\"); return CompletableFuture.completedFuture(response); } // 检查 Topic 权限 if (!PermName.isWriteable(topicConfig.getPerm())) { response.setCode(ResponseCode.NO_PERMISSION); response.setRemark(String.format(\\\"the topic[%s] sending message is forbidden\\\", newTopic)); return CompletableFuture.completedFuture(response); } // 根据偏移量从 CommitLog 查询发回的消息 MessageExt msgExt = this.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset()); if (null == msgExt) { response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(\\\"look message by offset failed, \\\" + requestHeader.getOffset()); return CompletableFuture.completedFuture(response); } // 如果消息之前没有重新消费过，将消息的真正 Topic 存入属性，因为 Topic 之后会被重试 Topic 覆盖 final String retryTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC); if (null == retryTopic) { MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic()); } msgExt.setWaitStoreMsgOK(false); // 客户端自动决定延迟等级 int delayLevel = requestHeader.getDelayLevel(); int maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes(); if (request.getVersion() >= MQVersion.Version.V3_4_9.ordinal()) { Integer times = requestHeader.getMaxReconsumeTimes(); if (times != null) { maxReconsumeTimes = times; } } // 死信消息处理，如果 > 0，表示由客户端控制重试次数 // 如果重试次数超过 maxReconsumeTimes，或者小于 0，会放入死信队列。改变 Topic 为 %DLQ%{消费者组} if (msgExt.getReconsumeTimes() >= maxReconsumeTimes || delayLevel < 0) { newTopic = MixAll.getDLQTopic(requestHeader.getGroup()); queueIdInt = ThreadLocalRandom.current().nextInt(99999999) % DLQ_NUMS_PER_GROUP; topicConfig = this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, DLQ_NUMS_PER_GROUP, PermName.PERM_WRITE | PermName.PERM_READ, 0); if (null == topicConfig) { response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(\\\"topic[\\\" + newTopic + \\\"] not exist\\\"); return CompletableFuture.completedFuture(response); } msgExt.setDelayTimeLevel(0); } else { // 如果是 0，表示由 Broker 端控制延迟时间，将延迟等级设置为：重新消费次数 + 3 if (0 == delayLevel) { delayLevel = 3 + msgExt.getReconsumeTimes(); } msgExt.setDelayTimeLevel(delayLevel); } // 创建一个新的消息对象，作为重试消息，它有新的消息 ID MessageExtBrokerInner msgInner = new MessageExtBrokerInner(); msgInner.setTopic(newTopic); msgInner.setBody(msgExt.getBody()); msgInner.setFlag(msgExt.getFlag()); MessageAccessor.setProperties(msgInner, msgExt.getProperties()); msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties())); msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(null, msgExt.getTags())); msgInner.setQueueId(queueIdInt); msgInner.setSysFlag(msgExt.getSysFlag()); msgInner.setBornTimestamp(msgExt.getBornTimestamp()); msgInner.setBornHost(msgExt.getBornHost()); msgInner.setStoreHost(msgExt.getStoreHost()); // 重新消费次数 +1，下次重新消费的延迟等级根据该值来确定 msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + 1); // 保存源消息的 ID String originMsgId = MessageAccessor.getOriginMessageId(msgExt); MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId); msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties())); // 存入 CommitLog CompletableFuture<PutMessageResult> putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner); // 存入之后统计数据并返回结果 return putMessageResult.thenApply((r) -> { if (r != null) { switch (r.getPutMessageStatus()) { case PUT_OK: String backTopic = msgExt.getTopic(); String correctTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC); if (correctTopic != null) { backTopic = correctTopic; } if (TopicValidator.RMQ_SYS_SCHEDULE_TOPIC.equals(msgInner.getTopic())) { this.brokerController.getBrokerStatsManager().incTopicPutNums(msgInner.getTopic()); this.brokerController.getBrokerStatsManager().incTopicPutSize(msgInner.getTopic(), r.getAppendMessageResult().getWroteBytes()); this.brokerController.getBrokerStatsManager().incQueuePutNums(msgInner.getTopic(), msgInner.getQueueId()); this.brokerController.getBrokerStatsManager().incQueuePutSize(msgInner.getTopic(), msgInner.getQueueId(), r.getAppendMessageResult().getWroteBytes()); } this.brokerController.getBrokerStatsManager().incSendBackNums(requestHeader.getGroup(), backTopic); response.setCode(ResponseCode.SUCCESS); response.setRemark(null); return response; default: break; } response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(r.getPutMessageStatus().name()); return response; } response.setCode(ResponseCode.SYSTEM_ERROR); response.setRemark(\\\"putMessageResult is null\\\"); return response; }); } \"]},\"1199\":{\"h\":\"4.3 消费进度管理\"},\"1200\":{\"h\":\"4.3.1 客户端消费进度管理器持久化消费进度\",\"t\":[\"// RemoteBrokerOffsetStore.java /** * 持久化消费进度 * 发送请求给 Broker，让 Broker 持久化消费进度到磁盘 * * @param mqs */ @Override public void persistAll(Set<MessageQueue> mqs) { if (null == mqs || mqs.isEmpty()) return; final HashSet<MessageQueue> unusedMQ = new HashSet<MessageQueue>(); // 遍历所有缓存的消息队列，为每隔队列发送持久化消费进度请求给 Broker for (Map.Entry<MessageQueue, AtomicLong> entry : this.offsetTable.entrySet()) { MessageQueue mq = entry.getKey(); AtomicLong offset = entry.getValue(); if (offset != null) { if (mqs.contains(mq)) { try { this.updateConsumeOffsetToBroker(mq, offset.get()); log.info(\\\"[persistAll] Group: {} ClientId: {} updateConsumeOffsetToBroker {} {}\\\", this.groupName, this.mQClientFactory.getClientId(), mq, offset.get()); } catch (Exception e) { log.error(\\\"updateConsumeOffsetToBroker exception, \\\" + mq.toString(), e); } } else { unusedMQ.add(mq); } } } if (!unusedMQ.isEmpty()) { for (MessageQueue mq : unusedMQ) { this.offsetTable.remove(mq); log.info(\\\"remove unused mq, {}, {}\\\", mq, this.groupName); } } } \",\"// RemoteBrokerOffsetStore.java /** * Update the Consumer Offset synchronously, once the Master is off, updated to Slave, here need to be optimized. * 发送 UPDATE_CONSUMER_OFFSET 请求到 Broker，让 Broker 持久化消费进度 */ @Override public void updateConsumeOffsetToBroker(MessageQueue mq, long offset, boolean isOneway) throws RemotingException, MQBrokerException, InterruptedException, MQClientException { // 获取 Broker 地址 FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true); if (null == findBrokerResult) { this.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic()); findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, false); } if (findBrokerResult != null) { UpdateConsumerOffsetRequestHeader requestHeader = new UpdateConsumerOffsetRequestHeader(); requestHeader.setTopic(mq.getTopic()); requestHeader.setConsumerGroup(this.groupName); requestHeader.setQueueId(mq.getQueueId()); requestHeader.setCommitOffset(offset); // 向 Broker 发送请求，持久化消费进度 if (isOneway) { this.mQClientFactory.getMQClientAPIImpl().updateConsumerOffsetOneway( findBrokerResult.getBrokerAddr(), requestHeader, 1000 * 5); } else { this.mQClientFactory.getMQClientAPIImpl().updateConsumerOffset( findBrokerResult.getBrokerAddr(), requestHeader, 1000 * 5); } } else { throw new MQClientException(\\\"The broker[\\\" + mq.getBrokerName() + \\\"] not exist\\\", null); } } \"]},\"1201\":{\"h\":\"4.3.2 Broker 端消费进度管理器\",\"t\":[\"收到客户端发来的持久化消费进度请求，将消费进度缓存\",\"/** * 持久化消费进度 * * @param clientHost * @param group * @param topic * @param queueId * @param offset */ public void commitOffset(final String clientHost, final String group, final String topic, final int queueId, final long offset) { // topic@group String key = topic + TOPIC_GROUP_SEPARATOR + group; this.commitOffset(clientHost, key, queueId, offset); } /** * 持久化消费进度，将消费进度保存到缓存表 * * @param clientHost * @param key * @param queueId * @param offset */ private void commitOffset(final String clientHost, final String key, final int queueId, final long offset) { ConcurrentMap<Integer, Long> map = this.offsetTable.get(key); if (null == map) { map = new ConcurrentHashMap<Integer, Long>(32); map.put(queueId, offset); this.offsetTable.put(key, map); } else { Long storeOffset = map.put(queueId, offset); if (storeOffset != null && offset < storeOffset) { log.warn(\\\"[NOTIFYME]update consumer offset less than store. clientHost={}, key={}, queueId={}, requestOffset={}, storeOffset={}\\\", clientHost, key, queueId, offset, storeOffset); } } } \",\"定时持久化消费进度\",\"// BrokerController#initialize() // 每 10s 持久化消费进度到磁盘 this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { @Override public void run() { try { BrokerController.this.consumerOffsetManager.persist(); } catch (Throwable e) { log.error(\\\"schedule persist consumerOffset error.\\\", e); } } }, 1000 * 10, this.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS); \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1202\":{\"h\":\"RocketMQ 消费者（6）顺序消费 流程详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20220929-rocketmq-consumer-6-consume-orderly.html\"]},\"1203\":{\"h\":\"1. 背景\",\"t\":[\"本文是 RocketMQ 消费者系列的第六篇，上一篇主要介绍并发消费，而本片主要介绍 RocketMQ 顺序消费的设计和流程。\",\"我把 RocketMQ 消费分成如下几个步骤\",\"重平衡\",\"消费者拉取消息\",\"Broker 接收拉取请求后从存储中查询消息并返回\",\"消费者消费消息\",\"顺序消息逻辑主要在步骤 4 当中承载，然而为了能够实现顺序的消费，在步骤 1 和 2 中就需要有相应的操作以锁定消费队列，确保顺序消费。\",\"RocketMQ 支持 2 种消费方式，即并发消费和顺序消费。\",\"并发消费是比较常用的一种消费方式。并发有两层含义：\",\"队列间并发消费：一个 Topic 可以有 N 个队列，每个队列都可以被一个消费者消费，最多可以有 N 个消费者同时进行消费\",\"队列中的多个消息并发消费：消费者执行消费逻辑时，使用一个消费线程池进行消费，该线程池默认有 20 个线程同时进行消费，所以也有可能并发消费一个队列中的多个消息\",\"由于 RocketMQ 的 Topic 和队列的设计，让同一 Topic 下的并发消费无法避免，因为只要有多个队列让多个消费者同时消费，就必定存在并发消费。所以 RocketMQ 仅支持单个队列中的消息的顺序消费。\",\"如果要做到 Topic 维度严格的顺序，那么需要将 Topic 的队列数设为 1。\"]},\"1204\":{\"h\":\"2. 概要设计\",\"t\":[\"顺序消费的设计的要点主要有两个：\",\"保证消费速度，即消费线程池同时消费多个队列的消息。\",\"保证顺序性，即一个队列同一时间只能被一个消费者的一个线程消费。\",\"第一点可以在并发消费的基础上修改消费线程池的逻辑，第二点需要用到多个锁来保证。\"]},\"1205\":{\"h\":\"2.1 消费线程池逻辑\"},\"1206\":{\"h\":\"2.1.1 消费线程池顺序消费\",\"t\":[\"并发消费的消费线程池，每个线程的消费任务是：消费一批（默认一条）消息。消费任务由拉取任务提交，存在同时运行的多个任务都是消费同一个队列的可能。\",\"顺序消费的消费任务也由拉取任务提交，逻辑改成了：持续消费一个队列的消息，直到该队列的消息消费完或者超过最大消费时间（1分钟）。这样可以保证每个队列最多被一个消费线程处理，每个消费线程也最大程度上被使用。1 分钟的超时时间是为了防止某个队列消息过多或消费过慢，让其他队列也有被消费到的机会。\"]},\"1207\":{\"h\":\"2.1.2 保证一个队列同时仅被一个消费线程消费\",\"t\":[\"在上述逻辑的基础上，可能存在同时有多个同一队列的消费任务被提交到消费线程池的情况，需要保证一个队列最多仅被一个线程消费。\",\"RocketMQ 为每个消息队列都初始化一把锁（消息队列锁），消费任务开始时获取锁，消费任务结束时释放锁，保证就算有多个线程同时消费一个队列，但同时最多只有一个线程真正在执行消费（其他线程都在等待锁释放）。\",\"这个实现可能导致消费线程池中多个线程同时等待一把锁，似乎是一个可以优化的点。比如通过修改消息拉取线程， 保证该队列消费完之前不拉取新的消息（拉取消息前判断该队列的消息是否被消费完，如果未被消费完则跳过拉取操作，将该拉取请求放入拉取队列末尾）\"]},\"1208\":{\"h\":\"2.2 重平衡时顺序消费\",\"t\":[\"消费任务中添加的消息队列锁保证了同一消费者中的顺序消费，但保证消费线程池顺序消费就可以实现顺序消费了吗？NO。顺序消费还有一个敌人——重平衡。\",\"重平衡可能会将一个队列的消费负载从一个消费者切换到另一个消费者。老消费者的消费任务可能还没有结束，新消费者开始消费，这样也存在两个消费者同时消费一个队列的情况。\"]},\"1209\":{\"h\":\"2.2.1 Broker 管理的分布式锁\",\"t\":[\"为了跨消费者进行消费队列负载的协调，引入分布式锁是最好的选择，RocketMQ 让 Broker 来管理和保存该锁，我们姑且把这个锁叫做 Broker锁。\",\"消费者在重平衡后，对于新分配到的队列，会尝试向 Broker 请求 Broker锁 ；丢弃的队列则向 Broker 释放锁。如果请求到锁才开始拉取，请求不到则等到下次重平衡再次请求。\",\"Broker锁 在 Broker 端被设了过期时间，1 分钟不更新则过期。顺序消费服务的定时任务会每 20s 向 Broker 发送请求，请求和更新自己负载的消费队列的 Broker锁。\",\"在消息拉取和顺序消费服务每消费一批消息前，都会判断是否持有 Broker锁，来保证没有多个消费者在重平衡后同时消费一个队列。\",\"还有一个消费锁，用来保证在有消息正在被顺序消费时，不能释放 Broker锁。\"]},\"1210\":{\"h\":\"3. 详细设计\"},\"1211\":{\"h\":\"3.1 Broker锁\"},\"1212\":{\"h\":\"3.1.1 设计\",\"t\":[\"Broker锁 是在 Broker 上保存和管理的分布式锁，它的存在是为了解决重平衡后可能的不同消费者并行消费问题。由 Broker 端的 RebalanceLockManager 管理。\",\"每个消息队列都可能会有一个锁，每个消费组的消费应该隔离，所以每个消费组都有一组锁。锁的容器是两层 Map：\",\"ConcurrentMap<String/* group */, ConcurrentHashMap<MessageQueue, LockEntry/* client ID & update timestamp */>> mqLockTable \",\"为了避免一些异常情况，如消费者异常退出，没有主动解锁，导致队列一直上锁，这里为 Broker锁 设置了超时时间（默认 1 分钟）。\",\"由消费者向 Broker 发请求进行加解锁、查询是否加锁等操作。\"]},\"1213\":{\"h\":\"3.1.2 加解锁时机\",\"t\":[\"消费者重平衡后，调用 updateProcessQueueTableInRebalance，如上图粉色部分所示。\",\"对于要丢弃的队列，尝试释放 Broker锁；对于对分配到的队列尝试请求 Broker锁。\"]},\"1214\":{\"h\":\"3.1.3 加解锁流程\",\"t\":[\"加锁的过程是向 Broker 发请求，锁管理器将锁创建后放入锁容器 mqLockTable 并更新加锁时间；解锁则是将 LockEntry 从锁容器中移除。\",\"上图展示了加锁流程：\",\"重平衡后更新处理队列，尝试加锁（或者更新现有锁），向 Broker 发请求\",\"MQClientAPIImpl 中准备锁定请求，调用 NettyRemotingClient 向 Broker 发送请求\",\"Broker 端 AdminBrokerProcessor 处理加锁请求\",\"RebalanceLockManager 最终处理加锁逻辑，先获取锁容器的改动锁。然后为没有加锁的队列新建 LockEntry，为已有的 LockEntry 更新加锁时间和客户端 ID。最后释放锁容器的锁。\"]},\"1215\":{\"h\":\"3.1.4 边界条件：消费消息时重平衡\",\"t\":[\"存在一种边界条件，消费消息耗时较长的情况下，可能存在重平衡后要释放某个队列的 Broker锁，但是这个队列仍有消息正在被消费。\",\"这种情况下不能贸然释放 Broker锁，因为如果释放，其他消费者会获取 Broker锁并开始消费，可能会重复且并发地消费那批没有消费完的消息，这里就存在并发问题。\",\"RocketMQ 的做法是如果队列有消息正被消费，则不会释放它的 Broker锁，等到下一次重平衡（默认 20s 周期）再判断是否可以释放。\",\"具体的做法是引入一个新的锁 消费锁，一批消息消费时加锁，消费完后解锁。\",\"重平衡后尝试释放 Broker锁 前，先试着获取 消费锁，如果 1s 内获取不到，则跳过。\"]},\"1216\":{\"h\":\"3.2 消费线程池顺序消费逻辑\"},\"1217\":{\"h\":\"3.2.1 消费线程池顺序消费设计\",\"t\":[\"每个消费者都有一个消费线程池（默认 20 个线程）来处理消息拉取任务拉取成功后提交的消费任务。\",\"消息拉取任务将拉取到的消息都放到消息队列对应的处理队列中，然后将处理队列整个放入消费任务，提交给消费线程池。\",\"每个消费任务都持续消费一个队列，直到消费时间到期（1 分钟）或者处理队列中消息消费完。\",\"为了保证消费线程池中没有多个线程消费同一个队列，为每个消费队列初始化消费队列锁（MQ Lock），并在消费任务执行时加锁\"]},\"1218\":{\"h\":\"3.2.2 消费线程池顺序消费任务流程\",\"t\":[\"检查处理队列是否丢弃（是否仍由该消费者负载该队列）\",\"获取消费队列锁（保证消费线程池中消费这个队列的最多只有一个线程）\",\"保证处理队列的 Broker锁 已经获取且未过期\",\"从处理队列中取一批消息（默认 1 条）\",\"对于重试消息，从消息属性中获取它真正的 Topic 并恢复\",\"执行消费前钩子函数\",\"加 消费锁，执行消费逻辑，释放 消费锁\",\"根据消费结果设置返回状态\",\"执行消费后钩子函数\",\"处理这批消息的消费结果 \",\"检查消费结果\",\"如果消费失败，广播模式：打印错误日志；集群模式：将消息发回 Broker，等待重新消费\",\"将消息从处理队列移除\",\"提交消费进度\"]},\"1219\":{\"h\":\"3.3 顺序消费流程\",\"t\":[\"消费流程以重平衡为起点。重平衡后向 Broker 发送请求，释放和申请 Broker锁\",\"为该消费者负载的队列新建消息拉取请求，进行消息拉取\",\"pullMessage：拉取前再次判断队列 Broker锁 的状态。消息拉取线程从拉取任务队列中获取任务并执行拉取\",\"拉取成功后的 PullCallback 将拉取到的消息放入处理队列，然后给顺序消费服务提交顺序消费任务\",\"顺序消费服务的消费线程池执行消费任务，执行逻辑上面讲过\"]},\"1220\":{\"h\":\"4. 源码解析\"},\"1221\":{\"h\":\"4.1 Broker锁\"},\"1222\":{\"h\":\"4.1.1 Broker锁 管理器\",\"t\":[\"public class RebalanceLockManager { // 锁容器读写锁 private final Lock lock = new ReentrantLock(); // 消息队列锁定状态表 private final ConcurrentMap<String/* group */, ConcurrentHashMap<MessageQueue, LockEntry>> mqLockTable = new ConcurrentHashMap<String, ConcurrentHashMap<MessageQueue, LockEntry>>(1024); /** * 批量锁定消息队列 * * @param group 消费组 * @param mqs 要锁定的消息队列 * @param clientId 客户端 ID * @return 锁定成功的消息队列 */ public Set<MessageQueue> tryLockBatch(final String group, final Set<MessageQueue> mqs, final String clientId) { // 要锁定的队列中已经锁定的队列 Set<MessageQueue> lockedMqs = new HashSet<MessageQueue>(mqs.size()); // 之前没有锁定，需要锁定的队列 Set<MessageQueue> notLockedMqs = new HashSet<MessageQueue>(mqs.size()); for (MessageQueue mq : mqs) { if (this.isLocked(group, mq, clientId)) { lockedMqs.add(mq); } else { notLockedMqs.add(mq); } } // 锁定需要锁定的队列 if (!notLockedMqs.isEmpty()) { try { this.lock.lockInterruptibly(); try { ConcurrentHashMap<MessageQueue, LockEntry> groupValue = this.mqLockTable.get(group); if (null == groupValue) { groupValue = new ConcurrentHashMap<>(32); this.mqLockTable.put(group, groupValue); } for (MessageQueue mq : notLockedMqs) { // 为队列新建锁定标识，加入锁定状态表 LockEntry lockEntry = groupValue.get(mq); if (null == lockEntry) { lockEntry = new LockEntry(); lockEntry.setClientId(clientId); groupValue.put(mq, lockEntry); } if (lockEntry.isLocked(clientId)) { lockEntry.setLastUpdateTimestamp(System.currentTimeMillis()); lockedMqs.add(mq); continue; } String oldClientId = lockEntry.getClientId(); if (lockEntry.isExpired()) { lockEntry.setClientId(clientId); lockEntry.setLastUpdateTimestamp(System.currentTimeMillis()); lockedMqs.add(mq); continue; } } } finally { this.lock.unlock(); } } catch (InterruptedException e) { log.error(\\\"putMessage exception\\\", e); } } return lockedMqs; } } \"]},\"1223\":{\"h\":\"4.1.2 消费者解锁/加锁\"},\"1224\":{\"h\":\"4.1.2.1 重平衡后更新处理队列\",\"t\":[\"重平衡时，队列分配完成后对队列进行解锁和加锁\",\"// RebalanceImpl.java /** * 重平衡后更新 ProcessQueue 表 * 丢弃不再消费的队列，为新增的队列新建 ProcessQueue 和 PullRequest * * @param topic 主题 * @param mqSet 重平衡后该消费者新分配到的的消息队列 * @param isOrder 是否顺序消费 * @return */ private boolean updateProcessQueueTableInRebalance(final String topic, final Set<MessageQueue> mqSet, final boolean isOrder) { boolean changed = false; // 遍历本地缓存的消费者分到的消息队列，判断要丢弃的队列并丢弃 Iterator<Entry<MessageQueue, ProcessQueue>> it = this.processQueueTable.entrySet().iterator(); while (it.hasNext()) { Entry<MessageQueue, ProcessQueue> next = it.next(); MessageQueue mq = next.getKey(); ProcessQueue pq = next.getValue(); if (mq.getTopic().equals(topic)) { // 如果新分配到的消息队列集合中不含有老的消息队列，丢弃老的处理队列 if (!mqSet.contains(mq)) { // 该 ProcessQueue 中不会有消息被消费 pq.setDropped(true); // 移除消费队列，并释放 Broker锁，移除前持久化。 if (this.removeUnnecessaryMessageQueue(mq, pq)) { it.remove(); changed = true; } } else if (pq.isPullExpired()) { /** * 如果Reblance之后的mq集合包含该MessageQueue,但是ProcessQueue已经太久没有拉取数据（上次拉取消息的时间距离现在超过设置时间） */ switch (this.consumeType()) { case CONSUME_ACTIVELY: break; case CONSUME_PASSIVELY: /** * PushConsumer为被动消费 * 如果是PUSH，则丢弃ProcessQueue * 同时删除MessageQueue */ pq.setDropped(true); if (this.removeUnnecessaryMessageQueue(mq, pq)) { it.remove(); changed = true; } break; default: break; } } } } // 遍历新分配的 MessageQueue，对于新分配的，创建 PullRequest 启动拉取 List<PullRequest> pullRequestList = new ArrayList<PullRequest>(); // 为每个 MessageQueue 新建一个 PullRequest for (MessageQueue mq : mqSet) { // 本地缓存的 ProcessQueue 中不包含，表示新增队列 if (!this.processQueueTable.containsKey(mq)) { // 如果是顺序消费，尝试给处理队列加锁：尝试向 Broker 发送锁定队列请求。如果加锁失败则跳过，在下一次重平衡时尝试加锁 if (isOrder && !this.lock(mq)) { log.warn(\\\"doRebalance, {}, add a new mq failed, {}, because lock failed\\\", consumerGroup, mq); // 顺序消费，锁定处理队列失败，跳过拉取 continue; } // 从内存中移除该 MessageQueue 的消费进度（老的进度不需要） this.removeDirtyOffset(mq); ProcessQueue pq = new ProcessQueue(); // 计算当前 MessageQueue 应该从哪里开始拉取消息 long nextOffset = -1L; try { // 计算并从偏移量存储中读取下次拉取的偏移量 nextOffset = this.computePullFromWhereWithException(mq); } catch (Exception e) { log.info(\\\"doRebalance, {}, compute offset failed, {}\\\", consumerGroup, mq); continue; } if (nextOffset >= 0) { // 添加 MessageQueue 和 ProcessQueue 的映射关系 ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq); if (pre != null) { log.info(\\\"doRebalance, {}, mq already exists, {}\\\", consumerGroup, mq); } else { // 添加成功，创建新的 PullRequest // 唯一的创建 PullRequest 的地方 log.info(\\\"doRebalance, {}, add a new mq, {}\\\", consumerGroup, mq); PullRequest pullRequest = new PullRequest(); pullRequest.setConsumerGroup(consumerGroup); pullRequest.setNextOffset(nextOffset); pullRequest.setMessageQueue(mq); pullRequest.setProcessQueue(pq); pullRequestList.add(pullRequest); changed = true; } } else { log.warn(\\\"doRebalance, {}, add new mq failed, {}\\\", consumerGroup, mq); } } } // 将新建的 PullRequest 加入消息拉取线程 PullMessageService，开始拉取 this.dispatchPullRequest(pullRequestList); return changed; } \"]},\"1225\":{\"h\":\"4.1.2.2 消息队列解锁\",\"t\":[\"// RebalancePushImpl.java /** * 将重平衡后丢弃的消费队列移除 * 移除前持久化消费的消费进度 * * @param mq 消息队列 * @param pq 处理队列 * @return */ @Override public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) { // 持久化消费进度，然后移除 this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq); this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq); if (this.defaultMQPushConsumerImpl.isConsumeOrderly() && MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) { try { // 如果是顺序消费，尝试获取队列的消费锁，最多等待 1s if (pq.getConsumeLock().tryLock(1000, TimeUnit.MILLISECONDS)) { // 获取成功，表示该队列没有消息正被消费，可以向 Broker 发请求解锁该队列 try { return this.unlockDelay(mq, pq); } finally { pq.getConsumeLock().unlock(); } } else { // 获取消费锁失败，表示该队列有消息正被消费，且消费时长大于 1s，那么本次无法将该队列解锁 // 该队列新分配到负载的 Broker 由于拿不到该队列的锁，也无法开始消费，需要等待下一次重平衡时再尝试解锁 log.warn(\\\"[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}\\\", mq, pq.getTryUnlockTimes()); // 增加解锁尝试次数 pq.incTryUnlockTimes(); } } catch (Exception e) { log.error(\\\"removeUnnecessaryMessageQueue Exception\\\", e); } return false; } return true; } \"]},\"1226\":{\"h\":\"4.1.2.3 消息队列加锁\",\"t\":[\"// RebalanceImpl.java /** * 锁定消息队列，向 Broker 发请求 * 顺序消费时使用 * * @param mq 要锁定的消息队列 * @return 是否锁定成功 */ public boolean lock(final MessageQueue mq) { // 查询 Broker 地址 FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true); if (findBrokerResult != null) { // 构造锁定消息队列请求 LockBatchRequestBody requestBody = new LockBatchRequestBody(); requestBody.setConsumerGroup(this.consumerGroup); requestBody.setClientId(this.mQClientFactory.getClientId()); requestBody.getMqSet().add(mq); try { // 调用 API 向 Broker 发送锁定队列请求，返回锁定成功的队列集合 Set<MessageQueue> lockedMq = this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000); for (MessageQueue mmqq : lockedMq) { // 将锁定成功队列的处理队列加锁 ProcessQueue processQueue = this.processQueueTable.get(mmqq); if (processQueue != null) { processQueue.setLocked(true); processQueue.setLastLockTimestamp(System.currentTimeMillis()); } } boolean lockOK = lockedMq.contains(mq); log.info(\\\"the message queue lock {}, {} {}\\\", lockOK ? \\\"OK\\\" : \\\"Failed\\\", this.consumerGroup, mq); return lockOK; } catch (Exception e) { log.error(\\\"lockBatchMQ exception, \\\" + mq, e); } } return false; } \"]},\"1227\":{\"h\":\"4.2 消息拉取\"},\"1228\":{\"h\":\"4.2.1 消息拉取\",\"t\":[\"消息拉取操作，对于顺序消费情况，提交拉取请求前会先判断处理队列的锁定状态。\",\"锁定：如果是第一次锁定（第一次拉取），计算并设置本次拉取任务消息队列的拉取偏移量\",\"未锁定：等待 3s 后再次执行拉取请求\",\"/** * 拉取消息入口 * * @param pullRequest 拉取请求，包含需要拉取的消费队列信息 */ public void pullMessage(final PullRequest pullRequest) { // 获取待拉取的消费队列 final ProcessQueue processQueue = pullRequest.getProcessQueue(); // ... if (!this.consumeOrderly) { // ... } else { // 处理顺序消费，如果处理队列已经被锁定 if (processQueue.isLocked()) { // 如果之前没有被锁定过（是第一次拉取） if (!pullRequest.isPreviouslyLocked()) { long offset = -1L; try { // 计算拉取偏移量 offset = this.rebalanceImpl.computePullFromWhereWithException(pullRequest.getMessageQueue()); } catch (Exception e) { // 计算异常，等待 3s 后再次判断 this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); log.error(\\\"Failed to compute pull offset, pullResult: {}\\\", pullRequest, e); return; } boolean brokerBusy = offset < pullRequest.getNextOffset(); log.info(\\\"the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}\\\", pullRequest, offset, brokerBusy); if (brokerBusy) { log.info(\\\"[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}\\\", pullRequest, offset); } // 设置之前已经锁定过 pullRequest.setPreviouslyLocked(true); // 设置要拉取的偏移量，在方法后面的逻辑中立即执行拉取 pullRequest.setNextOffset(offset); } } else { // 如果处理队列没有被锁定，等待 3s 后将 PullRequest 放入拉取请求队列，再次判断锁定情况尝试拉取 this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException); log.info(\\\"pull message later because not locked in broker, {}\\\", pullRequest); return; } } // ... } \"]},\"1229\":{\"h\":\"4.2.2 消息拉取成功\",\"t\":[\"public void onSuccess(PullResult pullResult) { if (pullResult != null) { // 将消息字节数组解码成消息列表并填充msgFoundList；对消息进行TAG模式过滤 pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult, subscriptionData); switch (pullResult.getPullStatus()) { // 找到对应消息 case FOUND: // 上次请求偏移量 long prevRequestOffset = pullRequest.getNextOffset(); // 更新下一次拉取的偏移量 pullRequest.setNextOffset(pullResult.getNextBeginOffset()); // 计算和记录拉取用时 long pullRT = System.currentTimeMillis() - beginTimestamp; DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(), pullRequest.getMessageQueue().getTopic(), pullRT); // 如果msgFoundList为空，马上进行下次拉取 // msgFoundList为空的情况：因为根据TAG过滤时在服务端只验证了TAG的哈希码，客户端要再次对消息进行了过滤（见上），可能会出现为空的情况 long firstMsgOffset = Long.MAX_VALUE; if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) { DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest); } else { // 获取返回结果中第一条消息的消费队列offset firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset(); DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(), pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size()); // 将拉取到的消息存入ProcessQueue boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList()); // 将拉取到的消息提交到ConsumeMessageService中供消费者消费（异步） DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest( pullResult.getMsgFoundList(), processQueue, pullRequest.getMessageQueue(), dispatchToConsume); // 等待pullInterval毫秒后重新拉取，或立即重新拉取 if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() > 0) { DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval()); } else { DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest); } } // ... } // ... } } \"]},\"1230\":{\"h\":\"4.3 顺序消费任务\",\"t\":[\"// ConsumeMessageOrderlyService.java // class ConsumeRequest public void run() { if (this.processQueue.isDropped()) { log.warn(\\\"run, the message queue not be able to consume, because it's dropped. {}\\\", this.messageQueue); return; } // 从锁容器中获取消息队列消费锁 final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue); // 消费时申请独占消息队列消费锁对象 synchronized (objLock) { // 如果是广播模式；或者集群模式下处理队列被锁定且锁未超时，直接消费 if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) || (this.processQueue.isLocked() && !this.processQueue.isLockExpired())) { final long beginTime = System.currentTimeMillis(); // 是否继续本次消费请求的消费任务 for (boolean continueConsume = true; continueConsume; ) { if (this.processQueue.isDropped()) { log.warn(\\\"the message queue not be able to consume, because it's dropped. {}\\\", this.messageQueue); break; } if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && !this.processQueue.isLocked()) { log.warn(\\\"the message queue not locked, so consume later, {}\\\", this.messageQueue); ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10); break; } if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) && this.processQueue.isLockExpired()) { log.warn(\\\"the message queue lock expired, so consume later, {}\\\", this.messageQueue); ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10); break; } // 计算本次消费请求任务执行时长，如果超过 60s，结束本次消费任务，（顺序消费任务以时长计算） long interval = System.currentTimeMillis() - beginTime; if (interval > MAX_TIME_CONSUME_CONTINUOUSLY) { // 如果本次消费任务执行时长超过 60s，等到 10ms 后继续执行，以便让其他队列有机会消费 ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10); break; } // 每次从处理队列获取的一批消息数量，默认为 1 final int consumeBatchSize = ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize(); // 从处理队列中取一批（默认 1 条）消息 List<MessageExt> msgs = this.processQueue.takeMessages(consumeBatchSize); // 为重试消息恢复真正的 Topic defaultMQPushConsumerImpl.resetRetryAndNamespace(msgs, defaultMQPushConsumer.getConsumerGroup()); if (!msgs.isEmpty()) { // 如果获取的这批消息不为空 final ConsumeOrderlyContext context = new ConsumeOrderlyContext(this.messageQueue); ConsumeOrderlyStatus status = null; // 消费前钩子函数 ConsumeMessageContext consumeMessageContext = null; if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) { consumeMessageContext = new ConsumeMessageContext(); consumeMessageContext .setConsumerGroup(ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumerGroup()); consumeMessageContext.setNamespace(defaultMQPushConsumer.getNamespace()); consumeMessageContext.setMq(messageQueue); consumeMessageContext.setMsgList(msgs); consumeMessageContext.setSuccess(false); // init the consume context type consumeMessageContext.setProps(new HashMap<String, String>()); ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext); } long beginTimestamp = System.currentTimeMillis(); ConsumeReturnType returnType = ConsumeReturnType.SUCCESS; boolean hasException = false; try { // 消费消息锁 this.processQueue.getConsumeLock().lock(); if (this.processQueue.isDropped()) { log.warn(\\\"consumeMessage, the message queue not be able to consume, because it's dropped. {}\\\", this.messageQueue); break; } // 消息消费监听器执行真正的消费业务逻辑 status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context); } catch (Throwable e) { log.warn(String.format(\\\"consumeMessage exception: %s Group: %s Msgs: %s MQ: %s\\\", RemotingHelper.exceptionSimpleDesc(e), ConsumeMessageOrderlyService.this.consumerGroup, msgs, messageQueue), e); hasException = true; } finally { // 消费消息锁解锁 this.processQueue.getConsumeLock().unlock(); } if (null == status || ConsumeOrderlyStatus.ROLLBACK == status || ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) { log.warn(\\\"consumeMessage Orderly return not OK, Group: {} Msgs: {} MQ: {}\\\", ConsumeMessageOrderlyService.this.consumerGroup, msgs, messageQueue); } // 判断消费状态 long consumeRT = System.currentTimeMillis() - beginTimestamp; if (null == status) { if (hasException) { returnType = ConsumeReturnType.EXCEPTION; } else { returnType = ConsumeReturnType.RETURNNULL; } } else if (consumeRT >= defaultMQPushConsumer.getConsumeTimeout() * 60 * 1000) { returnType = ConsumeReturnType.TIME_OUT; } else if (ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT == status) { returnType = ConsumeReturnType.FAILED; } else if (ConsumeOrderlyStatus.SUCCESS == status) { returnType = ConsumeReturnType.SUCCESS; } if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) { consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name()); } if (null == status) { status = ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT; } // 消息消费后钩子函数 if (ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.hasHook()) { consumeMessageContext.setStatus(status.toString()); consumeMessageContext .setSuccess(ConsumeOrderlyStatus.SUCCESS == status || ConsumeOrderlyStatus.COMMIT == status); ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext); } // 更新统计数据（消息消费时间） ConsumeMessageOrderlyService.this.getConsumerStatsManager() .incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT); // 消费结果处理 continueConsume = ConsumeMessageOrderlyService.this.processConsumeResult(msgs, status, context, this); } else { // 获取的这批消息为空，说明处理队列为空，结束本次消费请求的消费 continueConsume = false; } } } else { if (this.processQueue.isDropped()) { log.warn(\\\"the message queue not be able to consume, because it's dropped. {}\\\", this.messageQueue); return; } ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100); } } } \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1231\":{\"h\":\"RocketMQ 最佳实践\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20221104-rocketmq-best-practice.html\"]},\"1232\":{\"h\":\"生产者\"},\"1233\":{\"h\":\"发送重试\",\"t\":[\"默认的消息发送超时时间为 3s，重试次数为 2 次。\",\"在生产环境中建议将超时时间合重试次数设大一点，以便有足够的重试次数来应对发送失败的场景。\",\"配置建议：\",\"使用异步发送可以避免上游调用超时，可以将超时时间设为 10s，重试次数设为 16次。\",\" producer.setSendMsgTimeout(10000); producer.setRetryTimesWhenSendFailed(16); producer.setRetryTimesWhenSendAsyncFailed(16); \"]},\"1234\":{\"h\":\"延迟故障规避\",\"t\":[\"RocketMQ 引入了延迟故障规避机制，当消息发送失败后，不再会发送到失败的 Broker，而是换一个 Broker 发送。该机制默认不开启。\",\"该配置项为 sendLatencyFaultEnable\",\"false：默认值，规避策略只在当前消息发送失败重试时失效。\",\"true：一旦消息发送失败，在接下来的一段时间内所有的客户端都不会向对应的 Broker 发送消息。\",\"配置建议：\",\"根据集群的负载来选择，一般无需开启。\",\"如果集群负载较高，不建议开启。因为某个 Broker 发送失败后的 5 分钟不会接收消息，会造成其他 Broker 负载过高。\"]},\"1235\":{\"h\":\"同一进程中多个生产者发送消息到多个集群\",\"t\":[\"RocketMQ 客户端 SDK 中的 MQClientInstance 表示对应到一个 RocketMQ 集群的客户端，在一个进程中可以有多个。 在 MQClientInstance 中可以注册多个生产者和消费者，这些生产者和消费者的元数据配置是相同的。\",\"为了实现多个生产者分别发送消息到多个集群，需要将生产者分别注册到多个 MQClientInstance 下，具体的方法为：为生产者设置不同的 ClientId。\",\"配置建议：\",\"将生产者的 UnitName 设置成集群名称，ClientId 生成时会拼接 UnitName，进而产生不同的 ClientId。\",\"DefaultMQProducer producer1 = new DefaultMQProducer(\\\"producer_group1\\\"); producer.setUnitName(\\\"Cluster1\\\") producer.setNamesrvAddr(\\\"1.1.1.1:9876\\\"); producer.start(); DefaultMQProducer producer2 = new DefaultMQProducer(\\\"producer_group2\\\"); producer.setUnitName(\\\"Cluster2\\\") producer.setNamesrvAddr(\\\"2.2.2.2:9876\\\"); producer.start(); \",\"附：生成 ClientId 的源码，\",\"public String buildMQClientId() { StringBuilder sb = new StringBuilder(); sb.append(this.getClientIP()); sb.append(\\\"@\\\"); sb.append(this.getInstanceName()); if (!UtilAll.isBlank(this.unitName)) { sb.append(\\\"@\\\"); sb.append(this.unitName); } return sb.toString(); } \"]},\"1236\":{\"h\":\"消费者\"},\"1237\":{\"h\":\"消费幂等\",\"t\":[\"RocketMQ无法避免消息重复（Exactly-Once），所以如果业务对消费重复非常敏感，有必要根据业务上的唯一Key对消息做幂等处理。 因为不同的Message ID对应的消息内容可能相同，有可能出现冲突（重复）的情况，所以真正安全的幂等处理，不建议以Message ID作为处理依据。最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息Key设置。\"]},\"1238\":{\"h\":\"消费组线程数\",\"t\":[\"RocketMQ 消费者提供 consumeThreadMin、consumeThreadMax 两个参数来设置线程池中的线程个数，但是由于线程池内部为无界队列，所以 consumeThreadMax 参数无效。 在实践中这两个值往往会设置成相同的。\"]},\"1239\":{\"h\":\"避免订阅关系不一致导致消息丢失\",\"t\":[\"RocketMQ 的一个消费组可以订阅多个 Topic，订阅多个 Tag。到那时同一个消费组中的订阅关系必须一致。 如果订阅关系不一致会造成消息丢失（部分消息未被消费）。\"]},\"1240\":{\"h\":\"避免 ClientId 相同\",\"t\":[\"消费者的 ClientId 生成规则与生产者一样。如果一个消费组内两个消费者的 ClientId 相同，会出现有的队列重复消费、有的队列无法消费的情况。\",\"配置建议：\",\"由于 ClientId 生成时会拼接消费者的 clientIP 属性，同一 IP 下不同消费者的 clientIP 相同会导致 ClientId 相同，所以建议手动设置 clientIP。\",\"consumer.setClientIP('192.168.3.10' + System.currentTimeMillis()); \"]},\"1241\":{\"h\":\"消费重试次数\",\"t\":[\"普通消息默认重试 16 次，重试实践按照延迟等级每次重试会递增，到达 16 次后，之后每次重试按照最大延迟等级对应的时间间隔。\",\" // 重试的时间从 10s 开始 private String messageDelayLevel = \\\"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h\\\"; \",\"顺序消费模式下重试次数配置无效，如果一条消息消费不成功会一直重试，重试次数为 Integer.MAX_VALUE。重试时间间隔可以用 suspendCurrentQueueTimeMillis 设置，默认为 1s。\"]},\"1242\":{\"h\":\"Broker\",\"t\":[\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1243\":{\"h\":\"RocketMQ 5.0：POP 消费模式 原理详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20221212-rocketmq-consumer-7-pop-consume.html\"]},\"1244\":{\"h\":\"1. 背景\"},\"1245\":{\"h\":\"1.1 什么是 Pop 消费\",\"t\":[\"RocketMQ 5.0 中引入了一种新的消费模式：Pop 消费模式。\",\"我们知道 RocketMQ 原来有两种消费模式：Pull 模式消费和 Push 模式消费，其中 Push 模式指的是 Broker 将消息主动“推送”给消费者，它的背后其实是消费者在不断地 Pull 消息来实现类似于 Broker “推”消息给消费者的效果。\",\"新引入的 Pop 消费模式主要是用于 Push 消费时将拉消息的动作替换成 Pop 。Pop 消费的行为和 Pull 消费很像，区别在于 Pop 消费的重平衡是在 Broker 端做的，而之前的 Pull 和 Push 消费都是由客户端完成重平衡。\"]},\"1246\":{\"h\":\"1.2 如何使用 Pop 消费\",\"t\":[\"RocketMQ 提供了 2 种方式，能够让 Push 消费切换为使用 Pop 模式拉取消息（Pull 消费暂不支持切换 Pop 模式），分别为命令行方式切换和客户端代码方式切换。\"]},\"1247\":{\"h\":\"1.2.1 使用命令行方式切换\",\"t\":[\"利用命令行，用如下命令，指定集群和需要切换的消费组，可以将一个消费组切换成 Pop 消费模式消费某个 Topic\",\"mqadmin setConsumeMode -c cluster -t topic -g group -m POP -q 8 \",\"以下为参数含义，其中 popShareQueueNum 表示 1 个队列最多可以被 N 个消费者同时消费。\",\"opt = new Option(\\\"c\\\", \\\"clusterName\\\", true, \\\"create subscription group to which cluster\\\"); opt = new Option(\\\"t\\\", \\\"topicName\\\", true, \\\"topic name\\\"); opt = new Option(\\\"g\\\", \\\"groupName\\\", true, \\\"consumer group name\\\"); opt = new Option(\\\"m\\\", \\\"mode\\\", true, \\\"consume mode. PULL/POP\\\"); opt = new Option(\\\"q\\\", \\\"popShareQueueNum\\\", true, \\\"num of queue which share in pop mode\\\"); \"]},\"1248\":{\"h\":\"1.2.2 代码切换\",\"t\":[\"在创建 Consumer 之前，先运行 switchPop() 方法，它其实与上面命令行的逻辑一样，也是发送请求给集群中的所有 Broker 节点，让它们切换对应消费者组和 Topic 的消费者的消费模式为 Pop 模式。\",\"// PopPushConsumer.java public class PopPushConsumer { public static final String CONSUMER_GROUP = \\\"CID_JODIE_1\\\"; public static final String TOPIC = \\\"TopicTest\\\"; // Or use AdminTools directly: mqadmin setConsumeMode -c cluster -t topic -g group -m POP -n 8 private static void switchPop() throws Exception { DefaultMQAdminExt mqAdminExt = new DefaultMQAdminExt(); mqAdminExt.start(); ClusterInfo clusterInfo = mqAdminExt.examineBrokerClusterInfo(); Set<String> brokerAddrs = clusterInfo.getBrokerAddrTable().values().stream().map(BrokerData::selectBrokerAddr).collect(Collectors.toSet()); for (String brokerAddr : brokerAddrs) { mqAdminExt.setMessageRequestMode(brokerAddr, TOPIC, CONSUMER_GROUP, MessageRequestMode.POP, 8, 3_000); } } public static void main(String[] args) throws Exception { switchPop(); DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP); consumer.subscribe(TOPIC, \\\"*\\\"); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET); consumer.registerMessageListener((MessageListenerConcurrently) (msgs, context) -> { System.out.printf(\\\"%s Receive New Messages: %s %n\\\", Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; }); consumer.setClientRebalance(false); consumer.start(); System.out.printf(\\\"Consumer Started.%n\\\"); } } \"]},\"1249\":{\"h\":\"1.3 引入 Pop 消费模式的原因\",\"t\":[\"引入 Pop 消费主要的原因是由于 Push 消费的机制导致它存在一些痛点。RocketMQ 5.0 云原生化的要求催生着一种能够解决这些痛点的新消费模式诞生。\",\"Push 消费模式的重平衡逻辑是在客户端完成的，这就导致了几个问题：\",\"客户端代码逻辑较重，要支持一种新语言的客户端就必须实现完整的重平衡逻辑，此外还需要实现拉消息、位点管理、消费失败后将消息发回 Broker 重试等逻辑。这给多语言客户端的支持造成很大的阻碍。\",\"当客户端升级或者下线时，都要进行重平衡操作，可能造成消息堆积。\",\"此外，Push 消费的特性是重平衡后每个消费者都分配到消费一定数量的队列，而每个队列最多只能被一个消费者消费。这就决定了消费者的横向扩展能力受到 Topic 中队列数量的限制。这里有引入了如下痛点\",\"消费者无法无限扩展，当消费者数量扩大到大于队列数量时，有的消费者将无法分配到队列。\",\"当某些消费者僵死（hang 住）时（与 Broker 的心跳未断，但是无法消费消息），会造成其消费的队列的消息堆积，迟迟无法被消费，也不会主动重平衡来解决这个问题。\",\"引入 Pop 消费模式之后，可以解决 Push 消费导致的可能的消息堆积问题和横向扩展能力问题。此外，RocketMQ 5.0 中引入了的轻量化客户端就用到了 Pop 消费能力，将 Pop 消费接口用 gRPC 封装，实现了多语言轻量化客户端，而不必在客户端实现重平衡逻辑。详见该项目 rocketmq-clients。\"]},\"1250\":{\"h\":\"2. 概要设计\",\"t\":[\"Pop 消费主要的设计思想是将繁重的客户端逻辑如重平衡、消费进度提交、消费失败后发到 Broker 重试等逻辑放到 Broker 端。\",\"客户端只需要不断发送 Pop 请求，由 Broker 端来分配每次拉取请求要拉取的队列并返回消息。这样就可以实现多个客户端同时拉取一个队列的效果，不会存在一个客户端 hang 住导致队列消息堆积，也不会存在频繁的重平衡导致消息积压。\"]},\"1251\":{\"h\":\"2.1 Pop 消费流程\",\"t\":[\"为了保证消费速度，Pop 消费一次请求可以拉取一批消息，拉取到的消息系统属性中有一个比较重要的属性叫做 POP_CK，它是该消息的句柄，ACK 时要通过句柄来定位到它。在 Broker 端会为这批消息保存一个 CheckPoint，它里面包含一批消息的句柄信息。\",\"对于长时间没有 ACK 的消息，Broker 端并非毫无办法。Pop 消费引入了消息不可见时间（invisibleTime）的机制。当 Pop 出一条消息后，这条消息对所有消费者不可见，即进入不可见时间，当它超过该时刻还没有被 ACK，Broker 将会把它放入 Pop 专门的重试 Topic（这个过程称为 Revive），这条消息重新可以被消费。\",\"Push 消费的重试间隔时间会随着重试次数而增加，Pop 消费也沿用了这个设计。此外，Pop 消费提供了一个接口 changeInvisibleTime() 来修改单条消息的不可见时间。\",\"从图上可以看见，本来消息会在中间这个时间点再一次的可见的，但是我们在可见之前提前使用 changeInvisibleTime 延长了不可见时间，让这条消息的可见时间推迟了。\",\"当消费失败（用户业务代码返回 reconsumeLater 或者抛异常）的时候，消费者就通过 changeInvisibleTime 按照重试次数来修改下一次的可见时间。另外如果消费消息用时超过了 30 秒（默认值，可以修改），则 Broker 也会把消息放到重试队列。\"]},\"1252\":{\"h\":\"2.2 客户端-服务端交互\",\"t\":[\"Pop 消费的流程与 Push 消费较为相似，这里我分为 5 个步骤。\",\"向 Broker 端发送请求，切换消息拉取模式为 Pop 模式\",\"重平衡服务执行重平衡，此时已经切换为 Pop 模式，所以是向 Broker 端发起请求，请求中带有重平衡策略，Broker 会返回重平衡的结果。\",\"重平衡完毕之后开始拉取消息，拉取消息服务发送 POP_MESSAGE 请求给 Broker，获取一批消息\",\"消费这批消息\",\"对成功消费的消息，发送 ACK 请求给 Broker\"]},\"1253\":{\"h\":\"2.3 服务端实现\",\"t\":[\"服务端收到 Pop 请求后，会先在 Queue 维度上加锁，保证同一时间只有一个消费者可以拉取该队列的消息。\",\"随后服务端会在存储中查询一批消息，将这批消息的构建的 CheckPoint 保存在 Broker 中，以便与 ACK 的消息匹配。\",\"CheckPoint 的存在目的是与 ACK 的消息匹配，并将没有匹配的消息重试。CheckPoint 的 ReviveTime 就是它这批消息需要被尝试重试（唤醒）的时间。\",\"CheckPoint会先被保存在内存中，一般来说消息消费很快，所以在内存中就能够与 ACK 消息匹配成功后删除。如果在一段时间（默认 3s）内没有匹配成功，它将会从内存中被删除，转入磁盘等待匹配。\",\"对于 ACK 消息也一样，它先被放入内存中匹配，如果在内存中找不到对应的 CheckPoint，也会放入磁盘。\",\"RocketMQ 的磁盘存储实际上就是 Topic 和队列。为了避免频繁检查匹配状态，我们只在 CheckPoint 需要被唤醒时做检查，这里就可以用到定时消息，将 CheckPoint 和 ACK 消息定时到 ReviveTime 投递。这里 RocketMQ 将 CheckPoint 的投递时间提前 1s，以便能先消费到，与 ACK 消息匹配。\",\"当定时到期，它们会被投递到 REVIVE_TOPIC。有个后台线程消费这个 Topic，把 CheckPoint 放到一个 map 中，对于 ACK 消息则从 map 中查找 CheckPoint 来尝试匹配，如果匹配成功则更新 REVIVE_TOPIC 的消费位点。对于超过 ReviveTime 还没有被匹配的 CheckPoint，查出这批消息中要重试消息对应的真实消息，并放到 Pop 消费重试 Topic 中。\",\"Broker 端的 Pop 消费逻辑会概率性消费到重试 Topic 中的消息。\"]},\"1254\":{\"h\":\"3. 详细设计\"},\"1255\":{\"h\":\"3.1 Broker 端重平衡\",\"t\":[\"Pop 消费的重平衡在 Broker 端完成，客户端的重平衡服务重平衡时会向 Broker 端发送查询请求，查询自己的分配结果。\",\"重平衡的主要逻辑其实与在客户端重平衡类似，只不过变成了 Broker 接收客户端的参数之后根据这些参数进行重平衡，然后把重平衡结果返回给客户端。\",\"Broker 端重平衡入口为 QueryAssignmentProcessor#doLoadBalance()。\",\"对于广播模式，直接返回 Topic 下所有的队列。\",\"对于集群模式，Pop 模式的重平衡与 Push 模式不同，它允许一个队列被多个消费者 Pop 消费。在切换 Pop 模式时引入了 popShareQueueNum 参数，表示允许消费者进行额外的负载获取队列的次数（可以被共享的队列数），0 表示可以消费所有队列。\",\"所以重平衡时对每个消费者执行 popShareQueueNum 次重平衡策略，将多次重平衡分配到的队列都分给这个消费者消费。这样，每个队列就会被多个消费者消费。\",\"下图为 popShareQueueNum = 1 时的重平衡情况，每个消费者被负载了 2 次，每个队列被 2 个消费者共享（1 + popShareQueueNum）。\"]},\"1256\":{\"h\":\"3.2 Broker 端 Pop 消息\"},\"1257\":{\"h\":\"3.2.1 请求处理入口\",\"t\":[\"Pop 消息的 Broker 端处理是由 PopMessageProcessor#processRequest() 完成。\",\"该方法逻辑为\",\"完成请求体解析和一些参数和权限的校验\",\"生成一个 0 到 99 的随机整数，如果能被 5 整除，则先拉取重试 Topic。\",\"从重试 Topic 的每个 Queue 中 Pop 消息\",\"根据请求的队列 Pop 对应的队列的消息。如果 Pop 请求指定了队列，只会消费一个队列的消息；如果没有指定队列，则 Pop 所有队列的消息\",\"如果 Pop 的消息没有满（达到请求的最大消息数量），且之前没有拉取过重试消息，则 Pop 重试 Topic 所有队列的消息（期望填充满 Pop 请求要求的数量）\",\"判断是否 Pop 到消息，如果有则传输回客户端，如果没有则挂起轮询，直到超过请求的 timeout 参数指定的时间\"]},\"1258\":{\"h\":\"3.2.2 Pop 消息方法\",\"t\":[\"上面的 3、4、5 都涉及到从存储中 Pop 消息，它们都调用同一个方法：popMsgFromQueue，它是真正查询消息的方法，下面看一下它的逻辑\",\"将需要 Pop 的队列上锁（用 AtomicBoolean 实现）\",\"计算 Pop 消息的起始偏移量，会返回内存中 CheckPoint 与 ACK 消息匹配后的最新位点\",\"从磁盘中根据起始偏移量查询一批消息\",\"计算队列剩余的消息数量（用作返回值）\",\"拉取的这批消息将生成一个 CheckPoint，存入内存和磁盘\",\"解锁队列\",\"返回 Pop 到的消息\",\"上面方法第 5 步会将生成的 CheckPoint 放入内存和磁盘，注意这个 CheckPoint 会保存一批获取到的消息的起始偏移量和相对偏移量（相对于起始偏移量），所以一个 CheckPoint 在保存和匹配时都对应一批消息。\"]},\"1259\":{\"h\":\"3.2.3 保存 CheckPoint 用于匹配\",\"t\":[\"构造 CheckPoint，添加起始偏移量和所有 Pop 出的消息的相对偏移量\",\"尝试将 CheckPoint 添加到内存 Buffer，如果成功则直接返回。但是在内存中匹配 CheckPoint 和 AckMsg 的开关默认是关闭的，所以这里不会加入到内存，会继续后面的逻辑放入磁盘\",\"将 CheckPoint 构造成一个消息，数据都放到消息体中，然后这个消息定时到 ReviveTime（唤醒重试的时间）- 1s（为了留时间与 AckMsg 匹配）发送。会发送到 ReviveTopic 的一个队列。\"]},\"1260\":{\"h\":\"3.3 Broker 端 ACK 消息\",\"t\":[\"Ack 消息接口每次只允许 Ack 一条消息，入口是 AckMessageProcessor#processRequest()\",\"从请求头解析和构造 Ack 消息，并作一些校验\",\"顺序消息 Ack 和普通消息 Ack 分别处理，这里针对普通消息\",\"先尝试将 Ack 消息放入内存 Buffer，如果成功则直接返回。失败则有可能是内存匹配未开启。\",\"如果放入内存失败，构造一个用于存到磁盘的消息，定时到唤醒重试时间投递（到 ReviveTopic）。\"]},\"1261\":{\"h\":\"3.4 Broker 端 CheckPoint 与 AckMsg 匹配\",\"t\":[\"CheckPoint 和 AckMsg 都被设计成先尝试放入内存中匹配，然后再磁盘中匹配，因为通常情况下消息消费之后都能很快 ACK，内存匹配性能较高。如果 CheckPoint 在内存中停留太久没有被匹配，则会转移到磁盘中（ReviveTopic），有个线程消费这个 ReviveTopic 来匹配。到达唤醒重试时间（ReviveTime）还没有被匹配的 CheckPoint 里面的消息将会重试（发送到 Pop 消息重试 Topic，后面的 Pop 有概率消费到）。\"]},\"1262\":{\"h\":\"3.4.1 内存匹配\",\"t\":[\"内存匹配逻辑由一个线程 PopBufferMergeService 完成，只有主节点运行该匹配线程。\",\"Pop 消息时会先添加 CheckPoint 到 buffer，Ack 消息时尝试从内存 buffer 中的 CheckPoint 匹配。同时，它每 5ms 执行一次扫描，将不符合内存中存活条件的 CheckPoint 移除，放入磁盘存储。\",\"addCk 方法将 CheckPoint 放入内存 Buffer。CheckPoint 中有一个码表 BitMap，用来表示它里面的每个条消息是否被 Ack 和被存到磁盘。用 BitMap 可以加速匹配。\",\"addAk 方法会尝试从 buffer 中找 CheckPoint 来匹配。如果找到对应的 CheckPoint，则修改它码表的对应位，表示这条消息被 ACK。\",\"scan 方法每 5ms 执行一次\",\"将已经匹配或存盘的 CheckPoint 移出 buffer\",\"把超时的 CheckPoint 存入磁盘\",\"对于匹配完成或者存盘的 CheckPoint，为他们提交消息偏移量\"]},\"1263\":{\"h\":\"3.4.2 Store 匹配和消息重试\",\"t\":[\"从内存中移除保存到磁盘的 CheckPoint 和 AckMsg 都会封装成消息进行定时投递（定时到重试时间），最终投递到 ReviveTopic。存储中匹配也由一个线程 PopReviveService 完成，它消费 ReviveTopic 的消息进行匹配和重试。\",\"Pop 消费由于要根据 Topic 来 Pop 消息，重试 Topic 需要针对每个 [消费组-Topic] 隔离，所以它不能用普通消息的消费组维度的重试 Topic，而是用专门的 Pop 重试 Topic %RETRY%{消费组}_{TOPIC}。\",\"PopReviveService#run 方法是该处理线程的入口，它每秒都会调用 consumeReviveMessage 消费和匹配 ReviveTopic 消息，然后调用 mergeAndRevive 方法检查匹配的情况并对达到唤醒时间还没有成功匹配的消息重试。\",\"这两个方法会先初始化一个 map，用于存放 CheckPoint，供 AckMsg 根据 map key 查找 CheckPoint。\",\"consumeReviveMessage 会消费 2s 内的一批 ReviveTopic 消息，CK 消息放入 map，Ack 消息则从 map 中查找 CK，在码表上标记对应的消息为 Acked。\",\"mergeAndRevive 方法如其名，遍历消费到的 CK 消息，对于已经到重试时间的，对没有 Ack 的消息进行重试。\",\"重试逻辑为先从 MessageStore 查询对应的真正消息，然后将该消息发送到 Pop 重试队列。\"]},\"1264\":{\"h\":\"4. 源码解析\"},\"1265\":{\"h\":\"4.1 Broker 端重平衡\"},\"1266\":{\"h\":\"4.1.1 QueryAssignmentProcessor#doLoadBalance\",\"t\":[\"/** * Broker 端重平衡 * Returns empty set means the client should clear all load assigned to it before, null means invalid result and the * client should skip the update logic * * @param topic * @param consumerGroup * @param clientId * @param messageModel 消费模型（广播/集群） * @param strategyName 重平衡策略名 * @return the MessageQueues assigned to this client */ private Set<MessageQueue> doLoadBalance(final String topic, final String consumerGroup, final String clientId, final MessageModel messageModel, final String strategyName, SetMessageRequestModeRequestBody setMessageRequestModeRequestBody, final ChannelHandlerContext ctx) { Set<MessageQueue> assignedQueueSet = null; final TopicRouteInfoManager topicRouteInfoManager = this.brokerController.getTopicRouteInfoManager(); switch (messageModel) { case BROADCASTING: { // 广播模式，返回该 Topic 下所有队列 assignedQueueSet = topicRouteInfoManager.getTopicSubscribeInfo(topic); if (assignedQueueSet == null) { log.warn(\\\"QueryLoad: no assignment for group[{}], the topic[{}] does not exist.\\\", consumerGroup, topic); } break; } case CLUSTERING: { // 集群模式 // 获取 Topic 下所有队列 Set<MessageQueue> mqSet = topicRouteInfoManager.getTopicSubscribeInfo(topic); if (null == mqSet) { if (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { log.warn(\\\"QueryLoad: no assignment for group[{}], the topic[{}] does not exist.\\\", consumerGroup, topic); } return null; } if (!brokerController.getBrokerConfig().isServerLoadBalancerEnable()) { return mqSet; } List<String> cidAll = null; // 获取发起请求的消费组信息 ConsumerGroupInfo consumerGroupInfo = this.brokerController.getConsumerManager().getConsumerGroupInfo(consumerGroup); if (consumerGroupInfo != null) { cidAll = consumerGroupInfo.getAllClientId(); } if (null == cidAll) { log.warn(\\\"QueryLoad: no assignment for group[{}] topic[{}], get consumer id list failed\\\", consumerGroup, topic); return null; } List<MessageQueue> mqAll = new ArrayList<MessageQueue>(); mqAll.addAll(mqSet); // 将队列和消费者客户端ID 排序 Collections.sort(mqAll); Collections.sort(cidAll); List<MessageQueue> allocateResult = null; try { // 根据重平衡策略名称获取策略 AllocateMessageQueueStrategy allocateMessageQueueStrategy = name2LoadStrategy.get(strategyName); if (null == allocateMessageQueueStrategy) { log.warn(\\\"QueryLoad: unsupported strategy [{}], {}\\\", strategyName, RemotingHelper.parseChannelRemoteAddr(ctx.channel())); return null; } if (setMessageRequestModeRequestBody != null && setMessageRequestModeRequestBody.getMode() == MessageRequestMode.POP) { // POP 模式重平衡 allocateResult = allocate4Pop(allocateMessageQueueStrategy, consumerGroup, clientId, mqAll, cidAll, setMessageRequestModeRequestBody.getPopShareQueueNum()); } else { // 普通重平衡 allocateResult = allocateMessageQueueStrategy.allocate(consumerGroup, clientId, mqAll, cidAll); } } catch (Throwable e) { log.error(\\\"QueryLoad: no assignment for group[{}] topic[{}], allocate message queue exception. strategy name: {}, ex: {}\\\", consumerGroup, topic, strategyName, e); return null; } assignedQueueSet = new HashSet<MessageQueue>(); if (allocateResult != null) { assignedQueueSet.addAll(allocateResult); } break; } default: break; } return assignedQueueSet; } \"]},\"1267\":{\"h\":\"4.1.2 QueryAssignmentProcessor#allocate4Pop\",\"t\":[\"/** * POP 模式重平衡 * * @param allocateMessageQueueStrategy 重平衡策略 * @param consumerGroup 消费组 * @param clientId 消费组客户端 ID * @param mqAll 全部消息队列 * @param cidAll 全部客户端ID * @param popShareQueueNum Pop 模式下可允许被共享的队列数，0 表示无限 * @return 该消费者负载的队列列表 */ public List<MessageQueue> allocate4Pop(AllocateMessageQueueStrategy allocateMessageQueueStrategy, final String consumerGroup, final String clientId, List<MessageQueue> mqAll, List<String> cidAll, int popShareQueueNum) { List<MessageQueue> allocateResult; if (popShareQueueNum <= 0 || popShareQueueNum >= cidAll.size() - 1) { // 每个消费者能消费所有队列，返回全部队列。队列 ID 为 -1 表示 Pop 消费时消费全部队列 //each client pop all messagequeue allocateResult = new ArrayList<>(mqAll.size()); for (MessageQueue mq : mqAll) { //must create new MessageQueue in case of change cache in AssignmentManager MessageQueue newMq = new MessageQueue(mq.getTopic(), mq.getBrokerName(), -1); allocateResult.add(newMq); } } else { if (cidAll.size() <= mqAll.size()) { // 消费者数量小于等于队列数量，每个消费者分配 N 个队列，每个队列也会被分配给多个消费者 //consumer working in pop mode could share the MessageQueues assigned to the N (N = popWorkGroupSize) consumer following it in the cid list allocateResult = allocateMessageQueueStrategy.allocate(consumerGroup, clientId, mqAll, cidAll); int index = cidAll.indexOf(clientId); if (index >= 0) { // 负载 popShareQueueNum 次，将每次负载的结果加入最终结果 for (int i = 1; i <= popShareQueueNum; i++) { index++; index = index % cidAll.size(); List<MessageQueue> tmp = allocateMessageQueueStrategy.allocate(consumerGroup, cidAll.get(index), mqAll, cidAll); allocateResult.addAll(tmp); } } } else { // 消费者数量大于队列数量，保证每个消费者都有队列消费 //make sure each cid is assigned allocateResult = allocate(consumerGroup, clientId, mqAll, cidAll); } } return allocateResult; } \"]},\"1268\":{\"h\":\"4.2 Broker 端 Pop 消息\"},\"1269\":{\"h\":\"4.2.1 PopMessageProcessor#processRequest\",\"t\":[\"/** * 处理 POP 消息请求 * * @param channel * @param request * @return * @throws RemotingCommandException */ private RemotingCommand processRequest(final Channel channel, RemotingCommand request) throws RemotingCommandException { // ... 解析请求体和一系列校验 // 生成随机数 int randomQ = random.nextInt(100); int reviveQid; if (requestHeader.isOrder()) { reviveQid = KeyBuilder.POP_ORDER_REVIVE_QUEUE; } else { // 轮询选一个 Revive 队列 reviveQid = (int) Math.abs(ckMessageNumber.getAndIncrement() % this.brokerController.getBrokerConfig().getReviveQueueNum()); } int commercialSizePerMsg = this.brokerController.getBrokerConfig().getCommercialSizePerMsg(); GetMessageResult getMessageResult = new GetMessageResult(commercialSizePerMsg); // 队列中剩余的消息数量 long restNum = 0; // 1/5 的概率拉取重试消息 boolean needRetry = randomQ % 5 == 0; long popTime = System.currentTimeMillis(); // 拉取重试消息 if (needRetry && !requestHeader.isOrder()) { TopicConfig retryTopicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup())); if (retryTopicConfig != null) { for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) { int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums(); restNum = popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, messageFilter, startOffsetInfo, msgOffsetInfo, orderCountInfo); } } } // 如果拉取请求没有指定队列（-1），则拉取所有队列 if (requestHeader.getQueueId() < 0) { // read all queue for (int i = 0; i < topicConfig.getReadQueueNums(); i++) { int queueId = (randomQ + i) % topicConfig.getReadQueueNums(); restNum = popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, messageFilter, startOffsetInfo, msgOffsetInfo, orderCountInfo); } } else { // 拉取请求指定了队列，拉取对应的队列 int queueId = requestHeader.getQueueId(); restNum = popMsgFromQueue(false, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, messageFilter, startOffsetInfo, msgOffsetInfo, orderCountInfo); } // 如果前面拉取普通消息之后，没有满，则再拉取一次重试消息 // if not full , fetch retry again if (!needRetry && getMessageResult.getMessageMapedList().size() < requestHeader.getMaxMsgNums() && !requestHeader.isOrder()) { TopicConfig retryTopicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup())); if (retryTopicConfig != null) { for (int i = 0; i < retryTopicConfig.getReadQueueNums(); i++) { int queueId = (randomQ + i) % retryTopicConfig.getReadQueueNums(); restNum = popMsgFromQueue(true, getMessageResult, requestHeader, queueId, restNum, reviveQid, channel, popTime, messageFilter, startOffsetInfo, msgOffsetInfo, orderCountInfo); } } } // 拉取消息成功 if (!getMessageResult.getMessageBufferList().isEmpty()) { response.setCode(ResponseCode.SUCCESS); getMessageResult.setStatus(GetMessageStatus.FOUND); if (restNum > 0) { // all queue pop can not notify specified queue pop, and vice versa notifyMessageArriving(requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueId()); } } else { // 没有拉取到消息，长轮询 int pollingResult = polling(channel, request, requestHeader); if (POLLING_SUC == pollingResult) { return null; } else if (POLLING_FULL == pollingResult) { response.setCode(ResponseCode.POLLING_FULL); } else { response.setCode(ResponseCode.POLLING_TIMEOUT); } getMessageResult.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE); } responseHeader.setInvisibleTime(requestHeader.getInvisibleTime()); responseHeader.setPopTime(popTime); responseHeader.setReviveQid(reviveQid); responseHeader.setRestNum(restNum); responseHeader.setStartOffsetInfo(startOffsetInfo.toString()); responseHeader.setMsgOffsetInfo(msgOffsetInfo.toString()); if (requestHeader.isOrder() && orderCountInfo != null) { responseHeader.setOrderCountInfo(orderCountInfo.toString()); } response.setRemark(getMessageResult.getStatus().name()); // 传输消息 return response; } \"]},\"1270\":{\"h\":\"4.2.2 PopMessageProcessor#popMsgFromQueue\",\"t\":[\"/** * 从消息队列中 POP 消息 * * @param isRetry 是否是重试 Topic * @param getMessageResult * @param requestHeader * @param queueId 消息队列 ID * @param restNum 队列剩余消息数量 * @param reviveQid 唤醒队列 ID * @param channel Netty Channel，用于获取客户端 host，来提交消费进度 * @param popTime Pop 时间 * @param messageFilter * @param startOffsetInfo 获取 Pop 的起始偏移量 * @param msgOffsetInfo 获取所有 Pop 的消息的逻辑偏移量 * @param orderCountInfo * @return 队列剩余消息 */ private long popMsgFromQueue(boolean isRetry, GetMessageResult getMessageResult, PopMessageRequestHeader requestHeader, int queueId, long restNum, int reviveQid, Channel channel, long popTime, ExpressionMessageFilter messageFilter, StringBuilder startOffsetInfo, StringBuilder msgOffsetInfo, StringBuilder orderCountInfo) { String topic = isRetry ? KeyBuilder.buildPopRetryTopic(requestHeader.getTopic(), requestHeader.getConsumerGroup()) : requestHeader.getTopic(); // {TOPIC}@{GROUP}@{QUEUE_ID} String lockKey = topic + PopAckConstants.SPLIT + requestHeader.getConsumerGroup() + PopAckConstants.SPLIT + queueId; boolean isOrder = requestHeader.isOrder(); long offset = getPopOffset(topic, requestHeader, queueId, false, lockKey); // Queue 上加锁，保证同一时刻只有一个消费者可以拉取同一个 Queue 的消息 if (!queueLockManager.tryLock(lockKey)) { // 返回该队列中待 Pop 的消息数量 restNum = this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId) - offset + restNum; return restNum; } // 计算要 POP 的消息偏移量 offset = getPopOffset(topic, requestHeader, queueId, true, lockKey); GetMessageResult getMessageTmpResult = null; try { // 顺序消费，阻塞 if (isOrder && brokerController.getConsumerOrderInfoManager().checkBlock(topic, requestHeader.getConsumerGroup(), queueId, requestHeader.getInvisibleTime())) { return this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId) - offset + restNum; } // 已经拉取到足够的消息 if (getMessageResult.getMessageMapedList().size() >= requestHeader.getMaxMsgNums()) { restNum = this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId) - offset + restNum; return restNum; } // 从磁盘消息存储中根据逻辑偏移量查询消息 getMessageTmpResult = this.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup() , topic, queueId, offset, requestHeader.getMaxMsgNums() - getMessageResult.getMessageMapedList().size(), messageFilter); if (getMessageTmpResult == null) { return this.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId) - offset + restNum; } // maybe store offset is not correct. if (GetMessageStatus.OFFSET_TOO_SMALL.equals(getMessageTmpResult.getStatus()) || GetMessageStatus.OFFSET_OVERFLOW_BADLY.equals(getMessageTmpResult.getStatus()) || GetMessageStatus.OFFSET_FOUND_NULL.equals(getMessageTmpResult.getStatus())) { // commit offset, because the offset is not correct // If offset in store is greater than cq offset, it will cause duplicate messages, // because offset in PopBuffer is not committed. POP_LOGGER.warn(\\\"Pop initial offset, because store is no correct, {}, {}->{}\\\", lockKey, offset, getMessageTmpResult.getNextBeginOffset()); offset = getMessageTmpResult.getNextBeginOffset(); this.brokerController.getConsumerOffsetManager().commitOffset(channel.remoteAddress().toString(), requestHeader.getConsumerGroup(), topic, queueId, offset); getMessageTmpResult = this.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), topic, queueId, offset, requestHeader.getMaxMsgNums() - getMessageResult.getMessageMapedList().size(), messageFilter); } // 计算队列还剩下的消息数量 restNum = getMessageTmpResult.getMaxOffset() - getMessageTmpResult.getNextBeginOffset() + restNum; if (!getMessageTmpResult.getMessageMapedList().isEmpty()) { // 更新统计数据 this.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageTmpResult.getMessageCount()); this.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), topic, getMessageTmpResult.getMessageCount()); this.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), topic, getMessageTmpResult.getBufferTotalSize()); if (isOrder) { // 顺序消费，更新偏移量 int count = brokerController.getConsumerOrderInfoManager().update(topic, requestHeader.getConsumerGroup(), queueId, getMessageTmpResult.getMessageQueueOffset()); this.brokerController.getConsumerOffsetManager().commitOffset(channel.remoteAddress().toString(), requestHeader.getConsumerGroup(), topic, queueId, offset); ExtraInfoUtil.buildOrderCountInfo(orderCountInfo, isRetry, queueId, count); } else { // 添加 CheckPoint 到内存，用于等待 ACK appendCheckPoint(requestHeader, topic, reviveQid, queueId, offset, getMessageTmpResult, popTime, this.brokerController.getBrokerConfig().getBrokerName()); } ExtraInfoUtil.buildStartOffsetInfo(startOffsetInfo, isRetry, queueId, offset); ExtraInfoUtil.buildMsgOffsetInfo(msgOffsetInfo, isRetry, queueId, getMessageTmpResult.getMessageQueueOffset()); } else if ((GetMessageStatus.NO_MATCHED_MESSAGE.equals(getMessageTmpResult.getStatus()) || GetMessageStatus.OFFSET_FOUND_NULL.equals(getMessageTmpResult.getStatus()) || GetMessageStatus.MESSAGE_WAS_REMOVING.equals(getMessageTmpResult.getStatus()) || GetMessageStatus.NO_MATCHED_LOGIC_QUEUE.equals(getMessageTmpResult.getStatus())) && getMessageTmpResult.getNextBeginOffset() > -1) { // 没有拉取到消息，添加假的消息 CheckPoint 到队列 popBufferMergeService.addCkMock(requestHeader.getConsumerGroup(), topic, queueId, offset, requestHeader.getInvisibleTime(), popTime, reviveQid, getMessageTmpResult.getNextBeginOffset(), brokerController.getBrokerConfig().getBrokerName()); // this.brokerController.getConsumerOffsetManager().commitOffset(channel.remoteAddress().toString(), requestHeader.getConsumerGroup(), topic, // queueId, getMessageTmpResult.getNextBeginOffset()); } } catch (Exception e) { POP_LOGGER.error(\\\"Exception in popMsgFromQueue\\\", e); } finally { // Pop 完后解锁 queueLockManager.unLock(lockKey); } // 将拉取到的消息放入结果容器中 if (getMessageTmpResult != null) { for (SelectMappedBufferResult mapedBuffer : getMessageTmpResult.getMessageMapedList()) { getMessageResult.addMessage(mapedBuffer); } } return restNum; } \"]},\"1271\":{\"h\":\"4.2.3 PopMessageProcessor#appendCheckPoint\",\"t\":[\"/** * 在 POP 拉取消息后调用，添加 CheckPoint，等待 ACK * * @param requestHeader * @param topic POP 的 Topic * @param reviveQid Revive 队列 ID * @param queueId POP 的队列 ID * @param offset POP 消息的起始偏移量 * @param getMessageTmpResult POP 一批消息的结果 * @param popTime POP 时间 * @param brokerName */ private void appendCheckPoint(final PopMessageRequestHeader requestHeader, final String topic, final int reviveQid, final int queueId, final long offset, final GetMessageResult getMessageTmpResult, final long popTime, final String brokerName) { // add check point msg to revive log final PopCheckPoint ck = new PopCheckPoint(); // ... 构造 PopCheckPoint，赋值过程省略 for (Long msgQueueOffset : getMessageTmpResult.getMessageQueueOffset()) { // 添加所有拉取的消息的偏移量与起始偏移量的差值 ck.addDiff((int) (msgQueueOffset - offset)); } // 将 Offset 放入内存 final boolean addBufferSuc = this.popBufferMergeService.addCk( ck, reviveQid, -1, getMessageTmpResult.getNextBeginOffset() ); if (addBufferSuc) { return; } // 放入内存匹配失败（内存匹配未开启），将 Offset 放入内存和磁盘 this.popBufferMergeService.addCkJustOffset( ck, reviveQid, -1, getMessageTmpResult.getNextBeginOffset() ); } \"]},\"1272\":{\"h\":\"4.3 Broker 端 Ack 消息\"},\"1273\":{\"h\":\"4.3.1 AckMessageProcessor#processRequest\",\"t\":[\"/** * 处理 Ack 消息请求，每次 Ack 一条消息 * * @param channel * @param request * @param brokerAllowSuspend * @return * @throws RemotingCommandException */ private RemotingCommand processRequest(final Channel channel, RemotingCommand request, boolean brokerAllowSuspend) throws RemotingCommandException { // 解析请求头 final AckMessageRequestHeader requestHeader = (AckMessageRequestHeader) request.decodeCommandCustomHeader(AckMessageRequestHeader.class); MessageExtBrokerInner msgInner = new MessageExtBrokerInner(); AckMsg ackMsg = new AckMsg(); RemotingCommand response = RemotingCommand.createResponseCommand(ResponseCode.SUCCESS, null); response.setOpaque(request.getOpaque()); // ... 校验 // 拆分消息句柄字符串 String[] extraInfo = ExtraInfoUtil.split(requestHeader.getExtraInfo()); // 用请求头中的信息构造 AckMsg ackMsg.setAckOffset(requestHeader.getOffset()); ackMsg.setStartOffset(ExtraInfoUtil.getCkQueueOffset(extraInfo)); ackMsg.setConsumerGroup(requestHeader.getConsumerGroup()); ackMsg.setTopic(requestHeader.getTopic()); ackMsg.setQueueId(requestHeader.getQueueId()); ackMsg.setPopTime(ExtraInfoUtil.getPopTime(extraInfo)); ackMsg.setBrokerName(ExtraInfoUtil.getBrokerName(extraInfo)); int rqId = ExtraInfoUtil.getReviveQid(extraInfo); this.brokerController.getBrokerStatsManager().incBrokerAckNums(1); this.brokerController.getBrokerStatsManager().incGroupAckNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(), 1); if (rqId == KeyBuilder.POP_ORDER_REVIVE_QUEUE) { // ... 顺序消息 ACK } // 普通消息 ACK // 先尝试放入内存匹配，成功则直接返回。失败可能是内存匹配未开启 if (this.brokerController.getPopMessageProcessor().getPopBufferMergeService().addAk(rqId, ackMsg)) { return response; } // 构造 Ack 消息 msgInner.setTopic(reviveTopic); msgInner.setBody(JSON.toJSONString(ackMsg).getBytes(DataConverter.charset)); //msgInner.setQueueId(Integer.valueOf(extraInfo[3])); msgInner.setQueueId(rqId); msgInner.setTags(PopAckConstants.ACK_TAG); msgInner.setBornTimestamp(System.currentTimeMillis()); msgInner.setBornHost(this.brokerController.getStoreHost()); msgInner.setStoreHost(this.brokerController.getStoreHost()); // 定时消息，定时到唤醒重试时间投递 msgInner.setDeliverTimeMs(ExtraInfoUtil.getPopTime(extraInfo) + ExtraInfoUtil.getInvisibleTime(extraInfo)); msgInner.getProperties().put(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX, PopMessageProcessor.genAckUniqueId(ackMsg)); msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties())); // 保存 Ack 消息到磁盘 PutMessageResult putMessageResult = this.brokerController.getEscapeBridge().putMessageToSpecificQueue(msgInner); if (putMessageResult.getPutMessageStatus() != PutMessageStatus.PUT_OK && putMessageResult.getPutMessageStatus() != PutMessageStatus.FLUSH_DISK_TIMEOUT && putMessageResult.getPutMessageStatus() != PutMessageStatus.FLUSH_SLAVE_TIMEOUT && putMessageResult.getPutMessageStatus() != PutMessageStatus.SLAVE_NOT_AVAILABLE) { POP_LOGGER.error(\\\"put ack msg error:\\\" + putMessageResult); } return response; } \"]},\"1274\":{\"h\":\"4.4 Broker 端 CheckPoint 与 AckMsg 匹配\"},\"1275\":{\"h\":\"4.4.1 PopBufferMergeService#addCk\",\"t\":[\"/** * POP 消息后，新增 CheckPoint，放入内存 Buffer * * @param point * @param reviveQueueId * @param reviveQueueOffset * @param nextBeginOffset * @return 是否添加成功 */ public boolean addCk(PopCheckPoint point, int reviveQueueId, long reviveQueueOffset, long nextBeginOffset) { // key: point.getT() + point.getC() + point.getQ() + point.getSo() + point.getPt() if (!brokerController.getBrokerConfig().isEnablePopBufferMerge()) { return false; } // 内存匹配服务是否开启 if (!serving) { return false; } // 距离下次可重试 Pop 消费的时刻 < 4.5s long now = System.currentTimeMillis(); if (point.getReviveTime() - now < brokerController.getBrokerConfig().getPopCkStayBufferTimeOut() + 1500) { if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.warn(\\\"[PopBuffer]add ck, timeout, {}, {}\\\", point, now); } return false; } if (this.counter.get() > brokerController.getBrokerConfig().getPopCkMaxBufferSize()) { POP_LOGGER.warn(\\\"[PopBuffer]add ck, max size, {}, {}\\\", point, this.counter.get()); return false; } PopCheckPointWrapper pointWrapper = new PopCheckPointWrapper(reviveQueueId, reviveQueueOffset, point, nextBeginOffset); if (!checkQueueOk(pointWrapper)) { return false; } // 将 CheckPoint 放入 Offset 队列 putOffsetQueue(pointWrapper); // 将 CheckPoint 放入内存 Buffer this.buffer.put(pointWrapper.getMergeKey(), pointWrapper); this.counter.incrementAndGet(); if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.info(\\\"[PopBuffer]add ck, {}\\\", pointWrapper); } return true; } \"]},\"1276\":{\"h\":\"4.4.2 PopBufferMergeService#addAk\",\"t\":[\"/** * 消息 ACK，与内存中的 CheckPoint 匹配 * * @param reviveQid * @param ackMsg * @return 是否匹配成功 */ public boolean addAk(int reviveQid, AckMsg ackMsg) { // 如果未开启内存匹配，直接返回 if (!brokerController.getBrokerConfig().isEnablePopBufferMerge()) { return false; } if (!serving) { return false; } try { // 根据 ACK 的消息找到内存 Buffer 中的 CheckPoint PopCheckPointWrapper pointWrapper = this.buffer.get(ackMsg.getTopic() + ackMsg.getConsumerGroup() + ackMsg.getQueueId() + ackMsg.getStartOffset() + ackMsg.getPopTime() + ackMsg.getBrokerName()); if (pointWrapper == null) { // 找不到 CheckPoint if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.warn(\\\"[PopBuffer]add ack fail, rqId={}, no ck, {}\\\", reviveQid, ackMsg); } return false; } // 内存中仅保存 Offset，实际已经保存到磁盘，内存中不处理 ACK 消息的匹配，直接返回 if (pointWrapper.isJustOffset()) { return false; } PopCheckPoint point = pointWrapper.getCk(); long now = System.currentTimeMillis(); if (point.getReviveTime() - now < brokerController.getBrokerConfig().getPopCkStayBufferTimeOut() + 1500) { if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.warn(\\\"[PopBuffer]add ack fail, rqId={}, almost timeout for revive, {}, {}, {}\\\", reviveQid, pointWrapper, ackMsg, now); } return false; } if (now - point.getPopTime() > brokerController.getBrokerConfig().getPopCkStayBufferTime() - 1500) { if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.warn(\\\"[PopBuffer]add ack fail, rqId={}, stay too long, {}, {}, {}\\\", reviveQid, pointWrapper, ackMsg, now); } return false; } // 标记该 CheckPoint 已经被 ACK int indexOfAck = point.indexOfAck(ackMsg.getAckOffset()); if (indexOfAck > -1) { // 设置 CheckPoint 中被 Ack 消息的 bit 码表为 1 markBitCAS(pointWrapper.getBits(), indexOfAck); } else { POP_LOGGER.error(\\\"[PopBuffer]Invalid index of ack, reviveQid={}, {}, {}\\\", reviveQid, ackMsg, point); return true; } return true; } catch (Throwable e) { POP_LOGGER.error(\\\"[PopBuffer]add ack error, rqId=\\\" + reviveQid + \\\", \\\" + ackMsg, e); } return false; } \"]},\"1277\":{\"h\":\"4.4.3 PopBufferMergeService#scan\",\"t\":[\"/** * 扫描内存中的 CheckPoint * 把已经匹配或存盘的 CheckPoint 移出 buffer * 把已经全部 Ack 的 CheckPoint 存盘 */ private void scan() { long startTime = System.currentTimeMillis(); int count = 0, countCk = 0; Iterator<Map.Entry<String, PopCheckPointWrapper>> iterator = buffer.entrySet().iterator(); // 遍历所有内存中的 CheckPoint while (iterator.hasNext()) { Map.Entry<String, PopCheckPointWrapper> entry = iterator.next(); PopCheckPointWrapper pointWrapper = entry.getValue(); // 如果 CheckPoint 已经在磁盘中，或者全部消息都匹配成功，从内存中 buffer 中移除 // just process offset(already stored at pull thread), or buffer ck(not stored and ack finish) if (pointWrapper.isJustOffset() && pointWrapper.isCkStored() || isCkDone(pointWrapper) || isCkDoneForFinish(pointWrapper) && pointWrapper.isCkStored()) { iterator.remove(); counter.decrementAndGet(); continue; } PopCheckPoint point = pointWrapper.getCk(); long now = System.currentTimeMillis(); // 是否要从内存中移除 CheckPoint boolean removeCk = !this.serving; // 距离 ReviveTime 时间小于阈值（默认3s） // ck will be timeout if (point.getReviveTime() - now < brokerController.getBrokerConfig().getPopCkStayBufferTimeOut()) { removeCk = true; } // 在内存中时间大于阈值（默认10s） // the time stayed is too long if (now - point.getPopTime() > brokerController.getBrokerConfig().getPopCkStayBufferTime()) { removeCk = true; } if (now - point.getPopTime() > brokerController.getBrokerConfig().getPopCkStayBufferTime() * 2L) { POP_LOGGER.warn(\\\"[PopBuffer]ck finish fail, stay too long, {}\\\", pointWrapper); } // double check if (isCkDone(pointWrapper)) { continue; } else if (pointWrapper.isJustOffset()) { // just offset should be in store. if (pointWrapper.getReviveQueueOffset() < 0) { putCkToStore(pointWrapper, false); countCk++; } continue; } else if (removeCk) { // 将 CheckPoint 包装成消息放入磁盘，从内存中移除 // put buffer ak to store if (pointWrapper.getReviveQueueOffset() < 0) { putCkToStore(pointWrapper, false); countCk++; } if (!pointWrapper.isCkStored()) { continue; } // 在内存中移除 CheckPoint 前，把它当中已经 Ack 的消息也作为 Ack 消息存入磁盘 for (byte i = 0; i < point.getNum(); i++) { // 遍历 CheckPoint 中消息 bit 码表每一位，检查是否已经 Ack 并且没有存入磁盘 // reput buffer ak to store if (DataConverter.getBit(pointWrapper.getBits().get(), i) && !DataConverter.getBit(pointWrapper.getToStoreBits().get(), i)) { if (putAckToStore(pointWrapper, i)) { count++; markBitCAS(pointWrapper.getToStoreBits(), i); } } } if (isCkDoneForFinish(pointWrapper) && pointWrapper.isCkStored()) { if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.info(\\\"[PopBuffer]ck finish, {}\\\", pointWrapper); } iterator.remove(); counter.decrementAndGet(); continue; } } } // 扫描已经完成的 CheckPoint，为它们提交消息消费进度 int offsetBufferSize = scanCommitOffset(); scanTimes++; if (scanTimes >= countOfMinute1) { counter.set(this.buffer.size()); scanTimes = 0; } } \"]},\"1278\":{\"h\":\"4.4.4 PopReviveService#consumeReviveMessage\",\"t\":[\"/** * 消费 Revive Topic 中的消息，匹配 ACK 消息和 CheckPoint * CK 消息放到 Map 中，ACK 消息根据 Map key 匹配 CK 消息，更新 CK 消息的码表以完成 ACK * 只对 CK 进行标记 * 消费时间差 2s 内的 CK、ACK 消息，或 4s 没有消费到新消息 * * @param consumeReviveObj CK 与 ACK 匹配对象，用于 Revive 需要重试 Pop 消费的消息 */ protected void consumeReviveMessage(ConsumeReviveObj consumeReviveObj) { // CheckPoint 匹配 map，key = point.getTopic() + point.getCId() + point.getQueueId() + point.getStartOffset() + point.getPopTime() HashMap<String, PopCheckPoint> map = consumeReviveObj.map; long startScanTime = System.currentTimeMillis(); long endTime = 0; // 查询 ReviveTopic queue 之前的消费进度 long oldOffset = this.brokerController.getConsumerOffsetManager().queryOffset(PopAckConstants.REVIVE_GROUP, reviveTopic, queueId); consumeReviveObj.oldOffset = oldOffset; POP_LOGGER.info(\\\"reviveQueueId={}, old offset is {} \\\", queueId, oldOffset); long offset = oldOffset + 1; // 没有查询到消息的次数 int noMsgCount = 0; long firstRt = 0; // offset self amend while (true) { if (!shouldRunPopRevive) { POP_LOGGER.info(\\\"slave skip scan , revive topic={}, reviveQueueId={}\\\", reviveTopic, queueId); break; } // 查询一批 Revive Topic 中的消息（32条） List<MessageExt> messageExts = getReviveMessage(offset, queueId); if (messageExts == null || messageExts.isEmpty()) { long old = endTime; long timerDelay = brokerController.getMessageStore().getTimerMessageStore().getReadBehind(); long commitLogDelay = brokerController.getMessageStore().getTimerMessageStore().getEnqueueBehind(); // move endTime if (endTime != 0 && System.currentTimeMillis() - endTime > 3 * PopAckConstants.SECOND && timerDelay <= 0 && commitLogDelay <= 0) { endTime = System.currentTimeMillis(); } POP_LOGGER.info(\\\"reviveQueueId={}, offset is {}, can not get new msg, old endTime {}, new endTime {}\\\", queueId, offset, old, endTime); // 最后一个 CK 的唤醒时间与第一个 CK 的唤醒时间差大于 2s，中断消费 if (endTime - firstRt > PopAckConstants.ackTimeInterval + PopAckConstants.SECOND) { break; } noMsgCount++; // Fixme: why sleep is useful here? try { Thread.sleep(100); } catch (Throwable ignore) { } // 连续 4s 没有消费到新的消息，中断消费 if (noMsgCount * 100L > 4 * PopAckConstants.SECOND) { break; } else { continue; } } else { noMsgCount = 0; } if (System.currentTimeMillis() - startScanTime > brokerController.getBrokerConfig().getReviveScanTime()) { POP_LOGGER.info(\\\"reviveQueueId={}, scan timeout \\\", queueId); break; } // 遍历查询到的消息 for (MessageExt messageExt : messageExts) { if (PopAckConstants.CK_TAG.equals(messageExt.getTags())) { // 如果是 CheckPoint String raw = new String(messageExt.getBody(), DataConverter.charset); if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.info(\\\"reviveQueueId={},find ck, offset:{}, raw : {}\\\", messageExt.getQueueId(), messageExt.getQueueOffset(), raw); } PopCheckPoint point = JSON.parseObject(raw, PopCheckPoint.class); if (point.getTopic() == null || point.getCId() == null) { continue; } // 放入 HashMap，等待 ACK 消息匹配 map.put(point.getTopic() + point.getCId() + point.getQueueId() + point.getStartOffset() + point.getPopTime(), point); // 设置 reviveOffset 为 revive 队列中消息的逻辑 offset point.setReviveOffset(messageExt.getQueueOffset()); if (firstRt == 0) { firstRt = point.getReviveTime(); } } else if (PopAckConstants.ACK_TAG.equals(messageExt.getTags())) { // 如果是 ACK 消息 String raw = new String(messageExt.getBody(), DataConverter.charset); if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.info(\\\"reviveQueueId={},find ack, offset:{}, raw : {}\\\", messageExt.getQueueId(), messageExt.getQueueOffset(), raw); } AckMsg ackMsg = JSON.parseObject(raw, AckMsg.class); PopCheckPoint point = map.get(ackMsg.getTopic() + ackMsg.getConsumerGroup() + ackMsg.getQueueId() + ackMsg.getStartOffset() + ackMsg.getPopTime()); if (point == null) { continue; } // 如果 HashMap 中有 CheckPoint，计算 ACK 的 bit 码表 int indexOfAck = point.indexOfAck(ackMsg.getAckOffset()); if (indexOfAck > -1) { // Ack 消息 bit 码表为 1 的位 Ack 成功 point.setBitMap(DataConverter.setBit(point.getBitMap(), indexOfAck, true)); } else { POP_LOGGER.error(\\\"invalid ack index, {}, {}\\\", ackMsg, point); } } long deliverTime = messageExt.getDeliverTimeMs(); if (deliverTime > endTime) { endTime = deliverTime; } } offset = offset + messageExts.size(); } consumeReviveObj.endTime = endTime; } \"]},\"1279\":{\"h\":\"4.4.5 PopReviveService#mergeAndRevive\",\"t\":[\"/** * 匹配消费到的一批 CK 和 ACK 消息，对于没有成功 ACK 的消息，重发到重试 Topic */ protected void mergeAndRevive(ConsumeReviveObj consumeReviveObj) throws Throwable { // 获取排序后的 CheckPoint 列表 ArrayList<PopCheckPoint> sortList = consumeReviveObj.genSortList(); // ... long newOffset = consumeReviveObj.oldOffset; for (PopCheckPoint popCheckPoint : sortList) { // ... // 如果没有到 Revive 时间，跳过 if (consumeReviveObj.endTime - popCheckPoint.getReviveTime() <= (PopAckConstants.ackTimeInterval + PopAckConstants.SECOND)) { break; } // 从 CK 中解析原 Topic 并检查该 Topic 是否存在，如果不存在则跳过 // check normal topic, skip ck , if normal topic is not exist String normalTopic = KeyBuilder.parseNormalTopic(popCheckPoint.getTopic(), popCheckPoint.getCId()); if (brokerController.getTopicConfigManager().selectTopicConfig(normalTopic) == null) { POP_LOGGER.warn(\\\"reviveQueueId={},can not get normal topic {} , then continue \\\", queueId, popCheckPoint.getTopic()); newOffset = popCheckPoint.getReviveOffset(); continue; } if (null == brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(popCheckPoint.getCId())) { POP_LOGGER.warn(\\\"reviveQueueId={},can not get cid {} , then continue \\\", queueId, popCheckPoint.getCId()); newOffset = popCheckPoint.getReviveOffset(); continue; } // 重发 CK 中没有 Ack 的所有消息 reviveMsgFromCk(popCheckPoint); newOffset = popCheckPoint.getReviveOffset(); } // 匹配和重试完成后，更新 ReviveTopic 消费进度 if (newOffset > consumeReviveObj.oldOffset) { if (!shouldRunPopRevive) { POP_LOGGER.info(\\\"slave skip commit, revive topic={}, reviveQueueId={}\\\", reviveTopic, queueId); return; } this.brokerController.getConsumerOffsetManager().commitOffset(PopAckConstants.LOCAL_HOST, PopAckConstants.REVIVE_GROUP, reviveTopic, queueId, newOffset); } consumeReviveObj.newOffset = newOffset; } \"]},\"1280\":{\"h\":\"4.4.6 PopReviveService : 重试消息\",\"t\":[\"/** * 重发 CK 中没有 Ack 的所有消息 */ private void reviveMsgFromCk(PopCheckPoint popCheckPoint) throws Throwable { // 遍历 CK 中的所有消息 for (int j = 0; j < popCheckPoint.getNum(); j++) { if (DataConverter.getBit(popCheckPoint.getBitMap(), j)) { continue; } // retry msg long msgOffset = popCheckPoint.ackOffsetByIndex((byte) j); // 查询 CK 消息对应的真正消息 MessageExt messageExt = getBizMessage(popCheckPoint.getTopic(), msgOffset, popCheckPoint.getQueueId(), popCheckPoint.getBrokerName()); if (messageExt == null) { POP_LOGGER.warn(\\\"reviveQueueId={},can not get biz msg topic is {}, offset is {} , then continue \\\", queueId, popCheckPoint.getTopic(), msgOffset); continue; } //skip ck from last epoch if (popCheckPoint.getPopTime() < messageExt.getStoreTimestamp()) { POP_LOGGER.warn(\\\"reviveQueueId={},skip ck from last epoch {}\\\", queueId, popCheckPoint); continue; } // 唤醒没有被 ACK 的消息，发到重试队列 reviveRetry(popCheckPoint, messageExt); } } /** * 根据 CheckPoint 唤醒没有被 ACK 的消息，发到重试队列 * * @param popCheckPoint CK * @param messageExt 要被重试的消息 * @throws Exception */ private void reviveRetry(PopCheckPoint popCheckPoint, MessageExt messageExt) throws Exception { if (!shouldRunPopRevive) { POP_LOGGER.info(\\\"slave skip retry , revive topic={}, reviveQueueId={}\\\", reviveTopic, queueId); return; } // 构造新的消息 MessageExtBrokerInner msgInner = new MessageExtBrokerInner(); // 唤醒的消息发到重试 Topic if (!popCheckPoint.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) { msgInner.setTopic(KeyBuilder.buildPopRetryTopic(popCheckPoint.getTopic(), popCheckPoint.getCId())); } else { msgInner.setTopic(popCheckPoint.getTopic()); } msgInner.setBody(messageExt.getBody()); msgInner.setQueueId(0); if (messageExt.getTags() != null) { msgInner.setTags(messageExt.getTags()); } else { MessageAccessor.setProperties(msgInner, new HashMap<String, String>()); } msgInner.setBornTimestamp(messageExt.getBornTimestamp()); msgInner.setBornHost(brokerController.getStoreHost()); msgInner.setStoreHost(brokerController.getStoreHost()); // 重试次数 += 1 msgInner.setReconsumeTimes(messageExt.getReconsumeTimes() + 1); msgInner.getProperties().putAll(messageExt.getProperties()); if (messageExt.getReconsumeTimes() == 0 || msgInner.getProperties().get(MessageConst.PROPERTY_FIRST_POP_TIME) == null) { msgInner.getProperties().put(MessageConst.PROPERTY_FIRST_POP_TIME, String.valueOf(popCheckPoint.getPopTime())); } msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties())); // 添加 Pop 重试 Topic addRetryTopicIfNoExit(msgInner.getTopic(), popCheckPoint.getCId()); // 保存重试消息到存储 PutMessageResult putMessageResult = brokerController.getEscapeBridge().putMessageToSpecificQueue(msgInner); if (brokerController.getBrokerConfig().isEnablePopLog()) { POP_LOGGER.info(\\\"reviveQueueId={},retry msg , ck={}, msg queueId {}, offset {}, reviveDelay={}, result is {} \\\", queueId, popCheckPoint, messageExt.getQueueId(), messageExt.getQueueOffset(), (System.currentTimeMillis() - popCheckPoint.getReviveTime()) / 1000, putMessageResult); } if (putMessageResult.getAppendMessageResult() == null || putMessageResult.getAppendMessageResult().getStatus() != AppendMessageStatus.PUT_OK) { throw new Exception(\\\"reviveQueueId=\\\" + queueId + \\\",revive error ,msg is :\\\" + msgInner); } // ... 更新统计数据 if (brokerController.getPopMessageProcessor() != null) { brokerController.getPopMessageProcessor().notifyMessageArriving( KeyBuilder.parseNormalTopic(popCheckPoint.getTopic(), popCheckPoint.getCId()), popCheckPoint.getCId(), -1 ); } } \"]},\"1281\":{\"h\":\"参考资料\",\"t\":[\"[RIP 19] Server side rebalance, lightweight consumer client support\",\"RocketMQ 5.0 POP 消费模式探秘\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1282\":{\"h\":\"RocketMQ 轻量级队列 Light Message Queue（RIP-28）原理详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20230304-rocketmq-light-message-queue.html\"]},\"1283\":{\"h\":\"1. 背景\"},\"1284\":{\"h\":\"1.1 引入原因\",\"t\":[\"在 RocketMQ 4.9.3 版本中，引入了轻量级队列（以下简称 LMQ）特性。\",\"合入PR：https://github.com/apache/rocketmq/pull/3694\",\"这个特性主要是为了支持在一些消息场景下可能存在的大量队列场景。比如 MQTT 的多级主题和 AMQP 的队列，这些队列的数量可能非常多。而 RocketMQ 的 Topic 资源密集，很难支持百万级别甚至更多数量。Light Message Queue 特性就是为了解决 IOT 设备和 AMQP 协议可能需要的海量队列的场景。\",\"rocketmq-mqtt 项目就应用了 LMQ，实现了 RocketMQ 对 MQTT 协议的兼容。\"]},\"1285\":{\"h\":\"1.2 使用方法\"},\"1286\":{\"h\":\"1.2.1 Broker 启动配置\",\"t\":[\"broker.conf 文件需要增加以下的配置项，开启 LMQ 开关和多队列转发开关，这样才能识别 LMQ 相关消息属性，分发消息到 LMQ。\",\"enableLmq = true enableMultiDispatch = true \"]},\"1287\":{\"h\":\"1.2.2 生产消息\",\"t\":[\"发送消息的时候通过设置 INNER_MULTI_DISPATCH 属性，分发消息到多个 LMQ，多个 LMQ 之间使用逗号分割，名称前缀必须是 %LMQ%，这样 broker 就可以识别 LMQ。\",\"DefaultMQProducer producer = new DefaultMQProducer(\\\"please_rename_unique_group_name\\\"); producer.setNamesrvAddr(\\\"name-server1-ip:9876;name-server2-ip:9876\\\"); producer.start(); /* * Create a message instance, specifying topic, tag and message body. */ Message msg = new Message(\\\"TopicTest\\\" /* Topic */, \\\"TagA\\\" /* Tag */, (\\\"Hello RocketMQ \\\" + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */ ); /* * INNER_MULTI_DISPATCH property and PREFIX must start as \\\"%LMQ%\\\", * If it is multiple LMQ, need to use “,” split */ message.putUserProperty(\\\"INNER_MULTI_DISPATCH\\\", \\\"%LMQ%123,%LMQ%456\\\"); /* * Call send message to deliver message to one of brokers. */ SendResult sendResult = producer.send(msg); \"]},\"1288\":{\"h\":\"1.2.3 消费消息\",\"t\":[\"LMQ 在每个 broker 上只有一个 queue，queueId 为 0， 指明要消费的 LMQ 名称，就可以拉取消息进行消费。\",\"DefaultMQPullConsumer defaultMQPullConsumer = new DefaultMQPullConsumer(); defaultMQPullConsumer.setNamesrvAddr(\\\"name-server1-ip:9876;name-server2-ip:9876\\\"); defaultMQPullConsumer.setVipChannelEnabled(false); defaultMQPullConsumer.setConsumerGroup(\\\"CID_RMQ_SYS_LMQ_TEST\\\"); defaultMQPullConsumer.setInstanceName(\\\"CID_RMQ_SYS_LMQ_TEST\\\"); defaultMQPullConsumer.setRegisterTopics(new HashSet<>(Arrays.asList(\\\"TopicTest\\\"))); defaultMQPullConsumer.setBrokerSuspendMaxTimeMillis(2000); defaultMQPullConsumer.setConsumerTimeoutMillisWhenSuspend(3000); defaultMQPullConsumer.start(); String brokerName = \\\"set broker Name\\\"; MessageQueue mq = new MessageQueue(\\\"%LMQ%123\\\", brokerName, 0); defaultMQPullConsumer.getDefaultMQPullConsumerImpl().getRebalanceImpl().getmQClientFactory().updateTopicRouteInfoFromNameServer(\\\"TopicTest\\\"); Thread.sleep(30000); Long offset = defaultMQPullConsumer.maxOffset(mq); defaultMQPullConsumer.pullBlockIfNotFound( mq, \\\"*\\\", offset, 32, new PullCallback() { @Override public void onSuccess(PullResult pullResult) { List<MessageExt> list = pullResult.getMsgFoundList(); if (list == null || list.isEmpty()) { return; } for (MessageExt messageExt : list) { System.out.println(messageExt); } } @Override public void onException(Throwable e) { } }); \"]},\"1289\":{\"h\":\"2. 概要设计\"},\"1290\":{\"h\":\"2.1 当前痛点\",\"t\":[\"在 AMQP 协议中，消息发送到 Exchange，由 Exchange 将消息分发到一个或多个 Queue 中。在 RocketMQ 实现 AMQP 协议时，如果将 Topic 与 Queue 对应，就意味着同一条消息会保存到多个 Topic，在磁盘上存储多份。\",\"MQTT 协议的 Topic 则可以看作类似文件路径的字符串，可以有多个层级，如 home/kitchen/coffeemaker。订阅 Topic 时可以进行通配，以订阅一组路径的 Topic。在 IOT 场景下，Topic 数量可能会非常多。\",\"RocketMQ 原本的 Topic 是资源密集型的，并不适合海量 Topic 的场景。这体现在消息数据的存储和 Topic 元数据上。\",\"Topic 中的每个消息数据都会在磁盘上存储。\",\"所有 Topic 的元数据会上报到 NameServer，存储在内存中。\",\"当存在大量 Topic 时就会有严重的数据放大，占用大量磁盘存储空间和内存。\"]},\"1291\":{\"h\":\"2.1 实现思想\",\"t\":[\"对于上面两个痛点，LMQ 的实现思想是减少数据的重复存储，也减少元数据的内存占用。\",\"对于队列数据重复保存的问题，可以想到消费者消费时实际是读取消费队列 ConsumeQueue 进行消费，ConsumeQueue 将消费者和消息存储的 CommitLog 分开。那么可以用消费队列来表示一个 Topic，不同的消费队列可以复用 CommitLog 中存储的数据，但是对消费者来说看到的是多个消费队列。\",\"此外，用消费队列表示的好处还在于，它不会作为元数据上报到 NameServer。不过消费者需要在消费时指定拉取这个消费队列才可以消费。\",\"那么轻量级队列的实现也就呼之欲出：用消费队列来表示轻量级队列，消息存到 CommitLog 后分发构建索引时，构建轻量级队列。这样，一个 Topic 构建的队列除了它本身的读写队列以外，还可以包含大量轻量级队列。这样的队列模型也有助于实现 MQTT 与 AMQP 协议的兼容。\"]},\"1292\":{\"h\":\"3. 详细设计\"},\"1293\":{\"h\":\"3.1 消息生产和消费\",\"t\":[\"LMQ 依赖于一个父 Topic 存在，父 Topic 的消息分发构建消费索引时会构建 LMQ。LMQ 不需要提前创建，只需要在生产消息时带有需要分发的 LMQ 属性，就会在分发时构建。\",\"在消费时，LMQ 不在对应 Topic 上报的元数据中，订阅 Topic 也无法消费到其 LMQ。要消费 LMQ，需要显式指定拉取或订阅的队列信息才可以。因为 LMQ 仅仅是一个队列，所以它的队列 ID 为 0。\"]},\"1294\":{\"h\":\"3.2 CommitLog 分发到 LMQ\",\"t\":[\"LMQ 实现的重点就是 CommitLog 在生成消费索引时一并生成 LMQ。生成 LMQ 消息的主要步骤有两步\",\"在消息存入 CommitLog 前，解析消息属性中是否有需要分发的 LMQ 属性，如果有则解析该属性，查询要分发的 LMQ 当前的逻辑偏移量。然后把这些属性封装放入消息属性中，以便构建 LMQ 时使用。\",\"消息存入 CommitLog 后，索引构建线程 ReputMessageService 为每个消息构建消费队列时，会检查消息属性，判断是否需要分发构建 LMQ。如果属性中有 LMQ 和其逻辑偏移量，则从该偏移量开始构建 LMQ。\",\"处理 LMQ 消息分发的逻辑主要在 MultiDispatch 类中（4.9.x 版本），最新的 5.x 版本引入了 ConsumeQueueInterface 将这部分代码重构，放到 ConsumeQueue 中。\",\"分发 LMQ 逻辑如下：\",\"消息存到 CommitLog 之前，先调用 MultiDispatch.wrapMultiDispatch() （5.x 中 ConsumeQueue#assignQueueOffset()）方法，获取消息属性中需要分发的 LMQ 信息，然后查询 LMQ 当前的偏移量，把 LMQ 消息需要分发的新偏移量也放入消息属性。\",\"消息分发，生成消费索引\",\"生成消息的消费索引之后，如果需要分发到 LMQ，则执行 ConsumeQueue.multiDispatchLmqQueue() 方法进行分发。\"]},\"1295\":{\"h\":\"4. 源码解析\",\"t\":[\"（以 5.0.x 的源码为例）\"]},\"1296\":{\"h\":\"4.1 查询 LMQ 偏移量\",\"t\":[\"// CommitLog.java public CompletableFuture<PutMessageResult> asyncPutMessages(final MessageExtBatch messageExtBatch) { // ... try { defaultMessageStore.assignOffset(messageExtBatch, (short) putMessageContext.getBatchSize()); // ... result = mappedFile.appendMessages(messageExtBatch, this.appendMessageCallback, putMessageContext); // ... } // ... } \",\"/** * 查询要分发的队列的逻辑偏移量，放入消息属性 * * @param queueOffsetAssigner the delegated queue offset assigner * @param msg message itself * @param messageNum message number */ @Override public void assignQueueOffset(QueueOffsetAssigner queueOffsetAssigner, MessageExtBrokerInner msg, short messageNum) { String topicQueueKey = getTopic() + \\\"-\\\" + getQueueId(); long queueOffset = queueOffsetAssigner.assignQueueOffset(topicQueueKey, messageNum); msg.setQueueOffset(queueOffset); // 轻量级队列分发准备，为消息添加多队列分发属性 // For LMQ if (!messageStore.getMessageStoreConfig().isEnableMultiDispatch()) { return; } String multiDispatchQueue = msg.getProperty(MessageConst.PROPERTY_INNER_MULTI_DISPATCH); if (StringUtils.isBlank(multiDispatchQueue)) { return; } // 从原始消息属性中获取分发的队列列表 String[] queues = multiDispatchQueue.split(MixAll.MULTI_DISPATCH_QUEUE_SPLITTER); // 从队列偏移量表中查询当前队列偏移量 Long[] queueOffsets = new Long[queues.length]; for (int i = 0; i < queues.length; i++) { String key = queueKey(queues[i], msg); if (messageStore.getMessageStoreConfig().isEnableLmq() && MixAll.isLmq(key)) { queueOffsets[i] = queueOffsetAssigner.assignLmqOffset(key, (short) 1); } } // 将队列偏移量作为属性存入消息 MessageAccessor.putProperty(msg, MessageConst.PROPERTY_INNER_MULTI_QUEUE_OFFSET, StringUtils.join(queueOffsets, MixAll.MULTI_DISPATCH_QUEUE_SPLITTER)); // 移除消息的 WAIT_STORE 属性，节省存储空间 removeWaitStorePropertyString(msg); } \"]},\"1297\":{\"h\":\"4.2 分发 LMQ\",\"t\":[\"@Override public void putMessagePositionInfoWrapper(DispatchRequest request) { final int maxRetries = 30; boolean canWrite = this.messageStore.getRunningFlags().isCQWriteable(); // 写入ConsumeQueue，重试最多30次 for (int i = 0; i < maxRetries && canWrite; i++) { long tagsCode = request.getTagsCode(); if (isExtWriteEnable()) { ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit(); cqExtUnit.setFilterBitMap(request.getBitMap()); cqExtUnit.setMsgStoreTime(request.getStoreTimestamp()); cqExtUnit.setTagsCode(request.getTagsCode()); long extAddr = this.consumeQueueExt.put(cqExtUnit); if (isExtAddr(extAddr)) { tagsCode = extAddr; } else { log.warn(\\\"Save consume queue extend fail, So just save tagsCode! {}, topic:{}, queueId:{}, offset:{}\\\", cqExtUnit, topic, queueId, request.getCommitLogOffset()); } } // 写入ConsumeQueue，注意这里还未强制刷盘 boolean result = this.putMessagePositionInfo(request.getCommitLogOffset(), request.getMsgSize(), tagsCode, request.getConsumeQueueOffset()); if (result) { // 如果是SLAVE，在写入成功后更新CheckPoint中的最新写入时间。是为了修复在SLAVE中ConsumeQueue异常恢复慢的问题 // 因为在当前的设计中，没有更新SLAVE的消费队列时间戳到CheckPoint中的逻辑，所以在SLAVE中在doReput()逻辑中更新该时间戳 // https://github.com/apache/rocketmq/pull/1455 if (this.messageStore.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE || this.messageStore.getMessageStoreConfig().isEnableDLegerCommitLog()) { this.messageStore.getStoreCheckpoint().setPhysicMsgTimestamp(request.getStoreTimestamp()); } this.messageStore.getStoreCheckpoint().setLogicsMsgTimestamp(request.getStoreTimestamp()); if (checkMultiDispatchQueue(request)) { multiDispatchLmqQueue(request, maxRetries); } return; } else { // 只有一种情况会失败，创建新的MapedFile时报错或者超时 // 写入失败，等待1s继续写入，直到30次都失败 // XXX: warn and notify me log.warn(\\\"[BUG]put commit log position info to \\\" + topic + \\\":\\\" + queueId + \\\" \\\" + request.getCommitLogOffset() + \\\" failed, retry \\\" + i + \\\" times\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { log.warn(\\\"\\\", e); } } } // XXX: warn and notify me log.error(\\\"[BUG]consume queue can not write, {} {}\\\", this.topic, this.queueId); this.messageStore.getRunningFlags().makeLogicsQueueError(); } /** * 判断消息是否需要执行多队列分发 * * @param dispatchRequest 投递请求 * @return 是否需要分发 */ private boolean checkMultiDispatchQueue(DispatchRequest dispatchRequest) { if (!this.messageStore.getMessageStoreConfig().isEnableMultiDispatch()) { return false; } Map<String, String> prop = dispatchRequest.getPropertiesMap(); if (prop == null || prop.isEmpty()) { return false; } String multiDispatchQueue = prop.get(MessageConst.PROPERTY_INNER_MULTI_DISPATCH); String multiQueueOffset = prop.get(MessageConst.PROPERTY_INNER_MULTI_QUEUE_OFFSET); if (StringUtils.isBlank(multiDispatchQueue) || StringUtils.isBlank(multiQueueOffset)) { return false; } return true; } /** * Light message queue 分发到多个队列 * * @param request 分发请求 * @param maxRetries 最大重试次数，默认 30 */ private void multiDispatchLmqQueue(DispatchRequest request, int maxRetries) { Map<String, String> prop = request.getPropertiesMap(); String multiDispatchQueue = prop.get(MessageConst.PROPERTY_INNER_MULTI_DISPATCH); String multiQueueOffset = prop.get(MessageConst.PROPERTY_INNER_MULTI_QUEUE_OFFSET); String[] queues = multiDispatchQueue.split(MixAll.MULTI_DISPATCH_QUEUE_SPLITTER); String[] queueOffsets = multiQueueOffset.split(MixAll.MULTI_DISPATCH_QUEUE_SPLITTER); if (queues.length != queueOffsets.length) { log.error(\\\"[bug] queues.length!=queueOffsets.length \\\", request.getTopic()); return; } for (int i = 0; i < queues.length; i++) { String queueName = queues[i]; long queueOffset = Long.parseLong(queueOffsets[i]); int queueId = request.getQueueId(); // Light message queue 在每个 broker 上只有一个 queue，queueId 为 0 if (this.messageStore.getMessageStoreConfig().isEnableLmq() && MixAll.isLmq(queueName)) { queueId = 0; } doDispatchLmqQueue(request, maxRetries, queueName, queueOffset, queueId); } return; } /** * 分发消息到消费索引 * * @param request * @param maxRetries * @param queueName * @param queueOffset * @param queueId */ private void doDispatchLmqQueue(DispatchRequest request, int maxRetries, String queueName, long queueOffset, int queueId) { // 查找 ConsumeQueue ConsumeQueueInterface cq = this.messageStore.findConsumeQueue(queueName, queueId); boolean canWrite = this.messageStore.getRunningFlags().isCQWriteable(); for (int i = 0; i < maxRetries && canWrite; i++) { // 向 ConsumeQueue 写入索引项 boolean result = ((ConsumeQueue) cq).putMessagePositionInfo(request.getCommitLogOffset(), request.getMsgSize(), request.getTagsCode(), queueOffset); if (result) { break; } else { log.warn(\\\"[BUG]put commit log position info to \\\" + queueName + \\\":\\\" + queueId + \\\" \\\" + request.getCommitLogOffset() + \\\" failed, retry \\\" + i + \\\" times\\\"); try { Thread.sleep(1000); } catch (InterruptedException e) { log.warn(\\\"\\\", e); } } } } \"]},\"1298\":{\"h\":\"参考资料\",\"t\":[\"RIP28-Llight message queue (LMQ)\",\"RocketMQ LMQ 官方文档\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1299\":{\"h\":\"RocketMQ Netty 写缓冲区水位配置 NettyServerConfig#writeBufferHighWaterMark\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20230324-rocketmq-netty-write-buffer-watermark.html\",\"RocketMQ 4.9.3 版本中，Issue#3651 新增了 Netty 缓冲区高低水位的配置。\",\"该改动在服务端NettyServerConfig和客户端配置NettyClientConfig中新增了如下配置项：\",\"// NettySystemConfig.java public static int writeBufferHighWaterMark = Integer.parseInt(System.getProperty(COM_ROCKETMQ_REMOTING_WRITE_BUFFER_HIGH_WATER_MARK_VALUE, \\\"4194304\\\"));//4M public static int writeBufferLowWaterMark = Integer.parseInt(System.getProperty(COM_ROCKETMQ_REMOTING_WRITE_BUFFER_LOW_WATER_MARK, \\\"1048576\\\")); //1MB \",\"一开始的默认低水位为 1M，高水位为 4M，Issue#3825 将默认值改为 0。支持在配置文件中进行修改。\",\"这两个配置是 netty channel 的配置，原来的默认值分别为 32K 和 64K\",\"// WriteBufferWaterMark.java private static final int DEFAULT_LOW_WATER_MARK = 32 * 1024; private static final int DEFAULT_HIGH_WATER_MARK = 64 * 1024; public static final WriteBufferWaterMark DEFAULT = new WriteBufferWaterMark(DEFAULT_LOW_WATER_MARK, DEFAULT_HIGH_WATER_MARK, false); \",\"根据 Netty 的文档，这两个参数含义如下\",\"WriteBufferWaterMark 用于设置写缓冲区的低水位线和高水位线。\",\"如果在写缓冲区中排队的字节数超过了高水位线，Channel.isWritable() 将开始返回 false。\",\"如果在写缓冲区中排队的字节数先超过了高水位线，然后下降到低水位线以下，Channel.isWritable() 将再次开始返回 true。\",\"再看 Channel.isWritable() 的文档\",\"当且仅当I/O线程将立即执行所请求的写操作时返回 true。在此方法返回 false 时提交的写请求将被放入队列，直到I/O线程准备好处理队列中的写请求。\",\"https://www.liaoxuefeng.com/discuss/1279869501571105/1450880018677794\"]},\"1300\":{\"h\":\"WRITE_BUFFER_WATER_MARK\",\"t\":[\"控制 Netty 中 Write Buffer 的水位线\",\"要理解水位线 (wrter mark) 的概念，还要从 Netty 的 channel.write(...) 讲起。\",\"首先先来根据下面这张图来观察 write 的大致流程\",\"img\",\"首先，我们对一个 Channel 写入的时候，会先将需要 write 的对象封装为任务放入 Queue\",\"然后，同时 I/O 线程会定时将任务从 Queue 取出来，然后再经过 Pipeline 中各个处理器处理（图中未画出），再将处理结果写入到 Netty Buffer，然后到达操作系统的底层的 TCP 的发送缓冲区。\",\"最后，TCP 发送缓冲区中的数据会分包发送给对端，就是在这里的对面的 Client 的 TCP 接收缓冲区。\",\"需要注意的是，如果只是调用 channel.write(..) 方法是，该数据只会暂时存储到 Netty Buffer。在 channel.flush() 被调用后，则会发送信息 flush （即上图中标记为 \\\"F\\\" 的包），在 Netty Buffer 收到了 flush 控制包，才会将 Buffer 冲刷到 TCP Buffer。\",\"其中，TCP 连接的数据发送一方中的 TCP Buffer (发送缓冲区) 的大小由 SO_SNDBUF 控制，而 Netty Buffer 是\\\"无界\\\"的，且它的位置在堆外内存（Direct Buffer）。\",\"我们在一开始提到的水位线，则是标记当前 Netty Buffer 所使用的大小的一个值。当 Netty Buffer 的大小到达这个值后，调用 chanel.isWriteable 则会返回 false，且会通过调用业务 handler 的 writabilityChanged 方法来通知上层应用。\",\"同时水位线还分为高水位线和低水位线，到达高水位线后调用 chanel.isWriteable 则会返回 false ，直到下降到低水位线，调用时才会返回为 true 。\",\"不过，水位线只是一个警示，并不是实际上限，到达水位线后 Netty Buffer 仍然可以被写入，写入后会在由 Netty 维护的内部缓冲区进行排队。\",\"顺带一提，在之前的 netty 版本中，高水位线通过 WRITE_BUFFER_HIGH_WATER_MARK 设置，低水位线通过 WRITE_BUFFER_LOW_WATER_MARK，但现在已经被标记为 Deprecated，取而代之则是上文介绍的 WRITE_BUFFER_WATER_MARK，通过下列样式进行配置 .option(ChannelOption.WRITE_BUFFER_WATER_MARK, new WriteBufferWaterMark(10000, 20000))\",\"上面提到的 Netty Buffer 的在 Netty 中的类名为 ChannelOutboundBuffer；TCP Buffer 也叫 socket 发送缓冲区\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1301\":{\"h\":\"Rocketmq Filter 消息过滤（TAGS、SQL92）原理详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20230716-rocketmq-filter.html\"]},\"1302\":{\"h\":\"1. 背景\"},\"1303\":{\"h\":\"1.1 Rocketmq 支持的过滤方式\",\"t\":[\"Rocketmq 作为金融级的业务消息中间件，拥有强大的消息过滤能力。其支持多种消息过滤方式：\",\"表达式过滤：通过设置过滤表达式的方式进行过滤 \",\"TAG：根据消息的 tag 进行过滤。\",\"SQL92：可以用 SQL92 表达式来灵活地过滤消息的 tag 和属性。\",\"类过滤：可以新建一个过滤类，编写自定义的过滤规则。\"]},\"1304\":{\"h\":\"1.2 使用方法\"},\"1305\":{\"h\":\"1.2.1 TAG 过滤\",\"t\":[\"Tag 过滤是最简单的一种过滤方法，通常 Tag 可以用作消息的业务标识。可以设置 Tag 表达式，判断消息是否包含这个 Tag。\"]},\"1306\":{\"h\":\"生产者\",\"t\":[\"String[] tags = new String[] {\\\"TagA\\\", \\\"TagB\\\", \\\"TagC\\\"}; for (int i = 0; i < 60; i++) { Message msg = new Message(\\\"TagFilterTest\\\", tags[i % tags.length], // 设置消息 Tag \\\"Hello world\\\".getBytes(RemotingHelper.DEFAULT_CHARSET)); msg.setTags(tags[i % tags.length]); // 也可以通过 setTags 方法设置 Tag SendResult sendResult = producer.send(msg); } \"]},\"1307\":{\"h\":\"消费者\",\"t\":[\"在消费时，可以通过表达式过滤的方式设置需要过滤的 Tag，用 || 表达式表示或的意思，可以匹配多个 Tag。\",\"// 4.9.x consumer.subscribe(\\\"TagFilterTest\\\", \\\"TagA || TagC\\\"); \",\"在 Rocketmq 5.x 客户端之后，引入了新的订阅表达式写法：\",\"// 5.x // 只订阅消息标签为\\\"TagA\\\"、\\\"TagB\\\"或\\\"TagC\\\"的消息。 FilterExpression filterExpression = new FilterExpression(\\\"TagA||TagB||TagC\\\", FilterExpressionType.TAG); pushConsumer.subscribe(\\\"TagFilterTest\\\", filterExpression); \"]},\"1308\":{\"h\":\"1.2.2 SQL92\",\"t\":[\"SQL92 过滤比 Tag 过滤更灵活，它可以使用SQL92语法作为过滤规则表达式，可以过滤消息的属性和 Tag（在SQL语法中，Tag的属性名称为TAGS）。\",\"如果要使用 SQL92 过滤，需要设置 Broker 的配置项 enablePropertyFilter=true，这个配置默认为 false。\",\"enablePropertyFilter=true \",\"如果要开启布隆过滤器进行双层过滤，需要设置如下配置。\",\"enableCalcFilterBitMap=true # 设置在构造消费队列时，用布隆过滤器计算匹配过滤条件的消费组，构造成二进制数组 enableConsumeQueueExt=true # 启用消费队列扩展存储，二进制数组会存到扩展存储中 \",\"SQL92 的过滤语法规则如下：\",\"语法\",\"说明\",\"示例\",\"IS NULL\",\"判断属性不存在。\",\"a IS NULL ：属性a不存在。\",\"IS NOT NULL\",\"判断属性存在。\",\"a IS NOT NULL：属性a存在。\",\"> >= < <=\",\"用于比较数字，不能用于比较字符串，否则消费者客户端启动时会报错。 说明 可转化为数字的字符串也被认为是数字。\",\"a IS NOT NULL AND a > 100：属性a存在且属性a的值大于100。a IS NOT NULL AND a > 'abc'：错误示例，abc为字符串，不能用于比较大小。\",\"BETWEEN xxx AND xxx\",\"用于比较数字，不能用于比较字符串，否则消费者客户端启动时会报错。等价于>= xxx AND <= xxx。表示属性值在两个数字之间。\",\"a IS NOT NULL AND (a BETWEEN 10 AND 100)：属性a存在且属性a的值大于等于10且小于等于100。\",\"NOT BETWEEN xxx AND xxx\",\"用于比较数字，不能用于比较字符串，否则消费者客户端启动会报错。等价于< xxx OR > xxx，表示属性值在两个值的区间之外。\",\"a IS NOT NULL AND (a NOT BETWEEN 10 AND 100)：属性a存在且属性a的值小于10或大于100。\",\"IN (xxx, xxx)\",\"表示属性的值在某个集合内。集合的元素只能是字符串。\",\"a IS NOT NULL AND (a IN ('abc', 'def'))：属性a存在且属性a的值为abc或def。\",\"= <>\",\"等于和不等于。可用于比较数字和字符串。\",\"a IS NOT NULL AND (a = 'abc' OR a<>'def')：属性a存在且属性a的值为abc或a的值不为def。\",\"AND OR\",\"逻辑与、逻辑或。可用于组合任意简单的逻辑判断，需要将每个逻辑判断内容放入括号内。\",\"a IS NOT NULL AND (a > 100) OR (b IS NULL)：属性a存在且属性a的值大于100或属性b不存在。\"]},\"1309\":{\"h\":\"生产者\",\"t\":[\"String[] tags = new String[] {\\\"TagA\\\", \\\"TagB\\\", \\\"TagC\\\"}; for (int i = 0; i < 10; i++) { Message msg = new Message(\\\"SqlFilterTest\\\", tags[i % tags.length], (\\\"Hello RocketMQ \\\" + i).getBytes(RemotingHelper.DEFAULT_CHARSET) ); msg.putUserProperty(\\\"a\\\", String.valueOf(i)); // 设置消息属性 SendResult sendResult = producer.send(msg); System.out.printf(\\\"%s%n\\\", sendResult); } \"]},\"1310\":{\"h\":\"消费者\",\"t\":[\"// 4.9.x consumer.subscribe(\\\"SqlFilterTest\\\", MessageSelector.bySql(\\\"(TAGS is not null and TAGS in ('TagA', 'TagB'))\\\" + \\\"and (a is not null and a between 0 and 3)\\\")); \",\"// 5.x FilterExpression filterExpression = new FilterExpression(\\\"TAGS is not null and TAGS in ('TagA', 'TagB')\\\", FilterExpressionType.SQL92); simpleConsumer.subscribe(\\\"SqlFilterTest\\\", filterExpression); \"]},\"1311\":{\"h\":\"2. 概要设计\"},\"1312\":{\"h\":\"2.1 过滤信息的注册\",\"t\":[\"消费者启动时（和每隔一段时间）会向 Broker 端发送心跳，心跳的信息就包含消费者的订阅信息（和过滤信息）。Broker 端有一个专门的消费者过滤信息管理器，更新和存储消费者的过滤信息。\"]},\"1313\":{\"h\":\"2.2 表达式过滤\",\"t\":[\"表达式过滤的逻辑在 Broker 端处理消费者的拉取消息请求时执行。\",\"Rocketmq 的消息过滤接口MessageFilter 设计了两层过滤机制，它定义了两个方法，分别是根据消费队列过滤和根据消息详情过滤。这样设计的原因是：根据消息属性精确匹配的性能消耗比较大，所以先根据消费队列进行一次过滤，剩下的消息再根据消息详情过滤，可以减少比较次数，提升性能。\"]},\"1314\":{\"h\":\"2.2.1 Tag 过滤\",\"t\":[\"对于 Tag 过滤，在构建消费队列时会保存根据消息 Tag 生成的 Hash 码（Long 类型，8 字节）。\",\"根据消费队列过滤时，先计算消息的 Hash 码，判断是否与消费队列中保存的 hash 码一致。如果一致，说明消息的 Tag 有可能是过滤匹配的 Tag，需要进一步匹配。这是由于不同的 Tag 字符串计算出的 Hash 码可能相同。\",\"在 Broker 端，Tag 过滤不会进行进一步的匹配，而是在消费者端处理消息拉取结果时进行判断，如果过滤规则 Tag 集合中包含消息的 Tag，则返回给消费者，否则不消费。\"]},\"1315\":{\"h\":\"2.2.2 SQL92 过滤\",\"t\":[\"对于 SQL92 过滤，也有两层过滤机制。第一层根据消费队列过滤主要是用来在许多消费组之间筛选出有可能匹配的消费组，第二层过滤（消息详情过滤）则根据消费组设定的过滤表达式，根据消息的属性和 Tag 进行精确匹配过滤。\",\"具体的做法是，在消息生产时构造消费队列的过程当中，获取所有订阅该 Topic 的有过滤条件的消费组，预先根据这些消费组的过滤表达式进行一次精确匹配，计算出这条消息是否匹配。\",\"随后将这些匹配的消费组的名称通过布隆过滤器进行计算，得到一个二进制数组，将其放入消费队列的扩展存储中。\",\"布隆过滤器可以用来判断某个元素是否可能存在于集合中，在这里就用来判断这个消息是否可能匹配某个消费组的过滤规则。\",\"在第一层过滤（消费队列过滤）时，从消费队列扩展存储中取出这个消息的布隆过滤器产生的二进制数组，用它来判断这个消费者是否可能匹配过滤规则；然后在第二层过滤时将通过第一层过滤的消息信息进行 SQL92 表达式匹配。\",\"其中，在消息生产时用布隆过滤器计算二进制数组的操作和构造消费队列扩展存储的操作默认都是关闭的，也就是说默认只会进行 SQL92 表达式计算来精确匹配。如果要开启则需要设置一下配置项：\",\"enableCalcFilterBitMap=true # 设置在构造消费队列时，用布隆过滤器计算匹配过滤条件的消费组，构造成二进制数组 enableConsumeQueueExt=true # 启用消费队列扩展存储，二进制数组会存到扩展存储中 \",\"开启这两项相当于开启了第一层过滤（消费队列过滤），它其实是把精确过滤的逻辑提前到消息生产时来做。\"]},\"1316\":{\"h\":\"3. 详细设计\"},\"1317\":{\"h\":\"3.1 过滤信息注册\",\"t\":[\"Tag 过滤信息和 SQL92 过滤信息的保存位置不同。\",\"Tag 过滤信息由消费者发送心跳时有 Broker 端心跳处理方法调用 ConsumerManager#registerConsumer 进行更新，它存在 ConsumerManager 的 ConcurrentMap<String/* Group */, ConsumerGroupInfo> consumerTable 表中。其中的 SubscriptionData 就保存着 Tag 过滤表达式。\",\"SQL92 过滤信息的注册也是由消费这发送心跳触发，它的存储位置是 ConsumerFilterManager，最终的 ConsumerFilterData 中包含了编译好的过滤表达式。\"]},\"1318\":{\"h\":\"3.2 过滤器接口\",\"t\":[\"image-20230702220114234\",\"Rocketmq 的消息过滤逻辑（表达式过滤、类过滤）都需要实现 MessageFilter 接口。它的两个方法先后在从 MessageStore 获取消息时调用。通过这两个过滤方法，可以实现二层过滤，先根据较少的信息（消费队列）进行一次粗粒度的过滤，再根据完整的消息信息做精确过滤，这样能够减少精确过滤的次数，提升性能。\",\"boolean isMatchedByConsumeQueue(Long tagsCode, ConsumeQueueExt.CqExtUnit cqExtUnit)：根据消费队列判断消息是否匹配过滤规则 \",\"Long tagsCode：存在消费队列中消息的 Hash 码\",\"CqExtUnit cqExtUnit：消息消费队列扩展属性，为 SQL92 过滤专用，需要开启配置项才会存储扩展属性。\",\"boolean isMatchedByCommitLog(ByteBuffer msgBuffer, Map<String, String> properties)：根据完整消息来判断消息是否匹配过滤规则 \",\"ByteBuffer msgBuffer：完整消息内容\",\"Map<String, String> Properties：消息属性，主要用于 SQL92 过滤\",\"SQL92 和 Tag 过滤的逻辑都在 ExpressionMessageFilter 中，ExpressionForRetryMessageFilter 则为支持重试 Topic 的 Filter 实现。\",\"其中 Tag 过滤只用到 isMatchedByConsumeQueue，而 SQL92 过滤主要用到 isMatchedByCommitLog，如果开启了一些配置则也会用到 isMatchedByConsumeQueue。\",\"下面是 Tag 过滤的主方法 isMatchedByConsumeQUeue 和 isMatchedByCommitLog的调用层级（在 getMessage 中先后被调用）：\",\"PullMessageProcessor#processRequest： Broker 端消息拉取请求的入口。先尝试从消息拉取请求中获取过滤信息，如果没有则从服务端 ConsumerManager 中获取过滤信息，然后用订阅信息构造一个 ExpressionMessageFilter，将其传入 getMessage 。\",\"DefaultMessageStore#getMessage ：先根据 Topic 和队列 offset 获取消息的消费索引，然后根据消费索引从 CommitLog 查出完整消息。\",\"查出消费索引后，会先执行 isMatchedByConsumeQueue 的判断\",\"查出完整消息后，再执行 isMatchedByCommitLog 的判断\"]},\"1319\":{\"h\":\"3.3 Tag 过滤\",\"t\":[\"Rocketmq 的消费队列中专门开辟了 8 个字节的存储位置用于存储消息的 Tag 字符串的 Hash 码，用来为 Tag 过滤进行初筛。之所以不直接存 Tag 字符串，是因为 ConsumeQueue 的存储项是定长结构，加快处理性能。而且 ConsumeQueue 是内存映射文件，每个文件也不宜太大。\",\"在消费者上报心跳，注册消费者时就会把过滤信息（Tag 的 Hash 码）生成，放入 ConsumerManager 中。\",\"拉取消息时会先根据拉取消息的消费者信息，构造 ExpressionMessageFilter。\",\"在 Broker 端，调用 ExpressionMessageFilter#isMatchedByConsumeQueue 方法判断该消息 Tag 的 Hash 码是否在过滤规则允许的 Tag Hash 码列表中，如果在则表示该消息可能符合过滤条件，返回给消费者。\",\"在消费者端处理拉取结果的方法 PullApiWrapper#processPullResult 中，再进行精确判断，如果过滤匹配的 Tag 字符串列表中包含消息的 Tag，则返回给消费者消费。\"]},\"1320\":{\"h\":\"3.4 SQL92 过滤\"},\"1321\":{\"h\":\"3.4.1 编译 SQL 语句\",\"t\":[\"Rocketmq 从 ActiveMQ 中拿到的 SelectorParser.jj 语法标准文件，在其之上做了一些修改。用它能够将消费者端指定的 SQL 语句解析为 Expression 表达式对象，方便后续消息的过滤匹配。\",\"JavaCC (Java Compiler Compiler) 是一个能生成语法和词法分析器的生成程序，它通过阅读一个自定义的语法标准文件 (通常以 jj 为后缀名) ，然后就能生成能够解析该语法的扫描器和解析器的代码。\",\"通过执行 javacc SelectorParser.jj 命令以后，其会生成如下七个 Java 文件，用以解析 SQL 语法：\",\"JavaCC 生成的文件\",\"其中 SelectorParser.java 是主要的解析器类，会将 SQL92 表达式解析成一个抽象语法树（由 Expression 对象组成）。\",\"SqlFilter#compile 作为表达式编译的入口，内部调用 SelectorParser#parse 方法，将 SQL92 语句编译成 Expression 表达式对象。\",\"Rocketmq 实现了一些基本的 Expression 用以执行基本的 SQL92 过滤逻辑：\",\"image-20230703004414898\",\"编译 SQL92 Expression 表达式的时机与 Tag 表达式类似。消费者上报心跳，注册消费者时会预先编译好，放在 ConsumerFilterManager 中。\",\"在 Broker 端处理拉取消息请求时，先判断拉取消息请求是否带有过滤信息，如果带有，则根据过滤信息编译；否则从 ConsumerFilterManager 中获取编译好的 Expression 树。\"]},\"1322\":{\"h\":\"3.4.2 布隆过滤器 BloomFilter\",\"t\":[\"注意，仅 isEnableCalcFilterBitMap 配置为 true 时才使用布隆过滤器进行第一层过滤。否则仅进行第二层过滤。\",\"SQL92 的二层过滤中，第一层利用布隆过滤器判断这个消息是否大概率要被对应的消费者拉取，第二层则执行精确的过滤匹配。\",\"布隆过滤器的优点是它的空间占用率非常小，缺点则是只能判断出元素大概率存在集合中，但是无法确定。\",\"它主要提供了两个方法：put 用来将元素加入到集合中，contains 判断元素在集合中是否大概率存在，一般不能删除数据。\",\"存入的原理是：对要插入的元素进行 K 次 Hash 运算，将每次运算结果保存到一个二进制数组的一个下标中。\",\"img\",\"查询的原理是：对需要查询的数据进行 K 次同样的 Hash 运算，判断运算的结果是否都为 1。\"]},\"1323\":{\"h\":\"3.4.3 生成布隆过滤器位数组\",\"t\":[\"SQL92 过滤如果开启如下配置，则会在消息生产的构建索引阶段 CommitLogDispatcherCalcBitMap#dispatch() 计算出布隆过滤器的位数组，然后保存到消费队列索引的扩展存储中。\",\"enableCalcFilterBitMap=true # 设置在构造消费队列时，用布隆过滤器计算匹配过滤条件的消费组，构造成二进制数组 enableConsumeQueueExt=true # 启用消费队列扩展存储，二进制数组会存到扩展存储中 \",\"Rocketmq 的布隆过滤器实现与 Guava 的不太一样，它没有把二进制位数组 BitsArray 存到布隆过滤器中，而是无状态的，每次运算都需要传入这个数组运算函数。\",\"它的方法：\",\"put 方法：\",\"// 将 filterData 存入 BitsArray void hashTo(BloomFilterData filterData, BitsArray bits) \",\"contains 方法：\",\"// 检查给定的 BloomFilterData 对应数据是否在 BitsArray 中 boolean isHit(BloomFilterData filterData, BitsArray bits) \",\"bits：存储所有消费者名称经过 K 次 Hash 结果的位数组\",\"在消息生产时在 reput 步骤由 CommitLogDispatcherCalcBitMap 中调用 hashTo 生成，存到 ConsumeQueueExt 中。\",\"遍历所有消费者（的过滤信息），将所有消费者名称经过 K 次 Hash，存入位数组。（相当于将所有需要过滤的消费者名称存入布隆过滤器）\",\"BloomFilterData：本次拉取消息的消费者的过滤信息\",\"在消费者注册时根据消费者名称和订阅的 Topic 生成。\",\"BloomFilterData bloomFilterData = bloomFilter.generate(consumerGroup + \\\"#\\\" + topic); \",\"其中包含有消费者名称经过 K 次 Hash 得到的位数组 int[] bitPos\",\"class BloomFilterData { private int[] bitPos; private int bitNum; } \"]},\"1324\":{\"h\":\"3.4.4 消息过滤\",\"t\":[\"消息的两层过滤与 Tag 过滤一样，在拉消息方法中被调用。\",\"在拉取消息处理方法中，根据拉取消息的消费者信息，从 ConsumerFilterManager 中获取过滤数据，生成 ExpressionMessageFilter 对象。\",\"先调用 ExpressionMessageFilter#isMatchedByConsumeQueue，利用布隆过滤器进行初筛。判断拉消息的消费者是否可能需要消费到这条消息。\",\"然后调用 isMatchedByCommitLog 方法，用编译好的 Expression 进行过滤逻辑判断。\"]},\"1325\":{\"h\":\"3.4.5 是否启用布隆过滤器（第一层过滤）\",\"t\":[\"如上面所述，SQL92 过滤可以选择在消息生产的构建索引阶段预先计算布隆过滤器的位数组，然后就可以在第一层过滤时初筛掉大部分无需消费这条消息的消费组。那么开启布隆过滤器之后消费和生产的性能如何？开启之后可以消费的更快吗？\",\"带着这个疑问我做了一些压测，实际结果是开启布隆过滤器之后生产消费速度与开启之前差距并不明显。\",\"压测的过滤条件为：TAGS in ('TAG1', 'TAG2', ... , 'TAG128')，消息的 tag 为：TAG128\",\"未开启布隆过滤器：纯采用第二层过滤，由表达式直接匹配，占用总 CPU 时间为 5.28%\",\"开启布隆过滤器：生成索引占用 CPU 时间 4.2%，拉取时用两层过滤，第二层过滤的时间占用减少了，为 2.66%\",\"总结：采用布隆过滤器确实可以减少消息拉取时过滤的耗时，但也会增加消息保存时构建索引的时间，并且消费队列索引扩展文件会创建新的文件。所以我认为在大部分情况下不需要开启布隆过滤器（默认也未开启）。\"]},\"1326\":{\"h\":\"4. 源码解析\"},\"1327\":{\"h\":\"4.1 Tag 过滤\"},\"1328\":{\"h\":\"4.1.1 Broker 端过滤\",\"t\":[\"// ExpressMessageFilter.java /** * 根据 ConsumeQueue 中的属性哈希码进行过滤 * * @param tagsCode tagsCode * @param cqExtUnit extend unit of consume queue * @return */ @Override public boolean isMatchedByConsumeQueue(Long tagsCode, ConsumeQueueExt.CqExtUnit cqExtUnit) { if (null == subscriptionData) { return true; } // 如果是类过滤模式，直接返回 true if (subscriptionData.isClassFilterMode()) { return true; } // Tag 过滤 // by tags code. if (ExpressionType.isTagType(subscriptionData.getExpressionType())) { // 消息发送时没有设置 Tag，返回 true if (tagsCode == null) { return true; } // 允许任意 Tag，返回 true if (subscriptionData.getSubString().equals(SubscriptionData.SUB_ALL)) { return true; } // 返回过滤数据的 Tag 哈希码表中是否包含发送消息的哈希码 return subscriptionData.getCodeSet().contains(tagsCode.intValue()); } else { // SQL92 表达式过滤 // ... } return true; } \"]},\"1329\":{\"h\":\"4.1.2 客户端过滤\",\"t\":[\"// PullAPIWrapper.java /** * 拉取消息结果处理 * 消息过滤 & 将二进制消息解析成对象 * * @param mq * @param pullResult * @param subscriptionData * @return */ public PullResult processPullResult(final MessageQueue mq, final PullResult pullResult, final SubscriptionData subscriptionData) { PullResultExt pullResultExt = (PullResultExt) pullResult; // 根据拉取结果，更新下次从哪个节点拉取消息 this.updatePullFromWhichNode(mq, pullResultExt.getSuggestWhichBrokerId()); // 拉取成功 if (PullStatus.FOUND == pullResult.getPullStatus()) { ByteBuffer byteBuffer = ByteBuffer.wrap(pullResultExt.getMessageBinary()); List<MessageExt> msgList = MessageDecoder.decodes(byteBuffer); List<MessageExt> msgListFilterAgain = msgList; if (!subscriptionData.getTagsSet().isEmpty() && !subscriptionData.isClassFilterMode()) { // Tag 过滤模式 msgListFilterAgain = new ArrayList<MessageExt>(msgList.size()); for (MessageExt msg : msgList) { if (msg.getTags() != null) { // 如果过滤的 tag 集合中包含消息的 tag，则返回给消费者，否则不消费 if (subscriptionData.getTagsSet().contains(msg.getTags())) { msgListFilterAgain.add(msg); } } } } // ... } pullResultExt.setMessageBinary(null); return pullResult; } \"]},\"1330\":{\"h\":\"4.2 SQL92 过滤\"},\"1331\":{\"h\":\"4.2.1 注册过滤信息\",\"t\":[\"// DefaultConsumerIdsChangeListener.java /** * 消费者注册、注销，或连接断开时触发 */ @Override public void handle(ConsumerGroupEvent event, String group, Object... args) { if (event == null) { return; } switch (event) { case CHANGE: // 如果发生变化，向所有消费者发送重平衡请求 if (args == null || args.length < 1) { return; } // 获取消费组中所有消费者的 Channel List<Channel> channels = (List<Channel>) args[0]; if (channels != null && brokerController.getBrokerConfig().isNotifyConsumerIdsChangedEnable()) { for (Channel chl : channels) { // 发送重平衡请求 this.brokerController.getBroker2Client().notifyConsumerIdsChanged(chl, group); } } break; case UNREGISTER: this.brokerController.getConsumerFilterManager().unRegister(group); break; case REGISTER: if (args == null || args.length < 1) { return; } Collection<SubscriptionData> subscriptionDataList = (Collection<SubscriptionData>) args[0]; // 新消费者注册，更新过滤信息 this.brokerController.getConsumerFilterManager().register(group, subscriptionDataList); break; default: throw new RuntimeException(\\\"Unknown event \\\" + event); } } \",\"// ConsumerFilterManager.java /** * 注册 SQL92 的过滤信息，构造布隆过滤器 * * @param topic * @param consumerGroup * @param expression * @param type * @param clientVersion * @return */ public boolean register(final String topic, final String consumerGroup, final String expression, final String type, final long clientVersion) { if (ExpressionType.isTagType(type)) { return false; } if (expression == null || expression.length() == 0) { return false; } FilterDataMapByTopic filterDataMapByTopic = this.filterDataByTopic.get(topic); if (filterDataMapByTopic == null) { FilterDataMapByTopic temp = new FilterDataMapByTopic(topic); FilterDataMapByTopic prev = this.filterDataByTopic.putIfAbsent(topic, temp); filterDataMapByTopic = prev != null ? prev : temp; } // 生成布隆过滤器的位数据，保存到消费者过滤信息中。 BloomFilterData bloomFilterData = bloomFilter.generate(consumerGroup + \\\"#\\\" + topic); // 生成消费者过滤信息，保存到 Broker 的 ConsumerFilterManager 过滤信息管理器 return filterDataMapByTopic.register(consumerGroup, expression, type, bloomFilterData, clientVersion); } \"]},\"1332\":{\"h\":\"4.2.2 消息生产时构建布隆过滤器数据\",\"t\":[\"// CommitLogDispatcherCalcBitMap.java @Override public void dispatch(DispatchRequest request) { // enableCalcFilterBitMap 配置开启时才创建位数组 if (!this.brokerConfig.isEnableCalcFilterBitMap()) { return; } try { Collection<ConsumerFilterData> filterDatas = consumerFilterManager.get(request.getTopic()); if (filterDatas == null || filterDatas.isEmpty()) { return; } Iterator<ConsumerFilterData> iterator = filterDatas.iterator(); BitsArray filterBitMap = BitsArray.create( this.consumerFilterManager.getBloomFilter().getM() ); long startTime = System.currentTimeMillis(); // 遍历所有注册的带有 SQL92 表达式的消费者，判断是否通过过滤，如果没有被过滤，则消费者名称的位映射，放入到 filterBitMap 中 while (iterator.hasNext()) { ConsumerFilterData filterData = iterator.next(); if (filterData.getCompiledExpression() == null) { log.error(\\\"[BUG] Consumer in filter manager has no compiled expression! {}\\\", filterData); continue; } if (filterData.getBloomFilterData() == null) { log.error(\\\"[BUG] Consumer in filter manager has no bloom data! {}\\\", filterData); continue; } Object ret = null; try { MessageEvaluationContext context = new MessageEvaluationContext(request.getPropertiesMap()); ret = filterData.getCompiledExpression().evaluate(context); } catch (Throwable e) { log.error(\\\"Calc filter bit map error!commitLogOffset={}, consumer={}, {}\\\", request.getCommitLogOffset(), filterData, e); } log.debug(\\\"Result of Calc bit map:ret={}, data={}, props={}, offset={}\\\", ret, filterData, request.getPropertiesMap(), request.getCommitLogOffset()); // eval true if (ret != null && ret instanceof Boolean && (Boolean) ret) { // 将消费组对应的位数据（由 \\\"消费组#Topic\\\" Hash 生成）保存到位数组中 consumerFilterManager.getBloomFilter().hashTo( filterData.getBloomFilterData(), filterBitMap ); } } // 将所有没有被过滤的消费者名称计算出的位映射，放入 DispatchRequest 中，尝试存入 ConsumeQueueExt 文件中（如果开关开启）。 request.setBitMap(filterBitMap.bytes()); long elapsedTime = UtilAll.computeElapsedTimeMilliseconds(startTime); // 1ms if (elapsedTime >= 1) { log.warn(\\\"Spend {} ms to calc bit map, consumerNum={}, topic={}\\\", elapsedTime, filterDatas.size(), request.getTopic()); } } catch (Throwable e) { log.error(\\\"Calc bit map error! topic={}, offset={}, queueId={}, {}\\\", request.getTopic(), request.getCommitLogOffset(), request.getQueueId(), e); } } \"]},\"1333\":{\"h\":\"4.2.3 消息拉取时过滤\",\"t\":[\"一层过滤\",\"// ExpressionMessageFilter.java /** * 根据 ConsumeQueue 中的属性哈希码进行过滤 * * @param tagsCode tagsCode * @param cqExtUnit extend unit of consume queue * @return */ @Override public boolean isMatchedByConsumeQueue(Long tagsCode, ConsumeQueueExt.CqExtUnit cqExtUnit) { if (null == subscriptionData) { return true; } // 如果是类过滤模式，直接返回 true if (subscriptionData.isClassFilterMode()) { return true; } // Tag 过滤 // by tags code. if (ExpressionType.isTagType(subscriptionData.getExpressionType())) { // ... } else { // SQL92 表达式过滤 // no expression or no bloom if (consumerFilterData == null || consumerFilterData.getExpression() == null || consumerFilterData.getCompiledExpression() == null || consumerFilterData.getBloomFilterData() == null) { return true; } // message is before consumer if (cqExtUnit == null || !consumerFilterData.isMsgInLive(cqExtUnit.getMsgStoreTime())) { log.debug(\\\"Pull matched because not in live: {}, {}\\\", consumerFilterData, cqExtUnit); return true; } // 从 ConsumeQueueExt 中取出消息 Reput 时计算的 BitMap，它表示通过过滤条件的所有 SQL92 消费者名称。 byte[] filterBitMap = cqExtUnit.getFilterBitMap(); BloomFilter bloomFilter = this.consumerFilterManager.getBloomFilter(); if (filterBitMap == null || !this.bloomDataValid || filterBitMap.length * Byte.SIZE != consumerFilterData.getBloomFilterData().getBitNum()) { return true; } BitsArray bitsArray = null; try { // 判断当前消费者是否需要消费该消息（是否通过过滤），如果返回 true，表示可能需要消费该消息，false 则一定不需要消费 bitsArray = BitsArray.create(filterBitMap); boolean ret = bloomFilter.isHit(consumerFilterData.getBloomFilterData(), bitsArray); log.debug(\\\"Pull {} by bit map:{}, {}, {}\\\", ret, consumerFilterData, bitsArray, cqExtUnit); return ret; } catch (Throwable e) { log.error(\\\"bloom filter error, sub=\\\" + subscriptionData + \\\", filter=\\\" + consumerFilterData + \\\", bitMap=\\\" + bitsArray, e); } } return true; } \",\"二层过滤\",\" /** * 根据 CommitLog 中保存的消息内容进行过滤，主要为 SQL92 表达式模式过滤服务 * * @param msgBuffer message buffer in commit log, may be null if not invoked in store. * @param properties message properties, should decode from buffer if null by yourself. * @return */ @Override public boolean isMatchedByCommitLog(ByteBuffer msgBuffer, Map<String, String> properties) { if (subscriptionData == null) { return true; } // 类过滤模式 if (subscriptionData.isClassFilterMode()) { return true; } // TAG 模式 if (ExpressionType.isTagType(subscriptionData.getExpressionType())) { return true; } ConsumerFilterData realFilterData = this.consumerFilterData; Map<String, String> tempProperties = properties; // no expression if (realFilterData == null || realFilterData.getExpression() == null || realFilterData.getCompiledExpression() == null) { return true; } // 从消息 Buffer 中解码消息属性 if (tempProperties == null && msgBuffer != null) { tempProperties = MessageDecoder.decodeProperties(msgBuffer); } Object ret = null; try { MessageEvaluationContext context = new MessageEvaluationContext(tempProperties); // 用编译好的 SQL92 表达式去过滤消息属性 ret = realFilterData.getCompiledExpression().evaluate(context); } catch (Throwable e) { log.error(\\\"Message Filter error, \\\" + realFilterData + \\\", \\\" + tempProperties, e); } log.debug(\\\"Pull eval result: {}, {}, {}\\\", ret, realFilterData, tempProperties); if (ret == null || !(ret instanceof Boolean)) { return false; } return (Boolean) ret; } \"]},\"1334\":{\"h\":\"参考资料\",\"t\":[\"官方文档——消息过滤\",\"RocketMQ 消息过滤流程——赵坤\",\"源码分析RocketMQ消息过滤机制下篇-FilterServer、ClassFilter模式详解——丁威\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1335\":{\"h\":\"Rocketmq 5.0 任意时间定时消息（RIP-43） 原理详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20230808-rocketmq-timer.html\"]},\"1336\":{\"h\":\"1. 背景\"},\"1337\":{\"h\":\"1.1 概念和应用场景\",\"t\":[\"延迟消息（定时消息）即消息到达消息队列服务端后不会马上投递，而是到达某个时间才投递给消费者。它在在当前的互联网环境中有非常大的需求。\",\"例如电商/网约车等业务中都会出现的订单场景，客户下单后并不会马上付款，但是这个订单也不可能一直开着，因为订单会占用商品/网约车资源。这时候就需要一个机制，在比如 5 分钟后进行一次回调，回调关闭订单的方法。 这个回调的触发可以用分布式定时任务来处理，，但是更好的方法可以是使用消息队列发送一个延迟消息，因为一条消息会比一个分布式定时任务轻量得多。 开启一个消费者消费订单取消 Topic 的消息，收到消息后关闭订单，简单高效。\",\"当用户支付了订单，那么这个订单不再需要被取消，刚才发的延迟消息也不再需要被投递。当然，你可以在消费消息时判断一下订单的状态以确定是否需要关闭，但是这样做会有一次额外的数据库操作。如果可以取消定时消息，那么只要发送一条定时消息取消的命令就可以取消之前发送的定时消息投递。\",\"除此之外，定时消息还能用于更多其他场景，如定时任务触发、等待重试、事件预订等等。\"]},\"1338\":{\"h\":\"1.2 延迟消息与定时消息\",\"t\":[\"首先需要明确延迟消息与定时消息虽然意思不同，但在体现的效果上确实相同的，都是在消息生产到 Broker 之一段时间之后才会被投递（消费者可以消费到）。只不过在使用的 API 上，延迟消息指定延迟的时间，而定时消息指定确切的投递时间。实际上它们可以实现相同的效果。\",\"在 Rocketmq 4.x 中只支持通过设定延迟等级来支持 18 个固定延迟时间。具体的原理可以看 RocketMQ 延迟消息（定时消息）源码解析。\",\"4.x 的延迟消息有很大的局限性，它无法支持任意时间的定时，而且最大的定时时间也只有 2 小时，它的性能也达不到普通消息（后来 4.x 的延迟消息性能被优化，详见 RocketMQ 延迟消息（定时消息）4.9.3 版本优化 异步投递支持。\",\"许多公司不满足于它的能力，自研了任意时间定时消息，扩展了最大定时时长。\",\"在 Rocketmq 5.x 中终于开源了支持任意时间的定时消息（以下简称定时消息）。它与 4.x 的延迟消息是两套实现机制，互相之间几乎不影响。\"]},\"1339\":{\"h\":\"1.2 任意时间定时消息的使用\",\"t\":[\"在 Rocketmq 5.x 的客户端中，在构造消息时提供了 3 个 API 来指定延迟时间或定时时间。\",\"Message message = new Message(TOPIC, (\\\"Hello scheduled message \\\" + i).getBytes(StandardCharsets.UTF_8)); // 延迟 10s 后投递 message.setDelayTimeSec(10); // 延迟 10000ms 后投递 message.setDelayTimeMs(10_000L); // 定时投递，定时时间为当前时间 + 10000ms message.setDeliverTimeMs(System.currentTimeMillis() + 10_000L); // 发送消息 SendResult result = producer.send(message); \"]},\"1340\":{\"h\":\"2. 概要设计\"},\"1341\":{\"h\":\"2.1 任意时间定时消息的难点\",\"t\":[\"任意时间定时消息的实现存在一定的难点，所以 4.x 才会实现 18 个延迟等级的定时消息，作为一个折衷的方案。\",\"任意时间定时消息的主要难点有以下几个。\"]},\"1342\":{\"h\":\"2.1.1 难点1：任意的定时时间\",\"t\":[\"Rocketmq 4.x 的延迟消息的原理简单来说是：将延迟消息先不存到真正的 Topic，先存到一个延迟 Topic，然后周期性扫描这个 Topic 还未投递的消息是否到期，到期则投递到真正的 Topic 中。\",\"这个方案的局限性在于扫描的每个队列的消息延迟时间必须是相同的。否则会出现先扫描的消息要后投递的情况，如下图所示：\",\"队列中的第一个消息延迟 100s，从队列头开始扫描，需要等待第一个消息先投递，从队列中弹出，后面的消息才能投递。所以第一条消息会阻塞后续消息的投递。\",\"为了避免这个问题，Rocketmq 4.x 的延迟 Topic 中包含 18 个队列，每个队列代表一个延迟等级，对应一个固定的延迟时长，用一个周期性任务去扫描。\",\"但任意时间定时消息不可能无限制地增加延迟时长对应的队列数量，这是一个难点。\"]},\"1343\":{\"h\":\"2.1.2 难点2：定时消息的存储和老化\",\"t\":[\"我们知道 Rocketmq 的消息是有老化时间的，默认时间为 3 天。这就意味着延迟时间超过 3 天的消息可能会被老化清除，永远无法投递。\",\"让定时消息不受老化时间的限制，这也是一个难点。\"]},\"1344\":{\"h\":\"2.1.3 难点3：大量定时消息的极端情况\",\"t\":[\"在定时消息场景下有一种极端情况，就是在同一时刻定时了超大量的消息，需要在一瞬间投递（比如在 8 点定时了 1 亿条消息）。\",\"如果不进行流控直接写入，会把 Rocketmq 冲垮。\"]},\"1345\":{\"h\":\"2.2 设计思路\"},\"1346\":{\"h\":\"2.2.1 任意时间定时\",\"t\":[\"实现任意时间的定时的要点在于知道在某一时刻需要投递哪些消息，以及破除一个队列只能保存同一个延迟等级的消息的限制。\",\"联想 Rocketmq 的索引文件 IndexFile，可以通过索引文件来辅助定时消息的查询。需要建立这样的一个索引结构：Key 是时间戳，Value 表示这个时间要投递的所有定时消息。类似如下的结构：\",\"Map<Long /* 投递时间戳 */, List<Message /* 被定时的消息 */>> \",\"把这个索引结构以文件的形式实现，其中的 Message 可以仅保存消息的存储位置，投递的时候再查出来。\",\"RIP-43 中就引入了这样的两个存储文件：TimerWheel 和 TimerLog，存储结构如下图所示：\",\"TimerWheel 是时间轮的抽象，表示投递时间，它保存了 2 天（默认）内的所有时间窗。每个槽位表示一个对应的投递时间窗，并且可以调整槽位对应的时间窗长度来控制定时的精确度。\",\"采用时间轮的好处是它可以复用，在 2 天之后无需新建时间轮文件，而是只要将当前的时间轮直接覆盖即可。\",\"TimerLog 是定时消息文件，保存定时消息的索引（在CommitLog 中存储的位置）。它的存储结构类似 CommitLog，是 Append-only Log。\",\"TimerWheel 中的每个槽位都可以保存一个指向 TimerLog 中某个元素的索引，TimerLog 中的元素又保存它前一个元素的索引。也就是说，TimerLog 呈链表结构，存储着 TimerWheel 对应槽位时间窗所要投递的所有定时消息。\"]},\"1347\":{\"h\":\"2.2.2 定时消息轮转：避免定时消息被老化删除\",\"t\":[\"为了防止定时消息在投递之前就被老化删除，能想到的办法主要是两个：\",\"用单独的文件存储，不受 Rocketmq 老化时间限制\",\"在定时消息被老化之前，重新将他放入 CommitLog\",\"方法 1 需要引入新的存储文件，占用磁盘空间；方法 2 则需要在消息被老化前重新将其放入 CommitLog，增加了处理逻辑的复杂性。\",\"RIP-43 中选择了第二种方案，在定时消息放入时间轮前进行判断，如果在 2 天内要投递（在时间轮的时间窗口之内），则放入时间轮，否则重新放入 CommitLog 进行轮转。\"]},\"1348\":{\"h\":\"2.2.3 定时任务划分和解耦\",\"t\":[\"RIP-43 中，将定时消息的保存和投递分为多个步骤。为每个步骤单独定义了一个服务线程来处理。\",\"保存：\",\"从定时消息 Topic 中扫描定时消息\",\"将定时消息（偏移量）放入 TimerLog 和 TimeWheel 保存\",\"投递：\",\"从时间轮中扫描到期的定时消息（偏移量）\",\"根据定时消息偏移量，到 CommitLog 中查询完整的消息体\",\"将查到的消息投递到 CommitLog 的目标 Topic\",\"每两个步骤之间都使用了生产-消费模式，用一个有界的 BlockingQueue 作为任务的缓冲区，通过缓冲区实现每个步骤的流量控制。当队列满时，新的任务需要等待，无法直接执行。\"]},\"1349\":{\"h\":\"3. 详细设计\"},\"1350\":{\"h\":\"3.1 定时消息文件设计\",\"t\":[\"RIP-43 中引入了两个采用本地文件系统存储的文件：TimerWheel 和 TimerLog\"]},\"1351\":{\"h\":\"3.1.1 TimerWheel 时间轮\",\"t\":[\"时间轮是对时刻表的抽象，内部实际上是一个数组，表示一段时间。每项都是一个槽位，表示时刻表上的每一秒。采用时间轮的好处在于它可以循环使用，在时间轮表示的这段时间过去之后，无需创建新的文件，直接可以表示下一段时间。\",\"时间轮的每个槽位表示这一时刻需要投递的所有定时消息，槽位中保存了指向 TimerLog 的指针，与 TimerLog 一同构成一个链表，表示这组消息。\",\"时间轮的槽位设计如下：\",\"delayed_time(8B) 延迟时间\",\"first_pos(8B) 首条位置\",\"last_pos(8B) 最后位置\",\"num(4B)消息条数\",\"first_pos：TimerLog 中该时刻定时消息链表的第一个消息的物理偏移量（链表尾）\",\"last_pos：TimerLog 中该时刻定时消息链表的最后（最新）一个消息的物理偏移量（链表头）\"]},\"1352\":{\"h\":\"3.1.2 TimerLog 定时消息索引文件\",\"t\":[\"TimerLog 与 TimerWheel 配合，一起表示某一时刻需要投递的定时消息集合。\",\"它的形式是与 CommitLog 相似的 Append-only Log，不过每一项不需要保存消息的全量信息，只保存了消息在 CommitLog 上的物理偏移量，节省空间。\",\"它与 TimerWheel 中的槽位组成链表结构，所以它的每一项也有一个指向该项上一项的指针。\",\"它的每一项结构如下：\",\"名称\",\"大小\",\"备注\",\"size\",\"4B\",\"保存记录的大小\",\"prev_pos\",\"8B\",\"前一条记录的位置\",\"next_Pos\",\"8B\",\"后一条记录的位置，暂时为-1，作为保留字段\",\"magic\",\"4B\",\"magic value\",\"delayed_time\",\"4B\",\"该条记录的定时时间\",\"offset_real\",\"8B\",\"该条消息在commitLog中的位置\",\"size_real\",\"4B\",\"该条消息在commitLog中的大小\",\"hash_topic\",\"4B\",\"该条消息topic的hash code\",\"varbody\",\"存储可变的body，暂时没有为空\"]},\"1353\":{\"h\":\"3.2 定时消息投递步骤\",\"t\":[\"定时消息主要的逻辑可以分为保存和投递两个阶段，RIP-43 将每个节点都拆分成不同的任务（服务线程），用生产-消费模式衔接每个任务，实现任务的解耦和流控。\",\"如上图所示，带有 enqueue 的为定时消息保存的线程和队列，带有 dequeue 的为定时消息投递的线程和队列。\"]},\"1354\":{\"h\":\"3.2.1 定时消息保存\",\"t\":[\"定时消息在被保存到 CommitLog 前，会检查其的属性，如果消息属性中包含定时属性，则会将真正要投递的 Topic 暂存到消息属性中，把投递的 Topic 改成 rmq_sys_wheel_timer。\",\"随后等待服务线程扫描这个定时 Topic 中的消息，放入时间轮，开始定时。\",\"为了避免瞬时保存的定时消息过多，所以采用了生产-消费模式，将保存的过程分为扫描和入轮两个步骤。\"]},\"1355\":{\"h\":\"TimerEnqueueGetService 扫描定时消息\",\"t\":[\"这个线程通过遍历消费队列索引的方式不断扫描定时消息 Topic 中新的定时消息。\",\"扫描到了之后将消息从 CommitLog 中查出来，封装成 TimerRequest，放入有界阻塞队列 enqueuePutQueue。如果队列满，则会无限次重试等待，达到流控效果。\"]},\"1356\":{\"h\":\"TimerEnqueuePutService 将定时消息放入时间轮和 TimerLog\",\"t\":[\"不断扫描队列 enqueuePutQueue，取出 TimerRequest，并批量放入 TimerLog，再放入时间轮槽位。一批结束之后再操作下一批。\",\"如果定时时间小于当前写 TimerLog 的时间，说明消息已经到期，直接加入到 dequeuePutQueue，准备投递到 CommitLog。\"]},\"1357\":{\"h\":\"3.2.2 定时消息投递\",\"t\":[\"投递的步骤被分为三个任务：\",\"从时间轮中扫描到期的定时消息（偏移量）\",\"根据定时消息偏移量，到 CommitLog 中查询完整的消息体\",\"将查到的消息投递到 CommitLog 的目标 Topic\"]},\"1358\":{\"h\":\"TimerDequeueGetService 扫描时间轮中到期的消息\",\"t\":[\"这个线程的作用是：推进时间轮，将时间轮槽位对应的定时消息请求从时间轮和 TimerLog 中取出，加入到 dequeueGetQueue 中。\",\"每 0.1s 执行一次，根据当前扫描时间轮的时间戳，从时间轮和 TimerLog 中查询出 TimerRequest，并分成定时请求和定时消息取消请求两类。\",\"先批量将取消请求入队，等待处理完毕，再将定时消息请求入队，等待处理完毕。\",\"该槽位的定时消息都处理完成后，推进时间轮扫描时间到下一槽位。\"]},\"1359\":{\"h\":\"TimerDequeueGetMessageService 查询原始消息\",\"t\":[\"这个线程的作用是：处理 dequeueGetQueue 中的 TimerRequest，根据索引在 CommitLog 中查出原始消息，放到 dequeuePutQueue。\",\"从 dequeueGetQueue 中取出 TimerRequest\",\"对取出的 TimerRequst，从 CommitLog 中查询原始消息\",\"处理定时消息取消请求，查询出原始消息中要取消消息的 UNIQ_KEY，放入 deleteUniqKeys Set\",\"处理普通定时消息请求 \",\"如果 DeleteUniqKeys 中包含这个消息，则什么都不做（取消投递）\",\"否则将查出的原始消息放入 TimerRequest，然后将 TimerRequest 放入 dequeuePutQueue，准备投递到 CommitLog\"]},\"1360\":{\"h\":\"TimerDequeuePutMessageService 投递定时消息\",\"t\":[\"这个线程的作用是：将消息从 dequeuePutQueue 中取出，若已经到期，投递到 CommitLog 中\",\"无限循环从 dequeuePutQueue 中取出 TimerRequest\",\"将原始消息的 Topic 和 queueId 从消息属性中取出，用它们构造成一个新的消息\",\"将消息投递到 CommitLog\",\"如果投递失败，则需要等待{精确度 / 2}时间然后重新投递，必须保证消息投递成功。\"]},\"1361\":{\"h\":\"3.3 其他设计\"},\"1362\":{\"h\":\"3.3.1 定时消息文件的恢复\",\"t\":[\"Broker 可能存在正常或者异常宕机。TimerLog 和 TimerWheel 都有做定时持久化，所以对于已经持久化的数据影响不大。\",\"对于在内存中还未持久化的数据，可以通过 TimerLog 原封不动地还原出来。在 RIP-43 中设置了 Checkpoint 文件，以记录 TimerLog 中已经被 TimerWheel 记录的消息 offset。在重新启动时，将从该 checkpoint 记录的位置重新开始向后遍历 TimerLog 文件，并开始订正 TimerWheel 每一格中的头尾消息索引。\"]},\"1363\":{\"h\":\"3.3.2 随机读/PageCache 污染问题\",\"t\":[\"在 TimerLog 和 CommitLog 中去查询定时消息，都不可避免发生随机读。若要避免这个情况，势必要对消息的写入作进一步优化：排序，或者按时间轮的定位情况写入多个文件。但是这样可能带来另一个问题：大量的随机写。\",\"正如俗话说的，“读写难两全”。由于定时消息对于写入更加敏感，所以可以牺牲一定的读性能来保障写入的速度——当然，在性能测试中，该方案的读性能同样令人满意。\"]},\"1364\":{\"h\":\"3.3.3 另一种实现方案：RocksDB\",\"t\":[\"RIP-43 中还提出了另一种任意时间定时消息的实现方案，即使用 RocksDB（一种 KV 本地存储）。\",\"使用这种方式存储定时消息，将定时时间作为 Key，消息作为 Value，可以做到根据时间查询该时刻的所有定时消息。\",\"Key：定时时间 + Topic + 消息 ID\",\"Value：定时消息数据\",\"根据 Key 扫描 RocksDB 中的定时消息，如果到期则用生产-消费模式投递到 CommitLog 中。\",\"这种方式的优点是：\",\"流程较简单。\",\"可以避免消息的滚动导致的写放大。\",\"一定程度上避免 pagecache 的污染。\",\"缺点是：\",\"写入时需要排序，会额外消耗时间。\",\"在对 key 进行 compaction 的过程中可能会耗费额外的 CPU 资源。\",\"消息的检索需要消耗较多的计算资源。\",\"最终没有选用这种方案的考量：\",\"延时消息的写入速度与读取速度难以平衡。\",\"若 value 较大，大量消息的存储会导致 compaction 计算量较大。随着消息存储量的增加，写入速度将逐渐变慢。\",\"若采用 kv 分离以此保障写的速度，则读消息的速度将受到较严重的影响。\"]},\"1365\":{\"h\":\"4. 源码解析\"},\"1366\":{\"h\":\"4.1 定时消息文件\"},\"1367\":{\"h\":\"4.1.1 TimerWheel\",\"t\":[\"/** * 时间轮，用于定时消息到时 */ public class TimerWheel { /** * 槽位总数，默认为 604,800，为 7 天内的秒数 */ public final int slotsTotal; /** * 定时精度，默认 1s */ public final int precisionMs; /** * 根据时间戳获取槽位下标 * * @param timeMs 时间戳 * @return 槽位下标 */ public int getSlotIndex(long timeMs) { // 时间除以精度，然后对槽位总数 * 2取余 return (int) (timeMs / precisionMs % (slotsTotal * 2)); } /** * 将 TimerLog 写入的消息放入时间轮槽 * * @param timeMs 定时投递时间 * @param firstPos 该定时时间的第一条消息在 TimerLog 中的物理偏移量 * @param lastPos 该定时时间的最后（最新）一条消息在 TimerLog 中的物理偏移量 * @param num 该定时时间的消息数量 * @param magic */ public void putSlot(long timeMs, long firstPos, long lastPos, int num, int magic) { localBuffer.get().position(getSlotIndex(timeMs) * Slot.SIZE); localBuffer.get().putLong(timeMs / precisionMs); localBuffer.get().putLong(firstPos); localBuffer.get().putLong(lastPos); localBuffer.get().putInt(num); localBuffer.get().putInt(magic); } /** * 根据时间戳获取槽位 * * @param timeMs 时间戳 * @return 槽位 */ public Slot getSlot(long timeMs) { Slot slot = getRawSlot(timeMs); if (slot.timeMs != timeMs / precisionMs * precisionMs) { return new Slot(-1, -1, -1); } return slot; } //testable public Slot getRawSlot(long timeMs) { localBuffer.get().position(getSlotIndex(timeMs) * Slot.SIZE); return new Slot(localBuffer.get().getLong() * precisionMs, localBuffer.get().getLong(), localBuffer.get().getLong(), localBuffer.get().getInt(), localBuffer.get().getInt()); } } \"]},\"1368\":{\"h\":\"4.1.2 TimerLog\",\"t\":[\"public class TimerLog { /** * 将定时消息索引写入 TimerLog * * @param data * @param pos * @param len * @return TimerLog 写入的物理偏移量，写入失败返回 -1 */ public long append(byte[] data, int pos, int len) { MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile(); if (null == mappedFile || mappedFile.isFull()) { mappedFile = this.mappedFileQueue.getLastMappedFile(0); } if (null == mappedFile) { log.error(\\\"Create mapped file1 error for timer log\\\"); return -1; } if (len + MIN_BLANK_LEN > mappedFile.getFileSize() - mappedFile.getWrotePosition()) { ByteBuffer byteBuffer = ByteBuffer.allocate(MIN_BLANK_LEN); byteBuffer.putInt(mappedFile.getFileSize() - mappedFile.getWrotePosition()); byteBuffer.putLong(0); byteBuffer.putInt(BLANK_MAGIC_CODE); if (mappedFile.appendMessage(byteBuffer.array())) { //need to set the wrote position mappedFile.setWrotePosition(mappedFile.getFileSize()); } else { log.error(\\\"Append blank error for timer log\\\"); return -1; } mappedFile = this.mappedFileQueue.getLastMappedFile(0); if (null == mappedFile) { log.error(\\\"create mapped file2 error for timer log\\\"); return -1; } } long currPosition = mappedFile.getFileFromOffset() + mappedFile.getWrotePosition(); // 将定时消息索引写入 TimerLog if (!mappedFile.appendMessage(data, pos, len)) { log.error(\\\"Append error for timer log\\\"); return -1; } return currPosition; } /** * 根据偏移量获取 Buffer * * @param offsetPy TimerLog 中的物理偏移量 * @return */ public SelectMappedBufferResult getWholeBuffer(long offsetPy) { MappedFile mappedFile = mappedFileQueue.findMappedFileByOffset(offsetPy); if (null == mappedFile) return null; return mappedFile.selectMappedBuffer(0); } } \"]},\"1369\":{\"h\":\"4.2 定时消息投递步骤\"},\"1370\":{\"h\":\"4.2.1 TimerEnqueueGetService 保存——扫描定时消息\",\"t\":[\"/** * 从 commitLog 读取指定主题（TIMER_TOPIC）的定时消息，放入 enqueuePutQueue * * @param queueId 定时消息主题队列 ID，默认为 0（定时消息主题只有一个队列） * @return 是否取到消息 */ public boolean enqueue(int queueId) { if (storeConfig.isTimerStopEnqueue()) { return false; } if (!isRunningEnqueue()) { return false; } // 获取定时消息主题的消费队列 ConsumeQueue cq = (ConsumeQueue) this.messageStore.getConsumeQueue(TIMER_TOPIC, queueId); if (null == cq) { return false; } // 更新当前读取的队列偏移量 if (currQueueOffset < cq.getMinOffsetInQueue()) { LOGGER.warn(\\\"Timer currQueueOffset:{} is smaller than minOffsetInQueue:{}\\\", currQueueOffset, cq.getMinOffsetInQueue()); currQueueOffset = cq.getMinOffsetInQueue(); } long offset = currQueueOffset; SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(offset); if (null == bufferCQ) { return false; } try { int i = 0; // 遍历消费队列中的索引，查询消息，封装成 TimerRequest，放入 enqueuePutQueue for (; i < bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) { perfs.startTick(\\\"enqueue_get\\\"); try { long offsetPy = bufferCQ.getByteBuffer().getLong(); int sizePy = bufferCQ.getByteBuffer().getInt(); bufferCQ.getByteBuffer().getLong(); //tags code MessageExt msgExt = getMessageByCommitOffset(offsetPy, sizePy); if (null == msgExt) { perfs.getCounter(\\\"enqueue_get_miss\\\"); } else { lastEnqueueButExpiredTime = System.currentTimeMillis(); lastEnqueueButExpiredStoreTime = msgExt.getStoreTimestamp(); long delayedTime = Long.parseLong(msgExt.getProperty(TIMER_OUT_MS)); // use CQ offset, not offset in Message msgExt.setQueueOffset(offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE)); TimerRequest timerRequest = new TimerRequest(offsetPy, sizePy, delayedTime, System.currentTimeMillis(), MAGIC_DEFAULT, msgExt); // 无限次重试，直到成功放入 enqueuePutQueue，达到流控效果 while (true) { if (enqueuePutQueue.offer(timerRequest, 3, TimeUnit.SECONDS)) { break; } if (!isRunningEnqueue()) { return false; } } } } catch (Exception e) { //here may cause the message loss if (storeConfig.isTimerSkipUnknownError()) { LOGGER.warn(\\\"Unknown error in skipped in enqueuing\\\", e); } else { holdMomentForUnknownError(); throw e; } } finally { perfs.endTick(\\\"enqueue_get\\\"); } //if broker role changes, ignore last enqueue if (!isRunningEnqueue()) { return false; } // 移动消费队列下标，到下一个消费队列索引 currQueueOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE); } currQueueOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE); return i > 0; } catch (Exception e) { LOGGER.error(\\\"Unknown exception in enqueuing\\\", e); } finally { bufferCQ.release(); } return false; } \"]},\"1371\":{\"h\":\"4.2.2 TimerEnqueuePutService 保存——定时消息放入时间轮\",\"t\":[\"// TimerEnqueuePutService @Override public void run() { TimerMessageStore.LOGGER.info(this.getServiceName() + \\\" service start\\\"); while (!this.isStopped() || enqueuePutQueue.size() != 0) { try { long tmpCommitQueueOffset = currQueueOffset; List<TimerRequest> trs = null; //collect the requests TimerRequest firstReq = enqueuePutQueue.poll(10, TimeUnit.MILLISECONDS); // 如果队列中有 TimerRequest，循环将队列中的所有 TimerRequest 都取出 if (null != firstReq) { trs = new ArrayList<>(16); trs.add(firstReq); while (true) { TimerRequest tmpReq = enqueuePutQueue.poll(3, TimeUnit.MILLISECONDS); if (null == tmpReq) { break; } trs.add(tmpReq); if (trs.size() > 10) { break; } } } // 队列中没有 TimerRequest，更新 commitQueueOffset 和 ，直接跳过 if (CollectionUtils.isEmpty(trs)) { commitQueueOffset = tmpCommitQueueOffset; maybeMoveWriteTime(); continue; } while (!isStopped()) { // 并发将 TimerRequest 中的消息写入到 TimerLog 中 CountDownLatch latch = new CountDownLatch(trs.size()); for (TimerRequest req : trs) { req.setLatch(latch); try { perfs.startTick(\\\"enqueue_put\\\"); DefaultStoreMetricsManager.incTimerEnqueueCount(getRealTopic(req.getMsg())); if (shouldRunningDequeue && req.getDelayTime() < currWriteTimeMs) { // 如果定时时间小于当前写 TimerLog 的时间，说明消息已经到期 // 直接加入到 dequeuePutQueue，准备投递到 CommitLog dequeuePutQueue.put(req); } else { // 将 TimerRequest 加入 TimerLog 和时间轮 boolean doEnqueueRes = doEnqueue(req.getOffsetPy(), req.getSizePy(), req.getDelayTime(), req.getMsg()); req.idempotentRelease(doEnqueueRes || storeConfig.isTimerSkipUnknownError()); } perfs.endTick(\\\"enqueue_put\\\"); } catch (Throwable t) { LOGGER.error(\\\"Unknown error\\\", t); if (storeConfig.isTimerSkipUnknownError()) { req.idempotentRelease(true); } else { holdMomentForUnknownError(); } } } // 检查和等待 CountDownLatch checkDequeueLatch(latch, -1); boolean allSucc = true; for (TimerRequest tr : trs) { allSucc = allSucc && tr.isSucc(); } if (allSucc) { // 全部写入成功 break; } else { // 有写入失败，等待 0.05s holdMomentForUnknownError(); } } // 更新 commitQueueOffset 和 currWriteTimeMs commitQueueOffset = trs.get(trs.size() - 1).getMsg().getQueueOffset(); maybeMoveWriteTime(); } catch (Throwable e) { TimerMessageStore.LOGGER.error(\\\"Unknown error\\\", e); } } TimerMessageStore.LOGGER.info(this.getServiceName() + \\\" service end\\\"); } \",\"/** * 将 CommitLog 中的定时消息放入 TimerLog 和时间轮 * * @param offsetPy 索引项在 TimerLog 中的物理偏移量 * @param sizePy 索引项在 TimerLog 中的大小 * @param delayedTime 定时投递时间 * @param messageExt 索引项对应的消息 * @return 写入 TimerLog 是否成功 */ public boolean doEnqueue(long offsetPy, int sizePy, long delayedTime, MessageExt messageExt) { LOGGER.debug(\\\"Do enqueue [{}] [{}]\\\", new Timestamp(delayedTime), messageExt); //copy the value first, avoid concurrent problem long tmpWriteTimeMs = currWriteTimeMs; // 判断定时消息是否需要轮转。判断依据为：定时消息是不是近 2 天内要投递，不是则需要轮转 boolean needRoll = delayedTime - tmpWriteTimeMs >= timerRollWindowSlots * precisionMs; int magic = MAGIC_DEFAULT; if (needRoll) { magic = magic | MAGIC_ROLL; if (delayedTime - tmpWriteTimeMs - timerRollWindowSlots * precisionMs < timerRollWindowSlots / 3 * precisionMs) { //give enough time to next roll delayedTime = tmpWriteTimeMs + (timerRollWindowSlots / 2) * precisionMs; } else { delayedTime = tmpWriteTimeMs + timerRollWindowSlots * precisionMs; } } // 是否是取消定时消息 boolean isDelete = messageExt.getProperty(TIMER_DELETE_UNIQKEY) != null; if (isDelete) { magic = magic | MAGIC_DELETE; } String realTopic = messageExt.getProperty(MessageConst.PROPERTY_REAL_TOPIC); // 获取定时消息对应的时间轮槽 Slot slot = timerWheel.getSlot(delayedTime); ByteBuffer tmpBuffer = timerLogBuffer; tmpBuffer.clear(); tmpBuffer.putInt(TimerLog.UNIT_SIZE); //size tmpBuffer.putLong(slot.lastPos); //prev pos tmpBuffer.putInt(magic); //magic tmpBuffer.putLong(tmpWriteTimeMs); //currWriteTime tmpBuffer.putInt((int) (delayedTime - tmpWriteTimeMs)); //delayTime tmpBuffer.putLong(offsetPy); //offset tmpBuffer.putInt(sizePy); //size tmpBuffer.putInt(hashTopicForMetrics(realTopic)); //hashcode of real topic tmpBuffer.putLong(0); //reserved value, just set to 0 now long ret = timerLog.append(tmpBuffer.array(), 0, TimerLog.UNIT_SIZE); if (-1 != ret) { // 写入 TimerLog 成功，将写入 TimerLog 的消息加入时间轮 // If it's a delete message, then slot's total num -1 // TODO: check if the delete msg is in the same slot with \\\"the msg to be deleted\\\". timerWheel.putSlot(delayedTime, slot.firstPos == -1 ? ret : slot.firstPos, ret, isDelete ? slot.num - 1 : slot.num + 1, slot.magic); addMetric(messageExt, isDelete ? -1 : 1); } return -1 != ret; } \"]},\"1372\":{\"h\":\"4.2.3 TimerDequeueGetService 投递——扫描时间轮中到期的消息\",\"t\":[\"/** * 获取时间轮一个槽位中对应的 TimerLog 定时消息请求列表，放入 dequeueGetQueue 中处理 * * @return 0：当前读取的时间轮槽为空 no message，1：处理成功，2：处理失败 * @throws Exception */ public int dequeue() throws Exception { if (storeConfig.isTimerStopDequeue()) { return -1; } if (!isRunningDequeue()) { return -1; } if (currReadTimeMs >= currWriteTimeMs) { return -1; } // 根据当前时间轮扫描的时间戳，获取时间轮当前槽 Slot slot = timerWheel.getSlot(currReadTimeMs); if (-1 == slot.timeMs) { // 如果当前槽为空，推进时间轮并返回 moveReadTime(); return 0; } try { //clear the flag dequeueStatusChangeFlag = false; // 获取 TimerLog 中的物理偏移量 long currOffsetPy = slot.lastPos; Set<String> deleteUniqKeys = new ConcurrentSkipListSet<>(); // 普通定时消息请求栈 LinkedList<TimerRequest> normalMsgStack = new LinkedList<>(); // 定时消息取消请求栈 LinkedList<TimerRequest> deleteMsgStack = new LinkedList<>(); // TimerLog Buffer 队列 LinkedList<SelectMappedBufferResult> sbrs = new LinkedList<>(); SelectMappedBufferResult timeSbr = null; // 从 TimerLog 链表中一个一个读取索引项，放入请求栈 //read the timer log one by one while (currOffsetPy != -1) { perfs.startTick(\\\"dequeue_read_timerlog\\\"); if (null == timeSbr || timeSbr.getStartOffset() > currOffsetPy) { timeSbr = timerLog.getWholeBuffer(currOffsetPy); if (null != timeSbr) { sbrs.add(timeSbr); } } if (null == timeSbr) { break; } // TimerLog 链表前一个索引项的物理偏移量 long prevPos = -1; try { int position = (int) (currOffsetPy % timerLogFileSize); timeSbr.getByteBuffer().position(position); timeSbr.getByteBuffer().getInt(); //size prevPos = timeSbr.getByteBuffer().getLong(); int magic = timeSbr.getByteBuffer().getInt(); long enqueueTime = timeSbr.getByteBuffer().getLong(); long delayedTime = timeSbr.getByteBuffer().getInt() + enqueueTime; long offsetPy = timeSbr.getByteBuffer().getLong(); int sizePy = timeSbr.getByteBuffer().getInt(); // 读取 TimerLog 索引项，构造出 TimerRequest TimerRequest timerRequest = new TimerRequest(offsetPy, sizePy, delayedTime, enqueueTime, magic); timerRequest.setDeleteList(deleteUniqKeys); if (needDelete(magic) && !needRoll(magic)) { // 取消定时请求 deleteMsgStack.add(timerRequest); } else { // 普通定时消息请求 normalMsgStack.addFirst(timerRequest); } } catch (Exception e) { LOGGER.error(\\\"Error in dequeue_read_timerlog\\\", e); } finally { // 读取 TimerLog 链表中前一项 currOffsetPy = prevPos; perfs.endTick(\\\"dequeue_read_timerlog\\\"); } } if (deleteMsgStack.size() == 0 && normalMsgStack.size() == 0) { LOGGER.warn(\\\"dequeue time:{} but read nothing from timerlog\\\", currReadTimeMs); } for (SelectMappedBufferResult sbr : sbrs) { if (null != sbr) { sbr.release(); } } if (!isRunningDequeue()) { return -1; } // 分批将定时消息删除请求放入 dequeueGetQueue 去处理 CountDownLatch deleteLatch = new CountDownLatch(deleteMsgStack.size()); //read the delete msg: the msg used to mark another msg is deleted for (List<TimerRequest> deleteList : splitIntoLists(deleteMsgStack)) { for (TimerRequest tr : deleteList) { tr.setLatch(deleteLatch); } dequeueGetQueue.put(deleteList); } // 等待定时消息删除请求处理（放入 dequeuePutQueue） //do we need to use loop with tryAcquire checkDequeueLatch(deleteLatch, currReadTimeMs); // 分批将定时消息请求放入 dequeueGetQueue 去处理 CountDownLatch normalLatch = new CountDownLatch(normalMsgStack.size()); //read the normal msg for (List<TimerRequest> normalList : splitIntoLists(normalMsgStack)) { for (TimerRequest tr : normalList) { tr.setLatch(normalLatch); } dequeueGetQueue.put(normalList); } // 等待定时消息请求处理（放入 dequeuePutQueue） checkDequeueLatch(normalLatch, currReadTimeMs); // if master -> slave -> master, then the read time move forward, and messages will be lossed if (dequeueStatusChangeFlag) { return -1; } if (!isRunningDequeue()) { return -1; } // 推进时间轮 moveReadTime(); } catch (Throwable t) { LOGGER.error(\\\"Unknown error in dequeue process\\\", t); if (storeConfig.isTimerSkipUnknownError()) { moveReadTime(); } } return 1; } \"]},\"1373\":{\"h\":\"4.2.4 TimerDequeueGetMessageService 投递——查询原始消息\",\"t\":[\"@Override public void run() { setState(AbstractStateService.START); TimerMessageStore.LOGGER.info(this.getServiceName() + \\\" service start\\\"); while (!this.isStopped()) { try { setState(AbstractStateService.WAITING); // 取出到期的 TimerRequest List<TimerRequest> trs = dequeueGetQueue.poll(100 * precisionMs / 1000, TimeUnit.MILLISECONDS); if (null == trs || trs.size() == 0) { continue; } setState(AbstractStateService.RUNNING); // 遍历 TimerRequest for (int i = 0; i < trs.size(); ) { TimerRequest tr = trs.get(i); boolean doRes = false; try { long start = System.currentTimeMillis(); // 从 CommitLog 中查询原始消息 MessageExt msgExt = getMessageByCommitOffset(tr.getOffsetPy(), tr.getSizePy()); if (null != msgExt) { if (needDelete(tr.getMagic()) && !needRoll(tr.getMagic())) { // 删除消息请求 if (msgExt.getProperty(MessageConst.PROPERTY_TIMER_DEL_UNIQKEY) != null && tr.getDeleteList() != null) { tr.getDeleteList().add(msgExt.getProperty(MessageConst.PROPERTY_TIMER_DEL_UNIQKEY)); } // 处理删除消息请求成功，CountDownLatch -1 tr.idempotentRelease(); doRes = true; } else { // 普通消息请求 String uniqkey = MessageClientIDSetter.getUniqID(msgExt); if (null == uniqkey) { LOGGER.warn(\\\"No uniqkey for msg:{}\\\", msgExt); } if (null != uniqkey && tr.getDeleteList() != null && tr.getDeleteList().size() > 0 && tr.getDeleteList().contains(uniqkey)) { // 定时消息取消，什么都不做 doRes = true; // 处理定时消息请求成功，CountDownLatch -1 tr.idempotentRelease(); perfs.getCounter(\\\"dequeue_delete\\\").flow(1); } else { // 将查出的原始消息放入 TimerRequest，然后放入 dequeuePutQueue，准备投递到 CommitLog tr.setMsg(msgExt); while (!isStopped() && !doRes) { doRes = dequeuePutQueue.offer(tr, 3, TimeUnit.SECONDS); } } } perfs.getCounter(\\\"dequeue_get_msg\\\").flow(System.currentTimeMillis() - start); } else { //the tr will never be processed afterwards, so idempotentRelease it tr.idempotentRelease(); doRes = true; perfs.getCounter(\\\"dequeue_get_msg_miss\\\").flow(System.currentTimeMillis() - start); } } catch (Throwable e) { LOGGER.error(\\\"Unknown exception\\\", e); if (storeConfig.isTimerSkipUnknownError()) { tr.idempotentRelease(); doRes = true; } else { holdMomentForUnknownError(); } } finally { // 本 TimerRequest 求处理成功，处理下一个 TimerRequest，否则重新处理本 TimerRequest if (doRes) { i++; } } } trs.clear(); } catch (Throwable e) { TimerMessageStore.LOGGER.error(\\\"Error occurred in \\\" + getServiceName(), e); } } TimerMessageStore.LOGGER.info(this.getServiceName() + \\\" service end\\\"); setState(AbstractStateService.END); } \"]},\"1374\":{\"h\":\"4.2.5 TimerDequeuePutMessageService 投递——投递定时消息\",\"t\":[\"@Override public void run() { setState(AbstractStateService.START); TimerMessageStore.LOGGER.info(this.getServiceName() + \\\" service start\\\"); while (!this.isStopped() || dequeuePutQueue.size() != 0) { try { setState(AbstractStateService.WAITING); TimerRequest tr = dequeuePutQueue.poll(10, TimeUnit.MILLISECONDS); if (null == tr) { continue; } setState(AbstractStateService.RUNNING); // 投递结果是否成功 boolean doRes = false; boolean tmpDequeueChangeFlag = false; try { while (!isStopped() && !doRes) { if (!isRunningDequeue()) { dequeueStatusChangeFlag = true; tmpDequeueChangeFlag = true; break; } try { perfs.startTick(\\\"dequeue_put\\\"); DefaultStoreMetricsManager.incTimerDequeueCount(getRealTopic(tr.getMsg())); addMetric(tr.getMsg(), -1); // 将原始定时消息的 Topic 和 QueueId 等信息复原，构造一个新的消息 MessageExtBrokerInner msg = convert(tr.getMsg(), tr.getEnqueueTime(), needRoll(tr.getMagic())); // 投递到 CommitLog doRes = PUT_NEED_RETRY != doPut(msg, needRoll(tr.getMagic())); while (!doRes && !isStopped()) { // 如果投递失败需要重试，等待{精确度 / 2}时间然后重新投递 if (!isRunningDequeue()) { dequeueStatusChangeFlag = true; tmpDequeueChangeFlag = true; break; } doRes = PUT_NEED_RETRY != doPut(msg, needRoll(tr.getMagic())); Thread.sleep(500 * precisionMs / 1000); } perfs.endTick(\\\"dequeue_put\\\"); } catch (Throwable t) { LOGGER.info(\\\"Unknown error\\\", t); if (storeConfig.isTimerSkipUnknownError()) { doRes = true; } else { holdMomentForUnknownError(); } } } } finally { tr.idempotentRelease(!tmpDequeueChangeFlag); } } catch (Throwable e) { TimerMessageStore.LOGGER.error(\\\"Error occurred in \\\" + getServiceName(), e); } } TimerMessageStore.LOGGER.info(this.getServiceName() + \\\" service end\\\"); setState(AbstractStateService.END); } \"]},\"1375\":{\"h\":\"参考资料\",\"t\":[\"PR: [RIP-43] Support Timing Messages with Arbitrary Time Delay\",\"RIP-43 Support timing messages with arbitrary time delay\",\"社区在讨论什么？《Support Timing Messages with Arbitrary Time Delay》\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1376\":{\"h\":\"Rocketmq 5 分级存储 Tieredstore（RIP-57、RIP-65） 原理详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20240429-rocketmq-tieredstore.html\"]},\"1377\":{\"h\":\"1. 背景\"},\"1378\":{\"h\":\"1.1 需求\",\"t\":[\"RocketMQ 5.x 的演进目标之一是云原生化，在云原生和 Serverless 的浪潮下，需要解决 RocketMQ 存储层存在两个瓶颈。\",\"数据量膨胀过快，单体硬件无法支撑\",\"存储的低成本和速度无法兼得\",\"众多云厂商也希望提供 Serverless 化的 RocketMQ 来降低成本，为用户提供更加极致弹性的云服务。\"]},\"1379\":{\"h\":\"1.2 解决的问题\",\"t\":[\"除了以上两个瓶颈之外，分级存储还希望解决的问题是\",\"消息仅支持保留固定的时间\",\"Topic 的数据与 Broker 绑定，无法迁移。比如在 Broker 缩容的场景下，被削减的 Broker 上的历史数据无法保留。\"]},\"1380\":{\"h\":\"1.3 演进过程\",\"t\":[\"RocketMQ 5.1 中提出了分级存储的方案（RIP-57），但当时的版本还未达到生产可用。\",\"RIP-65 对之前的分级存储实现进行了重构，修改了模型抽象、线程模式、元数据管理和索引文件的实现，提升了分级存储的代码可读性。\",\"ISSUE #7878 又对分级存储的代码进行了大量重构，修复已知问题，提升性能，减少资源利用率。\",\"经过几次重构，当前的分级存储基本已经属于可用的状态。不过官方只提供了内存和本地文件两种分级存储文件段的实现，其他存储介质分级存储的实现需要用户自行扩展来实现。\"]},\"1381\":{\"h\":\"2. 使用\"},\"1382\":{\"h\":\"2.1 Broker 配置\",\"t\":[\"要测试分级存储，需要在 broker.conf 中添加如下配置：\",\"# tiered messageStorePlugIn=org.apache.rocketmq.tieredstore.TieredMessageStore tieredBackendServiceProvider=org.apache.rocketmq.tieredstore.provider.PosixFileSegment tieredStoreFilePath=e:\\\\\\\\data\\\\\\\\rocketmq\\\\\\\\node\\\\\\\\tieredstore tieredStorageLevel=FORCE \",\"分级存储各个配置的含义表如下：\",\"配置\",\"默认值\",\"单位\",\"作用\",\"messageStorePlugIn\",\"扩展 MessageStore 实现，如果要用分级存储，设置成org.apache.rocketmq.tieredstore.TieredMessageStore \",\"tieredMetadataServiceProvider\",\"org.apache.rocketmq.tieredstore.metadata.DefaultMetadataStore\",\"分级存储元数据存储实现\",\"tieredBackendServiceProvider\",\"org.apache.rocketmq.tieredstore.provider.MemoryFileSegment\",\"分级存储数据存储实现\",\"tieredStoreFilepath\",\"分级存储数据文件保存位置（POSIX provider）\",\"tieredStorageLevel\",\"NOT_IN_DISK\",\"分级存储读取策略，默认 NOT_IN_DISK，即只有在本地存储中不存在时才会读取分级存储。其他选项为：DISABLE，禁用分级存储；NOT_IN_MEM，消息不在内存（Page Cache）时读分级存储；FORCE，强制读取分级存储\",\"tieredStoreFileReservedTime\",\"72\",\"hour\",\"分级存储消息保存时间\",\"commitLogRollingInterval\",\"24\",\"hour\",\"分级存储 CommitLog 强制滚动时间\",\"readAheadCacheEnable\",\"true\",\"从分级存储读取时是否启用预读缓存\",\"readAheadMessageCountThreshold\",\"4096\",\"从分级存储时每次读取消息数量阈值\",\"readAheadMessageSizeThreshold\",\"16 * 1024 * 1024\",\"byte\",\"从分级存储中每次读取消息的长度阈值\",\"readAheadCacheExpireDuration\",\"15000\",\"ms\",\"预读缓存过期时间，没有读写操作 15s 后过期\",\"readAheadCacheSizeThresholdRate\",\"0.3\",\"比例\",\"最大预读缓存大小，为 JVM 最大内存的一定比例\",\"tieredStoreMaxPendingLimit\",\"10000\",\"分级存储写文件最大同时写文件数量\",\"目前 RocketMQ 源码中内置了两种分级存储 FileSegment 的实现\",\"MemoryFileSegment：使用内存作为二级存储\",\"PosixFileSegment：使用磁盘文件作为二级存储\",\"他们都是实验性的，这里选择了 PosixFileSegment。\",\"要实现其他存储介质的分级存储，只需要扩展 FileSegment 实现一个新的 FileSegment 类即可。\"]},\"1383\":{\"h\":\"2.2 数据组织结构\",\"t\":[\"对启用了分级存储的 Broker 进行压测，一段时间后分级存储目录中的文件：\",\"/e/data/rocketmq/node/tieredstore `-- [ 0] 212d6b50_DefaultCluster `-- [ 0] broker-a | `-- [ 0] rmq_sys_INDEX | `-- [ 0] 0 | `-- [ 0] INDEX | `-- [572M] cfcd208400000000000000000000 `-- [ 0] topic-tiered |-- [ 0] 0 | |-- [ 0] COMMIT_LOG | | |-- [1024M] 1f329fef00000000001073741775 | | |-- [1024M] cfcd208400000000000000000000 | | `-- [707M] dcb86ff200000000002147483550 | `-- [ 0] CONSUME_QUEUE | |-- [ 60M] 40d473e300000000000104857600 | `-- [100M] cfcd208400000000000000000000 |-- [ 0] 1 | |-- [ 0] COMMIT_LOG | | |-- [1024M] 1f329fef00000000001073741775 | | |-- [1024M] cfcd208400000000000000000000 | | `-- [707M] dcb86ff200000000002147483550 | `-- [ 0] CONSUME_QUEUE | |-- [ 60M] 40d473e300000000000104857600 | `-- [100M] cfcd208400000000000000000000 |-- [ 0] 2 | |-- [ 0] COMMIT_LOG | | |-- [1024M] 1f329fef00000000001073741775 | | |-- [1024M] cfcd208400000000000000000000 | | `-- [707M] dcb86ff200000000002147483550 | `-- [ 0] CONSUME_QUEUE | |-- [ 60M] 40d473e300000000000104857600 | `-- [100M] cfcd208400000000000000000000 `-- [ 0] 3 |-- [ 0] COMMIT_LOG | |-- [1024M] 1f329fef00000000001073741775 | |-- [1024M] cfcd208400000000000000000000 | `-- [707M] dcb86ff200000000002147483550 `-- [ 0] CONSUME_QUEUE |-- [ 60M] 40d473e300000000000104857600 `-- [100M] cfcd208400000000000000000000 \",\"其中索引文件单独存放，每个 Topic 的队列都单独有 CommitLog 和 ConsumeQueue\",\"CommitLog 为消息数据，与本地存储不同，每个 Topic 的队列都拆分单独一组的 CommitLog 文件，每个 1G\",\"ConsumeQueue 为消费索引\",\"INDEX 为索引文件，单独目录存放\"]},\"1384\":{\"h\":\"3. 概要设计\"},\"1385\":{\"h\":\"3.1 技术架构选型\",\"t\":[\"分级存储的方案中一个重要的选择是直写还是转写。\",\"直写：用高可用的存储或分布式文件系统直接替换本地块存储。优点是池化存储。\",\"转写：热数据使用本地块存储先顺序写，压缩之后转储到更廉价的存储系统中。优点是降低冷数据的长期存储成本。\",\"最理想的终态可以是两者的结合，RocketMQ 自己来做数据转冷。因为消息系统自身对如何更好的压缩数据和加速读取的细节更了解，在转冷的过程中能够做一些消息系统内部的格式变化来加速冷数据的读取，减少 IO 次数、配置不同的 TTL 等。\",\"目前的分级存储方案考虑到商业和开源技术架构的一致性，选择先实现转写模式。具体包括以下一些考虑：\",\"成本：将大部分冷数据卸载到更便宜的存储系统中后，热数据的存储成本可以显著减小，更直接的降低存储成本。\",\"可移植性：直写分布式文件系统通常需要依赖特定 SDK，配合 RDMA 等技术来降低延迟，对应用不完全透明，运维、人力、技术复杂度都有一定上升。保留成熟的本地存储，只需要实现与其他存储后端的适配层就可以轻松切换多种存储后端。\",\"延迟与性能：通常分布式文件系统跨可用区部署，消息写多数派成功才能被消费，存在跨可用区的延迟。直接写本地磁盘的延迟会小于跨可用区的延迟，其延迟在热数据读写的情况下也不是瓶颈。\",\"可用性： 转写模式下，整个系统弱依赖二级存储，更适合开源与非公有云场景。\"]},\"1386\":{\"h\":\"3.2 存储模型与抽象\",\"t\":[\"分级存储的模型与本地存储的模型一一对应，结构上也类似。最大的区别在于分级存储模型的组织形式，其 CommitLog 不再将所有队列的消息数据都存在一起，而是按照队列的维度拆分存储。\",\"下表展示了本地存储与分级存储模型的对应关系。\",\"本地存储\",\"分级存储\",\"说明\",\"MappedFile\",\"FileSegment\",\"对应单个文件，MappedFile 是 mmap 实现的内存映射文件，FileSegment 是分级存储中文件的句柄\",\"MappedFileQueue\",\"FlatAppendFile\",\"多个 MappedFile/FileSegment 组成的链表，只有最后一个文件是可写的，前面的都是不可变的\",\"CommitLog\",\"FlatCommitLogFile\",\"MappedFileQueue/FlatAppendFile 的封装，CommitLog 是由所有队列的消息数据构成的文件，FlatCommitLogFile 存储单个队列中的消息数据\",\"ConsumeQueue\",\"FlatConsumeQueueFile\",\"MappedFileQueue/FilatAppendFile 的封装，消费索引文件，保存着每个消息在 CommitLog 中的物理偏移量，用于消费每个队列的时候查询消息。本地存储的 ConsumeQueue 详解见 这篇文章\",\"FlatMessageFile\",\"分级存储引入的概念，表示单个队列的消息文件，组合 FlatCommitLogFile 和 FlatConsumeQueueFile，并提供一系列操作接口\",\"IndexFile\",\"IndexStoreFile\",\"索引文件，也由一组文件构成，用于根据 Key 查询消息。本地存储的 IndexFile 类似一个 HashMap，hash 冲突时，value 是头插法构造成的一个链表。分级存储的 IndexStoreFile 最后一个文件格式与本地存储的 IndexFile 类似，但是列表前面的文件在写入完毕后会经过压缩。本地存储的 IndexFile 讲解见 这篇文章\"]},\"1387\":{\"h\":\"3.3 分层设计\",\"t\":[\"分级存储的实现分为 3 层，从上至下分别是接入层、容器层、驱动层。\",\"驱动层最为底层，负责实现逻辑文件到具体的分级存储系统的映射。实现 FileSegment 接口，目前提供了内存和本地磁盘的实现。\",\"容器层为上面提到的存储模型除了 FileSegment 以外的其他分级存储抽象。\",\"接入层作为操作分级存储数据的入口，包含整个分级存储的 MessageStore，以及从分级存储读数据的 Fetcher 和写数据的 Dispatcher。\"]},\"1388\":{\"h\":\"3.4 写消息\",\"t\":[\"写消息经过一次重构，由原来的实时上传改为攒批，纯异步上传。在相同流量下性能提升了 3 倍以上。\",\"写消息逻辑由分级存储消息分发器处理，它被注册到默认存储的分发器链中，在其他分发器都分发完毕后被调用，在这里被调用只是为了创建队列的文件容器和持久化队列的元数据。\",\"分级存储消息分发器是一个服务线程，每 20s 进行一次扫描，依次扫描所有的队列，决定是否要上传消息。\",\"触发上传的条件有两个：距离上次提交达到一定时间（默认 30s），或者等待上传的消息超过一定数量（默认 4096）。\",\"上传的过程是：\",\"先将等待上传的这部分消息放入刷盘缓冲区\",\"为这些消息创建消费队列，也是将消费队列数据放入刷盘缓冲区\",\"判断缓冲区中的消息是否达到阈值（等到到一定时间或者缓冲区中消息到一定数量），如果达到阈值，则用一个专门的消息上传线程池异步上传已被放入缓冲区的消息。\",\"上传的过程中，先批量上传消息数据，上传成功后再批量上传消费索引数据（最后如果开启索引构建的话，再构建索引）\"]},\"1389\":{\"h\":\"3.5 读消息\"},\"1390\":{\"h\":\"3.5.1 读取策略\",\"t\":[\"在分级存储的情况下，随着时间的推移，消息的存储位置也会经历 内存（Page Cache）-> 本地存储 -> 二级存储 这样的转变。\",\"RocketMQ 分级存储把读取策略抽象了出来，供用户自行配置，默认是 NOT_IN_DISK。\",\"DISABLE：禁用分级存储，所有 fetch 请求都将由本地消息存储处理。\",\"NOT_IN_DISK：只有 offset 不在本地存储中的 fetch 请求才会由分级存储处理。\",\"NOT_IN_MEM：只有 offset 不在内存中的 fetch 请求才会由分级存储处理。\",\"FORCE：所有 fetch 请求都将由分级存储处理。\"]},\"1391\":{\"h\":\"3.5.2 读取流程\",\"t\":[\"为了加速从二级存储读取的速度和减少整体上对二级存储的请求次数，引入了预读缓存的设计。\",\"首先根据读取策略，查询已提交二级存储的 offset 和消息是否在内存中这些信息来判断是否要走二级存储读取。\",\"优先从预读缓存读取消息。（如果开启预读缓存功能）\",\"如果从缓存中读到消息，直接返回。如果没有读到消息，立即从二级存储中拉取消息，拉取到后放入缓存，然后返回。\",\"从二级存储读取消息的过程：先读取消费队列数据，然后用消费队列数据查询消息数据，确定要读取消息数据的长度，最后从分级存储中读取消息数据并返回。\"]},\"1392\":{\"h\":\"3.6 索引设计\"},\"1393\":{\"h\":\"3.6.1 索引重排\",\"t\":[\"索引文件 是为了根据 Key 查询消息而创建的。它的组织结构近似一个 HashMap，Key 为消息的 Key 进行 hash 之后的值，Value 包含了消息物理偏移量等信息。\",\"当发生哈希冲突时（消息 Key 经过 hash 之后可能相同），采用链表的形式处理冲突，将新插入的 Value 插入 hash 槽的开头（头插法）。这样，每个 hash 槽就对应了一条按照插入时间倒序排列的链表。\",\"但是这样的结构组成文件之后，读取一个 hash 槽对应的链表时，由于每个 Value 插入时间不是连续的，它们会分布在文件的不同位置，这样查询时就存在多次随机读。\",\"冷存储的 IOPS 代价是十分昂贵的，所以在分级存储中面向查询进行优化，如下图所示。\",\"新的索引文件将每个 hash 槽所对应的 Value 重新排列，在文件中连续存储和读取，不再使用非连续的链表形式。这样可以让查询时的多次随机 IO 变成一次 IO。\"]},\"1394\":{\"h\":\"3.6.2 索引构建流程\",\"t\":[\"分级存储的索引文件分为三个状态：\",\"UNSEALED：初始状态，类似主存索引文件格式（顺序写），存储在本地磁盘上，正在被写入。一般只有最后一个索引文件处于该状态。路径为 {storePath}/tiered_index_file/{时间戳}\",\"SEALED：已经或正在被压缩成新格式的索引文件，还未上传到外部存储。路径为 {storePath}/tiered_index_file/compacting/{时间戳}\",\"UPLOAD：已经上传到二级存储。\",\"索引文件在消息上传到二级存储后开始构建，每次写入只会写入文件列表最后一个处于 UNSEALED 状态的文件。当一个索引文件写满后，把它改为 SEALED 状态，并新建一个 UNSEALED 的索引文件。\",\"索引文件服务启动一个线程，每 10s 扫描一次，找到创建时间最早的处于 SEALED 状态的索引文件，压缩并上传到二级存储。\",\"压缩的过程会在 compacting 目录创建一个新格式的索引文件，然后遍历老索引文件，将内容重新排列后写入新的索引文件，最后将新索引文件内容上传到二级存储。上传完成之后会删掉处于本地的新老索引文件。\"]},\"1395\":{\"h\":\"3.7 重启恢复和元数据\",\"t\":[\"在 Broker 重启后，需要重新加载分级存储文件句柄到内存。之前加载过的二级存储文件信息通过元数据的形式保存在本地文件中，专门用于 Broker 重启之后的恢复。\",\"元数据文件默认保存的位置是 ${ROCKETMQ_HOME}/store/config/tieredStoreMetadata.json。\",\"元数据文件分为两类：一类是保存 Topic、Queue 数据的；另一类是保存所有分级存储文件句柄（FileSegment）的。每当有新的 Topic 或 Queue 的消息被分发到分级存储，对应的 Topic 和 Queue 的元数据会被创建和持久化；每当新的分级存储文件句柄（FileSegment）被创建，对应的文件句柄元数据也会被创建和持久化。\",\"在重启后，分级存储系统会读取持久化在本地的 Topic、Queue 元数据，在内存中重建 Queue，然后再读取文件句柄的元数据，在内存中恢复所有分级存储的文件句柄。\"]},\"1396\":{\"h\":\"4. 详细设计\",\"t\":[\"分级存储的代码位于一个单独的模块 tieredstore，由 TieredMessageStore 这个类承载。\"]},\"1397\":{\"h\":\"4.1 接入方式\",\"t\":[\"RocketMQ 支持以插件的方式引入自定义的存储实现，分级存储就是通过实现 AbstractPluginMessageStore 来作为插件进行接入的。AbstractPluginMessageStore 实现了 MessageStore 接口，可以作为 Broker 的存储实现。\"]},\"1398\":{\"h\":\"4.1.1 分级存储初始化\",\"t\":[\"在 BrokerController 初始化时，调用 initializeMessageStore() 方法，会先进行默认存储的初始化。\",\"默认存储有两种类型\",\"DefaultMessageStore，为使用磁盘文件存储的默认存储实现\",\"RocksDBMessageStore，使用 RocksDB 进行存储实现，为了支持百万队列而引入\",\"然后如果配置了插件存储，则将实例化插件存储，作为 Broker 中真正使用的存储实现。最后，将默认存储作为一个引用传入插件存储，这样，在插件存储中仍然可以调用默认存储。\"]},\"1399\":{\"h\":\"4.1.2 分级存储调用\"},\"1400\":{\"h\":\"写消息\",\"t\":[\"在存储消息时，TieredMessageStore 并没有重写消息存储的方法，而是直接调用了默认存储的消息保存，先将消息存至默认的本地存储中。\",\"分级存储在这里的接入方法是：在默认存储的消息分发器中添加分级存储的消息分发器实例。这样，消息在存储到 CommitLog 之后会先分发到 ConsumeQueue 和 IndexFile，然后分发到分级存储。\"]},\"1401\":{\"h\":\"读消息\",\"t\":[\"查询时，TieredMessageStore 重写了 getMessageAsync 方法，根据配置的分级存储消息读取策略进行判断，如果是读本地存储，则使用本地存储的引用调用其 getMessageAsync 方法，如果是读分级存储则调用分级存储 fetcher 获取消息。\"]},\"1402\":{\"h\":\"4.2 存储模型\",\"t\":[\"如上图所示，TieredMessageStore 中包含了分级存储所有的存储模型，下面来分别介绍\",\"FlatFileStore：分级存储中消息文件存储的实现，内部有一个 Map 作为分级存储文件容器，Key 是队列，Value 是该队列的分级存储文件，以 FlatMessageFile 的形式存储\",\"FlatMessageFile：表示单个队列的存储实现，它封装了 FlatCommitLogFile 和 FlatConsumeQueueFile 对象，并且提供了读/写消息等操作接口。\",\"FlatCommitLogFile：分级存储 CommitLog 文件，类似本地存储的 CommitLog，由一组 FileSegment 队列构成。区别是分级存储的 CommitLog 是以队列维度保存的。\",\"这是为了方便连续地读取单个队列中的消息。如果仍然以本地存储的方式将所有队列的 CommitLog 统一存储，同一队列的消息数据可能会横跨更多的文件，为分级存储带来更多的 IOPS 压力，这对分级存储来说是非常昂贵的。\",\"FlatConsumeQueueFile：分级存储队列消费索引，类似本地存储的 ConsumeQueue，由一组 FileSegment 队列构成。保存着消息位置（指向 FlatCommitLogFile 的偏移量）\",\"FlatAppendFile：FlatCommitLogFile 和 FlatConsumeQueueFile 都扩展了这个类，它类似本地存储的 MappedFileQueue，是零个或多个定长 FileSegment 组成的链表。其中最多只有最后一个 FileSegment 是可写的，前面的文件都是只读的。 \",\"FileSegment：类似本地存储的 MappedFile，分级存储中的文件最小单元。\",\"DefaultMetadataStore：分级存储元数据存储实现，用于存储 Topic、Queue、FileSegment 等元数据信息\",\"topicMetadataTable：Map，存储分级存储中 Topic 的元数据和额外属性\",\"queueMetadataTable：Map，存储分级存储中 Queue 元数据和额外属性\",\"commitLogFileSegmentTable：分级存储 CommitLog 的 FileSegment 文件元数据\",\"consumeQueueFileSegment：分级存储 ConsumeQueue 的 FileSegment 文件元数据\",\"indexFileSegmentTable：分级存储 IndexFile 的 FileSegment 文件元数据\",\"MessageStoreFetcher：分级存储消息读取器，负责处理分级存储读取请求。\",\"fetcherCache：读取器预读缓存，为了加速从二级存储读取的速度和减少整体上对二级存储请求数而设置。在读取前查询和读取缓存；从二级存储读到数据后放入缓存。\",\"MessageStoreDispatcher：分级存储消息分发器，是一个服务线程，定时将本地已经攒批的数据上传到分级存储。\",\"IndexStoreService：分级存储索引服务，内部包含了由 IndexStoreFile 构成的索引文件表，以及当前正在写入的索引文件的引用。同时提供了索引文件操作的接口。\",\"IndexStoreFile：分级存储索引文件，类似本地存储的 IndexFile，底层是分级存储 FileSegment。\"]},\"1403\":{\"h\":\"4.3 写消息\",\"t\":[\"初始化分级存储时会将分级存储 dispatcher 注册到 CommitLog 的 dispatcher 链当中。\",\"在消息写入 CommitLog 后，reput 线程会扫描 CommitLog 中的消息，然后依次运行 dispatcher 链中的 dispatcher，生成 ConsumeQueue 和 IndexFile。在这之后，会执行分级存储 dispatcher 方法。分级存储的 dispatcher 仅仅根据扫描到的消息创建分级存储对应的队列目录和空的分级存储 FileSegment 文件，上传数据的流程为定时发起。\",\"MessageStoreDispatcherImpl 是分级存储消息分发器的实现，用于将本地存储的消息提交到分级存储中。它是一个服务线程，每 20s 运行一次，判断缓冲区中等待上传的消息是否达到阈值，如果达到则将本地存储中的这批消息提交到分级存储。\",\"每 20s，它遍历当前分级存储中所有的 FlatMessageFile（也就是遍历每个 Queue），对他们执行 dispatchWithSemaphore 方法。\",\"这个方法获取信号量，然后将执行异步上传操作，当前默认允许的同时上传的 Queue 数量为 2500。\",\"doScheduleDispatch 方法执行消息数据的获取、缓冲和上传。\",\"每次上传的数据量是有一个阈值的，满足了阈值条件其中之一才进行上传，否则等待下一次扫描。\",\"超时：上次提交到当前时间是否超过分级存储存储的提交时间阈值（30s）\",\"缓冲区满：当前队列等待提交的消息数量超过阈值（4096）\",\"该方法的第一步是找到本次上传数据的偏移量起始和结束位置。在这之前需要明确一些概念。\",\"RocketMQ 在多副本的情况下，消息被写入 CommitLog 之后更新 max offset（图中黄色部分），但这些消息还需要同步到其他副本。多副本中多数派的最小位点（低水位）为 commit offset，而在这之间的消息是正在等待副本同步的。允许上传到分级存储的消息（也就是上传数据的结束位置最多）是 commit offset 之前。\",\"起始位置的计算方式如下：\",\"如果这个队列的分级存储 FileSegment 为空（刚初始化），那么起始位置即该 FileSegment 文件对应的队列起始偏移量。\",\"如果这个 FileSegment 已经初始化过，那么为分级存储 ConsumeQueue 当前的 maxOffset。因为分级存储的 CommitLog 和 ConsumeQueue 上传是一系列操作，必须保证消息上传到这两个文件成功才视作上传成功。所以应该以 ConsumeQueue 的 max offset 为准。\",\"明确了起始位置之后，要计算当次上传的结束位置。单次上传最大消息数据量也有一个阈值，默认为 4M，如果队列中等待上传的消息量超过 4M，则截断上传，否则全部上传。\",\"上传到分级存储的操作也分为两步，append 和 commit。\",\"append：将数据放入上传缓冲区，等待批量上传。这个过程在这里是同步的。分级存储文件的 max offset 包含了放入缓冲区中等待上传的消息数据。\",\"commit：真正将数据上传到二级存储，为异步操作。分级存储文件中的 commit offset 为已经上传到分级存储的消息数据。\",\"doScheduleDispatch 整个分发逻辑为：\",\"从起始位置到结束位置遍历队列逻辑偏移量\",\"根据偏移量获取本地存储中的 ConsumeQueue 单元\",\"根据 ConsumeQueue 单元查找本地存储 CommitLog，获取消息数据\",\"将消息数据 append 到分级存储 CommitLog 中的缓存\",\"提交一个分级存储的 DispatchRequest，append 到分级存储 ConsumeQueue 的缓存\",\"异步执行 commit，先将 CommitLog 缓存中的数据上传到分级存储，然后将 ConsumeQueue 缓存中的数据上传到二级存储。上传完成之后更新 commit offset，然后释放 CommitLog 缓冲区和 ConsumeQueue 分发请求缓冲区。\",\"如果开启 IndexFile，则调用 constructIndexFile 构造分级存储 IndexFile，具体逻辑后面会讲\",\"对于上传失败的情况，在 doScheduleDispatch 开始时进行判断，分级存储 ConsumeQueue 的 commit offset 是否大于等于 max offset，如果不是则重试上次上传，也就是把上次还在缓冲区的数据重新上传一次。\"]},\"1404\":{\"h\":\"4.4 读消息\",\"t\":[\"读消息的逻辑引入预读缓存，以加快读取速度、减少对分级存储的访问。读消息的逻辑也经过一次重构，原先的预读缓存使用了拥塞控制算法，每次预读消息量类似拥塞窗口采用加法增、乘法减的流量控制机制，但存在 OOM 的问题。重构后采用更简单明了的预读策略：当缓存中的数据大小大于缓存配置大小的 80% 时就直接走分级存储，解决了 OOM 的问题。\"]},\"1405\":{\"h\":\"4.4.1 TieredMessageStore 读消息\",\"t\":[\"如果使用分级存储，TieredMessageStore 则会作为 Broker 使用的 MessageStore，读消息时会调用 getMessageAsync 方法。它的逻辑是\",\"根据用户配置的分级存储读取策略，检查是否需要从分级存储中读取消息。分级存储读取策略如下，默认为 NOT_IN_DISK： \",\"DISABLE：禁用分级存储，所有 fetch 请求都将由本地消息存储处理。\",\"NOT_IN_DISK：只有 offset 不在本地存储中的 fetch 请求才会由分级存储处理。\",\"NOT_IN_MEM：只有 offset 不在内存中的 fetch 请求才会由分级存储处理。\",\"FORCE：所有 fetch 请求都将由分级存储处理。\",\"如果是从分级存储进行读取，则调用 MessageStoreFetcherImpl 的 getMessageAsync 方法，从分级存储读取消息数据。如果是从本地存储读取，则调用本地存储 MessageStore 的引用，读取本地存储中的消息数据。\",\"如果从分级存储没有找到消息，会从本地存储再读取一次。如果从分级存储中找到，更新分级存储的统计信息。\"]},\"1406\":{\"h\":\"4.4.2 预读缓存设计\",\"t\":[\"预读缓存是使用 Caffeine 库来创建的内存缓存。最大可用的内存默认为 JVM 内存的 30%，缓存项在 15s 内没有被使用则清理，使用消息 buffer 大小计算内存使用量。\"]},\"1407\":{\"h\":\"4.4.3 MessageStoreFetcher 读消息\",\"t\":[\"MessageStoreFetcherImpl#getMessageAsync 方法需要判断走预读缓存读消息还是直接走分级存储，根据判断结果来调用读取消息的方法。判断依据是预读缓存占用的内存是否超过阈值（即超过预读缓存最多可用内存的 80%）。\",\"缓存的 Key 是 topic@queueId@offset 字符串，Value 是 SelectBufferResult\"]},\"1408\":{\"h\":\"从分级存储读取\",\"t\":[\"先来看直接走分级存储读取的场景，会调用 getMessageFromTieredStoreAsync 方法，该方法逻辑如下\",\"根据要读取消息的偏移量和最大读取消息数量获取分级存储 ConsumeQueue\",\"根据 ConsumeQueue 读取分级存储 CommitLog \",\"从 ConsumeQueue Buffer 中解析出第一条和最后一条消息的 commitLog offset，并验证是否合法\",\"获取整体要读的消息长度，如果长度超过阈值，则缩小单次读取长度（从最后一条消息开始往前缩小，直到缩到只有一条消息）\",\"从分级存储 CommitLog 中读取消息\",\"读取到消息数据后进行处理，将返回结果解析成消息对象，放入返回结果中返回\"]},\"1409\":{\"h\":\"从预读缓存读取\",\"t\":[\"然后来看走预读缓存的场景，如果预读缓存中没有消息，会走到上面分级存储读取的方法来读取消息然后放入预读缓存。\",\"getMessageFromCacheAsync 逻辑如下：\",\"先尝试从缓存中读消息，根据消息逻辑偏移量一条一条从缓存中查询消息。\",\"如果从缓存中读取到消息，即便没有达到 maxCount 也直接返回。\",\"如果缓存中没有读到，调用 fetchMessageThenPutToCache 方法： \",\"它先调用 getMessageFromTieredStoreAsync 方法从分级存储查询消息\",\"然后将读到的消息放入缓存\",\"最后再查询缓存，将结果返回\"]},\"1410\":{\"h\":\"4.4.4 FlatAppendFile 读消息\",\"t\":[\"FlatAppendFile 是分级存储 FileSegment 列表的封装，readAsync 方法会找到要读取的 FileSegment，然后调用 FileSegment 的 readAsync 方法进行读取，逻辑如下：\",\"从后往前遍历 FileSegment，找到包含 offset 的 FileSegment\",\"获取 offset 所在的 FileSegment，以及它后面一个 FileSegment（如果要读取的数据跨越了两个 FileSegment）\",\"读取 FileSegment 的数据，合并后返回\"]},\"1411\":{\"h\":\"4.5 索引文件\",\"t\":[\"分级存储中的索引文件也是以一组 FileSegment 的形式存在。\",\"概要设计中讲到，为了减少分级存储索引文件的 IOPS，所以在设计上对分级存储中保存的 IndexFile 文件格式进行了优化。在分级存储索引项刚开始构建时，这个索引文件处于未压缩状态，文件内容格式与本地存储的索引文件相同。在一个索引文件写满后，会重排该索引文件，写到一个新的文件中，最后上传到分级存储。\"]},\"1412\":{\"h\":\"4.5.1 索引文件类设计\",\"t\":[\"IndexService 接口中包含了对索引文件操作的封装：putKey 和 queryAsync，两个索引文件类实现了这个接口。\",\"IndexStoreFile：表示单个索引文件，包含了压缩前的索引文件引用、压缩后索引文件引用、上传到二级存储的索引文件引用。 \",\"fileStatus：索引文件状态 \",\"UNSEALED：初始状态，类似主存索引文件格式（顺序写），存储在本地磁盘上，正在被写入。一般只有最后一个索引文件处于该状态。路径为 {storePath}/tiered_index_file/{时间戳}\",\"SEALED：已经或正在被压缩成新格式的索引文件，还未上传到外部存储。路径为 {storePath}/tiered_index_file/compacting/{时间戳}\",\"UPLOAD：已经上传到二级存储。\",\"mappedFile：UNSEALED 状态下索引文件引用，类似本地 IndexFile 的格式\",\"compactMappedFile：SEALED 状态下的索引文件，经过重排后的格式\",\"fileSegment：UPLOAD 状态下的索引文件，已上传二级存储\",\"IndexStoreService：IndexStoreFile 文件的容器，内部有排序的 IndexStoreFile 表，实现了索引文件读写接口，作为索引文件操作的入口。也是一个服务线程，用于扫描和重排已经写满的索引文件。 \",\"timeStoreTable：索引文件表，根据创建时间排序的跳表，Key 是创建时间\",\"currentWriteFile：正在写入的索引文件，也是 timeStoreTable 中的最后一个索引文件\"]},\"1413\":{\"h\":\"4.5.2 索引文件读写\",\"t\":[\"IndexStoreService 作为索引文件的容器和操作入口，保存着索引文件的跳表。该列表最多只允许有一个 UNSEALED 的文件，处理写入请求。\"]},\"1414\":{\"h\":\"写分级存储索引\",\"t\":[\"索引文件的写入在前面写过的分级存储 ConsumeQueue 数据上传完成之后被调用，入口是 MessageStoreDispatcherImpl#constructIndexFile，它会调用 IndexStoreService#putKey 方法进行写入。putKey 中会找到当前 UNSEALED 状态的索引文件，调用它的 putKey 方法写入，最多重试 3 次。如果文件写满，则创建新的索引文件后，都写入失败则打印错误日志。\",\"索引文件仅在根据 Key 查消息时使用，没有它的情况下也能正常消费消息，所以在多次写入失败的情况下可以放弃写入，它的写入顺序也是最靠后的。\",\"单个索引文件的写入逻辑如下：\",\"判断是否已经写满（索引数量超过最大值，默认 2000w），如果写满则将索引文件状态置为 SEALED 等待压缩，返回文件已满\",\"将索引项先写入本地的一个临时索引文件中\"]},\"1415\":{\"h\":\"读分级存储索引\",\"t\":[\"读索引的调用链如图所示，一般由 RocketMQ Admin client 发送 QueryMessage 请求触发，从下到上进行调用\",\"IndexStoreService#queryAsync 作为分级存储索引文件读取的入口，逻辑如下：\",\"获取查询时间范围内的所有索引文件\",\"逆序遍历索引文件，调用它的 queryAsync 方法异步查询索引项\",\"等待所有查询任务完成，将所有索引文件的查询结果放入结果列表\",\"单个索引文件的读取逻辑如下：\",\"根据索引文件状态判断从哪里读取 \",\"UNSEALED/SEALED 状态：从本地未压缩的临时索引文件查询，读取方式和读取普通的本地索引文件类似\",\"UPLOADED：从已上传分级存储的 FileSegment 中读取 \",\"根据 key 的 hashCode 计算 hash 槽位置\",\"读取 hash 槽中的索引项起始位置和总长度\",\"根据索引项起始位置和索引项总长度从 FileSegment 读取索引项\",\"从读到的索引项开始遍历，根据索引项的时间戳范围和 hashCode 过滤索引项，直到找到足够的索引项\"]},\"1416\":{\"h\":\"4.5.3 索引文件重排\"},\"1417\":{\"h\":\"4.5.3.1 重排流程\",\"t\":[\"索引文件重排的入口是 IndexStoreService，它是一个服务线程，每 10s 进行一次扫描，找到索引文件表中下一个 SEALED 状态的索引文件，准备重排和上传。\",\"重排和上传的入口函数是 doCompactThenUploadFile，它的逻辑如下\",\"如果这个文件还没有被重排，调用 IndexStoreFile#doCompaction 进行重排 \",\"创建一个新的本地内存映射文件，作为重排后的文件，它的目录也是单独的。在没有上传成功之前，重排前后的两个文件同时存在，老文件用来读取，新文件用来上传。 \",\"未重排文件：{storePath}/tiered_index_file/{时间戳}\",\"重排后文件：{storePath}/tiered_index_file/compacting/{时间戳}\",\"遍历老文件的 hash 槽和索引项，将索引项和 hash 槽写入新文件，此时进行重排\",\"更新新文件的头信息\",\"用重排后新索引文件的 ByteBuffer 在分级存储索引文件的 FlatAppendFile 中创建一个 FileSegment\",\"上传该 FileSegment 到分级存储\",\"上传完成之后将该 FileSegment 封装成 IndexStoreFile（UPLOADED 状态），放入 IndexStoreService 的跳表（覆盖原来未上传的）。\",\"删除本地的新老格式的索引文件\"]},\"1418\":{\"h\":\"4.5.3.2 重排细节\",\"t\":[\"左边是老的索引文件格式，这里不再赘述。重排的目标是在查询时减少对分级存储的 IOPS，也就是说在查询某个 Key 对应 hash 槽的所有索引项时，最好可以连续读。\",\"所以重排之后的结构就呼之欲出：原来 hash 槽的链表项，在文件中的位置是随机的，通过链表指针的方式连接起来。新的格式直接将同一 hash 槽的索引项在物理位置上连续排列，去掉链表指针也可以节省每个索引项占用的大小（4 Byte）。\",\"重排后的文件相对重排之前：\",\"Header 不变、hash 槽和索引项数量不变\",\"hash 槽大小从 4 Byte 扩大到 8 Byte，多了索引项总长度，方便一次性把这个 hash 槽的所有索引项查出来 \",\"0~4byte：hash 槽索引项的起始位置\",\"5~8byte：这个 hash 槽所有索引项的总长度\",\"索引项经过排序，去掉了链表指针，从 32byte 变为 28byte\"]},\"1419\":{\"h\":\"4.6 重启恢复和元数据\",\"t\":[\"分级存储的元数据是专门为了恢复分级存储文件引用而设置的，在分级存储相关的 Topic、Queue 或者 FileSegment 文件发生新建/删除时，索引文件会更新并持久化到本地文件中，在重启恢复分级存储模块时读取。\"]},\"1420\":{\"h\":\"4.6.1 元数据\",\"t\":[\"DefaultMetadataStore 作为分级存储元数据管理类，它扩展了 ConfigManager 类。\",\"ConfigManager 是 RocketMQ 一些动态配置（比如 topic 配置、消费组偏移量等）也用到的配置文件抽象类，它已经实现了 load 和 persist 方法，用于持久化到本地文件和从本地文件读取。扩展它之后只需要实现 decode 方法，定义持久化哪些数据。这里持久化了 5 组元数据表，以 json 的格式存储在 {storePath}/config/tieredStoreMetadata.json。\",\"元数据文件包括两类：\",\"Topic、Queue 的数据，在 FlatMessageFile 创建时更新，入口是 FlatMessageFile 构造函数。\",\"FileSegment 数据，包含创建时间、起始偏移量、大小、状态等。在 FileSegment 创建时更新，入口是 FlatAppendFile#rollingNewFile。\",\"一个简单的元数据文件示例如下：\",\"{ \\\"commitLogFileSegmentTable\\\":{ \\\"broker-a\\\\\\\\topic-tiered\\\\\\\\0\\\":{0:{ \\\"baseOffset\\\":0, \\\"beginTimestamp\\\":1713719372709, \\\"createTimestamp\\\":1713719498811, \\\"endTimestamp\\\":1713719488780, \\\"path\\\":\\\"broker-a\\\\\\\\topic-tiered\\\\\\\\0\\\", \\\"sealTimestamp\\\":0, \\\"size\\\":557667000, \\\"status\\\":0, \\\"type\\\":0 } } }, \\\"consumeQueueFileSegmentTable\\\":{ \\\"broker-a\\\\\\\\topic-tiered\\\\\\\\0\\\":{0:{ \\\"baseOffset\\\":0, \\\"beginTimestamp\\\":1713719372709, \\\"createTimestamp\\\":1713719498817, \\\"endTimestamp\\\":1713719488008, \\\"path\\\":\\\"broker-a\\\\\\\\topic-tiered\\\\\\\\0\\\", \\\"sealTimestamp\\\":0, \\\"size\\\":32417620, \\\"status\\\":0, \\\"type\\\":1 } } }, \\\"indexFileSegmentTable\\\":{}, \\\"queueMetadataTable\\\":{ \\\"topic-tiered\\\":{0:{ \\\"maxOffset\\\":0, \\\"minOffset\\\":0, \\\"queue\\\":{ \\\"brokerName\\\":\\\"broker-a\\\", \\\"queueId\\\":0, \\\"topic\\\":\\\"topic-tiered\\\" }, \\\"updateTimestamp\\\":1713719498827 } } }, \\\"topicMetadataTable\\\":{ \\\"topic-tiered\\\":{ \\\"reserveTime\\\":-1, \\\"status\\\":0, \\\"topic\\\":\\\"topic-tiered\\\", \\\"topicId\\\":2, \\\"updateTimestamp\\\":1713719372725 } }, \\\"topicSerialNumber\\\":2 } \"]},\"1421\":{\"h\":\"4.6.2 重启恢复\",\"t\":[\"恢复的入口是 TieredMessageStore#load 方法，它调用分级存储 FlatFileStore#load 方法，先恢复分级存储，然后调用本地存储的 load 方法恢复本地存储。\",\"FlatFileStore 的 load 方法中先清空所有分级存储文件，然后调用 recover 进行分级存储文件恢复，最后启动定时任务，每分钟扫描和清理过期文件。\",\"recover 方法逻辑如下：\",\"遍历 Topic 元数据，调用 recoverAsync(toicMetadata) 并发恢复 Topic，恢复之前获取信号量避免并发度过高\",\"遍历该 Topic 中的 Queue 元数据，调用 computeIfAbsent(MessageQueue) 为每个队列初始化分级存储消息数据文件 FlatMessageFile。初始化分级存储消息数据文件时，会递归恢复 CommitLog、ConsumeQueue、IndexFile 的分级存储文件（也遍历元数据来恢复）\",\"FlatMessageFile 的构造函数中会调用 createFlatFileForCommitLog 和 createFlatFileForConsumeQueue 来恢复对应的 FileSegment\",\"这两个方法也会调用元数据存储的 iterateFileSegment 遍历 FileSegment 的元数据来构造 FileSegment\"]},\"1422\":{\"h\":\"5. 源码解析\"},\"1423\":{\"h\":\"5.1 分级存储接入\"},\"1424\":{\"h\":\"5.1.1 BrokerController#initializeMessageStore 初始化分级存储实现\",\"t\":[\"public boolean initializeMessageStore() { boolean result = true; try { DefaultMessageStore defaultMessageStore; if (this.messageStoreConfig.isEnableRocksDBStore()) { defaultMessageStore = new RocksDBMessageStore(this.messageStoreConfig, this.brokerStatsManager, this.messageArrivingListener, this.brokerConfig, topicConfigManager.getTopicConfigTable()); } else { defaultMessageStore = new DefaultMessageStore(this.messageStoreConfig, this.brokerStatsManager, this.messageArrivingListener, this.brokerConfig, topicConfigManager.getTopicConfigTable()); } // 如果开启主从切换（DLedger 模式），为 DLedgerLeaderElector 选主器添加角色变更监听器 if (messageStoreConfig.isEnableDLegerCommitLog()) { DLedgerRoleChangeHandler roleChangeHandler = new DLedgerRoleChangeHandler(this, defaultMessageStore); ((DLedgerCommitLog) defaultMessageStore.getCommitLog()).getdLedgerServer().getDLedgerLeaderElector().addRoleChangeHandler(roleChangeHandler); } this.brokerStats = new BrokerStats(defaultMessageStore); // Load store plugin MessageStorePluginContext context = new MessageStorePluginContext( messageStoreConfig, brokerStatsManager, messageArrivingListener, brokerConfig, configuration); // 根据配置文件中的 storePlugin 属性，加载对应的消息存储插件。并且传入默认的消息存储实现的引用，以便插件中可以调用默认的消息存储实现。 this.messageStore = MessageStoreFactory.build(context, defaultMessageStore); this.messageStore.getDispatcherList().addFirst(new CommitLogDispatcherCalcBitMap(this.brokerConfig, this.consumerFilterManager)); if (messageStoreConfig.isTimerWheelEnable()) { // ... } } catch (IOException e) { result = false; LOG.error(\\\"BrokerController#initialize: unexpected error occurs\\\", e); } return result; } \"]},\"1425\":{\"h\":\"5.1.2 MessageStoreFactory#build 构造分级存储插件\",\"t\":[\"/** * 根据 BrokerConfig 配置的 MessageStorePlugin 创建扩展 MessageStore 实现 * * @param messageStore 默认 MessageStore，当前有 {@link org.apache.rocketmq.store.DefaultMessageStore} 和 {@link org.apache.rocketmq.store.RocksDBMessageStore} 两个实现 */ public static MessageStore build(MessageStorePluginContext context, MessageStore messageStore) throws IOException { String plugin = context.getBrokerConfig().getMessageStorePlugIn(); // 如果指定了扩展 MessageStore 实现，则创建扩展 MessageStore 实现，并将默认 MessageStore 作为参数传入 if (plugin != null && plugin.trim().length() != 0) { String[] pluginClasses = plugin.split(\\\",\\\"); for (int i = pluginClasses.length - 1; i >= 0; --i) { String pluginClass = pluginClasses[i]; try { @SuppressWarnings(\\\"unchecked\\\") Class<AbstractPluginMessageStore> clazz = (Class<AbstractPluginMessageStore>) Class.forName(pluginClass); Constructor<AbstractPluginMessageStore> construct = clazz.getConstructor(MessageStorePluginContext.class, MessageStore.class); AbstractPluginMessageStore pluginMessageStore = construct.newInstance(context, messageStore); messageStore = pluginMessageStore; } catch (Throwable e) { throw new RuntimeException(\\\"Initialize plugin's class: \\\" + pluginClass + \\\" not found!\\\", e); } } } return messageStore; } \"]},\"1426\":{\"h\":\"5.2 写消息\"},\"1427\":{\"h\":\"5.2.1 MessageStoreDispatcherImpl#doScheduleDispatch 定时上传消息到分级存储\",\"t\":[\"/** * 定时任务，每隔 20 秒为每个队列执行一次分发 */ @Override public void run() { log.info(\\\"{} service started\\\", this.getServiceName()); while (!this.isStopped()) { flatFileStore.deepCopyFlatFileToList().forEach(this::dispatchWithSemaphore); this.waitForRunning(Duration.ofSeconds(20).toMillis()); } log.info(\\\"{} service shutdown\\\", this.getServiceName()); } /** * 分发消息，将消息写入到 {@link FlatMessageFile} 文件中 * * @param force true: 等待直到获取锁成功，false: 获取锁失败时直接返回 */ @Override public CompletableFuture<Boolean> doScheduleDispatch(FlatFileInterface flatFile, boolean force) { if (stopped) { return CompletableFuture.completedFuture(true); } String topic = flatFile.getMessageQueue().getTopic(); int queueId = flatFile.getMessageQueue().getQueueId(); // 获取分级存储文件锁，写消息。force 为 true 时，会待直到获取锁成功 // For test scenarios, we set the 'force' variable to true to // ensure that the data in the cache is directly committed successfully. force = !storeConfig.isTieredStoreGroupCommit() || force; if (force) { flatFile.getFileLock().lock(); } else { if (!flatFile.getFileLock().tryLock()) { return CompletableFuture.completedFuture(false); } } try { // 如果 Topic 被过滤，则直接销毁文件 if (topicFilter != null && topicFilter.filterTopic(flatFile.getMessageQueue().getTopic())) { flatFileStore.destroyFile(flatFile.getMessageQueue()); return CompletableFuture.completedFuture(false); } // 已经提交到缓冲区的 ConsumeQueue offset long currentOffset = flatFile.getConsumeQueueMaxOffset(); // 已经刷盘的 ConsumeQueue offset long commitOffset = flatFile.getConsumeQueueCommitOffset(); long minOffsetInQueue = defaultStore.getMinOffsetInQueue(topic, queueId); long maxOffsetInQueue = defaultStore.getMaxOffsetInQueue(topic, queueId); // 如果 ConsumeQueue 的 FileSegment 文件完全没有初始化，则初始化文件 // If set to max offset here, some written messages may be lost if (!flatFile.isFlatFileInit()) { currentOffset = Math.max(minOffsetInQueue, maxOffsetInQueue - storeConfig.getTieredStoreGroupCommitSize()); flatFile.initOffset(currentOffset); return CompletableFuture.completedFuture(true); } // 如果上一次刷盘失败（已刷盘 offset 小于提交到缓冲区的 offset，说明没有全部刷盘成功），立即重试上次刷盘 // If the previous commit fails, attempt to trigger a commit directly. if (commitOffset < currentOffset) { this.commitAsync(flatFile); return CompletableFuture.completedFuture(false); } // 如果当前 offset 小于最小 offset，则销毁文件，重新创建文件 if (currentOffset < minOffsetInQueue) { log.warn(\\\"MessageDispatcher#dispatch, current offset is too small, \\\" + \\\"topic={}, queueId={}, offset={}-{}, current={}\\\", topic, queueId, minOffsetInQueue, maxOffsetInQueue, currentOffset); flatFileStore.destroyFile(flatFile.getMessageQueue()); flatFileStore.computeIfAbsent(new MessageQueue(topic, brokerName, queueId)); return CompletableFuture.completedFuture(true); } if (currentOffset > maxOffsetInQueue) { log.warn(\\\"MessageDispatcher#dispatch, current offset is too large, \\\" + \\\"topic: {}, queueId: {}, offset={}-{}, current={}\\\", topic, queueId, minOffsetInQueue, maxOffsetInQueue, currentOffset); return CompletableFuture.completedFuture(false); } // 如果超过滚动时间（24h），则滚动文件 long interval = TimeUnit.HOURS.toMillis(storeConfig.getCommitLogRollingInterval()); if (flatFile.rollingFile(interval)) { log.info(\\\"MessageDispatcher#dispatch, rolling file, \\\" + \\\"topic: {}, queueId: {}, offset={}-{}, current={}\\\", topic, queueId, minOffsetInQueue, maxOffsetInQueue, currentOffset); } if (currentOffset == maxOffsetInQueue) { return CompletableFuture.completedFuture(false); } long bufferSize = 0L; long groupCommitSize = storeConfig.getTieredStoreGroupCommitSize(); long groupCommitCount = storeConfig.getTieredStoreGroupCommitCount(); // 计算目标 offset，为当前以提交到缓冲区的 ConsumeQueue offset 加上单次提交的消息数阈值 long targetOffset = Math.min(currentOffset + groupCommitCount, maxOffsetInQueue); // 判断是否需要立即提交，还是继续攒批 // 取出最后 append 到缓冲区的一条消息 ConsumeQueueInterface consumeQueue = defaultStore.getConsumeQueue(topic, queueId); CqUnit cqUnit = consumeQueue.get(currentOffset); SelectMappedBufferResult message = defaultStore.selectOneMessageByOffset(cqUnit.getPos(), cqUnit.getSize()); // 超时：上次提交到当前时间是否超过分级存储存储的提交时间阈值（30s） boolean timeout = MessageFormatUtil.getStoreTimeStamp(message.getByteBuffer()) + storeConfig.getTieredStoreGroupCommitTimeout() < System.currentTimeMillis(); // 缓冲区满：当前队列等待提交的消息数量超过阈值（4096） boolean bufferFull = maxOffsetInQueue - currentOffset > storeConfig.getTieredStoreGroupCommitCount(); if (!timeout && !bufferFull && !force) { // 如果没有到提交时间阈值、缓冲区没有满、没有强制刷盘，则不进行刷盘，继续攒批 log.debug(\\\"MessageDispatcher#dispatch hold, topic={}, queueId={}, offset={}-{}, current={}, remain={}\\\", topic, queueId, minOffsetInQueue, maxOffsetInQueue, currentOffset, maxOffsetInQueue - currentOffset); return CompletableFuture.completedFuture(false); } else { // 如果到提交时间阈值或者缓冲区满或者强制刷盘，则进行刷盘 if (MessageFormatUtil.getStoreTimeStamp(message.getByteBuffer()) + TimeUnit.MINUTES.toMillis(5) < System.currentTimeMillis()) { log.warn(\\\"MessageDispatcher#dispatch behind too much, topic={}, queueId={}, offset={}-{}, current={}, remain={}\\\", topic, queueId, minOffsetInQueue, maxOffsetInQueue, currentOffset, maxOffsetInQueue - currentOffset); } else { log.info(\\\"MessageDispatcher#dispatch, topic={}, queueId={}, offset={}-{}, current={}, remain={}\\\", topic, queueId, minOffsetInQueue, maxOffsetInQueue, currentOffset, maxOffsetInQueue - currentOffset); } } message.release(); // 准备提交，先将消息放入缓冲区 // 对于目标偏移量之前的每个偏移量，从消费队列中获取消费队列单元，然后根据其从本地存储中查询消息 // 将消息追加到 CommitLog 缓冲区，并将分发请求追加到 ConsumeQueue 缓冲区 long offset = currentOffset; for (; offset < targetOffset; offset++) { cqUnit = consumeQueue.get(offset); bufferSize += cqUnit.getSize(); if (bufferSize >= groupCommitSize) { break; } message = defaultStore.selectOneMessageByOffset(cqUnit.getPos(), cqUnit.getSize()); // 将消息追加到分级存储 CommitLog 缓冲区 ByteBuffer byteBuffer = message.getByteBuffer(); AppendResult result = flatFile.appendCommitLog(message); if (!AppendResult.SUCCESS.equals(result)) { break; } long mappedCommitLogOffset = flatFile.getCommitLogMaxOffset() - byteBuffer.remaining(); Map<String, String> properties = MessageFormatUtil.getProperties(byteBuffer); DispatchRequest dispatchRequest = new DispatchRequest(topic, queueId, mappedCommitLogOffset, cqUnit.getSize(), cqUnit.getTagsCode(), MessageFormatUtil.getStoreTimeStamp(byteBuffer), cqUnit.getQueueOffset(), properties.getOrDefault(MessageConst.PROPERTY_KEYS, \\\"\\\"), properties.getOrDefault(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX, \\\"\\\"), 0, 0, new HashMap<>()); dispatchRequest.setOffsetId(MessageFormatUtil.getOffsetId(byteBuffer)); // 提交一个 DispatchRequest 到分级存储 ConsumeQueue result = flatFile.appendConsumeQueue(dispatchRequest); if (!AppendResult.SUCCESS.equals(result)) { break; } } // 如果等待提交的消息数量超过阈值（4096），立即进行下一次提交 // If there are many messages waiting to be uploaded, call the upload logic immediately. boolean repeat = timeout || maxOffsetInQueue - offset > storeConfig.getTieredStoreGroupCommitCount(); // 如果 FlatMessageFile 中待分发的 ConsumeQueue 请求不为空，则将缓冲区中的数据刷到二级存储 if (!flatFile.getDispatchRequestList().isEmpty()) { Attributes attributes = TieredStoreMetricsManager.newAttributesBuilder() .put(TieredStoreMetricsConstant.LABEL_TOPIC, topic) .put(TieredStoreMetricsConstant.LABEL_QUEUE_ID, queueId) .put(TieredStoreMetricsConstant.LABEL_FILE_TYPE, FileSegmentType.COMMIT_LOG.name().toLowerCase()) .build(); TieredStoreMetricsManager.messagesDispatchTotal.add(offset - currentOffset, attributes); this.commitAsync(flatFile).whenComplete((unused, throwable) -> { if (repeat) { // 如果等待提交的消息数量超过阈值（4096），立即进行下一次提交 storeExecutor.commonExecutor.submit(() -> dispatchWithSemaphore(flatFile)); } } ); } } finally { flatFile.getFileLock().unlock(); } return CompletableFuture.completedFuture(false); } /** * 执行 CommitLog 刷盘，再执行 ConsumeQueue 的刷盘，再执行 Index 构建（如果开启 Index） * * @param flatFile * @return */ public CompletableFuture<Void> commitAsync(FlatFileInterface flatFile) { return flatFile.commitAsync().thenAcceptAsync(success -> { if (success) { if (storeConfig.isMessageIndexEnable()) { flatFile.getDispatchRequestList().forEach( request -> constructIndexFile(flatFile.getTopicId(), request)); } flatFile.release(); } }, MessageStoreExecutor.getInstance().bufferCommitExecutor); } \"]},\"1428\":{\"h\":\"5.2.2 FileSegment#commitAsync 异步上传\",\"t\":[\"/** * 将 {@link #bufferList} 中的数据写入分级存储文件中 */ @SuppressWarnings(\\\"NonAtomicOperationOnVolatileField\\\") public CompletableFuture<Boolean> commitAsync() { if (closed) { return CompletableFuture.completedFuture(false); } if (!needCommit()) { return CompletableFuture.completedFuture(true); } // acquire lock if (commitLock.drainPermits() <= 0) { return CompletableFuture.completedFuture(false); } // 处理上次提交的错误（如果 fileSegmentInputStream 不为空） // handle last commit error if (fileSegmentInputStream != null) { long fileSize = this.getSize(); if (fileSize == GET_FILE_SIZE_ERROR) { log.error(\\\"FileSegment correct position error, fileName={}, commit={}, append={}, buffer={}\\\", this.getPath(), commitPosition, appendPosition, fileSegmentInputStream.getContentLength()); releaseCommitLock(); return CompletableFuture.completedFuture(false); } if (correctPosition(fileSize)) { fileSegmentInputStream = null; } } // 计算要提交数据的大小，并创建一个 FileSegmentInputStream 自定义输入流 int bufferSize; if (fileSegmentInputStream != null) { // 上次提交失败，重置输入流，重新提交 fileSegmentInputStream.rewind(); bufferSize = fileSegmentInputStream.available(); } else { // 上次提交成功，用 bufferList 中的 ByteBuffer 创建新的输入流 List<ByteBuffer> bufferList = this.borrowBuffer(); bufferSize = bufferList.stream().mapToInt(ByteBuffer::remaining).sum(); if (bufferSize == 0) { // 没有数据要提交，释放提交锁 releaseCommitLock(); return CompletableFuture.completedFuture(true); } fileSegmentInputStream = FileSegmentInputStreamFactory.build( fileType, this.getCommitOffset(), bufferList, null, bufferSize); } // 调用 commit0 方法执行实际提交操作 boolean append = fileType != FileSegmentType.INDEX; return flightCommitRequest = this.commit0(fileSegmentInputStream, commitPosition, bufferSize, append) // 处理提交操作结果 .thenApply(result -> { if (result) { // 提交成功，更新 commit offset，清空 fileSegmentInputStream commitPosition += bufferSize; fileSegmentInputStream = null; return true; } else { // 提交失败，重置 fileSegmentInputStream fileSegmentInputStream.rewind(); return false; } }) .exceptionally(this::handleCommitException) .whenComplete((result, e) -> releaseCommitLock()); } \"]},\"1429\":{\"h\":\"5.3 读消息\"},\"1430\":{\"h\":\"5.3.1 MessageStoreFetcherImpl#getMessageAsync 分级存储消息读取入口\",\"t\":[\"/** * 从分级存储读消息 * * @param group Consumer group that launches this query. * @param topic Topic to query. * @param queueId Queue ID to query. * @param queueOffset Logical offset to start from. * @param maxCount Maximum count of messages to query. * @param messageFilter Message filter used to screen desired messages. */ @Override public CompletableFuture<GetMessageResult> getMessageAsync( String group, String topic, int queueId, long queueOffset, int maxCount, final MessageFilter messageFilter) { GetMessageResult result = new GetMessageResult(); // 根据队列查找分级存储文件 FlatMessageFile flatFile = flatFileStore.getFlatFile(new MessageQueue(topic, brokerName, queueId)); // 分级存储队列文件不存在，返回 NO_MATCHED_LOGIC_QUEUE if (flatFile == null) { result.setNextBeginOffset(queueOffset); result.setStatus(GetMessageStatus.NO_MATCHED_LOGIC_QUEUE); return CompletableFuture.completedFuture(result); } // 从分级存储文件获取最小和最大偏移量，其中最大偏移量取的是消费队列的已提交偏移量（正在上传中的不算在内） // Max queue offset means next message put position result.setMinOffset(flatFile.getConsumeQueueMinOffset()); result.setMaxOffset(flatFile.getConsumeQueueCommitOffset()); // 根据 fetch 的 queueOffset 和返回结果的 minOffset、maxOffset 来决定返回的结果 // Fill result according file offset. // Offset range | Result | Fix to // (-oo, 0] | no message | current offset // (0, min) | too small | min offset // [min, max) | correct | // [max, max] | overflow one | max offset // (max, +oo) | overflow badly | max offset if (result.getMaxOffset() <= 0) { result.setStatus(GetMessageStatus.NO_MESSAGE_IN_QUEUE); result.setNextBeginOffset(queueOffset); return CompletableFuture.completedFuture(result); } else if (queueOffset < result.getMinOffset()) { result.setStatus(GetMessageStatus.OFFSET_TOO_SMALL); result.setNextBeginOffset(result.getMinOffset()); return CompletableFuture.completedFuture(result); } else if (queueOffset == result.getMaxOffset()) { result.setStatus(GetMessageStatus.OFFSET_OVERFLOW_ONE); result.setNextBeginOffset(result.getMaxOffset()); return CompletableFuture.completedFuture(result); } else if (queueOffset > result.getMaxOffset()) { result.setStatus(GetMessageStatus.OFFSET_OVERFLOW_BADLY); result.setNextBeginOffset(result.getMaxOffset()); return CompletableFuture.completedFuture(result); } boolean cacheBusy = fetcherCache.estimatedSize() > memoryMaxSize * 0.8; if (storeConfig.isReadAheadCacheEnable() && !cacheBusy) { // 从缓存读消息 return getMessageFromCacheAsync(flatFile, group, queueOffset, maxCount) .thenApply(messageResultExt -> messageResultExt.doFilterMessage(messageFilter)); } else { // 从分级存储读消息 return getMessageFromTieredStoreAsync(flatFile, queueOffset, maxCount) .thenApply(messageResultExt -> messageResultExt.doFilterMessage(messageFilter)); } } \"]},\"1431\":{\"h\":\"5.3.2 MessageStoreFetcherImpl#getMessageFromCacheAsync 从缓存中读取消息\",\"t\":[\"/** * 从分级存储预读缓存读消息 */ public CompletableFuture<GetMessageResultExt> getMessageFromCacheAsync( FlatMessageFile flatFile, String group, long queueOffset, int maxCount) { MessageQueue mq = flatFile.getMessageQueue(); // 从缓存中读一批消息 GetMessageResultExt result = getMessageFromCache(flatFile, queueOffset, maxCount); // 读取到消息 if (GetMessageStatus.FOUND.equals(result.getStatus())) { log.debug(\\\"MessageFetcher cache hit, group={}, topic={}, queueId={}, offset={}, maxCount={}, resultSize={}, lag={}\\\", group, mq.getTopic(), mq.getQueueId(), queueOffset, maxCount, result.getMessageCount(), result.getMaxOffset() - result.getNextBeginOffset()); return CompletableFuture.completedFuture(result); } // 如果缓存中没有读到，立即从二级存储中拉消息，并放入缓存 // If cache miss, pull messages immediately log.debug(\\\"MessageFetcher cache miss, group={}, topic={}, queueId={}, offset={}, maxCount={}, lag={}\\\", group, mq.getTopic(), mq.getQueueId(), queueOffset, maxCount, result.getMaxOffset() - result.getNextBeginOffset()); return fetchMessageThenPutToCache(flatFile, queueOffset, storeConfig.getReadAheadMessageCountThreshold()) .thenApply(maxOffset -> getMessageFromCache(flatFile, queueOffset, maxCount)); } /** * 从二级存储拉消息，放入缓存 */ protected CompletableFuture<Long> fetchMessageThenPutToCache( FlatMessageFile flatFile, long queueOffset, int batchSize) { MessageQueue mq = flatFile.getMessageQueue(); // 从二级存储读消息 return this.getMessageFromTieredStoreAsync(flatFile, queueOffset, batchSize) .thenApply(result -> { if (result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_ONE || result.getStatus() == GetMessageStatus.OFFSET_OVERFLOW_BADLY) { return -1L; } if (result.getStatus() != GetMessageStatus.FOUND) { log.warn(\\\"MessageFetcher prefetch message then put to cache failed, result={}, \\\" + \\\"topic={}, queue={}, queue offset={}, batch size={}\\\", result.getStatus(), mq.getTopic(), mq.getQueueId(), queueOffset, batchSize); return -1L; } List<Long> offsetList = result.getMessageQueueOffset(); List<Long> tagCodeList = result.getTagCodeList(); List<SelectMappedBufferResult> msgList = result.getMessageMapedList(); // 将读到的消息放入缓存 for (int i = 0; i < offsetList.size(); i++) { SelectMappedBufferResult msg = msgList.get(i); SelectBufferResult bufferResult = new SelectBufferResult( msg.getByteBuffer(), msg.getStartOffset(), msg.getSize(), tagCodeList.get(i)); this.putMessageToCache(flatFile, queueOffset + i, bufferResult); } return offsetList.get(offsetList.size() - 1); }); } \"]},\"1432\":{\"h\":\"5.3.3 MessageStoreFetcherImpl#getMessageFromTieredStoreAsync 从二级存储中读取消息\",\"t\":[\"/** * 从二级存储中读取消息 */ public CompletableFuture<GetMessageResultExt> getMessageFromTieredStoreAsync( FlatMessageFile flatFile, long queueOffset, int batchSize) { // 从分级存储文件获取最小和最大偏移量，其中最大偏移量取的是消费队列的已提交偏移量（正在上传中的不算在内） GetMessageResultExt result = new GetMessageResultExt(); result.setMinOffset(flatFile.getConsumeQueueMinOffset()); result.setMaxOffset(flatFile.getConsumeQueueCommitOffset()); // 根据 fetch 的 queueOffset 和返回结果的 minOffset、maxOffset 来决定返回的结果 if (queueOffset < result.getMinOffset()) { result.setStatus(GetMessageStatus.OFFSET_TOO_SMALL); result.setNextBeginOffset(result.getMinOffset()); return CompletableFuture.completedFuture(result); } else if (queueOffset == result.getMaxOffset()) { result.setStatus(GetMessageStatus.OFFSET_OVERFLOW_ONE); result.setNextBeginOffset(queueOffset); return CompletableFuture.completedFuture(result); } else if (queueOffset > result.getMaxOffset()) { result.setStatus(GetMessageStatus.OFFSET_OVERFLOW_BADLY); result.setNextBeginOffset(result.getMaxOffset()); return CompletableFuture.completedFuture(result); } if (queueOffset < result.getMaxOffset()) { batchSize = Math.min(batchSize, (int) Math.min( result.getMaxOffset() - queueOffset, storeConfig.getReadAheadMessageCountThreshold())); } // 读取 ConsumeQueue CompletableFuture<ByteBuffer> readConsumeQueueFuture; try { readConsumeQueueFuture = flatFile.getConsumeQueueAsync(queueOffset, batchSize); } catch (TieredStoreException e) { switch (e.getErrorCode()) { case ILLEGAL_PARAM: case ILLEGAL_OFFSET: default: result.setStatus(GetMessageStatus.OFFSET_FOUND_NULL); result.setNextBeginOffset(queueOffset); return CompletableFuture.completedFuture(result); } } int finalBatchSize = batchSize; CompletableFuture<ByteBuffer> readCommitLogFuture = readConsumeQueueFuture.thenCompose(cqBuffer -> { // 从 ConsumeQueue Buffer 中解析出第一条和最后一条消息的 commitLog offset，并验证是否合法 long firstCommitLogOffset = MessageFormatUtil.getCommitLogOffsetFromItem(cqBuffer); cqBuffer.position(cqBuffer.remaining() - MessageFormatUtil.CONSUME_QUEUE_UNIT_SIZE); long lastCommitLogOffset = MessageFormatUtil.getCommitLogOffsetFromItem(cqBuffer); if (lastCommitLogOffset < firstCommitLogOffset) { log.error(\\\"MessageFetcher#getMessageFromTieredStoreAsync, last offset is smaller than first offset, \\\" + \\\"topic={} queueId={}, offset={}, firstOffset={}, lastOffset={}\\\", flatFile.getMessageQueue().getTopic(), flatFile.getMessageQueue().getQueueId(), queueOffset, firstCommitLogOffset, lastCommitLogOffset); return CompletableFuture.completedFuture(ByteBuffer.allocate(0)); } // 获取整体要读的消息长度，如果长度超过阈值，则缩小单次读取长度（从最后一条消息开始往前缩小，直到缩到只有一条消息） // Get at least one message // Reducing the length limit of cq to prevent OOM long length = lastCommitLogOffset - firstCommitLogOffset + MessageFormatUtil.getSizeFromItem(cqBuffer); while (cqBuffer.limit() > MessageFormatUtil.CONSUME_QUEUE_UNIT_SIZE && length > storeConfig.getReadAheadMessageSizeThreshold()) { cqBuffer.limit(cqBuffer.position()); cqBuffer.position(cqBuffer.limit() - MessageFormatUtil.CONSUME_QUEUE_UNIT_SIZE); length = MessageFormatUtil.getCommitLogOffsetFromItem(cqBuffer) - firstCommitLogOffset + MessageFormatUtil.getSizeFromItem(cqBuffer); } int messageCount = cqBuffer.position() / MessageFormatUtil.CONSUME_QUEUE_UNIT_SIZE + 1; log.info(\\\"MessageFetcher#getMessageFromTieredStoreAsync, \\\" + \\\"topic={}, queueId={}, broker offset={}-{}, offset={}, expect={}, actually={}, lag={}\\\", flatFile.getMessageQueue().getTopic(), flatFile.getMessageQueue().getQueueId(), result.getMinOffset(), result.getMaxOffset(), queueOffset, finalBatchSize, messageCount, result.getMaxOffset() - queueOffset); // 从分级存储 CommitLog 中读取消息 return flatFile.getCommitLogAsync(firstCommitLogOffset, (int) length); }); return readConsumeQueueFuture.thenCombine(readCommitLogFuture, (cqBuffer, msgBuffer) -> { // 拆分每条消息的 ByteBuffer List<SelectBufferResult> bufferList = MessageFormatUtil.splitMessageBuffer(cqBuffer, msgBuffer); int requestSize = cqBuffer.remaining() / MessageFormatUtil.CONSUME_QUEUE_UNIT_SIZE; // not use buffer list size to calculate next offset to prevent split error if (bufferList.isEmpty()) { // 消息 ByteBuffer 列表为空 result.setStatus(GetMessageStatus.NO_MATCHED_MESSAGE); result.setNextBeginOffset(queueOffset + requestSize); } else { // 消息 ByteBuffer 列表不为空 result.setStatus(GetMessageStatus.FOUND); result.setNextBeginOffset(queueOffset + requestSize); // 将所有消息加入结果 for (SelectBufferResult bufferResult : bufferList) { ByteBuffer slice = bufferResult.getByteBuffer().slice(); slice.limit(bufferResult.getSize()); SelectMappedBufferResult msg = new SelectMappedBufferResult(bufferResult.getStartOffset(), bufferResult.getByteBuffer(), bufferResult.getSize(), null); result.addMessageExt(msg, MessageFormatUtil.getQueueOffset(slice), bufferResult.getTagCode()); } } return result; }).exceptionally(e -> { MessageQueue mq = flatFile.getMessageQueue(); log.warn(\\\"MessageFetcher#getMessageFromTieredStoreAsync failed, \\\" + \\\"topic={} queueId={}, offset={}, batchSize={}\\\", mq.getTopic(), mq.getQueueId(), queueOffset, finalBatchSize, e); result.setStatus(GetMessageStatus.OFFSET_FOUND_NULL); result.setNextBeginOffset(queueOffset); return result; }); } \"]},\"1433\":{\"h\":\"5.4 索引文件\"},\"1434\":{\"h\":\"5.4.1 IndexStoreService/IndexStoreFile#putKey 写入索引项\",\"t\":[\"// IndexStoreService.java /** * 向最新的索引文件中写入索引项 */ @Override public AppendResult putKey( String topic, int topicId, int queueId, Set<String> keySet, long offset, int size, long timestamp) { if (StringUtils.isBlank(topic)) { return AppendResult.UNKNOWN_ERROR; } if (keySet == null || keySet.isEmpty()) { return AppendResult.SUCCESS; } // 向当前写入的索引文件中写入索引项，重试 3 次 for (int i = 0; i < 3; i++) { AppendResult result = this.currentWriteFile.putKey( topic, topicId, queueId, keySet, offset, size, timestamp); if (AppendResult.SUCCESS.equals(result)) { return AppendResult.SUCCESS; } else if (AppendResult.FILE_FULL.equals(result)) { // 当前索引文件已满，创建新的索引文件 // use current time to ensure the order of file this.createNewIndexFile(System.currentTimeMillis()); } } // 写入失败 log.error(\\\"IndexStoreService put key three times return error, topic: {}, topicId: {}, \\\" + \\\"queueId: {}, keySize: {}, timestamp: {}\\\", topic, topicId, queueId, keySet.size(), timestamp); return AppendResult.UNKNOWN_ERROR; } // IndexStoreFile.java public AppendResult putKey( String topic, int topicId, int queueId, Set<String> keySet, long offset, int size, long timestamp) { if (StringUtils.isBlank(topic)) { return AppendResult.UNKNOWN_ERROR; } if (keySet == null || keySet.isEmpty()) { return AppendResult.SUCCESS; } try { fileReadWriteLock.writeLock().lock(); // 只有 UNSEALED 状态的索引文件才允许被写入 if (!UNSEALED.equals(fileStatus.get())) { return AppendResult.FILE_FULL; } // 索引数量超过最大值（默认 2000w），将索引文件状态置为 SEALED 等待压缩，返回文件已满 if (this.indexItemCount.get() + keySet.size() >= this.indexItemMaxCount) { this.fileStatus.set(IndexStatusEnum.SEALED); return AppendResult.FILE_FULL; } // 遍历每个 Key，插入索引项 for (String key : keySet) { int hashCode = this.hashCode(this.buildKey(topic, key)); int slotPosition = this.getSlotPosition(hashCode % this.hashSlotMaxCount); int slotOldValue = this.getSlotValue(slotPosition); int timeDiff = (int) ((timestamp - this.beginTimestamp.get()) / 1000L); // 构造 IndexItem，写入索引文件 IndexItem indexItem = new IndexItem( topicId, queueId, offset, size, hashCode, timeDiff, slotOldValue); int itemIndex = this.indexItemCount.incrementAndGet(); this.byteBuffer.position(this.getItemPosition(itemIndex)); this.byteBuffer.put(indexItem.getByteBuffer()); this.byteBuffer.putInt(slotPosition, itemIndex); if (slotOldValue <= INVALID_INDEX) { this.hashSlotCount.incrementAndGet(); } // 更新 endTimestamp if (this.endTimestamp.get() < timestamp) { this.endTimestamp.set(timestamp); } // 更新索引文件 Header this.flushNewMetadata(byteBuffer, indexItemMaxCount == this.indexItemCount.get() + 1); log.trace(\\\"IndexStoreFile put key, timestamp: {}, topic: {}, key: {}, slot: {}, item: {}, previous item: {}, content: {}\\\", this.getTimestamp(), topic, key, hashCode % this.hashSlotMaxCount, itemIndex, slotOldValue, indexItem); } return AppendResult.SUCCESS; } catch (Exception e) { log.error(\\\"IndexStoreFile put key error, topic: {}, topicId: {}, queueId: {}, keySet: {}, offset: {}, \\\" + \\\"size: {}, timestamp: {}\\\", topic, topicId, queueId, keySet, offset, size, timestamp, e); } finally { fileReadWriteLock.writeLock().unlock(); } return AppendResult.UNKNOWN_ERROR; } \"]},\"1435\":{\"h\":\"5.4.2 IndexStoreService/IndexStoreFile#doCompaction 索引文件压缩重排\",\"t\":[\"// IndexStoreService.java /** * 每 10s 进行一次扫描和压缩 */ @Override public void run() { while (!this.isStopped()) { // 删除过期索引文件 long expireTimestamp = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(storeConfig.getTieredStoreFileReservedTime()); this.destroyExpiredFile(expireTimestamp); // 按时间顺序找到下一个 SEALED 待压缩文件 IndexFile indexFile = this.getNextSealedFile(); // 压缩并上传 if (indexFile != null) { if (this.doCompactThenUploadFile(indexFile)) { this.setCompactTimestamp(indexFile.getTimestamp()); continue; } } this.waitForRunning(TimeUnit.SECONDS.toMillis(10)); } log.info(this.getServiceName() + \\\" service shutdown\\\"); } /** * 压缩索引文件并上传到二级存储 */ public boolean doCompactThenUploadFile(IndexFile indexFile) { if (IndexFile.IndexStatusEnum.UPLOAD.equals(indexFile.getFileStatus())) { log.error(\\\"IndexStoreService file status not correct, so skip, timestamp: {}, status: {}\\\", indexFile.getTimestamp(), indexFile.getFileStatus()); indexFile.destroy(); return true; } Stopwatch stopwatch = Stopwatch.createStarted(); // 如果缓冲区的所有内容都已刷盘到二级存储，则可以进行压缩 if (flatAppendFile.getCommitOffset() == flatAppendFile.getAppendOffset()) { // 压缩成新索引文件，返回新文件的 ByteBuffer ByteBuffer byteBuffer = indexFile.doCompaction(); if (byteBuffer == null) { log.error(\\\"IndexStoreService found compaction buffer is null, timestamp: {}\\\", indexFile.getTimestamp()); return false; } // 创建新的 FileSegment，即压缩后的索引文件 flatAppendFile.rollingNewFile(Math.max(0L, flatAppendFile.getAppendOffset())); flatAppendFile.append(byteBuffer, indexFile.getTimestamp()); flatAppendFile.getFileToWrite().setMinTimestamp(indexFile.getTimestamp()); flatAppendFile.getFileToWrite().setMaxTimestamp(indexFile.getEndTimestamp()); } // 等待压缩后的索引文件刷盘到分级存储 boolean result = flatAppendFile.commitAsync().join(); List<FileSegment> fileSegmentList = flatAppendFile.getFileSegmentList(); FileSegment fileSegment = fileSegmentList.get(fileSegmentList.size() - 1); if (!result || fileSegment == null || fileSegment.getMinTimestamp() != indexFile.getTimestamp()) { log.warn(\\\"IndexStoreService upload compacted file error, timestamp: {}\\\", indexFile.getTimestamp()); return false; } else { log.info(\\\"IndexStoreService upload compacted file success, timestamp: {}\\\", indexFile.getTimestamp()); } // 将上传后的所以你文件封装成 IndexFile，保存到 timeStoreTable 中 readWriteLock.writeLock().lock(); try { IndexFile storeFile = new IndexStoreFile(storeConfig, fileSegment); timeStoreTable.put(storeFile.getTimestamp(), storeFile); // 删除本地 IndexFile（未压缩的和压缩后的） indexFile.destroy(); } catch (Exception e) { log.error(\\\"IndexStoreService rolling file error, timestamp: {}, cost: {}ms\\\", indexFile.getTimestamp(), stopwatch.elapsed(TimeUnit.MILLISECONDS), e); } finally { readWriteLock.writeLock().unlock(); } return true; } // IndexStoreFile.java /** * 压缩索引文件到新文件，设置索引文件状态为 SEALED，返回新文件 ByteBuffer * * @return 压缩后索引文件 ByteBuffer，读模式 */ @Override public ByteBuffer doCompaction() { Stopwatch stopwatch = Stopwatch.createStarted(); ByteBuffer buffer; try { buffer = compactToNewFile(); log.debug(\\\"IndexStoreFile do compaction, timestamp: {}, file size: {}, cost: {}ms\\\", this.getTimestamp(), buffer.capacity(), stopwatch.elapsed(TimeUnit.MICROSECONDS)); } catch (Exception e) { log.error(\\\"IndexStoreFile do compaction, timestamp: {}, cost: {}ms\\\", this.getTimestamp(), stopwatch.elapsed(TimeUnit.MICROSECONDS), e); return null; } try { // Make sure there is no read request here fileReadWriteLock.writeLock().lock(); fileStatus.set(IndexStatusEnum.SEALED); } catch (Exception e) { log.error(\\\"IndexStoreFile change file status to sealed error, timestamp={}\\\", this.getTimestamp()); } finally { fileReadWriteLock.writeLock().unlock(); } return buffer; } /** * 将 UNSEALED 状态的索引文件压缩到新文件 * <p> * 压缩文件于压缩前文件相比 * <ul> * <li>header 不变</li> * <li>hash 槽从 4byte 扩大到 8byte，增加了</li> * <li>索引项经过排序，去掉了指针，从 32byte 变为 28byte</li> * </ul> * * @return 压缩后的新文件 ByteBuffer，读模式 * @throws IOException */ protected ByteBuffer compactToNewFile() throws IOException { byte[] payload = new byte[IndexItem.INDEX_ITEM_SIZE]; ByteBuffer payloadBuffer = ByteBuffer.wrap(payload); // 索引项开始写入位置 = header size + hash 槽总 size（hash 槽数 500w * hash 槽 size 8） int writePosition = INDEX_HEADER_SIZE + (hashSlotMaxCount * HASH_SLOT_SIZE); // 文件大小 = 索引项写入位置 + 索引项总 size（索引项数 2000w * 索引项 size 32） int fileMaxLength = writePosition + COMPACT_INDEX_ITEM_SIZE * indexItemCount.get(); // 创建新的压缩索引文件 compactMappedFile = new DefaultMappedFile(this.getCompactedFilePath(), fileMaxLength); // 压缩后的索引文件 ByteBuffer MappedByteBuffer newBuffer = compactMappedFile.getMappedByteBuffer(); // 遍历所有 hash 槽（500w） for (int i = 0; i < hashSlotMaxCount; i++) { int slotPosition = this.getSlotPosition(i); int slotValue = this.getSlotValue(slotPosition); int writeBeginPosition = writePosition; // 遍历 hash 槽中所有的索引项 while (slotValue > INVALID_INDEX && writePosition < fileMaxLength) { // 读取压缩前索引项 ByteBuffer buffer = this.byteBuffer.duplicate(); buffer.position(this.getItemPosition(slotValue)); buffer.get(payload); // 读取老索引项的下一个索引项位置 int newSlotValue = payloadBuffer.getInt(COMPACT_INDEX_ITEM_SIZE); // 截掉老索引项的下一个索引项位置，新索引项中不需要。这行是多余的，后面没有操作 buffer buffer.limit(COMPACT_INDEX_ITEM_SIZE); // 索引项写入到新索引文件 newBuffer.position(writePosition); newBuffer.put(payload, 0, COMPACT_INDEX_ITEM_SIZE); log.trace(\\\"IndexStoreFile do compaction, write item, slot: {}, current: {}, next: {}\\\", i, slotValue, newSlotValue); // 指向下一个索引项位置 slotValue = newSlotValue; // 写入位置后移 writePosition += COMPACT_INDEX_ITEM_SIZE; } // 计算所有索引项总长度 int length = writePosition - writeBeginPosition; // 向压缩后的文件写入 hash 槽数据 // 0~4byte: 这个 hash 槽索引项的起始位置 newBuffer.putInt(slotPosition, writeBeginPosition); // 5~8byte: 这个 hash 槽所有索引项的总长度 newBuffer.putInt(slotPosition + Integer.BYTES, length); if (length > 0) { log.trace(\\\"IndexStoreFile do compaction, write slot, slot: {}, begin: {}, length: {}\\\", i, writeBeginPosition, length); } } // 更新 header this.flushNewMetadata(newBuffer, true); // 切换成读模式 newBuffer.flip(); return newBuffer; } \"]},\"1436\":{\"h\":\"5.4.3 IndexStoreService/IndexStoreFile#queryAsync 根据消息 Key 查询索引项\",\"t\":[\"// IndexStoreService.java /** * 异步查询索引项 * * @param topic The topic of the key. * @param key The key to be queried. * @param maxCount * @param beginTime The start time of the query range. * @param endTime The end time of the query range. * @return */ @Override public CompletableFuture<List<IndexItem>> queryAsync( String topic, String key, int maxCount, long beginTime, long endTime) { CompletableFuture<List<IndexItem>> future = new CompletableFuture<>(); try { readWriteLock.readLock().lock(); // 获取时间范围内的所有索引文件 ConcurrentNavigableMap<Long, IndexFile> pendingMap = this.timeStoreTable.subMap(beginTime, true, endTime, true); List<CompletableFuture<Void>> futureList = new ArrayList<>(pendingMap.size()); ConcurrentHashMap<String /* queueId-offset */, IndexItem> result = new ConcurrentHashMap<>(); // 逆序遍历索引文件，异步查询索引项 for (Map.Entry<Long, IndexFile> entry : pendingMap.descendingMap().entrySet()) { CompletableFuture<Void> completableFuture = entry.getValue() .queryAsync(topic, key, maxCount, beginTime, endTime) .thenAccept(itemList -> itemList.forEach(indexItem -> { if (result.size() < maxCount) { result.put(String.format( \\\"%d-%d\\\", indexItem.getQueueId(), indexItem.getOffset()), indexItem); } })); futureList.add(completableFuture); } // 等待所有查询任务完成 CompletableFuture.allOf(futureList.toArray(new CompletableFuture[0])) .whenComplete((v, t) -> { // Try to return the query results as much as possible here // rather than directly throwing exceptions if (result.isEmpty() && t != null) { future.completeExceptionally(t); } else { List<IndexItem> resultList = new ArrayList<>(result.values()); future.complete(resultList.subList(0, Math.min(resultList.size(), maxCount))); } }); } catch (Exception e) { future.completeExceptionally(e); } finally { readWriteLock.readLock().unlock(); } return future; } \",\"// IndexStoreFile.java public CompletableFuture<List<IndexItem>> queryAsync( String topic, String key, int maxCount, long beginTime, long endTime) { switch (this.fileStatus.get()) { case UNSEALED: case SEALED: // 从本地未压缩的索引文件中查询索引项。SEALED 状态的索引文件仍然会保留未压缩前的索引文件。 return this.queryAsyncFromUnsealedFile(buildKey(topic, key), maxCount, beginTime, endTime); case UPLOAD: // 从已压缩并上传到二级存储的索引文件中查询索引项 return this.queryAsyncFromSegmentFile(buildKey(topic, key), maxCount, beginTime, endTime); case SHUTDOWN: default: return CompletableFuture.completedFuture(new ArrayList<>()); } } /** * 从未压缩的索引文件中查询索引项。SEALED 状态的索引文件仍然会保留未压缩前的索引文件，可能已经创建新索引文件并正在压缩 */ protected CompletableFuture<List<IndexItem>> queryAsyncFromUnsealedFile( String key, int maxCount, long beginTime, long endTime) { return CompletableFuture.supplyAsync(() -> { List<IndexItem> result = new ArrayList<>(); try { fileReadWriteLock.readLock().lock(); if (!UNSEALED.equals(this.fileStatus.get()) && !SEALED.equals(this.fileStatus.get())) { return result; } if (mappedFile == null || !mappedFile.hold()) { return result; } // 根据 key 的 hashCode 计算 hash 槽位置，获取 hash 槽的值。它指向第一个索引项的位置 int hashCode = this.hashCode(key); int slotPosition = this.getSlotPosition(hashCode % this.hashSlotMaxCount); int slotValue = this.getSlotValue(slotPosition); // 遍历索引项链表，直到找到足够的索引项或者达到最大查询次数（默认 512） int left = MAX_QUERY_COUNT; while (left > 0 && slotValue > INVALID_INDEX && slotValue <= this.indexItemCount.get()) { byte[] bytes = new byte[IndexItem.INDEX_ITEM_SIZE]; ByteBuffer buffer = this.byteBuffer.duplicate(); buffer.position(this.getItemPosition(slotValue)); buffer.get(bytes); IndexItem indexItem = new IndexItem(bytes); if (hashCode == indexItem.getHashCode()) { result.add(indexItem); if (result.size() > maxCount) { break; } } slotValue = indexItem.getItemIndex(); left--; } log.debug(\\\"IndexStoreFile query from unsealed mapped file, timestamp: {}, result size: {}, \\\" + \\\"key: {}, hashCode: {}, maxCount: {}, timestamp={}-{}\\\", getTimestamp(), result.size(), key, hashCode, maxCount, beginTime, endTime); } catch (Exception e) { log.error(\\\"IndexStoreFile query from unsealed mapped file error, timestamp: {}, \\\" + \\\"key: {}, maxCount: {}, timestamp={}-{}\\\", getTimestamp(), key, maxCount, beginTime, endTime, e); } finally { fileReadWriteLock.readLock().unlock(); mappedFile.release(); } return result; }, MessageStoreExecutor.getInstance().bufferFetchExecutor); } /** * 从已压缩并上传到二级存储的索引文件中查询索引项 */ protected CompletableFuture<List<IndexItem>> queryAsyncFromSegmentFile( String key, int maxCount, long beginTime, long endTime) { if (this.fileSegment == null || !UPLOAD.equals(this.fileStatus.get())) { return CompletableFuture.completedFuture(Collections.emptyList()); } Stopwatch stopwatch = Stopwatch.createStarted(); // 从二级存储中读取索引文件，根据 key 的 hashCode 计算 hash 槽位置 int hashCode = this.hashCode(key); int slotPosition = this.getSlotPosition(hashCode % this.hashSlotMaxCount); // 根据 hash 槽位置查询 hash 槽 CompletableFuture<List<IndexItem>> future = this.fileSegment.readAsync(slotPosition, HASH_SLOT_SIZE) .thenCompose(slotBuffer -> { if (slotBuffer.remaining() < HASH_SLOT_SIZE) { log.error(\\\"IndexStoreFile query from tiered storage return error slot buffer, \\\" + \\\"key: {}, maxCount: {}, timestamp={}-{}\\\", key, maxCount, beginTime, endTime); return CompletableFuture.completedFuture(null); } // 读取 hash 槽中的索引项起始位置和总长度 int indexPosition = slotBuffer.getInt(); int indexTotalSize = Math.min(slotBuffer.getInt(), COMPACT_INDEX_ITEM_SIZE * 1024); if (indexPosition <= INVALID_INDEX || indexTotalSize <= 0) { return CompletableFuture.completedFuture(null); } // 根据索引项起始位置和索引项总长度读取索引项 return this.fileSegment.readAsync(indexPosition, indexTotalSize); }) // 组装读取到的索引项 .thenApply(itemBuffer -> { List<IndexItem> result = new ArrayList<>(); if (itemBuffer == null) { return result; } if (itemBuffer.remaining() % COMPACT_INDEX_ITEM_SIZE != 0) { log.error(\\\"IndexStoreFile query from tiered storage return error item buffer, \\\" + \\\"key: {}, maxCount: {}, timestamp={}-{}\\\", key, maxCount, beginTime, endTime); return result; } // 遍历索引项，根据索引项的时间戳范围和 hashCode 过滤索引项，直到找到足够的索引项 int size = itemBuffer.remaining() / COMPACT_INDEX_ITEM_SIZE; byte[] bytes = new byte[COMPACT_INDEX_ITEM_SIZE]; for (int i = 0; i < size; i++) { itemBuffer.get(bytes); IndexItem indexItem = new IndexItem(bytes); long storeTimestamp = indexItem.getTimeDiff() + beginTimestamp.get(); if (hashCode == indexItem.getHashCode() && beginTime <= storeTimestamp && storeTimestamp <= endTime && result.size() < maxCount) { result.add(indexItem); } } return result; }); return future.whenComplete((result, throwable) -> { long costTime = stopwatch.elapsed(TimeUnit.MILLISECONDS); if (throwable != null) { log.error(\\\"IndexStoreFile query from segment file, cost: {}ms, timestamp: {}, \\\" + \\\"key: {}, hashCode: {}, maxCount: {}, timestamp={}-{}\\\", costTime, getTimestamp(), key, hashCode, maxCount, beginTime, endTime, throwable); } else { String details = Optional.ofNullable(result) .map(r -> r.stream() .map(item -> String.format(\\\"%d-%d\\\", item.getQueueId(), item.getOffset())) .collect(Collectors.joining(\\\", \\\"))) .orElse(\\\"\\\"); log.debug(\\\"IndexStoreFile query from segment file, cost: {}ms, timestamp: {}, result size: {}, ({}), \\\" + \\\"key: {}, hashCode: {}, maxCount: {}, timestamp={}-{}\\\", costTime, getTimestamp(), result != null ? result.size() : 0, details, key, hashCode, maxCount, beginTime, endTime); } }); } \"]},\"1437\":{\"h\":\"参考资料\",\"t\":[\"Tiered storage README.md\",\"RIP 57 Tiered storage for RocketMQ\",\"RIP 65 Tiered Storage Optimization\",\"Refactoring and improving Tiered Storage Implementation\",\"[RIP-65] Support efficient random index for massive messages\",\"[Enhancement] Performance Improvement and Bug Fixes for the Tiered Storage Module\",\"RocketMQ 多级存储设计与实现\",\"谈谈 RocketMQ 5.0 分级存储背后一些有挑战的技术优化\",\"RocketMQ5源码（七）分层存储\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1438\":{\"h\":\"RocketMQ 事务消息原理详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20250131-rocketmq-transactional-message.html\"]},\"1439\":{\"h\":\"1. 背景\",\"t\":[\"在当下的互联网时代，微服务架构兴起，业务量也达到了惊人的量级。消息队列作为微服务架构解耦、流量削峰、异步处理等的重要组件，成为了微服务架构中不可或缺的一部分。\",\"事务指的是一系列操作，要么全部成功，要么全部失败，事务在业务系统中也有大规模的应用。当涉及到事务相关的系统模块时，普通消息无法满足“本地操作和消息发送”要么全部成功，要么全部失败的需求，因此有了事务消息的需求。\",\"RocketMQ 在 4.3.0 版本开始支持分布式事务消息。RocketMQ 的事务消息在普通消息基础上，支持二阶段的提交能力。将二阶段提交和本地事务绑定，实现全局提交结果的一致性。\",\"本文将基于 RocketMQ 5.3.x 源码，分析 RocketMQ 事务消息的实现原理。\"]},\"1440\":{\"h\":\"2. 使用示例\",\"t\":[\"本示例使用 RocketMQ 4.x 的 Java 客户端实现。\"]},\"1441\":{\"h\":\"2.1 创建事务 Topic\",\"t\":[\"事先创建好一个 Topic 用作事务消息接收。RocketMQ 5.x 版本之后，需要在创建 Topic 时指定消息类型，这里创建一个 TRANSACTION 类型的 Topic。\",\"./bin/mqadmin updatetopic -n localhost:9876 -t TopicTest1234 -c DefaultCluster -a +message.type=TRANSACTION \"]},\"1442\":{\"h\":\"2.2 实现事务消息本地执行和回查逻辑\",\"t\":[\"然后需要实现 TransactionListener 接口，该接口有两个方法：\",\"executeLocalTransaction：执行本地事务，这个方法中填写本地事务逻辑，返回 LocalTransactionState 枚举值，表示本地事务的状态。\",\"checkLocalTransaction：检查本地事务，返回 LocalTransactionState 枚举值，表示本地事务的状态。\",\"如果执行本地事务的操作直接返回 LocalTransactionState.COMMIT_MESSAGE 或 LocalTransactionState.ROLLBACK_MESSAGE，则不会调用 checkLocalTransaction 方法。如果返回 LocalTransactionState.UNKNOW，表示本地事务暂时没有执行完，结果未知，则会在后续调用 checkLocalTransaction 方法来检查本地事务执行的状态。\",\"public class TransactionListenerImpl implements TransactionListener { private AtomicInteger transactionIndex = new AtomicInteger(0); private ConcurrentHashMap<String, Integer> localTrans = new ConcurrentHashMap<>(); @Override public LocalTransactionState executeLocalTransaction(Message msg, Object arg) { // 用作示例，模拟 3 种本地事务的执行结果 int value = transactionIndex.getAndIncrement(); int status = value % 3; localTrans.put(msg.getTransactionId(), status); // 故意返回 UNKNOW，模拟本地事务未执行完，需要执行事务状态检查 return LocalTransactionState.UNKNOW; } @Override public LocalTransactionState checkLocalTransaction(MessageExt msg) { // 根据本地事务随机模拟的 3 种执行结果，返回对应的本地事务状态 Integer status = localTrans.get(msg.getTransactionId()); if (null != status) { switch (status) { case 0: return LocalTransactionState.UNKNOW; case 1: return LocalTransactionState.COMMIT_MESSAGE; case 2: return LocalTransactionState.ROLLBACK_MESSAGE; } } return LocalTransactionState.COMMIT_MESSAGE; } } \"]},\"1443\":{\"h\":\"2.3 事务消息生产者\",\"t\":[\"然后创建一个 TransactionMQProducer 实例，并设置 TransactionListener。\",\"public static void main(String[] args) throws MQClientException, InterruptedException { TransactionListener transactionListener = new TransactionListenerImpl(); TransactionMQProducer producer = new TransactionMQProducer(PRODUCER_GROUP, Arrays.asList(TOPIC)); producer.setNamesrvAddr(DEFAULT_NAMESRVADDR); // 本地事务执行状态回查线程池 ExecutorService executorService = new ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, new ArrayBlockingQueue<>(2000), r -> { Thread thread = new Thread(r); thread.setName(\\\"client-transaction-msg-check-thread\\\"); return thread; }); producer.setExecutorService(executorService); // 设置之前定义的本地事务执行和回查监听器实例 producer.setTransactionListener(transactionListener); producer.start(); String[] tags = new String[] {\\\"TagA\\\", \\\"TagB\\\", \\\"TagC\\\", \\\"TagD\\\", \\\"TagE\\\"}; for (int i = 0; i < MESSAGE_COUNT; i++) { try { Message msg = new Message(TOPIC, tags[i % tags.length], \\\"KEY\\\" + i, (\\\"Hello RocketMQ \\\" + i).getBytes(RemotingHelper.DEFAULT_CHARSET)); SendResult sendResult = producer.sendMessageInTransaction(msg, null); System.out.printf(\\\"%s%n\\\", sendResult); Thread.sleep(10); } catch (MQClientException | UnsupportedEncodingException e) { e.printStackTrace(); } } // ... } \"]},\"1444\":{\"h\":\"2.4 消费者\",\"t\":[\"最后启动一个消费者来消费事务消息。\",\"public static void main(String[] args) throws InterruptedException, MQClientException { DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(CONSUMER_GROUP); // Uncomment the following line while debugging, namesrvAddr should be set to your local address consumer.setNamesrvAddr(NAMESRV_ADDR); consumer.subscribe(TOPIC, \\\"*\\\"); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> msgs, ConsumeConcurrentlyContext context) { System.out.printf(\\\"%s Receive New Messages: %s %n\\\", Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); consumer.start(); System.out.printf(\\\"Consumer Started.%n\\\"); } \"]},\"1445\":{\"h\":\"2.5 运行结果\",\"t\":[\"生产者的运行日志如下：\",\"SendResult [sendStatus=SEND_OK, msgId=C0A80109803418B4AAC25D18010D0000, offsetMsgId=null, messageQueue=MessageQueue [topic=TopicTest1234, brokerName=broker-a, queueId=0], queueOffset=0, recallHandle=null] SendResult [sendStatus=SEND_OK, msgId=C0A80109803418B4AAC25D1801BE0001, offsetMsgId=null, messageQueue=MessageQueue [topic=TopicTest1234, brokerName=broker-a, queueId=1], queueOffset=1, recallHandle=null] SendResult [sendStatus=SEND_OK, msgId=C0A80109803418B4AAC25D1801CD0002, offsetMsgId=null, messageQueue=MessageQueue [topic=TopicTest1234, brokerName=broker-a, queueId=2], queueOffset=2, recallHandle=null] SendResult [sendStatus=SEND_OK, msgId=C0A80109803418B4AAC25D1801DA0003, offsetMsgId=null, messageQueue=MessageQueue [topic=TopicTest1234, brokerName=broker-a, queueId=3], queueOffset=3, recallHandle=null] SendResult [sendStatus=SEND_OK, msgId=C0A80109803418B4AAC25D1801E70004, offsetMsgId=null, messageQueue=MessageQueue [topic=TopicTest1234, brokerName=broker-a, queueId=0], queueOffset=4, recallHandle=null] SendResult [sendStatus=SEND_OK, msgId=C0A80109803418B4AAC25D1801F50005, offsetMsgId=null, messageQueue=MessageQueue [topic=TopicTest1234, brokerName=broker-a, queueId=1], queueOffset=5, recallHandle=null] SendResult [sendStatus=SEND_OK, msgId=C0A80109803418B4AAC25D1802020006, offsetMsgId=null, messageQueue=MessageQueue [topic=TopicTest1234, brokerName=broker-a, queueId=2], queueOffset=6, recallHandle=null] SendResult [sendStatus=SEND_OK, msgId=C0A80109803418B4AAC25D18020F0007, offsetMsgId=null, messageQueue=MessageQueue [topic=TopicTest1234, brokerName=broker-a, queueId=3], queueOffset=7, recallHandle=null] SendResult [sendStatus=SEND_OK, msgId=C0A80109803418B4AAC25D18021D0008, offsetMsgId=null, messageQueue=MessageQueue [topic=TopicTest1234, brokerName=broker-a, queueId=0], queueOffset=8, recallHandle=null] SendResult [sendStatus=SEND_OK, msgId=C0A80109803418B4AAC25D18022B0009, offsetMsgId=null, messageQueue=MessageQueue [topic=TopicTest1234, brokerName=broker-a, queueId=1], queueOffset=9, recallHandle=null] \",\"消费者运行日志如下：\",\"Consumer Started. ConsumeMessageThread_CID_JODIE_1_1 Receive New Messages: [MessageExt [brokerName=broker-a, queueId=0, storeSize=420, queueOffset=0, sysFlag=8, bornTimestamp=1737222654439, bornHost=/127.0.0.1:5290, storeTimestamp=1737222675592, storeHost=/127.0.0.1:10911, msgId=7F00000100002A9F000000104A169B49, commitLogOffset=69962472265, bodyCRC=601994070, reconsumeTimes=0, preparedTransactionOffset=69962469259, toString()=Message{topic='TopicTest1234', flag=0, properties={CONSUME_START_TIME=1737222710178, MSG_REGION=DefaultRegion, UNIQ_KEY=C0A80109803418B4AAC25D1801E70004, CLUSTER=DefaultCluster, PGROUP=please_rename_unique_group_name, MIN_OFFSET=0, __transactionId__=C0A80109803418B4AAC25D1801E70004, TAGS=TagE, TRAN_MSG=true, KEYS=KEY4, WAIT=true, TRACE_ON=true, TRANSACTION_CHECK_TIMES=1, REAL_TOPIC=TopicTest1234, MAX_OFFSET=1, REAL_QID=0}, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 52], transactionId='C0A80109803418B4AAC25D1801E70004'}]] ConsumeMessageThread_CID_JODIE_1_2 Receive New Messages: [MessageExt [brokerName=broker-a, queueId=1, storeSize=420, queueOffset=0, sysFlag=8, bornTimestamp=1737222654398, bornHost=/127.0.0.1:5290, storeTimestamp=1737222675591, storeHost=/127.0.0.1:10911, msgId=7F00000100002A9F000000104A1699A5, commitLogOffset=69962471845, bodyCRC=1401636825, reconsumeTimes=0, preparedTransactionOffset=69962467966, toString()=Message{topic='TopicTest1234', flag=0, properties={CONSUME_START_TIME=1737222710178, MSG_REGION=DefaultRegion, UNIQ_KEY=C0A80109803418B4AAC25D1801BE0001, CLUSTER=DefaultCluster, PGROUP=please_rename_unique_group_name, MIN_OFFSET=0, __transactionId__=C0A80109803418B4AAC25D1801BE0001, TAGS=TagB, TRAN_MSG=true, KEYS=KEY1, WAIT=true, TRACE_ON=true, TRANSACTION_CHECK_TIMES=1, REAL_TOPIC=TopicTest1234, MAX_OFFSET=1, REAL_QID=1}, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 49], transactionId='C0A80109803418B4AAC25D1801BE0001'}]] ConsumeMessageThread_CID_JODIE_1_3 Receive New Messages: [MessageExt [brokerName=broker-a, queueId=3, storeSize=420, queueOffset=0, sysFlag=8, bornTimestamp=1737222654479, bornHost=/127.0.0.1:5290, storeTimestamp=1737222675592, storeHost=/127.0.0.1:10911, msgId=7F00000100002A9F000000104A169CED, commitLogOffset=69962472685, bodyCRC=988340972, reconsumeTimes=0, preparedTransactionOffset=69962470552, toString()=Message{topic='TopicTest1234', flag=0, properties={CONSUME_START_TIME=1737222710178, MSG_REGION=DefaultRegion, UNIQ_KEY=C0A80109803418B4AAC25D18020F0007, CLUSTER=DefaultCluster, PGROUP=please_rename_unique_group_name, MIN_OFFSET=0, __transactionId__=C0A80109803418B4AAC25D18020F0007, TAGS=TagC, TRAN_MSG=true, KEYS=KEY7, WAIT=true, TRACE_ON=true, TRANSACTION_CHECK_TIMES=1, REAL_TOPIC=TopicTest1234, MAX_OFFSET=1, REAL_QID=3}, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 55], transactionId='C0A80109803418B4AAC25D18020F0007'}]] \",\"只收到 3 条消息，因为发送时模拟了 3 种本地事务的执行结果，只有 3 条消息是 COMMIT_MESSAGE 状态，4 条消息是 UNKNOW 状态，3 条消息是 ROLLBACK_MESSAGE 状态。UNKNOWN 状态的消息会继续进行回查，ROLLBACK_MESSAGE 状态的消息会被丢弃。\"]},\"1446\":{\"h\":\"3. 概要设计\",\"t\":[\"RocketMQ 的事务实现方式为二阶段提交：\",\"先将原始消息以事务半消息的形式发送到服务端，对消费者不可见。\",\"然后生产者执行本地事务，根据本地事务执行结果来复原或丢弃事务半消息。\",\"如果本地事务执行结果未知，则服务端对生产者进行定期回查本地事务执行状态。\",\"根据回查的本地事务执行结果，服务端将事务半消息复原或丢弃。\",\"整个流程如下图所示：\",\"生产者（Sender）发送消息到 RocketMQ 服务端（Server），除了原本的信息外，向消息属性中添加了事务消息标识，表示一个事务半消息（Half message）。\",\"我们并不希望事务半消息被消费者消费到，所以它被保存在服务端一个专门用来保存半消息的特殊 Topic 中，消息持久化成功之后，向生产者返回 Ack 确认消息已经发送成功。\",\"生产者开始执行本地事务逻辑。\",\"生产者将本地事务执行结果上报给服务端。如果本地事务无法马上执行完，应上报 Unknown；执行成功则上报 Commit，执行失败上报 Rollback。服务端收到确认结果后处理逻辑如下： \",\"Unknown：暂不处理，服务端在一定时间后，对生产者实例发起定时回查。\",\"Commit/Rollback：生成一个事务操作消息（OP 消息），记录该事务半消息的最终处理结果，然后将 OP 消息保存到 OP Topic 中。在后面服务端定期回查前，从 OP Topic 中查询 OP 消息，如果能找到 OP 消息，表示该事务半消息需要提交或回滚，则执行提交或回滚操作。\",\"服务端进行定时回查，对半消息 Topic 中的半消息进行回查。先根据 OP Topic 中是否有该半消息对应的 OP 消息来判断半消息的执行结果。 \",\"没有 OP 消息：进行回查。\",\"有 Commit 的 OP 消息：将半消息复原，发送到真实的 Topic，可以投递给消费者。\",\"有 Rollback 的 OP 消息：丢弃半消息。\",\"生产者收到消息回查请求后，检查对应消息的本地事务执行的最终结果。\",\"生产者将本地事务执行状态上报给服务端，进行二次确认，服务端仍按照步骤 4 对半事务消息进行处理。\"]},\"1447\":{\"h\":\"4. 原理详解\"},\"1448\":{\"h\":\"4.1 事务消息发送\"},\"1449\":{\"h\":\"4.1.1 生产者发送事务消息\",\"t\":[\"RocketMQ 为事务消息定义了专门的生产者类型 TransactionMQProducer 和本地事务执行接口 TransactionListener。\",\"调用事务生产者的 sendMessageInTransaction 方法发送事务消息，该方法会调用 DefaultMQProducerImpl 的 sendMessageInTransaction 方法，事务消息发送的主要逻辑都在该方法中。\",\"sendMessageInTransaction 方法接收一个普通消息，将它包装成事务半消息发送给 Broker，然后执行本地事务，上报执行结果给 Broker。详细逻辑如下：\",\"设置原始消息的 TRAN_MSG 属性设置为 true，表示该消息是一个事务半消息。\",\"发送半消息到 Broker。\",\"如果半消息发送成功，执行本地事务，获取本地事务执行结果；如果发送失败，则不执行。\",\"调用 endTransaction 方法，通知 Broker 本地事务执行结果。这里是异步单向请求，不需要等待响应。\"]},\"1450\":{\"h\":\"4.1.2 Broker 接收事务半消息\",\"t\":[\"Broker 的消息生产请求处理器 SendMessageProcessor 的 processRequest 方法处理生产者发来的普通消息和事务消息。\",\"该方法会检查消息的 TRAN_MSG 属性，如果为 true，则表示该消息是一个事务半消息。为了让消费者暂时无法消费到该消息，RocketMQ 的设计是将它保存到 RMQ_SYS_TRANS_HALF_TOPIC Topic 中。后续收到生产者的本地事务执行结果后，会根据执行结果将事务半消息查出来，复原或丢弃。\"]},\"1451\":{\"h\":\"4.1.3 Broker 接收事务执行结果请求\",\"t\":[\"Broker 的事务执行结果处理逻辑会在以下两个情况下触发：\",\"生产者第一次发送事务半消息，执行本地事务，会调用 endTransaction 方法，通知 Broker 本地事务执行结果。\",\"生产者收到 Broker 的事务执行状态回查请求，会查询本地事务执行结果，然后上报给 Broker。\",\"Broker 的 EndTransactionProcessor 的 processRequest 方法处理事务执行结果请求，它根据生产者上报的本地事务执行结果，将事务半消息复原或丢弃。详细逻辑如下：\",\"如果本地事务执行状态为 COMMIT_MESSAGE： \",\"根据请求头中的事务半消息物理偏移量，从存储中查询出事务半消息。\",\"复原事务半消息的原始 Topic 和队列。\",\"将复原后的消息保存到存储，此时消息可以被消费者消费。\",\"删除事务半消息：将事务半消息存储在事务消息 OP Topic：RMQ_SYS_TRANS_OP_HALF_TOPIC 中，表示该消息已经被处理, 无需再次回查。\",\"如果本地事务执行状态为 ROLLBACK_MESSAGE\",\"从存储中查询出事务半消息\",\"删除事务半消息\",\"如果本地事务执行状态为 UNKNOWN 则不作处理\"]},\"1452\":{\"h\":\"4.2 事务状态回查\"},\"1453\":{\"h\":\"4.2.1 Broker 回查事务状态\",\"t\":[\"Broker 的服务线程 TransactionalMessageCheckService 每 30s 触发一次 TransactionalMessageServiceImpl#check 方法进行事务消息的回查。该方法会从半消息 Topic 中取出半消息，与 OP Topic 中的消息进行匹配（匹配上则认为处理完）。对于没有处理完的半消息，发送回查请求给生产者组中的一个生产者，触发生产者上报本地事务执行状态。它的详细逻辑如下：\",\"获取事务半消息 Topic 的所有队列，然后遍历这些队列（默认只有 1 个队列） \",\"获取半消息队列对应的 OP Topic 的队列，OP Topic 是用来保存事务半消息的操作结果的 Topic，为 RMQ_SYS_TRANS_OP_HALF_TOPIC。在上面的 Broker 处理本地事务执行结果请求时，事务的执行结果会保存到该 Topic 中。\",\"调用 fillOpRemoveMap 方法，查询一批 OP 消息，然后遍历它们，把它们对应的需要移除的半消息的逻辑偏移量放到 removeMap 中，用作后续匹配。\",\"不断循环消费事务半消息进行处理，直到没有新的半消息或处理持续时间超过 60s：\",\"判断当前要消费的半消息的偏移量是否在 removeMap 中，如果在则表示该半消息已经提交或回滚，跳过，继续消费下一条。\",\"对于没有在 removeMap 中的半消息 \",\"调用 getHalfMsg 方法从存储中查询出该半消息\",\"判断事务消息是否需要丢弃，即超过最大回查次数（15次）；或者是否需要跳过，即超过文件保存时间。如果是则丢弃后继续查询下一条。\",\"更新半消息的回查次数（+1），在消息属性中。\",\"计算事务半消息是否处在免疫回查期：即事务消息发送一段时间之内不进行回查，默认 6s。如果在免疫器则跳出回查循环。\",\"如果需要回查，将半消息重新保存（因为前面更新了回查次数，这里会新写入一条消息，这也是为了后面能够重新消费到这条半消息再次进行回查的判断，如果回查次数多会导致写放大。)。\",\"根据生产组，轮询一个生产者，异步发送单向消息回查请求。\",\"回查时会复原半消息的原始 Topic 和队列，然后将其作为回查请求体发送给生产者。\",\"这里 OP 消息的操作较为繁琐，它用来标记一条半消息的事务执行结果。一个优化方案是直接将半消息的事务执行结果覆写到半消息本身，这样后面判断半消息是否需要回查时可以直接根据半消息本身来判断。这个方案的好处是可以不需要 OP 消息繁琐的操作，坏处是这样会破坏 CommitLog WAL 的语义，造成随机读写。如果需要覆盖的半消息不在页缓存，会触发磁盘 I/O，速度就比较慢了。\"]},\"1454\":{\"h\":\"4.2.2 生产者处理事务状态回查请求\",\"t\":[\"生产者处理 Broker 回查请求的主要方法是 DefaultMQProducerImpl#checkLocalTransaction，它根据 Broker 发回的半消息获取本地事务执行结果，然后将执行结果发回 Broker。\"]},\"1455\":{\"h\":\"5. 源码解析\"},\"1456\":{\"h\":\"5.1 事务消息发送\"},\"1457\":{\"h\":\"5.1.1 生产者发送事务消息\"},\"1458\":{\"h\":\"TransactionMQProducer#sendMessageInTransaction\",\"t\":[\"// TransactionMQProducer.java /** * 发送事务消息 * * @param msg Transactional message to send. * 需要发送的事务消息 * @param arg Argument used along with local transaction executor. * 本地事务执行器的参数 * @return 事务消息发送结果 */ @Override public TransactionSendResult sendMessageInTransaction(final Message msg, final Object arg) throws MQClientException { if (null == this.transactionListener) { throw new MQClientException(\\\"TransactionListener is null\\\", null); } msg.setTopic(NamespaceUtil.wrapNamespace(this.getNamespace(), msg.getTopic())); return this.defaultMQProducerImpl.sendMessageInTransaction(msg, null, arg); } \"]},\"1459\":{\"h\":\"DefaultMQProducerImpl#sendMessageInTransaction\",\"t\":[\"// DefaultMQProducerImpl.java /** * 发送事务消息 * * @param msg 事务消息 * @param localTransactionListener 本地事务执行和状态检查器 * @param arg 本地事务执行参数 */ public TransactionSendResult sendMessageInTransaction(final Message msg, final TransactionListener localTransactionListener, final Object arg) throws MQClientException { TransactionListener transactionListener = getCheckListener(); if (null == localTransactionListener && null == transactionListener) { throw new MQClientException(\\\"tranExecutor is null\\\", null); } // ignore DelayTimeLevel parameter if (msg.getDelayTimeLevel() != 0) { MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_DELAY_TIME_LEVEL); } Validators.checkMessage(msg, this.defaultMQProducer); SendResult sendResult = null; // 设置消息属性 TRAN_MSG，标记消息为事务消息 MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, \\\"true\\\"); MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup()); try { // 发送半事务消息 sendResult = this.send(msg); } catch (Exception e) { throw new MQClientException(\\\"send message Exception\\\", e); } LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW; Throwable localException = null; switch (sendResult.getSendStatus()) { case SEND_OK: { try { if (sendResult.getTransactionId() != null) { msg.putUserProperty(\\\"__transactionId__\\\", sendResult.getTransactionId()); } String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX); if (null != transactionId && !\\\"\\\".equals(transactionId)) { msg.setTransactionId(transactionId); } if (null != localTransactionListener) { // 使用 DefaultMQProducerImpl 进行事务消息发送，执行本地事务 localTransactionState = localTransactionListener.executeLocalTransaction(msg, arg); } else { // 使用新的 TransactionMQProducer 进行事务消息发送，执行本地事务 log.debug(\\\"Used new transaction API\\\"); localTransactionState = transactionListener.executeLocalTransaction(msg, arg); } if (null == localTransactionState) { localTransactionState = LocalTransactionState.UNKNOW; } if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) { log.info(\\\"executeLocalTransactionBranch return: {} messageTopic: {} transactionId: {} tag: {} key: {}\\\", localTransactionState, msg.getTopic(), msg.getTransactionId(), msg.getTags(), msg.getKeys()); } } catch (Throwable e) { log.error(\\\"executeLocalTransactionBranch exception, messageTopic: {} transactionId: {} tag: {} key: {}\\\", msg.getTopic(), msg.getTransactionId(), msg.getTags(), msg.getKeys(), e); localException = e; } } break; case FLUSH_DISK_TIMEOUT: case FLUSH_SLAVE_TIMEOUT: case SLAVE_NOT_AVAILABLE: localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE; break; default: break; } try { // 结束事务，如果半消息发送失败或本地事务执行失败告诉服务端删除半消息，半消息发送成功且本地事务执行成功则告诉服务端让半消息复原 this.endTransaction(msg, sendResult, localTransactionState, localException); } catch (Exception e) { log.warn(\\\"local transaction execute \\\" + localTransactionState + \\\", but end broker transaction failed\\\", e); } TransactionSendResult transactionSendResult = new TransactionSendResult(); transactionSendResult.setSendStatus(sendResult.getSendStatus()); transactionSendResult.setMessageQueue(sendResult.getMessageQueue()); transactionSendResult.setMsgId(sendResult.getMsgId()); transactionSendResult.setQueueOffset(sendResult.getQueueOffset()); transactionSendResult.setTransactionId(sendResult.getTransactionId()); transactionSendResult.setLocalTransactionState(localTransactionState); return transactionSendResult; } \"]},\"1460\":{\"h\":\"TransactionMQProducer#endTransaction\",\"t\":[\"// TransactionMQProducer.java /** * 向 Broker 发送结束事务请求，根据本地事务执行状态，通知 Broker 半消息如何处理 * * @param msg 事务消息 * @param sendResult 事务半消息的发送结果 * @param localTransactionState 本地事务执行状态 */ public void endTransaction( final Message msg, final SendResult sendResult, final LocalTransactionState localTransactionState, final Throwable localException) throws RemotingException, MQBrokerException, InterruptedException, UnknownHostException { final MessageId id; if (sendResult.getOffsetMsgId() != null) { id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId()); } else { id = MessageDecoder.decodeMessageId(sendResult.getMsgId()); } String transactionId = sendResult.getTransactionId(); final String destBrokerName = this.mQClientFactory.getBrokerNameFromMessageQueue(defaultMQProducer.queueWithNamespace(sendResult.getMessageQueue())); final String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(destBrokerName); EndTransactionRequestHeader requestHeader = new EndTransactionRequestHeader(); requestHeader.setTopic(msg.getTopic()); requestHeader.setTransactionId(transactionId); requestHeader.setCommitLogOffset(id.getOffset()); requestHeader.setBrokerName(destBrokerName); // 根据本地事务执行状态设置事务结束请求类型 switch (localTransactionState) { case COMMIT_MESSAGE: requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE); break; case ROLLBACK_MESSAGE: requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE); break; case UNKNOW: requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE); break; default: break; } // 执行事务结束钩子，这里主要会记录消息轨迹 doExecuteEndTransactionHook(msg, sendResult.getMsgId(), brokerAddr, localTransactionState, false); requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup()); requestHeader.setTranStateTableOffset(sendResult.getQueueOffset()); requestHeader.setMsgId(sendResult.getMsgId()); String remark = localException != null ? (\\\"executeLocalTransactionBranch exception: \\\" + localException.toString()) : null; // 向 Broker 发送事务消息结束请求，根据本地事务执行状态通知 Broker 半消息如何处理 this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark, this.defaultMQProducer.getSendMsgTimeout()); } \"]},\"1461\":{\"h\":\"5.1.2 Broker 接收事务消息\"},\"1462\":{\"h\":\"SendMessageProcessor#processRequest 接收事务半消息\",\"t\":[\"// SendMessageProcessor.java public RemotingCommand sendMessage(final ChannelHandlerContext ctx, final RemotingCommand request, final SendMessageContext sendMessageContext, final SendMessageRequestHeader requestHeader, final TopicQueueMappingContext mappingContext, final SendMessageCallback sendMessageCallback) throws RemotingCommandException { // ... // 尝试获取事务消息标识 String traFlag = oriProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED); boolean sendTransactionPrepareMessage; if (Boolean.parseBoolean(traFlag) && !(msgInner.getReconsumeTimes() > 0 && msgInner.getDelayTimeLevel() > 0)) { //For client under version 4.6.1 if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) { response.setCode(ResponseCode.NO_PERMISSION); response.setRemark( \\\"the broker[\\\" + this.brokerController.getBrokerConfig().getBrokerIP1() + \\\"] sending transaction message is forbidden\\\"); return response; } // 是事务消息 sendTransactionPrepareMessage = true; } else { sendTransactionPrepareMessage = false; } // 异步存储消息 if (brokerController.getBrokerConfig().isAsyncSendEnable()) { CompletableFuture<PutMessageResult> asyncPutMessageFuture; if (sendTransactionPrepareMessage) { // 如果是事务消息，构造事务半消息并存储 asyncPutMessageFuture = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner); } else { // 普通消息存储 asyncPutMessageFuture = this.brokerController.getMessageStore().asyncPutMessage(msgInner); } final int finalQueueIdInt = queueIdInt; final MessageExtBrokerInner finalMsgInner = msgInner; asyncPutMessageFuture.thenAcceptAsync(putMessageResult -> { RemotingCommand responseFuture = handlePutMessageResult(putMessageResult, response, request, finalMsgInner, responseHeader, sendMessageContext, ctx, finalQueueIdInt, beginTimeMillis, mappingContext, BrokerMetricsManager.getMessageType(requestHeader)); if (responseFuture != null) { doResponse(ctx, request, responseFuture); } // record the transaction metrics, responseFuture == null means put successfully if (sendTransactionPrepareMessage && (responseFuture == null || responseFuture.getCode() == ResponseCode.SUCCESS)) { this.brokerController.getTransactionalMessageService().getTransactionMetrics().addAndGet(msgInner.getProperty(MessageConst.PROPERTY_REAL_TOPIC), 1); } sendMessageCallback.onComplete(sendMessageContext, response); }, this.brokerController.getPutMessageFutureExecutor()); // Returns null to release the send message thread return null; // 同步存储消息 } else { PutMessageResult putMessageResult = null; if (sendTransactionPrepareMessage) { // 如果是事务消息，构造事务半消息并存储 putMessageResult = this.brokerController.getTransactionalMessageService().prepareMessage(msgInner); } else { // 普通消息存储 putMessageResult = this.brokerController.getMessageStore().putMessage(msgInner); } handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt, beginTimeMillis, mappingContext, BrokerMetricsManager.getMessageType(requestHeader)); // record the transaction metrics if (putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK && putMessageResult.getAppendMessageResult().isOk()) { this.brokerController.getTransactionalMessageService().getTransactionMetrics().addAndGet(msgInner.getProperty(MessageConst.PROPERTY_REAL_TOPIC), 1); } sendMessageCallback.onComplete(sendMessageContext, response); return response; } } \"]},\"1463\":{\"h\":\"TransactionMessageBridge#parseHalfMessageInner 事务消息转换成事务半消息保存\",\"t\":[\"// TransactionMessageBridge.java public PutMessageResult putHalfMessage(MessageExtBrokerInner messageInner) { return store.putMessage(parseHalfMessageInner(messageInner)); } public CompletableFuture<PutMessageResult> asyncPutHalfMessage(MessageExtBrokerInner messageInner) { return store.asyncPutMessage(parseHalfMessageInner(messageInner)); } /** * 准备事务半消息，将原消息的 Topic 和 QueueId 保存到消息属性中，然后将消息的 Topic 设置为 RMQ_SYS_TRANS_HALF_TOPIC 的 0 队列 */ private MessageExtBrokerInner parseHalfMessageInner(MessageExtBrokerInner msgInner) { String uniqId = msgInner.getUserProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX); if (uniqId != null && !uniqId.isEmpty()) { MessageAccessor.putProperty(msgInner, TransactionalMessageUtil.TRANSACTION_ID, uniqId); } // 将原始消息的 Topic 和 QueueId 保存到事务半消息的属性中 MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic()); MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msgInner.getQueueId())); msgInner.setSysFlag( MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE)); // 设置事务半消息的 Topic 为 RMQ_SYS_TRANS_HALF_TOPIC msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic()); msgInner.setQueueId(0); msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties())); return msgInner; } \"]},\"1464\":{\"h\":\"EndTransactionProcessor#processRequest 处理 EndTransaction 请求\",\"t\":[\"// EndTransactionProcessor.java /** * 两个场景会发触发 END_TRANSACTION 请求 * 1. 生产者第一次发送事务消息，执行完本地事务后 * 2. 生产者收到服务端事务回查请求，查询完本地事务执行状态 */ @Override public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException { final RemotingCommand response = RemotingCommand.createResponseCommand(null); final EndTransactionRequestHeader requestHeader = (EndTransactionRequestHeader) request.decodeCommandCustomHeader(EndTransactionRequestHeader.class); if (BrokerRole.SLAVE == brokerController.getMessageStoreConfig().getBrokerRole()) { response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE); LOGGER.warn(\\\"Message store is slave mode, so end transaction is forbidden. \\\"); return response; } // ... OperationResult result = new OperationResult(); // 事务提交 if (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) { // 从存储中查询出事务半消息 result = this.brokerController.getTransactionalMessageService().commitMessage(requestHeader); // 成功查询出事务半消息 if (result.getResponseCode() == ResponseCode.SUCCESS) { if (rejectCommitOrRollback(requestHeader, result.getPrepareMessage())) { response.setCode(ResponseCode.ILLEGAL_OPERATION); LOGGER.warn(\\\"Message commit fail [producer end]. currentTimeMillis - bornTime > checkImmunityTime, msgId={},commitLogOffset={}, wait check\\\", requestHeader.getMsgId(), requestHeader.getCommitLogOffset()); return response; } // 验证事务半消息的必要字段 RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader); if (res.getCode() == ResponseCode.SUCCESS) { // 验证成功 // 恢复事务半消息的真实 Topic、队列，并设置事务 ID，并设置相关属性 MessageExtBrokerInner msgInner = endMessageTransaction(result.getPrepareMessage()); msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback())); msgInner.setQueueOffset(requestHeader.getTranStateTableOffset()); msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset()); msgInner.setStoreTimestamp(result.getPrepareMessage().getStoreTimestamp()); MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_TRANSACTION_PREPARED); // 发送最终的事务消息，存储到 CommitLog 中，可以被消费者消费 RemotingCommand sendResult = sendFinalMessage(msgInner); if (sendResult.getCode() == ResponseCode.SUCCESS) { // 删除事务半消息：将事务半消息存储在事务消息操作 Topic：RMQ_SYS_TRANS_OP_HALF_TOPIC 中，表示该消息已经被处理 this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage()); // successful committed, then total num of half-messages minus 1 this.brokerController.getTransactionalMessageService().getTransactionMetrics().addAndGet(msgInner.getTopic(), -1); BrokerMetricsManager.commitMessagesTotal.add(1, BrokerMetricsManager.newAttributesBuilder() .put(LABEL_TOPIC, msgInner.getTopic()) .build()); // record the commit latency. Long commitLatency = (System.currentTimeMillis() - result.getPrepareMessage().getBornTimestamp()) / 1000; BrokerMetricsManager.transactionFinishLatency.record(commitLatency, BrokerMetricsManager.newAttributesBuilder() .put(LABEL_TOPIC, msgInner.getTopic()) .build()); } return sendResult; } return res; } // 事务回滚 } else if (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) { // 从存储中查询出事务半消息 result = this.brokerController.getTransactionalMessageService().rollbackMessage(requestHeader); if (result.getResponseCode() == ResponseCode.SUCCESS) { // 成功查询出事务半消息 if (rejectCommitOrRollback(requestHeader, result.getPrepareMessage())) { response.setCode(ResponseCode.ILLEGAL_OPERATION); LOGGER.warn(\\\"Message rollback fail [producer end]. currentTimeMillis - bornTime > checkImmunityTime, msgId={},commitLogOffset={}, wait check\\\", requestHeader.getMsgId(), requestHeader.getCommitLogOffset()); return response; } RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader); if (res.getCode() == ResponseCode.SUCCESS) { // 删除事务半消息：将事务半消息存储在事务消息操作 Topic：RMQ_SYS_TRANS_OP_HALF_TOPIC 中，表示该消息已经被处理 this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage()); // roll back, then total num of half-messages minus 1 this.brokerController.getTransactionalMessageService().getTransactionMetrics().addAndGet(result.getPrepareMessage().getProperty(MessageConst.PROPERTY_REAL_TOPIC), -1); BrokerMetricsManager.rollBackMessagesTotal.add(1, BrokerMetricsManager.newAttributesBuilder() .put(LABEL_TOPIC, result.getPrepareMessage().getProperty(MessageConst.PROPERTY_REAL_TOPIC)) .build()); } return res; } } // 事务执行状态未知则不做处理 response.setCode(result.getResponseCode()); response.setRemark(result.getResponseRemark()); return response; } \"]},\"1465\":{\"h\":\"5.2 事务状态回查\"},\"1466\":{\"h\":\"5.2.1 Broker 回查事务状态\"},\"1467\":{\"h\":\"TransactionalMessageCheckService#onWaitEnd\",\"t\":[\"// TransactionalMessageCheckService.java @Override public void run() { log.info(\\\"Start transaction check service thread!\\\"); while (!this.isStopped()) { // 默认每 30s 检查一次 long checkInterval = brokerController.getBrokerConfig().getTransactionCheckInterval(); this.waitForRunning(checkInterval); } log.info(\\\"End transaction check service thread!\\\"); } @Override protected void onWaitEnd() { // 事务消息回查免疫期，过了免疫期，即消息的存储时间 + 该值 > 系统当前时间，才对该消息执行事务状态回查。默认为 6s long timeout = brokerController.getBrokerConfig().getTransactionTimeOut(); // 事务的最大检测次数，如果超过检测次数，消息会默认为丢弃，即 rollback 消息。默认 15 次 int checkMax = brokerController.getBrokerConfig().getTransactionCheckMax(); long begin = System.currentTimeMillis(); log.info(\\\"Begin to check prepare message, begin time:{}\\\", begin); // 发送请求到生产者客户端，回查事务消息执行状态 this.brokerController.getTransactionalMessageService().check(timeout, checkMax, this.brokerController.getTransactionalMessageCheckListener()); log.info(\\\"End to check prepare message, consumed time:{}\\\", System.currentTimeMillis() - begin); } \"]},\"1468\":{\"h\":\"TransactionalMessageServiceImpl#check\",\"t\":[\"// TransactionalMessageServiceImpl.java /** * 发送请求到生产者客户端，回查事务消息执行状态 * * @param transactionTimeout The minimum time of the transactional message to be checked firstly, one message only * exceed this time interval that can be checked. * 事务消息首次回查的最小时间，超过这个时间间隔的事务消息才会被回查 * @param transactionCheckMax The maximum number of times the message was checked, if exceed this value, this * message will be discarded. * 消息被回查的最大次数，超过这个次数则丢弃 * @param listener When the message is considered to be checked or discarded, the relative method of this class will * be invoked. * 当消息被回查或者丢弃时，会调用该监听器的方法 */ @Override public void check(long transactionTimeout, int transactionCheckMax, AbstractTransactionalMessageCheckListener listener) { try { String topic = TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC; // 获取事务半消息 Topic 的所有队列，默认只有 1 个队列 Set<MessageQueue> msgQueues = transactionalMessageBridge.fetchMessageQueues(topic); if (msgQueues == null || msgQueues.size() == 0) { log.warn(\\\"The queue of topic is empty :\\\" + topic); return; } for (MessageQueue messageQueue : msgQueues) { long startTime = System.currentTimeMillis(); // 获取对应的操作队列，主题为：RMQ_SYS_TRANS_OP_HALF_TOPIC。该主题保存事务消息提交或者回滚的请求 MessageQueue opQueue = getOpQueue(messageQueue); // 内部消费组 CID_SYS_RMQ_TRANS 对事务半消息的消费进度 long halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue); // 内部消费组 CID_SYS_RMQ_TRANS 对操作队列的消费进度 long opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue); log.info(\\\"Before check, the queue={} msgOffset={} opOffset={}\\\", messageQueue, halfOffset, opOffset); if (halfOffset < 0 || opOffset < 0) { log.error(\\\"MessageQueue: {} illegal offset read: {}, op offset: {},skip this queue\\\", messageQueue, halfOffset, opOffset); continue; } // 已经处理完的操作消息的偏移量列表 List<Long> doneOpOffset = new ArrayList<>(); // 已经收到操作消息的事务半消息偏移量，需要被移除。key：半消息偏移量，value：操作消息偏移量 HashMap<Long, Long> removeMap = new HashMap<>(); // 在操作消息中的所有半消息的偏移量 HashMap<Long, HashSet<Long>> opMsgMap = new HashMap<Long, HashSet<Long>>(); // 拉取一批（32 条）操作队列的消息，填充 removeMap 和 opMsgMap。对于这批操作消息已经提交的事务半消息，不用回查需要移除 PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, opMsgMap, doneOpOffset); if (null == pullResult) { log.error(\\\"The queue={} check msgOffset={} with opOffset={} failed, pullResult is null\\\", messageQueue, halfOffset, opOffset); continue; } // single thread // 获取空消息的次数 int getMessageNullCount = 1; // 事务半消息队列的最新消费进度 long newOffset = halfOffset; // 当前处理回查的事务半消息消费偏移量，从当前消费进度开始遍历 long i = halfOffset; long nextOpOffset = pullResult.getNextBeginOffset(); // 重新放入事务半消息队列的事务半消息数量 int putInQueueCount = 0; int escapeFailCnt = 0; // 消息回查死循环，回查该队列中需要回查的事务半消息的执行状态 while (true) { // 对该队列的消息的回查最多持续 60s if (System.currentTimeMillis() - startTime > MAX_PROCESS_TIME_LIMIT) { log.info(\\\"Queue={} process time reach max={}\\\", messageQueue, MAX_PROCESS_TIME_LIMIT); break; } // 如果 removeMap 中包含该事务半消息的偏移量，说明该事务半消息已经被提交或者回滚，需要移除，不需要回查 if (removeMap.containsKey(i)) { log.debug(\\\"Half offset {} has been committed/rolled back\\\", i); Long removedOpOffset = removeMap.remove(i); opMsgMap.get(removedOpOffset).remove(i); if (opMsgMap.get(removedOpOffset).size() == 0) { opMsgMap.remove(removedOpOffset); doneOpOffset.add(removedOpOffset); } // 该事务半消息没有被提交或者回滚，需要回查。查询出该事务半消息的消息体 } else { GetResult getResult = getHalfMsg(messageQueue, i); // 事务半消息 MessageExt msgExt = getResult.getMsg(); if (msgExt == null) { // 如果事务半消息 Topic 中获取不到消息，且超过最大获取不到消息的次数（默认 1 次），则结束本次回查 if (getMessageNullCount++ > MAX_RETRY_COUNT_WHEN_HALF_NULL) { break; } if (getResult.getPullResult().getPullStatus() == PullStatus.NO_NEW_MSG) { log.debug(\\\"No new msg, the miss offset={} in={}, continue check={}, pull result={}\\\", i, messageQueue, getMessageNullCount, getResult.getPullResult()); break; } else { // 传入的偏移量非法，修正偏移量后继续查询事务半消息 log.info(\\\"Illegal offset, the miss offset={} in={}, continue check={}, pull result={}\\\", i, messageQueue, getMessageNullCount, getResult.getPullResult()); i = getResult.getPullResult().getNextBeginOffset(); newOffset = i; continue; } } // 事务消息逃逸 // ... // 判断事务消息是否需要丢弃，即超过最大回查次数（15次）；或者是否需要跳过，即超过文件保存时间。 // 如果不丢弃或跳过，这里会增加事务半消息属性中的重试次数 if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) { // 丢弃或跳过：将事务半消息发送到特殊的内部 Topic：TRANS_CHECK_MAX listener.resolveDiscardMsg(msgExt); newOffset = i + 1; i++; continue; } // 如果事务半消息的存储时间大于等于本次回查开始时间，说明这条是新的事务半消息存储进来，结束本次回查，稍后再回查 if (msgExt.getStoreTimestamp() >= startTime) { log.debug(\\\"Fresh stored. the miss offset={}, check it later, store={}\\\", i, new Date(msgExt.getStoreTimestamp())); break; } // 计算事务半消息是否处在免疫回查期：即事务消息发送一段时间之内不进行回查 // 事务半消息已经存在的时长 long valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp(); // 免疫回查期时长，默认等于事务超时时间，6s long checkImmunityTime = transactionTimeout; // 消息属性中定义的免疫回查时长 String checkImmunityTimeStr = msgExt.getUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS); if (null != checkImmunityTimeStr) { // 如果消息属性中也定义了免疫回查时长，优先使用消息属性中的值，单位为秒 checkImmunityTime = getImmunityTime(checkImmunityTimeStr, transactionTimeout); // 事务半消息存在时长小于免疫回查时长，不需要回查 if (valueOfCurrentMinusBorn < checkImmunityTime) { // 检查该事务半消息的偏移量，如果在 removeMap 里，即该消息已经被提交或回滚，不需要处理了。 // 跳过，继续下一个事务半消息的回查判断 if (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt, checkImmunityTimeStr)) { newOffset = i + 1; i++; continue; } } } else { if (0 <= valueOfCurrentMinusBorn && valueOfCurrentMinusBorn < checkImmunityTime) { log.debug(\\\"New arrived, the miss offset={}, check it later checkImmunity={}, born={}\\\", i, checkImmunityTime, new Date(msgExt.getBornTimestamp())); break; } } /* * 判断是否需要回查，满足以下 3 个条件之一则进行回查 * 1. 没有操作消息，且当前半消息在回查免疫期外 * 2. 存在操作消息，且本批次操作消息中最后一个在免疫期外 * 3. Broker 与客户端有时间差 */ List<MessageExt> opMsg = pullResult == null ? null : pullResult.getMsgFoundList(); boolean isNeedCheck = opMsg == null && valueOfCurrentMinusBorn > checkImmunityTime || opMsg != null && opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime > transactionTimeout || valueOfCurrentMinusBorn <= -1; if (isNeedCheck) { // 将事务半消息重新放入到事务半消息队列中，因为前面更新了事务半消息的属性（回查次数），需要更新消费偏移量并且重新存储。 // 并且回查是一个异步过程，不确定回查是否能够请求到，所以这里做最坏的打算，没有请求成功则下次继续回查。 // 如果回查成功则写入操作消息 Map，下次不会回查。 // 这里有个问题是：最坏的情况下（事务消息一直执行中，不停回查），会最多重复存储 15 次事务半消息，造成写放大。 if (!putBackHalfMsgQueue(msgExt, i)) { continue; } putInQueueCount++; log.info(\\\"Check transaction. real_topic={},uniqKey={},offset={},commitLogOffset={}\\\", msgExt.getUserProperty(MessageConst.PROPERTY_REAL_TOPIC), msgExt.getUserProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX), msgExt.getQueueOffset(), msgExt.getCommitLogOffset()); // 通过 listener 向消费者客户端发送单向的消息回查请求 listener.resolveHalfMsg(msgExt); // 不需要进行回查，更新下一个要检查的事务操作消息的偏移量 } else { nextOpOffset = pullResult != null ? pullResult.getNextBeginOffset() : nextOpOffset; pullResult = fillOpRemoveMap(removeMap, opQueue, nextOpOffset, halfOffset, opMsgMap, doneOpOffset); if (pullResult == null || pullResult.getPullStatus() == PullStatus.NO_NEW_MSG || pullResult.getPullStatus() == PullStatus.OFFSET_ILLEGAL || pullResult.getPullStatus() == PullStatus.NO_MATCHED_MSG) { try { Thread.sleep(SLEEP_WHILE_NO_OP); } catch (Throwable ignored) { } } else { log.info(\\\"The miss message offset:{}, pullOffsetOfOp:{}, miniOffset:{} get more opMsg.\\\", i, nextOpOffset, halfOffset); } continue; } } newOffset = i + 1; i++; } // 更新事务半消息消费队列的回查进度 if (newOffset != halfOffset) { transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset); } // 更新操作队列的消费进度 long newOpOffset = calculateOpOffset(doneOpOffset, opOffset); if (newOpOffset != opOffset) { transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset); } GetResult getResult = getHalfMsg(messageQueue, newOffset); pullResult = pullOpMsg(opQueue, newOpOffset, 1); long maxMsgOffset = getResult.getPullResult() == null ? newOffset : getResult.getPullResult().getMaxOffset(); long maxOpOffset = pullResult == null ? newOpOffset : pullResult.getMaxOffset(); long msgTime = getResult.getMsg() == null ? System.currentTimeMillis() : getResult.getMsg().getStoreTimestamp(); log.info(\\\"After check, {} opOffset={} opOffsetDiff={} msgOffset={} msgOffsetDiff={} msgTime={} msgTimeDelayInMs={} putInQueueCount={}\\\", messageQueue, newOpOffset, maxOpOffset - newOpOffset, newOffset, maxMsgOffset - newOffset, new Date(msgTime), System.currentTimeMillis() - msgTime, putInQueueCount); } } catch (Throwable e) { log.error(\\\"Check error\\\", e); } } /** * 计算免疫回查时长，如果消息属性中定义了免疫回查时长，则使用消息属性中定义的免疫回查时长，否则使用事务超时时间 * @param checkImmunityTimeStr 消息属性中定义的免疫回查时长 * @param transactionTimeout 事务超时时间 * @return 免疫回查时长 */ private long getImmunityTime(String checkImmunityTimeStr, long transactionTimeout) { long checkImmunityTime; checkImmunityTime = getLong(checkImmunityTimeStr); if (-1 == checkImmunityTime) { checkImmunityTime = transactionTimeout; } else { checkImmunityTime *= 1000; } return checkImmunityTime; } \"]},\"1469\":{\"h\":\"AbstractTransactionalMessageCheckListener#resolveHalfMsg\",\"t\":[\"// AbstractTransactionalMessageCheckListener.java /** * 处理事务半消息（回查其执行状态） * @param msgExt 事务半消息 */ public void resolveHalfMsg(final MessageExt msgExt) { if (executorService != null) { executorService.execute(new Runnable() { @Override public void run() { try { sendCheckMessage(msgExt); } catch (Exception e) { LOGGER.error(\\\"Send check message error!\\\", e); } } }); } else { LOGGER.error(\\\"TransactionalMessageCheckListener not init\\\"); } } /** * 发送回查请求到生产者客户端 * * @param msgExt 事务半消息 * @throws Exception */ public void sendCheckMessage(MessageExt msgExt) throws Exception { CheckTransactionStateRequestHeader checkTransactionStateRequestHeader = new CheckTransactionStateRequestHeader(); checkTransactionStateRequestHeader.setTopic(msgExt.getTopic()); checkTransactionStateRequestHeader.setCommitLogOffset(msgExt.getCommitLogOffset()); checkTransactionStateRequestHeader.setOffsetMsgId(msgExt.getMsgId()); checkTransactionStateRequestHeader.setMsgId(msgExt.getUserProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX)); checkTransactionStateRequestHeader.setTransactionId(checkTransactionStateRequestHeader.getMsgId()); checkTransactionStateRequestHeader.setTranStateTableOffset(msgExt.getQueueOffset()); checkTransactionStateRequestHeader.setBrokerName(brokerController.getBrokerConfig().getBrokerName()); // 从消息属性中复原真实的 topic 和 queueId msgExt.setTopic(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_TOPIC)); msgExt.setQueueId(Integer.parseInt(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_QUEUE_ID))); msgExt.setStoreSize(0); String groupId = msgExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP); // 轮询选择一个可用的生产者客户端通道 Channel channel = brokerController.getProducerManager().getAvailableChannel(groupId); if (channel != null) { // 发送回查请求到生产者客户端，回查事务消息执行状态。单向请求，不需要等待响应 brokerController.getBroker2Client().checkProducerTransactionState(groupId, channel, checkTransactionStateRequestHeader, msgExt); } else { LOGGER.warn(\\\"Check transaction failed, channel is null. groupId={}\\\", groupId); } } \"]},\"1470\":{\"h\":\"5.2.2 Producer 处理回查请求\"},\"1471\":{\"h\":\"ClientRemotingProcessor#checkTransactionState\",\"t\":[\"// ClientRemotingProcessor.java /** * 处理 Broker 发来的事务回查请求，发送本地事务执行状态到 Broker */ public RemotingCommand checkTransactionState(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException { final CheckTransactionStateRequestHeader requestHeader = (CheckTransactionStateRequestHeader) request.decodeCommandCustomHeader(CheckTransactionStateRequestHeader.class); final ByteBuffer byteBuffer = ByteBuffer.wrap(request.getBody()); final MessageExt messageExt = MessageDecoder.decode(byteBuffer); if (messageExt != null) { if (StringUtils.isNotEmpty(this.mqClientFactory.getClientConfig().getNamespace())) { messageExt.setTopic(NamespaceUtil .withoutNamespace(messageExt.getTopic(), this.mqClientFactory.getClientConfig().getNamespace())); } String transactionId = messageExt.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX); if (null != transactionId && !\\\"\\\".equals(transactionId)) { messageExt.setTransactionId(transactionId); } final String group = messageExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP); if (group != null) { MQProducerInner producer = this.mqClientFactory.selectProducer(group); if (producer != null) { final String addr = RemotingHelper.parseChannelRemoteAddr(ctx.channel()); // 检查本地事务执行状态，发送到 Broker producer.checkTransactionState(addr, messageExt, requestHeader); } else { logger.debug(\\\"checkTransactionState, pick producer by group[{}] failed\\\", group); } } else { logger.warn(\\\"checkTransactionState, pick producer group failed\\\"); } } else { logger.warn(\\\"checkTransactionState, decode message failed\\\"); } return null; } \"]},\"1472\":{\"h\":\"DefaultMQProducerImpl#checkTransactionState\",\"t\":[\"// DefaultMQProducerImpl.java /** * 处理 Broker 发来的事务消息执行状态回查请求，检查本地事务执行状态，发送到 Broker * * @param addr Broker 地址 * @param msg Broker 发回的事务半消息 * @param header Broker 回查的请求头 */ @Override public void checkTransactionState(final String addr, final MessageExt msg, final CheckTransactionStateRequestHeader header) { Runnable request = new Runnable() { private final String brokerAddr = addr; private final MessageExt message = msg; private final CheckTransactionStateRequestHeader checkRequestHeader = header; private final String group = DefaultMQProducerImpl.this.defaultMQProducer.getProducerGroup(); @Override public void run() { TransactionCheckListener transactionCheckListener = DefaultMQProducerImpl.this.checkListener(); TransactionListener transactionListener = getCheckListener(); if (transactionCheckListener != null || transactionListener != null) { LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW; Throwable exception = null; try { // 获取本地事务执行状态 if (transactionCheckListener != null) { // 使用了老的生产者 localTransactionState = transactionCheckListener.checkLocalTransactionState(message); } else { // 使用了新的事务消息生产者 API log.debug(\\\"TransactionCheckListener is null, used new check API, producerGroup={}\\\", group); localTransactionState = transactionListener.checkLocalTransaction(message); } } catch (Throwable e) { log.error(\\\"Broker call checkTransactionState, but checkLocalTransactionState exception\\\", e); exception = e; } // 将本地事务执行状态发送到 Broker this.processTransactionState( checkRequestHeader.getTopic(), localTransactionState, group, exception); } else { log.warn(\\\"CheckTransactionState, pick transactionCheckListener by group[{}] failed\\\", group); } } /** * 根据本地事务执行装填，提交或回滚事务消息 */ private void processTransactionState( final String topic, final LocalTransactionState localTransactionState, final String producerGroup, final Throwable exception) { final EndTransactionRequestHeader thisHeader = new EndTransactionRequestHeader(); thisHeader.setTopic(topic); thisHeader.setCommitLogOffset(checkRequestHeader.getCommitLogOffset()); thisHeader.setProducerGroup(producerGroup); thisHeader.setTranStateTableOffset(checkRequestHeader.getTranStateTableOffset()); // 是 Broker 端回查后发出的请求 thisHeader.setFromTransactionCheck(true); thisHeader.setBrokerName(checkRequestHeader.getBrokerName()); String uniqueKey = message.getProperties().get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX); if (uniqueKey == null) { uniqueKey = message.getMsgId(); } thisHeader.setMsgId(uniqueKey); thisHeader.setTransactionId(checkRequestHeader.getTransactionId()); // 根据本地事务执行状态，设置请求头中的 commitOrRollback 值 switch (localTransactionState) { case COMMIT_MESSAGE: thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE); break; case ROLLBACK_MESSAGE: thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE); log.warn(\\\"when broker check, client rollback this transaction, {}\\\", thisHeader); break; case UNKNOW: thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE); log.warn(\\\"when broker check, client does not know this transaction state, {}\\\", thisHeader); break; default: break; } String remark = null; if (exception != null) { remark = \\\"checkLocalTransactionState Exception: \\\" + UtilAll.exceptionSimpleDesc(exception); } // 执行事务消息状态回查后钩子，主要是上报消息轨迹 doExecuteEndTransactionHook(msg, uniqueKey, brokerAddr, localTransactionState, true); try { // 向 Broker 发送事务执行结果，Broker 根据结果处理事务半消息 DefaultMQProducerImpl.this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark, 3000); } catch (Exception e) { log.error(\\\"endTransactionOneway exception\\\", e); } } }; this.checkExecutor.submit(request); } \"]},\"1473\":{\"h\":\"参考资料\",\"t\":[\"RocketMQ 设计文档——事务消息\",\"官方文档——事务消息\",\"RocketMQ 源码分析事务消息系列——丁威\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1474\":{\"h\":\"RocketMQ DLedger Leader 选举 流程详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20250204-rocketmq-dledger-leader-election.html\"]},\"1475\":{\"h\":\"1. 背景\",\"t\":[\"在 RocketMQ 4.5.0 版本以前，只提供了主从同步功能，但是主节点宕机之后从节点只能读不能写，没有主从切换能力。RocketMQ 4.5.0 引入了 DLedger 来实现主从切换。\",\"DLedger 是基于 Raft 算法的 WAL 实现，它是为消息场景量身定制的，提供了日志写入和读取的接口，且对顺序读出和随机读出做了优化，充分适应消息系统消峰填谷的需求。\",\"在 RocketMQ 4.8.0 版本以前，DLedger 模式的性能比主备模式差 1 个数量级[1]，所以建议用尽可能新的版本部署。\",\"DLedger 的实现大体可以分为两个部分，Leader 选举和日志复制，本文基于 DLedger 0.2.7 版本源码详解 Leader 选举的设计和流程。\"]},\"1476\":{\"h\":\"2. 概要设计\"},\"1477\":{\"h\":\"2.1 节点状态流转\",\"t\":[\"DLedger 的主从同步主要是实现了 Raft 协议，我们先来看一下 Raft 协议中节点的 3 个角色之间的行为和转换。\",\"Raft 选主的过程中有一些重要的请求类型：\",\"心跳请求：Leader 节点定期发送心跳请求给其他节点，以维持领导地位。\",\"投票请求：Candidate 节点在选举超时后，会发起投票请求，向其他节点请求投票。由于是向其他节点请求投票，所以我们后面把它称为拉票请求方便理解。\",\"其它的客户端请求和日志追加请求不在 Leader 选举流程中，本文暂不展开。\",\"Raft 选主流程中还有两个重要的 timeout：\",\"心跳超时：Leader 节点发送心跳请求给其他节点的间隔时间，DLedger 里是 2s。\",\"选举超时：Follower 在选举超时后，会成为 Candidate，启动选主流程。DLedger 里是 3 倍的心跳超时，即 6s。\",\"下面我们看一下每种角色的节点的行为。\"]},\"1478\":{\"h\":\"2.2 Follower\",\"t\":[\"行为： \",\"启动计时器，时间为选举超时（Election timeout）。\",\"发起请求：无\",\"处理请求： \",\"Candidate 拉票请求：如果没有投过票则返回投票，更新投票轮次（为请求的轮次），并记录投票给谁。\",\"Leader 心跳请求：收到后会返回响应并重新启动计时器。\",\"状态转移： \",\"计时器到期：转换成 Candidate。\"]},\"1479\":{\"h\":\"2.3 Leader\",\"t\":[\"行为： \",\"处理所有客户端请求和日志复制\",\"每过心跳超时（Heartbeat timeout），向所有其他节点发送心跳请求，维持统治。\",\"发起请求： \",\"向其他节点发送心跳请求，处理心跳响应。如果收到的响应的轮次大于当前轮次，则转换为 Follower。\",\"处理请求： \",\"Candidate 拉票请求： \",\"轮次大于当前，转换成 Follower。\",\"轮次小于等于当前，无动作。\",\"Leader 心跳请求： \",\"轮次小于当前，无动作。\",\"轮次大于当前，转换成 Follower。\",\"轮次等于当前，可能是由于发生网络分区导致出现多个 Leader，都降为 Follower 重新选举。\",\"客户端请求：处理日志复制\",\"状态转移： \",\"发现其他节点的心跳请求响应有更大的投票轮次：转换成 Follower。\"]},\"1480\":{\"h\":\"2.4 Candidate\",\"t\":[\"行为： \",\"发起新的选举轮次（term += 1），给自己投票，然后向其他节点发起拉票请求。 \",\"刚进入 Candidate 状态会发起新的投票轮次，先给自己投票。\",\"发起投票后，启动计时器，统计选举超时。当计时器到期仍未得到半数以上投票，开启新的投票轮次。\",\"发起请求： \",\"选举轮次启动时，给其他节点发拉票请求，获取其他节点的投票响应。\",\"处理请求： \",\"其他 Candidate 拉票请求：如果其他 Candidate 投票轮次大于当前轮次，则投票给它并更新当前轮次。否则无动作。\",\"Leader 心跳请求：对比投票轮次，如果大于等于当前轮次，则说明已经有 Leader 选出，自己转换成 Follower。\",\"状态转移： \",\"选票超过半数：转换成 Leader。\",\"收到 Leader 心跳请求：此时其他节点已经是 Leader，转换成 Follower。\",\"选票未超过半数（Split vote）：保持为 Candidate，在选举超时后开始新的选举轮次。\"]},\"1481\":{\"h\":\"3. 详细设计\",\"t\":[\"下图是 3 个 DLedger 节点组成的集群，其中中间的是主节点，左右两个从节点。\",\"alt text\",\"其中 DLedgerStore 是日志存储类，收到日志追加请求后把日志保存，然后推给 DLedgerEntryPusher 类。\",\"DLedgerEntryPusher 是 DLedger 的日志追加实现类，它会把本地的数据推到从节点的 DLedgerEntryPusher，在从节点上保存。\",\"DLedgerLeaderElector 则是负责 DLedger 主从切换的，它向其他节点收发心跳和投票请求，来执行主从切换。\"]},\"1482\":{\"h\":\"3.1 类设计\",\"t\":[\"上图为 DLedger 主要类的类图。\",\"其中 DLedgerServer 表示一个 DLedger 节点，它是 Raft 协议集群节点的封装。\",\"DLedgerProtocolHandler 和 DLedgerClientProtocolHandler 分别是 DLedger 服务端和客户端的协议处理器接口，定义了一个 DLedger 节点需要实现的协议处理方法。\",\"DLedgerProtocl 和 DLedgerClientProtocol 分别是 DLedger 服务端和客户端的请求实现类，定义了一个 DLedger 节点需要实现的所有请求方法。\",\"DLedgerServer 封装了实现 DLedger 所需要的字段，下面我们一一说明它们的含义和作用。\",\"MemberState：节点状态机，用于保存当前节点的角色（Leader/Follower/Candidate）、当前任期、当前日志写入状态、当前投票、对端节点列表等。\",\"DLedgerStore：日志存储类，用于操作当前节点的日志存储。\",\"DLedgerRpcService：DLedger 节点间通信类，实现了 DLedgerProtocolHandler 和 DLedgerProtocol 接口。它是 DLedger 节点发送请求和处理请求的入口。处理请求时，它会调用 DLedgerServer 的请求处理方法，本身不处理请求，仅作为代理转发。\",\"DLedgerLeaderElector：主从切换逻辑实现类，有一个服务线程不断运行节点的状态维护方法，根据节点角色的不同，执行不同的状态维护逻辑。这也是本文将着重解析的类。\"]},\"1483\":{\"h\":\"3.2 DLedgerLeaderElector 逻辑\",\"t\":[\"DLedger 的选主逻辑与 Raft 标准的选主逻辑实现上有一些差异。\",\"DLedgerLeaderElector 负责节点的状态维护。它当中有一个 StateMaintainer 现成，负责触发节点的状态维护方法，即 maintainState()，它会根据节点当前的状态执行对应状态的状态维维护方法。每次执行完状态维护方法后，等待 10ms 再执行下一次状态维护方法。\",\"下面详细分析每个状态维护的方法。\"]},\"1484\":{\"h\":\"3.2.1 Follower\",\"t\":[\"maintainAsFollower() 方法的逻辑如下：\",\"如果在 3 个心跳周期内没有收到心跳请求，将角色转换为 Candidate。\"]},\"1485\":{\"h\":\"3.2.2 Leader\",\"t\":[\"如果当前时间距离上次发送心跳的时间超过心跳周期（2s），则向所有节点发送心跳，然后等待响应并仲裁结果。\"]},\"1486\":{\"h\":\"3.2.3 Candidate\",\"t\":[\"如果到了下一次拉票请求的时间，则进行判断\",\"如果当前节点不是 Candidate，无动作\",\"上一次投票结果是需要等待下一轮投票，或需要立即开始下一轮投票 \",\"更新投票轮次，发起新一轮投票\",\"否则，维持当前投票轮次\",\"向其他节点发拉票请求，等待所有节点响应并仲裁结果\"]},\"1487\":{\"h\":\"3.2.4 心跳请求\"},\"1488\":{\"h\":\"心跳请求发送、响应处理\",\"t\":[\"发送心跳请求的方法是 DLedgerLeaderElector#sendHeartbeats\",\"等待心跳响应，超过半数成功则继续。 \",\"如果半数以上 Follower 返回成功，则更新成功心跳时间戳。\",\"如果没有达到半数以上 Follower 返回成功 \",\"成功 + 未准备的响应超过半数，立即发送下一次心跳\",\"Follower 的最大投票 term 比当前节点大，当前节点切换成 Candidate\",\"Follower 有其他的 Leader，当前节点切换成 Candidate\",\"超过 3 个心跳周期都没有半数以上成功响应，当前节点切换成 Candidate，待收到 Leader 的心跳请求后变为 Follower\"]},\"1489\":{\"h\":\"心跳请求处理\",\"t\":[\"处理心跳请求的方法是 DLedgerLeaderElector#handleHeartbeat\",\"发送节点的 term 小于当前节点的 term，告诉对方已经过期，需要重新选举。\",\"term 相同，判断请求的节点是否是当前的 Leader \",\"如果请求节点是当前节点的 Leader，更新心跳时间戳，返回成功\",\"如果当前节点还没有 Leader，切换角色为 Follower，设置 Leader\",\"如果请求节点不是当前节点的 Leader，告诉对方 Leader 不一致，对方会切换回 Candidate，重新选举\",\"发送节点的 term 大于当前节点的 term，则当前节点切换为 Candidate，立即发起选举。\"]},\"1490\":{\"h\":\"3.2.5 拉票请求\"},\"1491\":{\"h\":\"拉票请求发送、响应处理\",\"t\":[\"发送拉票请求的方法是 DLedgerLeaderElector#voteForQuorumResponses\",\"发送拉票请求时，会先投票给自己，然后把当前节点的状态、term 等信息放入请求中。\",\"根据投票结果进行仲裁的逻辑如下：\",\"对端 term 大于当前节点 term，使用对端 term 进入 Candidate 角色。\",\"已有 Leader，保持 Candidate 角色，待收到 Leader 的心跳请求后变为 Follower。重置下次拉票计时器，如果没有收到心跳的话在选举超时后会重新发起拉票请求。\",\"有效投票未超过半数，重置下次拉票计时器，等待重新投票，不增加 term。\",\"有效票超过半数，切换成 Leader\",\"有效票 + 未准备好 超过半数，立即重新拉票\",\"其他情况，重置下次拉票计时器，继续本轮拉票\"]},\"1492\":{\"h\":\"拉票请求处理\",\"t\":[\"处理拉票请求的方法是 DLedgerLeaderElector#handleVote\",\"先根据 LedgerEndTerm 进行仲裁，LedgerEndTerm 是日志最后写入时的投票轮次。 \",\"如果请求拉票节点的 ledgerEndTerm 小于当前节点的 ledgerEndTerm，说明拉票节点的日志复制进度比当前低，无法成为 Leader，返回拒绝。\",\"如果 ledgerEndTerm 相等，ledgerEndIndex 小于当前节点的 ledgerEndIndex，说明拉票节点的日志复制进度比当前低，无法成为 Leader，返回拒绝。\",\"然后根据 term 进行仲裁 \",\"如果请求拉票节点的 term 小于当前的 term，说明请求拉票节点已经过期，返回拒绝。\",\"如果 term 相等，继续判断 \",\"如果当前节点未投票，继续下面逻辑\",\"如果当前节点已投票给请求的节点，也继续下面逻辑\",\"如果当前节点已投票给其他节点，拒绝投票，并返回自己投的 Leader\",\"如果请求拉票节点的 term 大于当前的 term，则当前节点用对方的 term 降级为 Candidate，拒绝拉票请求，告知对方自己未准备好\",\"最后如果请求拉票节点的 term 小于当前节点的 ledgerEndTerm，也拒绝\",\"如果通过上面所有的过滤，则投票给请求拉票的节点：设置自己投票的 Leader，并返回投票。\"]},\"1493\":{\"h\":\"4. 源码解析\"},\"1494\":{\"h\":\"4.1 状态维护\"},\"1495\":{\"h\":\"4.2 maintainAsFollower\",\"t\":[\"// DLedgerLeaderElector.java private void maintainAsFollower() { // 距离上次收到心跳是否超过 2 个心跳周期。在不加锁的情况下判断，减少加锁次数 if (DLedgerUtils.elapsed(lastLeaderHeartBeatTime) > 2 * heartBeatTimeIntervalMs) { synchronized (memberState) { // 超过 maxHeartBeatLeak(3) 个心跳周期没有收到心跳包，则切换成 Candidate if (memberState.isFollower() && (DLedgerUtils.elapsed(lastLeaderHeartBeatTime) > maxHeartBeatLeak * heartBeatTimeIntervalMs)) { logger.info(\\\"[{}][HeartBeatTimeOut] lastLeaderHeartBeatTime: {} heartBeatTimeIntervalMs: {} lastLeader={}\\\", memberState.getSelfId(), new Timestamp(lastLeaderHeartBeatTime), heartBeatTimeIntervalMs, memberState.getLeaderId()); changeRoleToCandidate(memberState.currTerm()); } } } } \"]},\"1496\":{\"h\":\"4.3 maintainAsLeader\",\"t\":[\"// DLedgerLeaderElector.java private void maintainAsLeader() throws Exception { // 距离上次发送心跳超过 1 个心跳周期（2s），发送心跳请求 if (DLedgerUtils.elapsed(lastSendHeartBeatTime) > heartBeatTimeIntervalMs) { long term; String leaderId; synchronized (memberState) { if (!memberState.isLeader()) { //stop sending return; } term = memberState.currTerm(); leaderId = memberState.getLeaderId(); // 记录本次发送心跳时间戳 lastSendHeartBeatTime = System.currentTimeMillis(); } // 向所有从节点发送心跳 sendHeartbeats(term, leaderId); } } \"]},\"1497\":{\"h\":\"4.3 maintainAsCandidate\",\"t\":[\"// DLedgerLeaderElector.java private void maintainAsCandidate() throws Exception { //for candidate // 未到下一次拉票时间，直接返回 if (System.currentTimeMillis() < nextTimeToRequestVote && !needIncreaseTermImmediately) { return; } // 投票轮次 long term; // 日志末尾 Term long ledgerEndTerm; // 当前 Log 最大 index，即下一条 Log 的起始 index long ledgerEndIndex; synchronized (memberState) { if (!memberState.isCandidate()) { return; } // 如果上一次投票结果是等待下一轮投票，或应立即发起投票 if (lastParseResult == VoteResponse.ParseResult.WAIT_TO_VOTE_NEXT || needIncreaseTermImmediately) { // 获取新投票轮次，准备发起新一轮投票 long prevTerm = memberState.currTerm(); term = memberState.nextTerm(); logger.info(\\\"{}_[INCREASE_TERM] from {} to {}\\\", memberState.getSelfId(), prevTerm, term); lastParseResult = VoteResponse.ParseResult.WAIT_TO_REVOTE; } else { // 维持当前投票轮次 term = memberState.currTerm(); } ledgerEndIndex = memberState.getLedgerEndIndex(); ledgerEndTerm = memberState.getLedgerEndTerm(); } // 如果需要立即发起拉票 if (needIncreaseTermImmediately) { // 设置下一次拉票时间 nextTimeToRequestVote = getNextTimeToRequestVote(); // 设置该标志位为 false needIncreaseTermImmediately = false; return; } // 向其他节点发起拉票请求 long startVoteTimeMs = System.currentTimeMillis(); final List<CompletableFuture<VoteResponse>> quorumVoteResponses = voteForQuorumResponses(term, ledgerEndTerm, ledgerEndIndex); // 已知的最大投票轮次 final AtomicLong knownMaxTermInGroup = new AtomicLong(term); // 所有投票数 final AtomicInteger allNum = new AtomicInteger(0); // 有效投票数 final AtomicInteger validNum = new AtomicInteger(0); // 赞成投票数 final AtomicInteger acceptedNum = new AtomicInteger(0); // 未准备好投票。如果对端节点的投票轮次小于发起投票的轮次，则认为我对端未准备好，对端节点会用本节点的轮次进入 Candidate 状态 final AtomicInteger notReadyTermNum = new AtomicInteger(0); // 发起投票节点的投票轮次小于对端节点的个数 final AtomicInteger biggerLedgerNum = new AtomicInteger(0); // 是否已经存在 Leader final AtomicBoolean alreadyHasLeader = new AtomicBoolean(false); // 等待所有响应结果 CountDownLatch voteLatch = new CountDownLatch(1); for (CompletableFuture<VoteResponse> future : quorumVoteResponses) { future.whenComplete((VoteResponse x, Throwable ex) -> { try { if (ex != null) { throw ex; } logger.info(\\\"[{}][GetVoteResponse] {}\\\", memberState.getSelfId(), JSON.toJSONString(x)); if (x.getVoteResult() != VoteResponse.RESULT.UNKNOWN) { // 有效票 + 1 validNum.incrementAndGet(); } // 统计投票结果 synchronized (knownMaxTermInGroup) { switch (x.getVoteResult()) { case ACCEPT: // 赞成票 + 1 acceptedNum.incrementAndGet(); break; case REJECT_ALREADY_VOTED: // 拒绝，已经投给其他节点 case REJECT_TAKING_LEADERSHIP: break; case REJECT_ALREADY_HAS_LEADER: // 拒绝，已经存在 Leader 节点 alreadyHasLeader.compareAndSet(false, true); break; case REJECT_TERM_SMALL_THAN_LEDGER: case REJECT_EXPIRED_VOTE_TERM: // 拒绝，当前投票轮次小于 Leader，更新自身投票轮次 if (x.getTerm() > knownMaxTermInGroup.get()) { knownMaxTermInGroup.set(x.getTerm()); } break; case REJECT_EXPIRED_LEDGER_TERM: // 拒绝，当前 ledgerTerm 小于对端 ledgerTerm case REJECT_SMALL_LEDGER_END_INDEX: // 拒绝，当前 ledgerEndIndex 小于对端 ledgerEndIndex biggerLedgerNum.incrementAndGet(); break; case REJECT_TERM_NOT_READY: // 拒绝，对端投票轮次小于当前轮次，即对端未准备好。此时对端节点使用当前投票轮次进入 Candidate 状态 notReadyTermNum.incrementAndGet(); break; default: break; } } // 已经有 Leader / 收到过半赞成，结束等待 if (alreadyHasLeader.get() || memberState.isQuorum(acceptedNum.get()) || memberState.isQuorum(acceptedNum.get() + notReadyTermNum.get())) { voteLatch.countDown(); } } catch (Throwable t) { logger.error(\\\"vote response failed\\\", t); } finally { // 如果所有对端节点都返回响应，结束等待 allNum.incrementAndGet(); if (allNum.get() == memberState.peerSize()) { voteLatch.countDown(); } } }); } // 同步等待所有节点响应 try { voteLatch.await(2000 + random.nextInt(maxVoteIntervalMs), TimeUnit.MILLISECONDS); } catch (Throwable ignore) { } lastVoteCost = DLedgerUtils.elapsed(startVoteTimeMs); VoteResponse.ParseResult parseResult; // 根据投票结果进行仲裁，驱动状态机 if (knownMaxTermInGroup.get() > term) { // 对端 term 大于自身 term，使用对端 term 进入 Candidate 状态 parseResult = VoteResponse.ParseResult.WAIT_TO_VOTE_NEXT; nextTimeToRequestVote = getNextTimeToRequestVote(); changeRoleToCandidate(knownMaxTermInGroup.get()); } else if (alreadyHasLeader.get()) { // 已有 Leader，保持 Candidate 状态，待收到 Leader 心跳请求后变为 Follower parseResult = VoteResponse.ParseResult.WAIT_TO_REVOTE; // 重置下次拉票计时器，添加心跳最大超时时间。表示：等待在指定时间内收到 Leader 的心跳，降为 Follower。 nextTimeToRequestVote = getNextTimeToRequestVote() + heartBeatTimeIntervalMs * maxHeartBeatLeak; } else if (!memberState.isQuorum(validNum.get())) { // 有效票未超过半数，重置下次拉票计时器，等待重新投票。不增加投票轮次 parseResult = VoteResponse.ParseResult.WAIT_TO_REVOTE; nextTimeToRequestVote = getNextTimeToRequestVote(); } else if (!memberState.isQuorum(validNum.get() - biggerLedgerNum.get())) { parseResult = VoteResponse.ParseResult.WAIT_TO_REVOTE; nextTimeToRequestVote = getNextTimeToRequestVote() + maxVoteIntervalMs; } else if (memberState.isQuorum(acceptedNum.get())) { // 有效票超过半数，成为 Leader 节点 parseResult = VoteResponse.ParseResult.PASSED; } else if (memberState.isQuorum(acceptedNum.get() + notReadyTermNum.get())) { // 有效票 + 未准备好投票 超过半数，立即重新拉票 parseResult = VoteResponse.ParseResult.REVOTE_IMMEDIATELY; } else { // 赞成票 + 对端 ledgerEndIndex 超过半数，重置计时器，继续本轮选举 parseResult = VoteResponse.ParseResult.WAIT_TO_VOTE_NEXT; nextTimeToRequestVote = getNextTimeToRequestVote(); } lastParseResult = parseResult; logger.info(\\\"[{}] [PARSE_VOTE_RESULT] cost={} term={} memberNum={} allNum={} acceptedNum={} notReadyTermNum={} biggerLedgerNum={} alreadyHasLeader={} maxTerm={} result={}\\\", memberState.getSelfId(), lastVoteCost, term, memberState.peerSize(), allNum, acceptedNum, notReadyTermNum, biggerLedgerNum, alreadyHasLeader, knownMaxTermInGroup.get(), parseResult); if (parseResult == VoteResponse.ParseResult.PASSED) { // 有效票超过半数的情况，切换成 Leader logger.info(\\\"[{}] [VOTE_RESULT] has been elected to be the leader in term {}\\\", memberState.getSelfId(), term); changeRoleToLeader(term); } } \"]},\"1498\":{\"h\":\"4.4 心跳请求\"},\"1499\":{\"h\":\"4.4.1 sendHeartbeats\",\"t\":[\"// DLedgerLeaderElector.java /** * Leader 节点向 Follower 节点发送心跳包，等待所有节点的心跳响应，然后根据响应的节点数量进行结果仲裁。 */ private void sendHeartbeats(long term, String leaderId) throws Exception { // 集群内节点个数 final AtomicInteger allNum = new AtomicInteger(1); // 收到成功响应的节点个数 final AtomicInteger succNum = new AtomicInteger(1); // 收到对端未准备好的响应的节点个数 final AtomicInteger notReadyNum = new AtomicInteger(0); // 当前集群节点维护的最大投票轮次 final AtomicLong maxTerm = new AtomicLong(-1); // 是否存在 Leader 节点不一致 final AtomicBoolean inconsistLeader = new AtomicBoolean(false); // latch，用于等待异步请求结果 final CountDownLatch beatLatch = new CountDownLatch(1); // 本次心跳包开始发送的时间戳 long startHeartbeatTimeMs = System.currentTimeMillis(); // 遍历集群中所有节点，异步发送心跳 for (String id : memberState.getPeerMap().keySet()) { if (memberState.getSelfId().equals(id)) { continue; } // 构造心跳包 HeartBeatRequest heartBeatRequest = new HeartBeatRequest(); heartBeatRequest.setGroup(memberState.getGroup()); heartBeatRequest.setLocalId(memberState.getSelfId()); heartBeatRequest.setRemoteId(id); heartBeatRequest.setLeaderId(leaderId); heartBeatRequest.setTerm(term); // 异步发送心跳 CompletableFuture<HeartBeatResponse> future = dLedgerRpcService.heartBeat(heartBeatRequest); future.whenComplete((HeartBeatResponse x, Throwable ex) -> { // 心跳响应回调，统计响应结果 try { if (ex != null) { memberState.getPeersLiveTable().put(id, Boolean.FALSE); throw ex; } switch (DLedgerResponseCode.valueOf(x.getCode())) { // 成功响应 case SUCCESS: succNum.incrementAndGet(); break; // Leader 节点投票轮次小于 Follower 节点 case EXPIRED_TERM: maxTerm.set(x.getTerm()); break; // Follower 节点已经有新的 Leader case INCONSISTENT_LEADER: inconsistLeader.compareAndSet(false, true); break; // Follower 未准备好 case TERM_NOT_READY: notReadyNum.incrementAndGet(); break; default: break; } if (x.getCode() == DLedgerResponseCode.NETWORK_ERROR.getCode()) memberState.getPeersLiveTable().put(id, Boolean.FALSE); else memberState.getPeersLiveTable().put(id, Boolean.TRUE); // 成功响应的 Follower 节点超过半数，唤醒心跳线程 if (memberState.isQuorum(succNum.get()) || memberState.isQuorum(succNum.get() + notReadyNum.get())) { beatLatch.countDown(); } } catch (Throwable t) { logger.error(\\\"heartbeat response failed\\\", t); } finally { allNum.incrementAndGet(); // 所有 Follower 都响应（但成功的没有超过半数），也唤醒心跳线程 if (allNum.get() == memberState.peerSize()) { beatLatch.countDown(); } } }); } // 等待心跳结果，超过半数成功则继续 beatLatch.await(heartBeatTimeIntervalMs, TimeUnit.MILLISECONDS); // 仲裁心跳响应结果 if (memberState.isQuorum(succNum.get())) { // 半数以上 Follower 节点成功响应，更新上次成功心跳时间戳 lastSuccHeartBeatTime = System.currentTimeMillis(); } else { logger.info(\\\"[{}] Parse heartbeat responses in cost={} term={} allNum={} succNum={} notReadyNum={} inconsistLeader={} maxTerm={} peerSize={} lastSuccHeartBeatTime={}\\\", memberState.getSelfId(), DLedgerUtils.elapsed(startHeartbeatTimeMs), term, allNum.get(), succNum.get(), notReadyNum.get(), inconsistLeader.get(), maxTerm.get(), memberState.peerSize(), new Timestamp(lastSuccHeartBeatTime)); if (memberState.isQuorum(succNum.get() + notReadyNum.get())) { // （成功 + 未准备）超过半数，立即发送下一次心跳 lastSendHeartBeatTime = -1; } else if (maxTerm.get() > term) { // Follower 投票轮次比 Leader 大，Leader 切换成 Candidate 并使用从节点的轮次 changeRoleToCandidate(maxTerm.get()); } else if (inconsistLeader.get()) { // Follower 有其他 Leader，该 Leader 节点切换成 Candidate changeRoleToCandidate(term); } else if (DLedgerUtils.elapsed(lastSuccHeartBeatTime) > maxHeartBeatLeak * heartBeatTimeIntervalMs) { // 超过 maxHeartBeatLeak 个心跳周期（6s）没有半数心跳响应成功，切换成 Candidate changeRoleToCandidate(term); } } } \"]},\"1500\":{\"h\":\"4.4.2 handleHeartbeat\",\"t\":[\"// DLedgerLeaderElector.java /** * Follower 收到 Leader 心跳请求，处理心跳请求后响应 * * @param request * @return * @throws Exception */ public CompletableFuture<HeartBeatResponse> handleHeartBeat(HeartBeatRequest request) throws Exception { if (!memberState.isPeerMember(request.getLeaderId())) { logger.warn(\\\"[BUG] [HandleHeartBeat] remoteId={} is an unknown member\\\", request.getLeaderId()); return CompletableFuture.completedFuture(new HeartBeatResponse().term(memberState.currTerm()).code(DLedgerResponseCode.UNKNOWN_MEMBER.getCode())); } if (memberState.getSelfId().equals(request.getLeaderId())) { logger.warn(\\\"[BUG] [HandleHeartBeat] selfId={} but remoteId={}\\\", memberState.getSelfId(), request.getLeaderId()); return CompletableFuture.completedFuture(new HeartBeatResponse().term(memberState.currTerm()).code(DLedgerResponseCode.UNEXPECTED_MEMBER.getCode())); } // 发送请求的节点（Leader）轮次小于当前节点（Follower），返回 EXPIRED_TERM，告诉对方轮次已经过期，需要重新选举 if (request.getTerm() < memberState.currTerm()) { return CompletableFuture.completedFuture(new HeartBeatResponse().term(memberState.currTerm()).code(DLedgerResponseCode.EXPIRED_TERM.getCode())); } else if (request.getTerm() == memberState.currTerm()) { // 轮次相同，判断请求的节点是否是当前的 Leader if (request.getLeaderId().equals(memberState.getLeaderId())) { // 如果请求的节点是当前的 Leader，更新上次收到 Leader 心跳的时间戳，返回成功 lastLeaderHeartBeatTime = System.currentTimeMillis(); return CompletableFuture.completedFuture(new HeartBeatResponse()); } } // 处理异常情况，通常情况下上面已经返回。需要加锁以保证线程安全 //abnormal case //hold the lock to get the latest term and leaderId synchronized (memberState) { if (request.getTerm() < memberState.currTerm()) { // Leader 节点轮次小于 Follower，返回 EXPIRED_TERM，告诉对方轮次已经过期，需要重新选举 return CompletableFuture.completedFuture(new HeartBeatResponse().term(memberState.currTerm()).code(DLedgerResponseCode.EXPIRED_TERM.getCode())); } else if (request.getTerm() == memberState.currTerm()) { // 轮次相同，判断请求的节点是否是当前的 Leader if (memberState.getLeaderId() == null) { // 如果当前节点还没有 Leader，切换角色成为 Follower，设置 Leader 节点 Id，返回成功 changeRoleToFollower(request.getTerm(), request.getLeaderId()); return CompletableFuture.completedFuture(new HeartBeatResponse()); } else if (request.getLeaderId().equals(memberState.getLeaderId())) { // 如果请求的节点是当前的 Leader，更新上次收到 Leader 心跳的时间戳，返回成功 lastLeaderHeartBeatTime = System.currentTimeMillis(); return CompletableFuture.completedFuture(new HeartBeatResponse()); } else { // 如果请求的节点不是当前的 Leader，返回 INCONSISTENT_LEADER，告诉对方 Leader 节点不一致，对方会切换成 Candidate，重新选举 //this should not happen, but if happened logger.error(\\\"[{}][BUG] currTerm {} has leader {}, but received leader {}\\\", memberState.getSelfId(), memberState.currTerm(), memberState.getLeaderId(), request.getLeaderId()); return CompletableFuture.completedFuture(new HeartBeatResponse().code(DLedgerResponseCode.INCONSISTENT_LEADER.getCode())); } } else { // 如果请求的轮次大于当前轮次，认为本节点未准备好，进入 Candidate 状态，立即发起一轮投票，返回 TERM_NOT_READY //To make it simple, for larger term, do not change to follower immediately //first change to candidate, and notify the state-maintainer thread changeRoleToCandidate(request.getTerm()); needIncreaseTermImmediately = true; //TOOD notify return CompletableFuture.completedFuture(new HeartBeatResponse().code(DLedgerResponseCode.TERM_NOT_READY.getCode())); } } } \"]},\"1501\":{\"h\":\"4.5 拉票请求\"},\"1502\":{\"h\":\"4.5.1 voteForQuorumResponses\",\"t\":[\"// DLedgerLeaderElector.java /** * 向其他节点发起投票请求（拉票），等待各个节点响应 * * @param term 当前轮次 * @param ledgerEndTerm 最新日志的 term * @param ledgerEndIndex 最大日志条目 index * @return * @throws Exception */ private List<CompletableFuture<VoteResponse>> voteForQuorumResponses(long term, long ledgerEndTerm, long ledgerEndIndex) throws Exception { List<CompletableFuture<VoteResponse>> responses = new ArrayList<>(); // 遍历集群内所有节点 for (String id : memberState.getPeerMap().keySet()) { // 构建投票请求 VoteRequest voteRequest = new VoteRequest(); voteRequest.setGroup(memberState.getGroup()); voteRequest.setLedgerEndIndex(ledgerEndIndex); voteRequest.setLedgerEndTerm(ledgerEndTerm); voteRequest.setLeaderId(memberState.getSelfId()); voteRequest.setTerm(term); voteRequest.setRemoteId(id); CompletableFuture<VoteResponse> voteResponse; if (memberState.getSelfId().equals(id)) { // 投票给自己 voteResponse = handleVote(voteRequest, true); } else { // 发送投票请求到其他节点 //async voteResponse = dLedgerRpcService.vote(voteRequest); } responses.add(voteResponse); } return responses; } \"]},\"1503\":{\"h\":\"4.5.2 handleVote\",\"t\":[\"// DLedgerLeaderElector.java /** * 处理收到的拉票请求 * * @param request 拉票请求 * @param self 是否自身发送的投票请求 * @return */ public CompletableFuture<VoteResponse> handleVote(VoteRequest request, boolean self) { // 由于一个节点可能同时收到多个其他节点的拉票请求，所以需要加锁。锁定状态机对象。 //hold the lock to get the latest term, leaderId, ledgerEndIndex synchronized (memberState) { if (!memberState.isPeerMember(request.getLeaderId())) { logger.warn(\\\"[BUG] [HandleVote] remoteId={} is an unknown member\\\", request.getLeaderId()); return CompletableFuture.completedFuture(new VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_UNKNOWN_LEADER)); } if (!self && memberState.getSelfId().equals(request.getLeaderId())) { logger.warn(\\\"[BUG] [HandleVote] selfId={} but remoteId={}\\\", memberState.getSelfId(), request.getLeaderId()); return CompletableFuture.completedFuture(new VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_UNEXPECTED_LEADER)); } // 根据当前节点的 ledgerEndTerm 进行仲裁 // 如果发起拉票节点的 ledgerEndTerm 小于当前节点的 ledgerEndTerm，说明发起拉票节点的日志复制进度比当前节点低，无法成为 Leader，拒绝 if (request.getLedgerEndTerm() < memberState.getLedgerEndTerm()) { return CompletableFuture.completedFuture(new VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_EXPIRED_LEDGER_TERM)); // 如果 ledgerEndTerm 相等，但是发起拉票节点的 ledgerEndIndex 小于当前节点的 ledgerEndIndex，说明发起拉票节点的日志复制进度比当前节点低，无法成为 Leader，拒绝 } else if (request.getLedgerEndTerm() == memberState.getLedgerEndTerm() && request.getLedgerEndIndex() < memberState.getLedgerEndIndex()) { return CompletableFuture.completedFuture(new VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_SMALL_LEDGER_END_INDEX)); } // 拉票请求的 term 小于当前 term，拒绝投票 if (request.getTerm() < memberState.currTerm()) { return CompletableFuture.completedFuture(new VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_EXPIRED_VOTE_TERM)); // 拉票请求的 term 等于当前 term，处理拉票请求 } else if (request.getTerm() == memberState.currTerm()) { // 如果当前节点未投票，继续下面的逻辑 if (memberState.currVoteFor() == null) { //let it go // 如果当前节点已投票给请求节点，也继续下面的逻辑 } else if (memberState.currVoteFor().equals(request.getLeaderId())) { //repeat just let it go // 如果当前节点已投票给其他节点，拒绝投票 } else { // 如果当前节点已存在 Leader 节点，拒绝并告知对方已有的 Leader 节点 if (memberState.getLeaderId() != null) { return CompletableFuture.completedFuture(new VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_ALREADY_HAS_LEADER)); // 如果当前节点没有 Leader 节点，拒绝 } else { return CompletableFuture.completedFuture(new VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_ALREADY_VOTED)); } } // 拉票请求的 term 大于当前 term，当前节点降级为 Candidate，拒绝拉票请求，告知对方节点自己未准备好 } else { // 使用发起拉票请求的 term 进入 Candidate 状态 //stepped down by larger term changeRoleToCandidate(request.getTerm()); needIncreaseTermImmediately = true; //only can handleVote when the term is consistent return CompletableFuture.completedFuture(new VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_TERM_NOT_READY)); } // 如果发起拉票请求节点的 term 小于当前节点的 ledgerEndTerm，拒绝投票 if (request.getTerm() < memberState.getLedgerEndTerm()) { return CompletableFuture.completedFuture(new VoteResponse(request).term(memberState.getLedgerEndTerm()).voteResult(VoteResponse.RESULT.REJECT_TERM_SMALL_THAN_LEDGER)); } if (!self && isTakingLeadership() && request.getLedgerEndTerm() == memberState.getLedgerEndTerm() && memberState.getLedgerEndIndex() >= request.getLedgerEndIndex()) { return CompletableFuture.completedFuture(new VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_TAKING_LEADERSHIP)); } // 投票给发起拉票请求的节点 memberState.setCurrVoteFor(request.getLeaderId()); return CompletableFuture.completedFuture(new VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.ACCEPT)); } } \"]},\"1504\":{\"h\":\"参考资料\",\"t\":[\"DLedger Wiki\",\"RocketMQ 技术内幕 第2版\",\"The Secret Lives of Data - Raft\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\",\"https://github.com/apache/rocketmq/issues/2278↩︎\"]},\"1505\":{\"h\":\"RocketMQ DLedger 日志复制 流程详解 & 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/20250315-rocketmq-dledger-log-replication.html\"]},\"1506\":{\"h\":\"1. 背景\",\"t\":[\"在 RocketMQ 4.5.0 版本以前，只提供了主从同步功能，但是主节点宕机之后从节点只能读不能写，没有主从切换能力。RocketMQ 4.5.0 引入了 DLedger 来实现主从切换。\",\"DLedger 是基于 Raft 算法的 WAL 实现，它是为消息场景量身定制的，提供了日志写入和读取的接口，且对顺序读出和随机读出做了优化，充分适应消息系统消峰填谷的需求。\",\"在 RocketMQ 4.8.0 版本以前，DLedger 模式的性能比主备模式差 1 个数量级[1]，所以建议用尽可能新的版本部署。\",\"DLedger 的实现大体可以分为两个部分，Leader 选举和日志复制。Leader 选举负责集群中选出一个主节点，而日志复制则确保各节点之间的数据一致性。本文基于 DLedger 0.2.7 版本源码详解日志复制的设计和流程。\"]},\"1507\":{\"h\":\"2. 概要设计\",\"t\":[\"整个日志复制流程如上图所示：\",\"客户端向 Broker 发送消息，Leader Broker 中的消息处理器处理该生产请求。\",\"在 DLedger 模式开启的情况下，消息处理器将生产请求交给 DLedger 服务进行消息存储。\",\"DLedger 服务先将消息保存到本地存储。\",\"构造客户端响应的 Future，放到一个 Map 中，等待日志转发线程将日志转发到 Follower 之后回填这个 Future 的结果后返回给客户端。\",\"日志转发线程从上次转发的位置开始扫描。\",\"日志转发线程将消息转发到 Follower 节点，该过程也是异步的，转发后会将等待转发完成的日志序号存在一个 pendingMap 中。\",\"Follower Broker 中 DLedger 请求处理器收到 Leader 的日志转发请求，将该请求放入待处理队列。\",\"Follower 的日志条目接收器扫描待处理队列中的请求。\",\"将扫描到的请求对应的消息写入 Follower 本地存储，回填等待转发完成的 Future 结果。\",\"Leader 的日志转发线程感知到日志转发请求完成后，移除 pendingMap 中的日志序号，更新节点水位表，这个表中存储着集群中所有节点的日志转发最新水位，用于判断日志是否被大多数节点写入。\",\"日志转发线程同时唤醒结果仲裁线程。\",\"结果仲裁线程根据节点水位表，得到当前集群中的大多数节点已经写入的日志序号。\",\"大多数节点已经写入的日志序号和它之前的日志序号都认为已经写入完成，回填之前日志追加请求的 Future 结果。\",\"返回结果给客户端。\",\"我们可以把日志复制的流程分为 4 个部分：\",\"Leader 接收日志请求并存储，包含上面的 2~4 步。\",\"Leader 的日志转发线程将日志转发到 Follower，包含上面的 5~6 步。\",\"Follower 的请求处理线程接收和保存 Leader 的推送的日志，包含上面的 7~9 步。\",\"Leader 的结果仲裁线程仲裁日志在所有节点保存的状态，更新日志水位，包含上面的 10~13 步。\",\"在下面的详细设计中，会按照这 4 个步骤来进行分析。\"]},\"1508\":{\"h\":\"3. 详细设计\",\"t\":[\"在概要设计中，我们把 DLedger 日志复制分成 4 个主要步骤，在 DLedger 中，这 4 个步骤都主要在类 DLedgerEntryPusher 中实现，其中后面 3 个步骤有专门的线程进行处理，这些线程都作为 DLedgerEntryPusher 的内部类存在，这样就可以访问 DLedgerEntryPusher 的私有字段。\",\"Leader 接收日志请求并存储：由 DLedgerMmapFileStore 保存日志，然后由 DLedgerEntryPusher 等待日志转发完成。\",\"Leader 转发日志到 Follower：由 EntryDispatcher 处理。\",\"Follower 接收和保存 Leader 推送的日志：由 EntryHandler 处理。\",\"Leader 仲裁复制结果：由 QuorumAckChecker 处理。\",\"在具体讲解每个步骤之前，我们先来看一下 DLedger 日志复制中用到的容易混淆的几个 index 的含义。只有 DLedgerMmapFileStore 的两个字段是定时持久化的，其他的几个 index 字段都是对应的处理类在处理业务逻辑时需要临时用到的。\",\"字段名\",\"所属类\",\"持久化\",\"含义\",\"writeIndex\",\"EntryDispatcher\",\"×\",\"Leader 向某一 Follower 节点推送的下一 index\",\"ledgerEndIndex\",\"DLedgerMmapFileStore\",\"√\",\"本地已写入存储的最大 index\",\"committedIndex\",\"DLedgerMmapFileStore\",\"√\",\"已被集群中超过半数节点确认的 index，表示已提交（可应用到状态机）的最大index\",\"lastQuorumIndex\",\"QuorumAckChecker\",\"×\",\"仲裁成功的最大 index，表示已达到多数节点复制确认的最大 index\",\"peerWaterMarksByTerm\",\"DLedgerEntryPusher\",\"×\",\"每个 term，集群内各个节点已经确认存储的最大 index（水位线）\",\"他们的大小关系通常是：\",\"lastQuorumIndex ≤ committedIndex ≤ ledgerEndIndex \"]},\"1509\":{\"h\":\"3.1 Leader 日志存储\",\"t\":[\"对于启动 DLedger 模式的 RocketMQ Broker，其 CommitLog 会被初始化为 DLedgerCommitLog，它的 handleAppend 方法会作为 DLedgerServer 的入口，调用 DLedger 的日志追加逻辑。\",\"先校验日志追加请求的合法性，然后调用 appendAsLeader 将日志追加到 Leader 本地存储。 \",\"追加前会先根据追加请求计算出 log 需要放入的偏移量。\",\"将 log 写入底层文件。\",\"将构造 log 索引，写入索引文件。\",\"更新 ledgerEndIndex 和 ledgerEndTerm，表示 Ledger 本地存储的最大 index 和 term。这两个元数据会定期持久化到磁盘，以便故障恢复时使用。\",\"返回追加结果。\",\"调用 DLedgerEntryPusher 的 waitAck 方法，将日志推送到 Follower 节点。 \",\"更新集群水位表中 Leader 的最大日志序号，因为在 Leader 上写入的日志已经被确认。\",\"新建一个日志追加的 Future，放入等待响应的日志追加 Future 中，等日志转发线程回填该 Future 的结果后就将结果返回给上层客户端。\"]},\"1510\":{\"h\":\"3.2 Leader 转发日志到 Follower\",\"t\":[\"Leader 日志转发的流程由 EntryDispatcher 类处理，它的主要逻辑在 doWork 方法中，无限循环调用。\",\"EntryDispatcher 类有 4 个状态，每个状态会向 Follower 发送不同类型的请求。 下面是 EntryDispatcher 类状态流转图：\",\"COMPARE：日志对比，当发生 Leader 切换时，新 Leader 需要与 Follower 进行日志对比，截断 Follower 多余的日志。\",\"TRUNCATE：日志截断，新 Leader 发现 Follower 存在多余的数据（未提交的），发送 TRUNCATE 请求，要求 Follower 删除多余的数据，保证数据一致性。\",\"APPEND：日志追加，Leader 向 Follower 发送日志追加请求，Leader 将日志复制追加到 Follower。\",\"COMMIT：日志提交，Leader 向 Follower 同步当前节点的已提交日志序号。其实在 APPEND 时也会向 Follower 同步当前节点的已提交日志序号，但是有时 APPEND 请求不那么频繁，可能存在老的日志在多数节点复制完之后更新 committedIndex，但是无法及时用 APPEND 请求去更新到 Follower，所以此时需要 COMMIT 请求来同步。每秒会向 Follower COMMIT 一次。\",\"EntryDispatcher 的执行逻辑如下：\",\"检查和刷新节点状态，如果不是 Leader 则返回，如果是，则继续判断 EntryDispatcher 的状态。\",\"如果是新 Leader，初始状态是 COMPARE，进入 doCompare 方法。 \",\"如果是新集群，没有数据，无需比较。\",\"把 Leader 当前的日志末尾 index 作为需要比较的 index，从存储中获取末尾的日志。\",\"向 Follower 发送 COMPARE 请求，等待 Follower 的响应。\",\"根据比较的结果，决定 Follower 是否要截断，以及从哪里开始截断。具体逻辑查看下面的源码解析部分。\",\"切换 EntryDispatcher 状态为 TRUNCATE\",\"执行 doTruncate 方法。\",\"根据需要截断的 index，从存储中获取对应的日志。\",\"向 Follower 发送 TRUNCATE 请求，等待 Follower 的响应。\",\"切换 EntryDispatcher 状态为 APPEND。\",\"完成 COMPARE 和 TRUNCATE 后，EntryDispatcher 的状态会被切换为 APPEND，进入 doAppend 方法。 \",\"如果 Leader 当前向 Follower 推送的日志 index 大于 Leader 本地存储的日志 index，此时一般是已经推送完了全部的日志（但还不一定全部成功响应），还没有新日志要推送。这种情况下可能之前推送的日志条目被 Follower 响应，这样日志在多数节点复制完成后会推进 committedIndex，需要定时向 Follower 发送 COMMIT 请求来更新集群的 committedIndex。所以这里直接调用 doCommit 之后返回。\",\"挂起的推送请求数量如果超过 1000，则不推送新的日志到 Follower，而是检查挂起的请求中超时的推送请求进行重推。\",\"执行 doAppendInner 方法进行日志推送 \",\"从存储获取要推送的日志数据\",\"检查是否需要流控，用 sleep 进行流控\",\"向 Follower 发送 APPEND 请求\",\"将推送的 index 加入推送等待表\",\"设置推送成功的回调\",\"如果 Follower 返回成功，则从等待表中删除 index，更新集群水位表，启动 QuorumAckChecker 进行结果检查。\",\"如果 Follower 返回 INCONSISTENT_STATE，表示主从日志不一致，需要进行 COMPARE 和 TRUNCATE，切换状态到 COMPARE。\",\"当前 index 推送完成，将 writeIndex 加一，准备推送下一条日志。\"]},\"1511\":{\"h\":\"3.3 Follower 存储日志\",\"t\":[\"Follower 收到 Leader 发来的推送请求会进行处理，根据请求类型不同，进行不同的逻辑。\",\"EntryHandler 的 handlePush 方法接收 Leader 的推送请求，把请求放入对应的等待表中，唤醒 EntryHandler 线程后续从等待表中提取和处理。\",\"主要有两个请求等待表 \",\"红色的 compareOrTruncateRequests 表示 COMPARE、TRUNCATE、COMMIT 请求的等待表，EntryHandler 线程会优先处理这个表中的请求，进行日志比对和截断操作。\",\"绿色的 writeRequestMap 表示 APPEND 请求的等待表。\",\"EntryHandler 线程的 doWork 方法主逻辑从两个请求等待表中获取等待的请求进行处理，，如果为空，则从 writeRequestMap 中获取请求。 \",\"优先从 compareOrTruncateRequests 中获取请求 \",\"COMPARE：根据请求中需要比对的 index，从本地获取日志数据，判断是否存在（请求数据和本地数据是否相等）。存在则返回 SUCCESS，不存在返回 INCONSISTENT_STATE。\",\"TRUNCATE：调用 DLedgerMmapFileStore 的 truncate 方法，进行截断。该方法会把需要截断 index 之后的文件删除，index 所在的文件则重置文件末尾位置。\",\"COMMIT：将请求中的 committedIndex 更新到本地，表示整个集群已经确认的 index 序号。\",\"如果 compareOrTruncateRequests 为空，从 writeRequestMap 中获取请求 \",\"如果没有找到下一个 index 的 APPEND 请求，且等待表不为空，说明可能存在 APPEND 异常：调用 checkAbnormalFuture 检查请求是否丢失，会遍历所有挂起的 APPEND 请求进行检查。 \",\"待 APPEND 的 index 小于 Follower 存储的最大日志序号，这种情况在 Leader 重复推送时会出现，Follower 存储的内容与请求的一致返回 SUCCESS，内容不一致返回 INCONSISTENT_STATE\",\"待 APPEND 的 index 等于 Follower 存储的最大日志序号：正常，直接返回\",\"待 APPEND 的 index 大于 Follower 存储的最大日志序号，这种情况在 Follower 宕机重启后，其最大 index 可能比宕机之前小，这样 Leader 推送的条目就超前于当前 Follower 保存的最大日志 index。请求已超时则返回 INCONSISTENT_STATE，触发 Leader 发送 COMPARE。\",\"如果成功找到下一个 index 的 APPEND 请求，则将请求中的日志数据写入 Follower 本地存储。然后用请求中的 committedIndex 更新到本地。\"]},\"1512\":{\"h\":\"3.4 Leader 仲裁日志复制结果\",\"t\":[\"Leader 在收到 Follower APPEND 成功的响应后会唤醒 QuorumAckChecker 线程，进行结果检查。QuorumAckChecker 的 doWork 方法是其主逻辑循环，逻辑如下：\",\"清除过期的（term 与当前不同）被挂起的 APPEND 请求\",\"获取当前 term 的水位表，水位表中包含了集群中所有节点的当前日志复制水位。\",\"将所有节点的水位倒序排序，中间的值就是大多数节点已经确认的 index。\",\"更新 DLedgerStore 的已确认 index\",\"对于已确认 index 之前的日志附加请求 Future，遍历它们，回填成功结果，此时客户端的请求会被响应。\",\"更新 lastQuorumIndex，用于下次检查后的遍历\"]},\"1513\":{\"h\":\"4. 源码解析\"},\"1514\":{\"h\":\"4.1 DLedgerEntryPusher 类字段设计\",\"t\":[\"/** * DLedger 条目推送器，负责在 Leader 节点上将条目推送给 Follower */ public class DLedgerEntryPusher { private static Logger logger = LoggerFactory.getLogger(DLedgerEntryPusher.class); private DLedgerConfig dLedgerConfig; /** * DLedger 存储 */ private DLedgerStore dLedgerStore; /** * Raft 节点状态机，保存当前节点角色、id、term、对端节点等信息 */ private final MemberState memberState; /** * RPC 实现类，用于集群内网络通信 */ private DLedgerRpcService dLedgerRpcService; /** * 每个投票轮次中，复制组中每个节点当前已存储的最大日志序号（水位） * 用于判断已提交条目序号，仲裁一个条目是否已被超过半数节点存储 */ private Map<Long /* 投票轮次 */, ConcurrentMap<String /* 节点编号 */, Long /* 日志序号 */>> peerWaterMarksByTerm = new ConcurrentHashMap<>(); /** * 每一个投票轮次中，发给 Follower，等待响应挂起的 Append 请求 */ private Map<Long /* 投票轮次 */, ConcurrentMap<Long /* 日志序号 */, TimeoutFuture<AppendEntryResponse>>> pendingAppendResponsesByTerm = new ConcurrentHashMap<>(); /** * 条目接收处理线程，仅在 Follower 激活 */ private EntryHandler entryHandler; /** * 追加条目 ACK 仲裁线程，仅在 Leader 激活 */ private QuorumAckChecker quorumAckChecker; /** * 数据复制线程，在 Leader 节点会为每一个 Follower 节点创建一个 {@link EntryDispatcher} */ private Map<String, EntryDispatcher> dispatcherMap = new HashMap<>(); } \"]},\"1515\":{\"h\":\"4.2 Leader 日志存储\"},\"1516\":{\"h\":\"4.2.1 DLedgerServer 处理客户端 Append 请求\",\"t\":[\" /** * Leader 处理追加条目请求入口 * * 1. 将条目追加到本地存储 * 2. 将 Future 提交给 EntryPusher 并等待超过半数节点 ACK * 3. 如果待处理请求已满，则立即拒绝 * * Handle the append requests: * 1.append the entry to local store * 2.submit the future to entry pusher and wait the quorum ack * 3.if the pending requests are full, then reject it immediately * * @param request * @return * @throws IOException */ @Override public CompletableFuture<AppendEntryResponse> handleAppend(AppendEntryRequest request) throws IOException { try { // 验证请求合理性 // 1. 验证请求目的节点是否为当前节点 PreConditions.check(memberState.getSelfId().equals(request.getRemoteId()), DLedgerResponseCode.UNKNOWN_MEMBER, \\\"%s != %s\\\", request.getRemoteId(), memberState.getSelfId()); // 2. 验证请求集群是否为当前集群 PreConditions.check(memberState.getGroup().equals(request.getGroup()), DLedgerResponseCode.UNKNOWN_GROUP, \\\"%s != %s\\\", request.getGroup(), memberState.getGroup()); // 3. 验证当前节点是否为 Leader PreConditions.check(memberState.isLeader(), DLedgerResponseCode.NOT_LEADER); // 4. 验证当前节点状态是否为转移中 PreConditions.check(memberState.getTransferee() == null, DLedgerResponseCode.LEADER_TRANSFERRING); long currTerm = memberState.currTerm(); // 追加条目是异步过程，会将内容暂存到内存队列中。首先检查内存队列是否已满 if (dLedgerEntryPusher.isPendingFull(currTerm)) { // 已满，向客户端返回错误码 LEADER_PENDING_FULL，表示本次追加请求失败 AppendEntryResponse appendEntryResponse = new AppendEntryResponse(); appendEntryResponse.setGroup(memberState.getGroup()); appendEntryResponse.setCode(DLedgerResponseCode.LEADER_PENDING_FULL.getCode()); appendEntryResponse.setTerm(currTerm); appendEntryResponse.setLeaderId(memberState.getSelfId()); return AppendFuture.newCompletedFuture(-1, appendEntryResponse); } else { // Push 队列未满 if (request instanceof BatchAppendEntryRequest) { // 批量 Append 请求 BatchAppendEntryRequest batchRequest = (BatchAppendEntryRequest) request; if (batchRequest.getBatchMsgs() != null && batchRequest.getBatchMsgs().size() != 0) { // record positions to return; long[] positions = new long[batchRequest.getBatchMsgs().size()]; DLedgerEntry resEntry = null; // split bodys to append int index = 0; Iterator<byte[]> iterator = batchRequest.getBatchMsgs().iterator(); while (iterator.hasNext()) { DLedgerEntry dLedgerEntry = new DLedgerEntry(); dLedgerEntry.setBody(iterator.next()); resEntry = dLedgerStore.appendAsLeader(dLedgerEntry); positions[index++] = resEntry.getPos(); } // only wait last entry ack is ok BatchAppendFuture<AppendEntryResponse> batchAppendFuture = (BatchAppendFuture<AppendEntryResponse>) dLedgerEntryPusher.waitAck(resEntry, true); batchAppendFuture.setPositions(positions); return batchAppendFuture; } throw new DLedgerException(DLedgerResponseCode.REQUEST_WITH_EMPTY_BODYS, \\\"BatchAppendEntryRequest\\\" + \\\" with empty bodys\\\"); } else { // 单个 Append 请求 DLedgerEntry dLedgerEntry = new DLedgerEntry(); dLedgerEntry.setBody(request.getBody()); // Leader 节点日志存储 DLedgerEntry resEntry = dLedgerStore.appendAsLeader(dLedgerEntry); // 把写入的条目 Push 到所有 Follower，Leader 等待 Follower 节点 ACK return dLedgerEntryPusher.waitAck(resEntry, false); } } } catch (DLedgerException e) { logger.error(\\\"[{}][HandleAppend] failed\\\", memberState.getSelfId(), e); AppendEntryResponse response = new AppendEntryResponse(); response.copyBaseInfo(request); response.setCode(e.getCode().getCode()); response.setLeaderId(memberState.getLeaderId()); return AppendFuture.newCompletedFuture(-1, response); } } \"]},\"1517\":{\"h\":\"4.2.2 DLedgerStore 保存日志到本地存储\",\"t\":[\"/** * Leader 节点追加日志条目 * * @param entry 日志条目 * @return */ @Override public DLedgerEntry appendAsLeader(DLedgerEntry entry) { // 校验 // 1. 当前节点是否为 Leader PreConditions.check(memberState.isLeader(), DLedgerResponseCode.NOT_LEADER); // 2. 当前节点磁盘是否已满，超过 90% 则磁盘满 PreConditions.check(!isDiskFull, DLedgerResponseCode.DISK_FULL); // 取 ThreadLocal 缓存的 条目和索引 Buffer ByteBuffer dataBuffer = localEntryBuffer.get(); ByteBuffer indexBuffer = localIndexBuffer.get(); // 对客户端发送的数据进行编码，按照 DLedger 存储协议进行封装 DLedgerEntryCoder.encode(entry, dataBuffer); // 数据缓冲区大小 int entrySize = dataBuffer.remaining(); // 锁定状态机 synchronized (memberState) { // 再次校验节点状态是否为 Leader PreConditions.check(memberState.isLeader(), DLedgerResponseCode.NOT_LEADER, null); PreConditions.check(memberState.getTransferee() == null, DLedgerResponseCode.LEADER_TRANSFERRING, null); // 设置当前日志条目序号和投票轮次，DLedger 会为 Leader 节点收到的每一条数据在服务端维护一个递增的日志序号，作为唯一标识 long nextIndex = ledgerEndIndex + 1; entry.setIndex(nextIndex); entry.setTerm(memberState.currTerm()); entry.setMagic(CURRENT_MAGIC); // 将当前节点的投票轮次和日志序号强制覆盖写入到数据缓冲区中 DLedgerEntryCoder.setIndexTerm(dataBuffer, nextIndex, memberState.currTerm(), CURRENT_MAGIC); // 计算消息写入的起始物理偏移量，并设置 long prePos = dataFileList.preAppend(dataBuffer.remaining()); entry.setPos(prePos); PreConditions.check(prePos != -1, DLedgerResponseCode.DISK_ERROR, null); // 将写入位置覆盖写入到数据缓冲区 DLedgerEntryCoder.setPos(dataBuffer, prePos); // 执行追加条目钩子函数，在 RocketMQ 中，这里会重新计算消息数据的偏移量并覆盖写入 buffer for (AppendHook writeHook : appendHooks) { writeHook.doHook(entry, dataBuffer.slice(), DLedgerEntry.BODY_OFFSET); } // 将数据条目追加到 PageCache 中 long dataPos = dataFileList.append(dataBuffer.array(), 0, dataBuffer.remaining()); PreConditions.check(dataPos != -1, DLedgerResponseCode.DISK_ERROR, null); PreConditions.check(dataPos == prePos, DLedgerResponseCode.DISK_ERROR, null); // 构建索引，写入 indexBuffer，并将索引追加到 PageCache 中 DLedgerEntryCoder.encodeIndex(dataPos, entrySize, CURRENT_MAGIC, nextIndex, memberState.currTerm(), indexBuffer); long indexPos = indexFileList.append(indexBuffer.array(), 0, indexBuffer.remaining(), false); PreConditions.check(indexPos == entry.getIndex() * INDEX_UNIT_SIZE, DLedgerResponseCode.DISK_ERROR, null); if (logger.isDebugEnabled()) { logger.info(\\\"[{}] Append as Leader {} {}\\\", memberState.getSelfId(), entry.getIndex(), entry.getBody().length); } // 日志末尾序号 + 1 ledgerEndIndex++; // 设置日志末尾 term ledgerEndTerm = memberState.currTerm(); // 如果日志开始序号没有初始化，则初始化 if (ledgerBeginIndex == -1) { ledgerBeginIndex = ledgerEndIndex; } // 更新当前节点 MemberState 的 ledgerEndIndex 与 ledgerEndTerm updateLedgerEndIndexAndTerm(); return entry; } } \"]},\"1518\":{\"h\":\"4.2.3 DLedgerEntryPusher 推送写入的日志到 Follower，等待 Follower 节点 ACK\",\"t\":[\"/** * 把写入的条目 Push 到所有 Follower，Leader 等待 Follower 节点 ACK * * @param entry 追加的条目 * @param isBatchWait * @return */ public CompletableFuture<AppendEntryResponse> waitAck(DLedgerEntry entry, boolean isBatchWait) { // Leader 节点更新自身水位线 updatePeerWaterMark(entry.getTerm(), memberState.getSelfId(), entry.getIndex()); if (memberState.getPeerMap().size() == 1) { // 如果复制组内只有一个节点，直接返回成功 AppendEntryResponse response = new AppendEntryResponse(); response.setGroup(memberState.getGroup()); response.setLeaderId(memberState.getSelfId()); response.setIndex(entry.getIndex()); response.setTerm(entry.getTerm()); response.setPos(entry.getPos()); if (isBatchWait) { return BatchAppendFuture.newCompletedFuture(entry.getPos(), response); } return AppendFuture.newCompletedFuture(entry.getPos(), response); } else { // Leader 等待 Follower 复制完数据，返回给客户端一个 Future checkTermForPendingMap(entry.getTerm(), \\\"waitAck\\\"); AppendFuture<AppendEntryResponse> future; if (isBatchWait) { future = new BatchAppendFuture<>(dLedgerConfig.getMaxWaitAckTimeMs()); } else { future = new AppendFuture<>(dLedgerConfig.getMaxWaitAckTimeMs()); } future.setPos(entry.getPos()); // 将 Future 放入 pendingAppendResponsesByTerm 中，等待 Follower 复制完数据后，填充结果 CompletableFuture<AppendEntryResponse> old = pendingAppendResponsesByTerm.get(entry.getTerm()).put(entry.getIndex(), future); if (old != null) { logger.warn(\\\"[MONITOR] get old wait at index={}\\\", entry.getIndex()); } return future; } } \"]},\"1519\":{\"h\":\"4.3 EntryDispatcher 将日志从 Leader 转发到 Follower\",\"t\":[\"/** * 数据转发线程，负责将 Leader 节点的条目推送给 Follower 节点 */ private class EntryDispatcher extends ShutdownAbleThread { /** * 向 Follower 发送命令的类型 */ private AtomicReference<PushEntryRequest.Type> type = new AtomicReference<>(PushEntryRequest.Type.COMPARE); /** * 上一次发送 commit 请求的时间戳 */ private long lastPushCommitTimeMs = -1; /** * 目标节点 ID */ private String peerId; /** * Leader 已完成 COMPARE 的日志序号 */ private long compareIndex = -1; /** * 已向 Follower 发送 APPEND 请求的日志序号（异步操作，不保证 Follower 响应） */ private long writeIndex = -1; /** * 允许的最大挂起条目数量 */ private int maxPendingSize = 1000; /** * Leader 节点当前投票轮次 */ private long term = -1; /** * Leader 节点 ID */ private String leaderId = null; /** * 上次检测泄露的时间，即挂起的日志数量超过 maxPendingSize 的时间 */ private long lastCheckLeakTimeMs = System.currentTimeMillis(); /** * 挂起的 APPEND 请求列表（Leader 将日志转发到 Follower 的请求） */ private ConcurrentMap<Long /* 日志序号 */, Long /* 挂起的时间戳 */> pendingMap = new ConcurrentHashMap<>(); private ConcurrentMap<Long, Pair<Long, Integer>> batchPendingMap = new ConcurrentHashMap<>(); private PushEntryRequest batchAppendEntryRequest = new PushEntryRequest(); /** * 每秒转发到 Follower 的日志带宽配额，默认 20M */ private Quota quota = new Quota(dLedgerConfig.getPeerPushQuota()); public EntryDispatcher(String peerId, Logger logger) { super(\\\"EntryDispatcher-\\\" + memberState.getSelfId() + \\\"-\\\" + peerId, logger); this.peerId = peerId; } /** * 检查节点是否为 Leader，并更新日志转发器的状态 * @return */ private boolean checkAndFreshState() { // 当前节点不是 Leader，直接返回 false，暂停 EntryDispatcher 的复制执行 if (!memberState.isLeader()) { return false; } // 如果集群触发了重新选举，当前节点刚被选举成 Leader， // 日志转发器投票轮次与状态机投票轮次不相等，或 LeaderId 为空，或 LeaderId 与状态机 LeaderId 不相等 // 将 EntryDispatcher 的 term、leaderId 与 MemberState 同步，然后发送 COMPARE 请求 if (term != memberState.currTerm() || leaderId == null || !leaderId.equals(memberState.getLeaderId())) { synchronized (memberState) { if (!memberState.isLeader()) { return false; } PreConditions.check(memberState.getSelfId().equals(memberState.getLeaderId()), DLedgerResponseCode.UNKNOWN); // 更新投票轮次和 LeaderId 为状态机的 term = memberState.currTerm(); leaderId = memberState.getSelfId(); // 改变日志转发器的状态为 COMPARE changeState(-1, PushEntryRequest.Type.COMPARE); } } return true; } private PushEntryRequest buildPushRequest(DLedgerEntry entry, PushEntryRequest.Type target) { PushEntryRequest request = new PushEntryRequest(); request.setGroup(memberState.getGroup()); request.setRemoteId(peerId); request.setLeaderId(leaderId); request.setTerm(term); request.setEntry(entry); request.setType(target); request.setCommitIndex(dLedgerStore.getCommittedIndex()); return request; } private void resetBatchAppendEntryRequest() { batchAppendEntryRequest.setGroup(memberState.getGroup()); batchAppendEntryRequest.setRemoteId(peerId); batchAppendEntryRequest.setLeaderId(leaderId); batchAppendEntryRequest.setTerm(term); batchAppendEntryRequest.setType(PushEntryRequest.Type.APPEND); batchAppendEntryRequest.clear(); } /** * 检查是否超出配额，超出会触发流控 * 1. 挂起的 APPEND 请求数，阈值为 1000 * 2. 主从同步差异，阈值为 300 MB * 3. 每秒追加日志速率，阈值为 20 MB * * @param entry */ private void checkQuotaAndWait(DLedgerEntry entry) { // 检查挂起的 APPEND 请求数是否超过阈值，未超过则返回 if (dLedgerStore.getLedgerEndIndex() - entry.getIndex() <= maxPendingSize) { return; } // 内存存储，直接返回 if (dLedgerStore instanceof DLedgerMemoryStore) { return; } // MMAP 存储，检查主从同步差异，未超过则返回 DLedgerMmapFileStore mmapFileStore = (DLedgerMmapFileStore) dLedgerStore; if (mmapFileStore.getDataFileList().getMaxWrotePosition() - entry.getPos() < dLedgerConfig.getPeerPushThrottlePoint()) { return; } // 统计当前秒的速率，累加 quota.sample(entry.getSize()); // 如果触发流控，等待，直到当前这一秒结束 if (quota.validateNow()) { long leftNow = quota.leftNow(); logger.warn(\\\"[Push-{}]Quota exhaust, will sleep {}ms\\\", peerId, leftNow); DLedgerUtils.sleep(leftNow); } } /** * APPEND 日志实现，Leader 将日志转发到 Follower * @param index 日志序号 * @throws Exception */ private void doAppendInner(long index) throws Exception { // 根据日志序号查询日志内容 DLedgerEntry entry = getDLedgerEntryForAppend(index); if (null == entry) { return; } // 检查是否超出配额，如果超出则流控，sleep 一段时间 checkQuotaAndWait(entry); // 构造 APPEND 请求 PushEntryRequest request = buildPushRequest(entry, PushEntryRequest.Type.APPEND); // 异步发送 APPEND 请求 CompletableFuture<PushEntryResponse> responseFuture = dLedgerRpcService.push(request); // 保存发送 APPEND 请求，Key：APPEND 的日志序号，Value：APPEND 的时间戳 pendingMap.put(index, System.currentTimeMillis()); // APPEND 成功回调 responseFuture.whenComplete((x, ex) -> { try { PreConditions.check(ex == null, DLedgerResponseCode.UNKNOWN); DLedgerResponseCode responseCode = DLedgerResponseCode.valueOf(x.getCode()); switch (responseCode) { case SUCCESS: // 移除 APPEND 请求等待列表中的日志条目 pendingMap.remove(x.getIndex()); // APPEND 成功后更新 Peer（对端节点）水位线（追加成功的日志序号） updatePeerWaterMark(x.getTerm(), peerId, x.getIndex()); // 唤醒 ACK 仲裁线程，用于仲裁 APPEND 结果 quorumAckChecker.wakeup(); break; case INCONSISTENT_STATE: // APPEND 请求状态不一致，Leader 将发送 COMPARE 请求，对比数据是否一致 logger.info(\\\"[Push-{}]Get INCONSISTENT_STATE when push index={} term={}\\\", peerId, x.getIndex(), x.getTerm()); changeState(-1, PushEntryRequest.Type.COMPARE); break; default: logger.warn(\\\"[Push-{}]Get error response code {} {}\\\", peerId, responseCode, x.baseInfo()); break; } } catch (Throwable t) { logger.error(\\\"\\\", t); } }); lastPushCommitTimeMs = System.currentTimeMillis(); } /** * 根据日志序号查询内容 * * @param index 日志序号 * @return 日志条目 */ private DLedgerEntry getDLedgerEntryForAppend(long index) { DLedgerEntry entry; try { entry = dLedgerStore.get(index); } catch (DLedgerException e) { // Do compare, in case the ledgerBeginIndex get refreshed. if (DLedgerResponseCode.INDEX_LESS_THAN_LOCAL_BEGIN.equals(e.getCode())) { logger.info(\\\"[Push-{}]Get INDEX_LESS_THAN_LOCAL_BEGIN when requested index is {}, try to compare\\\", peerId, index); changeState(-1, PushEntryRequest.Type.COMPARE); return null; } throw e; } PreConditions.check(entry != null, DLedgerResponseCode.UNKNOWN, \\\"writeIndex=%d\\\", index); return entry; } private void doCommit() throws Exception { // 仅在距离上次发送至少过了1秒后才发送COMMIT请求 if (DLedgerUtils.elapsed(lastPushCommitTimeMs) > 1000) { PushEntryRequest request = buildPushRequest(null, PushEntryRequest.Type.COMMIT); //Ignore the results dLedgerRpcService.push(request); lastPushCommitTimeMs = System.currentTimeMillis(); } } /** * APPEND 请求重推 * 判断最新一个 APPEND 请求是否已经超时，如果超时则重新发送请求 * * @throws Exception */ private void doCheckAppendResponse() throws Exception { // 获取 Follower 节点水位（已复制日志序号） long peerWaterMark = getPeerWaterMark(term, peerId); // 尝试查找最老的（已复制序号 + 1）等待的 APPEND 请求 Long sendTimeMs = pendingMap.get(peerWaterMark + 1); // 如果下一个等待的 APPEND 请求已超时（1s），重试推送 if (sendTimeMs != null && System.currentTimeMillis() - sendTimeMs > dLedgerConfig.getMaxPushTimeOutMs()) { logger.warn(\\\"[Push-{}]Retry to push entry at {}\\\", peerId, peerWaterMark + 1); doAppendInner(peerWaterMark + 1); } } /** * 追加日志条目到 Follower * * @throws Exception */ private void doAppend() throws Exception { // 无限循环 while (true) { // 检查节点状态，确保是 Leader，否则直接跳出 if (!checkAndFreshState()) { break; } // 检查日志转发器内部状态，确保为 APPEND，否则直接跳出 if (type.get() != PushEntryRequest.Type.APPEND) { break; } // 如果准备 APPEND 的日志超过了当前 Leader 的最大日志序号，一般是已经 push 完最后一条消息，还没有新消息需要同步的场景 // 此时每秒都向 follower 同步一次 commitIndex，因为 commitIndex 可能会随着某些条目在多数节点复制完成后推进 if (writeIndex > dLedgerStore.getLedgerEndIndex()) { // 单独发送 COMMIT 请求 doCommit(); // 检查最老的日志 APPEND 的请求是否超时，如果超时，重新发送 APPEND 请求 doCheckAppendResponse(); // 没有新的日志条目需要推送，跳出 break; } // 检查挂起的 APPEND 请求数量是否超过阈值（1000） if (pendingMap.size() >= maxPendingSize || (DLedgerUtils.elapsed(lastCheckLeakTimeMs) > 1000)) { // 获取 Follower 节点的水位线（成功 APPEND 的日志序号） long peerWaterMark = getPeerWaterMark(term, peerId); // 如果挂起请求日志序号小于水位线，说明已经 APPEND 成功，丢弃该请求 for (Long index : pendingMap.keySet()) { if (index < peerWaterMark) { pendingMap.remove(index); } } // 记录最新一次检查的时间戳 lastCheckLeakTimeMs = System.currentTimeMillis(); } // 如果挂起的 APPEND 请求数量大于阈值 if (pendingMap.size() >= maxPendingSize) { // 检查最老的日志 APPEND 的请求是否超时，如果超时，重新发送 APPEND 请求，跳出 doCheckAppendResponse(); break; } // 将日志转发到 Follower，异步操作，不等待 Follower 响应 doAppendInner(writeIndex); // 准备 APPEND 下一条日志 writeIndex++; } } /** * 在发送 COMPARE 请求后，发现 Follower 数据存在差异 * Leader 向 Follower 发送 TRUNCATE 请求，截断 Follower 的数据 * * @param truncateIndex Follower 需要开始截断的日志序号 * @throws Exception */ private void doTruncate(long truncateIndex) throws Exception { PreConditions.check(type.get() == PushEntryRequest.Type.TRUNCATE, DLedgerResponseCode.UNKNOWN); DLedgerEntry truncateEntry = dLedgerStore.get(truncateIndex); PreConditions.check(truncateEntry != null, DLedgerResponseCode.UNKNOWN); logger.info(\\\"[Push-{}]Will push data to truncate truncateIndex={} pos={}\\\", peerId, truncateIndex, truncateEntry.getPos()); // 构造 TRUNCATE 请求，发送到 Follower，等待 Follower 响应 PushEntryRequest truncateRequest = buildPushRequest(truncateEntry, PushEntryRequest.Type.TRUNCATE); PushEntryResponse truncateResponse = dLedgerRpcService.push(truncateRequest).get(3, TimeUnit.SECONDS); PreConditions.check(truncateResponse != null, DLedgerResponseCode.UNKNOWN, \\\"truncateIndex=%d\\\", truncateIndex); PreConditions.check(truncateResponse.getCode() == DLedgerResponseCode.SUCCESS.getCode(), DLedgerResponseCode.valueOf(truncateResponse.getCode()), \\\"truncateIndex=%d\\\", truncateIndex); lastPushCommitTimeMs = System.currentTimeMillis(); // Follower 清理完多余的数据，Leader 将状态变为 APPEND changeState(truncateIndex, PushEntryRequest.Type.APPEND); } /** * 改变日志转发器的状态 * * @param index 已写入日志序号 * @param target 要修改的目标状态 */ private synchronized void changeState(long index, PushEntryRequest.Type target) { logger.info(\\\"[Push-{}]Change state from {} to {} at {}\\\", peerId, type.get(), target, index); switch (target) { case APPEND: // 重置 compareIndex 指针 compareIndex = -1; // 更新当前节点已追加日志序号为 index updatePeerWaterMark(term, peerId, index); // 唤醒 ACK 仲裁线程，对 APPEND 结果进行仲裁 quorumAckChecker.wakeup(); // 更新待追加日志序号 writeIndex = index + 1; if (dLedgerConfig.isEnableBatchPush()) { resetBatchAppendEntryRequest(); } break; case COMPARE: // 从 APPEND 切换到 COMPARE if (this.type.compareAndSet(PushEntryRequest.Type.APPEND, PushEntryRequest.Type.COMPARE)) { // 重置 compareIndex 指针为 -1 compareIndex = -1; // 清空挂起的日志转发请求 if (dLedgerConfig.isEnableBatchPush()) { batchPendingMap.clear(); } else { pendingMap.clear(); } } break; case TRUNCATE: // 重置 compareIndex 为 -1 compareIndex = -1; break; default: break; } // 更新日志转发器状态 type.set(target); } /** * 向 Follower 发送 COMPARE 请求 * @throws Exception */ private void doCompare() throws Exception { // 无限循环 while (true) { // 验证当前状态下是否可以发送 COMPARE 请求，不是 Leader 则跳出循环 if (!checkAndFreshState()) { break; } // 请求类型不是 COMPARE 或 TRUNCATE，跳出 if (type.get() != PushEntryRequest.Type.COMPARE && type.get() != PushEntryRequest.Type.TRUNCATE) { break; } // compareIndex 和 ledgerEndIndex 都为 -1，表示时新的集群，没有存储任何数据，无需比较主从数据是否一致，跳出 if (compareIndex == -1 && dLedgerStore.getLedgerEndIndex() == -1) { break; } // 重置 compareIndex，如果为 -1 或不在有效范围内，重置 compareIndex 为 Leader 当前存储的最大日志序号 //revise the compareIndex if (compareIndex == -1) { compareIndex = dLedgerStore.getLedgerEndIndex(); logger.info(\\\"[Push-{}][DoCompare] compareIndex=-1 means start to compare\\\", peerId); } else if (compareIndex > dLedgerStore.getLedgerEndIndex() || compareIndex < dLedgerStore.getLedgerBeginIndex()) { logger.info(\\\"[Push-{}][DoCompare] compareIndex={} out of range {}-{}\\\", peerId, compareIndex, dLedgerStore.getLedgerBeginIndex(), dLedgerStore.getLedgerEndIndex()); compareIndex = dLedgerStore.getLedgerEndIndex(); } // 根据待比较日志序号查询 Leader 日志 DLedgerEntry entry = dLedgerStore.get(compareIndex); PreConditions.check(entry != null, DLedgerResponseCode.INTERNAL_ERROR, \\\"compareIndex=%d\\\", compareIndex); // 构造 COMPARE 请求 PushEntryRequest request = buildPushRequest(entry, PushEntryRequest.Type.COMPARE); // 向 Follower 发起 COMPARE 请求 CompletableFuture<PushEntryResponse> responseFuture = dLedgerRpcService.push(request); // 等待获取请求结果，默认超时时间为 3s PushEntryResponse response = responseFuture.get(3, TimeUnit.SECONDS); PreConditions.check(response != null, DLedgerResponseCode.INTERNAL_ERROR, \\\"compareIndex=%d\\\", compareIndex); PreConditions.check(response.getCode() == DLedgerResponseCode.INCONSISTENT_STATE.getCode() || response.getCode() == DLedgerResponseCode.SUCCESS.getCode() , DLedgerResponseCode.valueOf(response.getCode()), \\\"compareIndex=%d\\\", compareIndex); // Follower 需要开始截断的日志序号 long truncateIndex = -1; // 根据 Follower 响应计算 truncateIndex（Follower 需要截断的日志序号，即多余的数据） // 如果响应码为 SUCCESS，表示 compareIndex 对应的日志条目在 Follower 上存在 if (response.getCode() == DLedgerResponseCode.SUCCESS.getCode()) { /* * The comparison is successful: * 1.Just change to append state, if the follower's end index is equal the compared index. * 2.Truncate the follower, if the follower has some dirty entries. */ if (compareIndex == response.getEndIndex()) { // 如果 Leader 已经完成比较的日志序号与 Follower 存储的最大日志序号相同，无需截断，切换日志转发器状态为 APPEND changeState(compareIndex, PushEntryRequest.Type.APPEND); break; } else { // 设置 truncateIndex 为 compareIndex，将向从节点发送 TRUNCATE truncateIndex = compareIndex; } } else if (response.getEndIndex() < dLedgerStore.getLedgerBeginIndex() || response.getBeginIndex() > dLedgerStore.getLedgerEndIndex()) { /* * Leader 和 Follower 日志不相交 * 设置 truncateIndex 为 Leader 目前最小的偏移量。 * 这就意味着会删除 Follower 的所有数据，然后从 truncateIndex 开始向从节点重新转发日志 * 这种情况通常发生在 Follower 崩溃很长一段时间，而 Leader 删除过期的日志时 */ /* The follower's entries does not intersect with the leader. This usually happened when the follower has crashed for a long time while the leader has deleted the expired entries. Just truncate the follower. */ truncateIndex = dLedgerStore.getLedgerBeginIndex(); } else if (compareIndex < response.getBeginIndex()) { /* * Leader 的 compareIndex 小于 Follower 节点的起始日志序号，从 Leader 最小日志序号开始同步 */ /* The compared index is smaller than the follower's begin index. This happened rarely, usually means some disk damage. Just truncate the follower. */ truncateIndex = dLedgerStore.getLedgerBeginIndex(); } else if (compareIndex > response.getEndIndex()) { /* * Leader 的 compareIndex 大于 Follower 节点的最大日志序号 * 将 compareIndex 设置为 Follower 最大日志序号，继续发起 COMPARE 请求 */ /* The compared index is bigger than the follower's end index. This happened frequently. For the compared index is usually starting from the end index of the leader. */ compareIndex = response.getEndIndex(); } else { /* * compareIndex 大于 Follower 节点的开始日志序号，但小于 最大日志序号 * 表示有相交，将 compareIndex 减 1，继续比较，直到找到需要截断的日志序号 */ /* Compare failed and the compared index is in the range of follower's entries. */ compareIndex--; } // compareIndex 小于 Leader 的最小日志序号，将 truncateIndex 设置为 Leader 的最小日志序号 /* The compared index is smaller than the leader's begin index, truncate the follower. */ if (compareIndex < dLedgerStore.getLedgerBeginIndex()) { truncateIndex = dLedgerStore.getLedgerBeginIndex(); } /* * 如果 truncateIndex 不等于 -1，则日志转发器状态为 TRUNCATE，然后立即向 Follower 发送 TRUNCATE 请求 */ /* If get value for truncateIndex, do it right now. */ if (truncateIndex != -1) { changeState(truncateIndex, PushEntryRequest.Type.TRUNCATE); doTruncate(truncateIndex); break; } } } /** * 线程主循环，不断循环执行该方法 */ @Override public void doWork() { try { // 检查节点状态，并更新日志转发器状态 if (!checkAndFreshState()) { waitForRunning(1); return; } // 根据日志转发器状态向 Follower 发送 APPEND 或 COMPARE 请求 if (type.get() == PushEntryRequest.Type.APPEND) { if (dLedgerConfig.isEnableBatchPush()) { doBatchAppend(); } else { doAppend(); } } else { doCompare(); } waitForRunning(1); } catch (Throwable t) { DLedgerEntryPusher.logger.error(\\\"[Push-{}]Error in {} writeIndex={} compareIndex={}\\\", peerId, getName(), writeIndex, compareIndex, t); changeState(-1, PushEntryRequest.Type.COMPARE); DLedgerUtils.sleep(500); } } } \"]},\"1520\":{\"h\":\"4.4 EntryHandler 在 Follower 接收 Leader 推送的请求，存储日志\",\"t\":[\"/** * 数据接收处理线程，节点为 Follower 时激活 */ private class EntryHandler extends ShutdownAbleThread { /** * 上次检查 Leader 是否有推送消息的时间戳 */ private long lastCheckFastForwardTimeMs = System.currentTimeMillis(); /** * APPEND 请求处理队列 */ ConcurrentMap<Long, Pair<PushEntryRequest, CompletableFuture<PushEntryResponse>>> writeRequestMap = new ConcurrentHashMap<>(); /** * COMMIT、COMPARE、TRUNCATE 请求处理队列 */ BlockingQueue<Pair<PushEntryRequest, CompletableFuture<PushEntryResponse>>> compareOrTruncateRequests = new ArrayBlockingQueue<Pair<PushEntryRequest, CompletableFuture<PushEntryResponse>>>(100); public EntryHandler(Logger logger) { super(\\\"EntryHandler-\\\" + memberState.getSelfId(), logger); } /** * Follower 收到 Leader 请求处理入口，将请求放入待处理队列 * {@link #writeRequestMap} 和 {@link #compareOrTruncateRequests}，由 {@link #doWork()} 方法从队列拉取任务进行处理 * * @param request Leader 请求 * @return * @throws Exception */ public CompletableFuture<PushEntryResponse> handlePush(PushEntryRequest request) throws Exception { //The timeout should smaller than the remoting layer's request timeout CompletableFuture<PushEntryResponse> future = new TimeoutFuture<>(1000); switch (request.getType()) { case APPEND: if (request.isBatch()) { PreConditions.check(request.getBatchEntry() != null && request.getCount() > 0, DLedgerResponseCode.UNEXPECTED_ARGUMENT); } else { PreConditions.check(request.getEntry() != null, DLedgerResponseCode.UNEXPECTED_ARGUMENT); } long index = request.getFirstEntryIndex(); // 放入 APPEND 请求处理队列 Pair<PushEntryRequest, CompletableFuture<PushEntryResponse>> old = writeRequestMap.putIfAbsent(index, new Pair<>(request, future)); // 如果该序号的日志条目已存在，返回 REPEATED_PUSH if (old != null) { logger.warn(\\\"[MONITOR]The index {} has already existed with {} and curr is {}\\\", index, old.getKey().baseInfo(), request.baseInfo()); future.complete(buildResponse(request, DLedgerResponseCode.REPEATED_PUSH.getCode())); } break; case COMMIT: // 放入处理队列 compareOrTruncateRequests.put(new Pair<>(request, future)); break; case COMPARE: case TRUNCATE: PreConditions.check(request.getEntry() != null, DLedgerResponseCode.UNEXPECTED_ARGUMENT); // 将 APPEND 等待队列清空 writeRequestMap.clear(); // 放入处理队列 compareOrTruncateRequests.put(new Pair<>(request, future)); break; default: logger.error(\\\"[BUG]Unknown type {} from {}\\\", request.getType(), request.baseInfo()); future.complete(buildResponse(request, DLedgerResponseCode.UNEXPECTED_ARGUMENT.getCode())); break; } wakeup(); return future; } private PushEntryResponse buildResponse(PushEntryRequest request, int code) { PushEntryResponse response = new PushEntryResponse(); response.setGroup(request.getGroup()); response.setCode(code); response.setTerm(request.getTerm()); if (request.getType() != PushEntryRequest.Type.COMMIT) { response.setIndex(request.getFirstEntryIndex()); response.setCount(request.getCount()); } response.setBeginIndex(dLedgerStore.getLedgerBeginIndex()); response.setEndIndex(dLedgerStore.getLedgerEndIndex()); return response; } /** * 处理 Leader 发来的 APPEND 请求 * * @param writeIndex * @param request * @param future */ private void handleDoAppend(long writeIndex, PushEntryRequest request, CompletableFuture<PushEntryResponse> future) { try { PreConditions.check(writeIndex == request.getEntry().getIndex(), DLedgerResponseCode.INCONSISTENT_STATE); // Follower 日志追加 DLedgerEntry entry = dLedgerStore.appendAsFollower(request.getEntry(), request.getTerm(), request.getLeaderId()); PreConditions.check(entry.getIndex() == writeIndex, DLedgerResponseCode.INCONSISTENT_STATE); future.complete(buildResponse(request, DLedgerResponseCode.SUCCESS.getCode())); // 使用 Leader 节点的已提交指针更新 Follower 节点的已提交指针 updateCommittedIndex(request.getTerm(), request.getCommitIndex()); } catch (Throwable t) { logger.error(\\\"[HandleDoWrite] writeIndex={}\\\", writeIndex, t); future.complete(buildResponse(request, DLedgerResponseCode.INCONSISTENT_STATE.getCode())); } } /** * Follower 处理 Leader 发来的 COMPARE 请求 * 判断 Leader 传来的日志序号在 Follower 是否存在 * * @param compareIndex Leader 已经完成比较的日志序号 * @param request LEADER 发来的 COMPARE 请求 * @param future * @return 日志序号存在：SUCCESS，不存在：INCONSISTENT_STATE */ private CompletableFuture<PushEntryResponse> handleDoCompare(long compareIndex, PushEntryRequest request, CompletableFuture<PushEntryResponse> future) { try { PreConditions.check(compareIndex == request.getEntry().getIndex(), DLedgerResponseCode.UNKNOWN); PreConditions.check(request.getType() == PushEntryRequest.Type.COMPARE, DLedgerResponseCode.UNKNOWN); // 从 Follower 中获取日志序号为 compareIndex 的日志条目 DLedgerEntry local = dLedgerStore.get(compareIndex); // 检查日志条目是否存在 PreConditions.check(request.getEntry().equals(local), DLedgerResponseCode.INCONSISTENT_STATE); // 存在，构造返回体返回 future.complete(buildResponse(request, DLedgerResponseCode.SUCCESS.getCode())); } catch (Throwable t) { // 日志条目在 Follower 不存在 logger.error(\\\"[HandleDoCompare] compareIndex={}\\\", compareIndex, t); future.complete(buildResponse(request, DLedgerResponseCode.INCONSISTENT_STATE.getCode())); } return future; } /** * Follower 处理 Leader 发来的 COMMIT 请求 * @param committedIndex Leader 中已提交的日志序号 * @param request COMMIT 请求 * @param future * @return */ private CompletableFuture<PushEntryResponse> handleDoCommit(long committedIndex, PushEntryRequest request, CompletableFuture<PushEntryResponse> future) { try { PreConditions.check(committedIndex == request.getCommitIndex(), DLedgerResponseCode.UNKNOWN); PreConditions.check(request.getType() == PushEntryRequest.Type.COMMIT, DLedgerResponseCode.UNKNOWN); // 将 Leader 节点的轮次和已提交指针，更新到 Follower 节点 updateCommittedIndex(request.getTerm(), committedIndex); future.complete(buildResponse(request, DLedgerResponseCode.SUCCESS.getCode())); } catch (Throwable t) { logger.error(\\\"[HandleDoCommit] committedIndex={}\\\", request.getCommitIndex(), t); future.complete(buildResponse(request, DLedgerResponseCode.UNKNOWN.getCode())); } return future; } /** * 处理 Leader 发来的 TRUNCATE 请求 * 删除节点上 truncateIndex 之后的所有日志 * * @param truncateIndex * @param request * @param future * @return */ private CompletableFuture<PushEntryResponse> handleDoTruncate(long truncateIndex, PushEntryRequest request, CompletableFuture<PushEntryResponse> future) { try { logger.info(\\\"[HandleDoTruncate] truncateIndex={} pos={}\\\", truncateIndex, request.getEntry().getPos()); PreConditions.check(truncateIndex == request.getEntry().getIndex(), DLedgerResponseCode.UNKNOWN); PreConditions.check(request.getType() == PushEntryRequest.Type.TRUNCATE, DLedgerResponseCode.UNKNOWN); // 删除节点上 truncateIndex 之后的所有日志文件，包含 truncateIndex 的文件会修改读写指针 long index = dLedgerStore.truncate(request.getEntry(), request.getTerm(), request.getLeaderId()); PreConditions.check(index == truncateIndex, DLedgerResponseCode.INCONSISTENT_STATE); future.complete(buildResponse(request, DLedgerResponseCode.SUCCESS.getCode())); // 使用 Leader 节点的已提交指针更新 Follower 节点的已提交指针 updateCommittedIndex(request.getTerm(), request.getCommitIndex()); } catch (Throwable t) { logger.error(\\\"[HandleDoTruncate] truncateIndex={}\\\", truncateIndex, t); future.complete(buildResponse(request, DLedgerResponseCode.INCONSISTENT_STATE.getCode())); } return future; } /** * 遍历所有挂起的 APPEND 请求进行检查 * 1. 待 APPEND 的 index 小于 Follower 存储的最大日志序号： * * 内容一致返回 SUCCESS，不一致 INCONSISTENT_STATE * * 这种情况在 Leader 重复推送消息时出现 * 2. 待 APPEND 的 index 等于 Follower 存储的最大日志序号：正常，直接返回 * 3. 待 APPEND 的 index 大于 Follower 存储的最大日志序号： * * 请求已超时则返回 INCONSISTENT_STATE，触发 Leader 发送 COMPARE 请求 * * 这种情况在 Follower 宕机重启后，其 ledgerEndIndex 可能比之前小。Leader 推送条目的序号可能超前于当前 Follower 的最大日志序号 * @param endIndex Follower 存储的最大日志序号 */ private void checkAppendFuture(long endIndex) { long minFastForwardIndex = Long.MAX_VALUE; // 遍历所有挂起的 APPEND 请求 for (Pair<PushEntryRequest, CompletableFuture<PushEntryResponse>> pair : writeRequestMap.values()) { // Batch append 的头尾 index long firstEntryIndex = pair.getKey().getFirstEntryIndex(); long lastEntryIndex = pair.getKey().getLastEntryIndex(); // 待追加日志序号小于等于 Follower 存储的最大日志序号 //Fall behind if (lastEntryIndex <= endIndex) { try { // 如果 Follower 存储的该条日志与 Leader 推送请求中的不一样，返回 INCONSISTENT_STATE // 表示从该日志序号开始，Leader 与 Follower 数据不一致，需要发送 COMPARE 和 TRUNCATE 请求修正数据 if (pair.getKey().isBatch()) { for (DLedgerEntry dLedgerEntry : pair.getKey().getBatchEntry()) { PreConditions.check(dLedgerEntry.equals(dLedgerStore.get(dLedgerEntry.getIndex())), DLedgerResponseCode.INCONSISTENT_STATE); } } else { DLedgerEntry dLedgerEntry = pair.getKey().getEntry(); PreConditions.check(dLedgerEntry.equals(dLedgerStore.get(dLedgerEntry.getIndex())), DLedgerResponseCode.INCONSISTENT_STATE); } // Follower 存储的该条日志内容与 Leader 推送的日志内容相同，说明从节点已经存储该条日志，返回 SUCCESS pair.getValue().complete(buildResponse(pair.getKey(), DLedgerResponseCode.SUCCESS.getCode())); logger.warn(\\\"[PushFallBehind]The leader pushed an batch append entry last index={} smaller than current ledgerEndIndex={}, maybe the last ack is missed\\\", lastEntryIndex, endIndex); } catch (Throwable t) { logger.error(\\\"[PushFallBehind]The leader pushed an batch append entry last index={} smaller than current ledgerEndIndex={}, maybe the last ack is missed\\\", lastEntryIndex, endIndex, t); pair.getValue().complete(buildResponse(pair.getKey(), DLedgerResponseCode.INCONSISTENT_STATE.getCode())); } writeRequestMap.remove(pair.getKey().getFirstEntryIndex()); continue; } // 待追加日志序号等于 endIndex + 1，表示 Follower 下一条期望追加的日志已经被 Leader 推送过来，是正常情况，直接返回 if (firstEntryIndex == endIndex + 1) { return; } // 处理待追加日志序号大于 endIndex + 1 的情况 // 挂起时间未超时，继续检查下一条待追加日志 TimeoutFuture<PushEntryResponse> future = (TimeoutFuture<PushEntryResponse>) pair.getValue(); if (!future.isTimeOut()) { continue; } // 快速失败机制 // 挂起时间超时，说明该日志没有正常写入 Follower。记录其日志序号，最终向主节点反馈最小的超时日志序号。 if (firstEntryIndex < minFastForwardIndex) { minFastForwardIndex = firstEntryIndex; } } if (minFastForwardIndex == Long.MAX_VALUE) { return; } Pair<PushEntryRequest, CompletableFuture<PushEntryResponse>> pair = writeRequestMap.get(minFastForwardIndex); if (pair == null) { return; } // 如果有记录超时的待追加日志序号，向 Leader 返回 INCONSISTENT_STATE，让主节点发送 COMPARE 进行数据比对，保证主从一致性 logger.warn(\\\"[PushFastForward] ledgerEndIndex={} entryIndex={}\\\", endIndex, minFastForwardIndex); pair.getValue().complete(buildResponse(pair.getKey(), DLedgerResponseCode.INCONSISTENT_STATE.getCode())); } /** * Leader 确实会向 Follower 推送条目并记录已推送的索引。但在以下情况下，推送过程可能会停止： * * 如果 Follower 异常关闭，它的 ledgerEndIndex 可能会比之前更小（丢失提交的日志）。此时，Leader 可能会推送 index 超前的条目，并不断重试。 * * 如果 Follower 最后的（ack）丢失，且没有新消息写入，Leader 可能会重试推送最后一条消息，但 Follower 会忽略它。 * @param endIndex Follower 存储的最大日志序号 */ private void checkAbnormalFuture(long endIndex) { // 距离上一次异常检查不到 1s，直接返回 if (DLedgerUtils.elapsed(lastCheckFastForwardTimeMs) < 1000) { return; } lastCheckFastForwardTimeMs = System.currentTimeMillis(); // 没有积压的 APPEND 请求，Leader 没有推送新日志，直接返回 if (writeRequestMap.isEmpty()) { return; } checkAppendFuture(endIndex); } @Override public void doWork() { try { // 不是从节点，跳出 if (!memberState.isFollower()) { waitForRunning(1); return; } if (compareOrTruncateRequests.peek() != null) { // 如果 COMMIT、COMPARE、TRUNCATE 请求队列不为空，优先处理 Pair<PushEntryRequest, CompletableFuture<PushEntryResponse>> pair = compareOrTruncateRequests.poll(); PreConditions.check(pair != null, DLedgerResponseCode.UNKNOWN); switch (pair.getKey().getType()) { case TRUNCATE: handleDoTruncate(pair.getKey().getEntry().getIndex(), pair.getKey(), pair.getValue()); break; case COMPARE: handleDoCompare(pair.getKey().getEntry().getIndex(), pair.getKey(), pair.getValue()); break; case COMMIT: handleDoCommit(pair.getKey().getCommitIndex(), pair.getKey(), pair.getValue()); break; default: break; } } else { // 处理 APPEND 请求 // 下一条待写日志序号 = 已存储的最大日志序号 + 1 long nextIndex = dLedgerStore.getLedgerEndIndex() + 1; // 根据序号获取 APPEND 请求 Pair<PushEntryRequest, CompletableFuture<PushEntryResponse>> pair = writeRequestMap.remove(nextIndex); if (pair == null) { // 在待写队列中没有找到对应的 APPEND 请求，调用 checkAbnormalFuture 检查请求是否丢失 checkAbnormalFuture(dLedgerStore.getLedgerEndIndex()); waitForRunning(1); return; } // 能找到 APPEND 请求，处理请求 PushEntryRequest request = pair.getKey(); if (request.isBatch()) { handleDoBatchAppend(nextIndex, request, pair.getValue()); } else { handleDoAppend(nextIndex, request, pair.getValue()); } } } catch (Throwable t) { DLedgerEntryPusher.logger.error(\\\"Error in {}\\\", getName(), t); DLedgerUtils.sleep(100); } } } \"]},\"1521\":{\"h\":\"4.5 Leader 的 QuorumAckChecker 检查日志推送到 Follower 的结果\",\"t\":[\"/** * 日志追加 ACK 投票仲裁线程，Leader 节点激活 * This thread will check the quorum index and complete the pending requests. */ private class QuorumAckChecker extends ShutdownAbleThread { /** * 上次打印水位线日志的时间戳，用于日志打印 */ private long lastPrintWatermarkTimeMs = System.currentTimeMillis(); /** * 上次检测泄漏的时间戳 */ private long lastCheckLeakTimeMs = System.currentTimeMillis(); /** * 已投票仲裁的日志序号 */ private long lastQuorumIndex = -1; public QuorumAckChecker(Logger logger) { super(\\\"QuorumAckChecker-\\\" + memberState.getSelfId(), logger); } /** * 追加日志仲裁主逻辑循环 * 不断根据当前 term 复制组中所有节点已保存的日志水位 {@link #peerWaterMarksByTerm} 来进行仲裁， * 根据仲裁成功的日志 index，把对应的 APPEND 请求返回客户端 */ @Override public void doWork() { try { // 打印日志，如果距上次打印时间超过 3s，则输出当前状态日志 if (DLedgerUtils.elapsed(lastPrintWatermarkTimeMs) > 3000) { if (DLedgerEntryPusher.this.fsmCaller.isPresent()) { final long lastAppliedIndex = DLedgerEntryPusher.this.fsmCaller.get().getLastAppliedIndex(); logger.info(\\\"[{}][{}] term={} ledgerBegin={} ledgerEnd={} committed={} watermarks={} appliedIndex={}\\\", memberState.getSelfId(), memberState.getRole(), memberState.currTerm(), dLedgerStore.getLedgerBeginIndex(), dLedgerStore.getLedgerEndIndex(), dLedgerStore.getCommittedIndex(), JSON.toJSONString(peerWaterMarksByTerm), lastAppliedIndex); } else { logger.info(\\\"[{}][{}] term={} ledgerBegin={} ledgerEnd={} committed={} watermarks={}\\\", memberState.getSelfId(), memberState.getRole(), memberState.currTerm(), dLedgerStore.getLedgerBeginIndex(), dLedgerStore.getLedgerEndIndex(), dLedgerStore.getCommittedIndex(), JSON.toJSONString(peerWaterMarksByTerm)); } lastPrintWatermarkTimeMs = System.currentTimeMillis(); } // 不是 Leader，等 1ms（防止 CPU 空转），返回 if (!memberState.isLeader()) { waitForRunning(1); return; } long currTerm = memberState.currTerm(); checkTermForPendingMap(currTerm, \\\"QuorumAckChecker\\\"); checkTermForWaterMark(currTerm, \\\"QuorumAckChecker\\\"); // 清除过期的（term 与当前不同）被挂起的 APPEND 请求 if (pendingAppendResponsesByTerm.size() > 1) { for (Long term : pendingAppendResponsesByTerm.keySet()) { if (term == currTerm) { continue; } // 清除 term 与当前不同的挂起请求，向客户端返回错误码 TERM_CHANGED for (Map.Entry<Long, TimeoutFuture<AppendEntryResponse>> futureEntry : pendingAppendResponsesByTerm.get(term).entrySet()) { AppendEntryResponse response = new AppendEntryResponse(); response.setGroup(memberState.getGroup()); response.setIndex(futureEntry.getKey()); response.setCode(DLedgerResponseCode.TERM_CHANGED.getCode()); response.setLeaderId(memberState.getLeaderId()); logger.info(\\\"[TermChange] Will clear the pending response index={} for term changed from {} to {}\\\", futureEntry.getKey(), term, currTerm); futureEntry.getValue().complete(response); } pendingAppendResponsesByTerm.remove(term); } } // 清除已过期的节点日志保存水位线，即投票 term 与当前 term 不同的水位线 if (peerWaterMarksByTerm.size() > 1) { for (Long term : peerWaterMarksByTerm.keySet()) { if (term == currTerm) { continue; } // 清除投票轮次与当前轮次不同的水位线（复制组中每个节点当前存储的最大日志序列号），避免内存泄漏 logger.info(\\\"[TermChange] Will clear the watermarks for term changed from {} to {}\\\", term, currTerm); peerWaterMarksByTerm.remove(term); } } // 追加日志仲裁 // 获取当前 term 节点已经保存的日志表 Map<String /* 节点编号 */, Long /*日志序号*/> peerWaterMarks = peerWaterMarksByTerm.get(currTerm); // 按已经保存的日志序号大小降序排序 List<Long> sortedWaterMarks = peerWaterMarks.values() .stream() .sorted(Comparator.reverseOrder()) .collect(Collectors.toList()); // 获取日志表中间的日志序号，即为完成仲裁的日志序号（超过半数大于它） long quorumIndex = sortedWaterMarks.get(sortedWaterMarks.size() / 2); final Optional<StateMachineCaller> fsmCaller = DLedgerEntryPusher.this.fsmCaller; if (fsmCaller.isPresent()) { // If there exist statemachine DLedgerEntryPusher.this.dLedgerStore.updateCommittedIndex(currTerm, quorumIndex); final StateMachineCaller caller = fsmCaller.get(); caller.onCommitted(quorumIndex); // Check elapsed if (DLedgerUtils.elapsed(lastCheckLeakTimeMs) > 1000) { updatePeerWaterMark(currTerm, memberState.getSelfId(), dLedgerStore.getLedgerEndIndex()); checkResponseFuturesElapsed(caller.getLastAppliedIndex()); lastCheckLeakTimeMs = System.currentTimeMillis(); } if (quorumIndex == this.lastQuorumIndex) { waitForRunning(1); } } else { // 更新 committedIndex 索引（已提交的日志序号），方便 DLedgerStore 定时将 committedIndex 写入 checkPoint dLedgerStore.updateCommittedIndex(currTerm, quorumIndex); // 处理 quorumIndex（已提交指针）之前的挂起等待 handleAppend 的 future 完成的 Dledger 客户端追加日志请求，返回成功 ConcurrentMap<Long, TimeoutFuture<AppendEntryResponse>> responses = pendingAppendResponsesByTerm.get(currTerm); boolean needCheck = false; int ackNum = 0; // 从 quorumIndex （已提交指针）开始倒序遍历 for (Long i = quorumIndex; i > lastQuorumIndex; i--) { try { // 移除对应的挂起请求 CompletableFuture<AppendEntryResponse> future = responses.remove(i); if (future == null) { // 如果未找到对应挂起的请求，说明前面挂起的请求已经全部处理完毕，结束遍历。 // 标记需要进行泄漏检测 needCheck = true; break; } else if (!future.isDone()) { // 找到对应的挂起请求，向客户端返回写入成功 AppendEntryResponse response = new AppendEntryResponse(); response.setGroup(memberState.getGroup()); response.setTerm(currTerm); response.setIndex(i); response.setLeaderId(memberState.getSelfId()); response.setPos(((AppendFuture) future).getPos()); // 向客户端返回响应结果 future.complete(response); } // ackNum + 1，表示本次仲裁向客户端返回响应结果的数量 ackNum++; } catch (Throwable t) { logger.error(\\\"Error in ack to index={} term={}\\\", i, currTerm, t); } } // 如果本次仲裁没有日志被成功追加，检查被挂起的追加请求 // 判断其大于 quorumIndex 日志序号的 APPEND 请求是否超时，如果超时，向客户端返回 WAIT_QUORUM_ACK_TIMEOUT if (ackNum == 0) { checkResponseFuturesTimeout(quorumIndex + 1); waitForRunning(1); } if (DLedgerUtils.elapsed(lastCheckLeakTimeMs) > 1000 || needCheck) { // 检查挂起的日志追加请求是否泄漏 updatePeerWaterMark(currTerm, memberState.getSelfId(), dLedgerStore.getLedgerEndIndex()); // 遍历已挂起的请求，如果日志序号已经仲裁成功，则向客户端返回成功 checkResponseFuturesElapsed(quorumIndex); lastCheckLeakTimeMs = System.currentTimeMillis(); } } // 更新上次仲裁成功的日志序号 lastQuorumIndex = quorumIndex; } catch (Throwable t) { DLedgerEntryPusher.logger.error(\\\"Error in {}\\\", getName(), t); DLedgerUtils.sleep(100); } } } \"]},\"1522\":{\"h\":\"参考资料\",\"t\":[\"RocketMQ 技术内幕 第2版\",\"The Secret Lives of Data - Raft\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\",\"https://github.com/apache/rocketmq/issues/2278↩︎\"]},\"1523\":{\"h\":\"Rocketmq 动态配置\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/99991231-rocketmq-dynamic-config.html\",\"# BrokerController#constructor // 初始化配置类，把 4 个配置项注册到配置类中，在配置类被更新时刷新配置项 this.configuration = new Configuration( log, BrokerPathConfigHelper.getBrokerConfigPath(), this.brokerConfig, this.nettyServerConfig, this.nettyClientConfig, this.messageStoreConfig ); \",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1524\":{\"h\":\"RocketMQ 与 Kafka 对零拷贝的使用 源码解析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/99991231-rocketmq-kafka-zero-copy.html\"]},\"1525\":{\"h\":\"背景\"},\"1526\":{\"h\":\"用户态和内核态\"},\"1527\":{\"h\":\"参考资料\",\"t\":[\"用户态和内核态：用户态线程和内核态线程有什么区别？\",\"磁盘I/O那些事 - 美团技术团队\",\"什么是零拷贝？ - 小林coding\",\"文件 I/O 简明概述 - Spongecaptain\",\"怎么理解内存中的Buffer和Cache？ - 倪朋飞\",\"linux中普通文件和块设备文件的区别 - CobbLiu\",\"Linux内核Page Cache和Buffer Cache关系及演化历史 - lday\",\"Kafka和RocketMQ底层存储之那些你不知道的事 - yes的练级攻略\",\"性能之道：RocketMQ与Kafka高性能设计对比 - 丁威\",\"Linux I/O 原理和 Zero-copy 技术全面揭秘\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1528\":{\"h\":\"RocketMQ 的底层存储实现：内存映射文件 MappedFile、MappedFileQueue 源码剖析\",\"t\":[\"原文地址：http://hscarb.github.io/rocketmq/99991231-rocketmq-mappedfile.html\"]},\"1529\":{\"h\":\"1. 背景\",\"t\":[\"RocketMQ 是一个低延迟、拥有金融级别稳定性的高性能消息队列。\"]},\"1530\":{\"h\":\"2. 概述\"},\"1531\":{\"h\":\"2.1 MappedFile 的创建\"},\"1532\":{\"h\":\"2.2 MappedFile 的写入\"},\"1533\":{\"h\":\"2.3 MappedFile 刷盘\"},\"1534\":{\"h\":\"2.4\"},\"1535\":{\"h\":\"3. 详解\"},\"1536\":{\"h\":\"4. 代码\"},\"1537\":{\"h\":\"5. 参考资料\",\"t\":[\"RocketMQ 官方文档\",\"Kafka 和 RocketMQ 底层存储之那些你不知道的事\",\"RocketMQ高性能之底层存储设计\",\"深入剖析 RocketMQ 源码 - 消息存储模块\",\"RocketMQ存储实现分析\",\"谈谈MQ | 与Page Cache的爱恨情仇\",\"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！\"]},\"1538\":{\"h\":\"rocketmq\",\"t\":[\"RocketMQ 4.9.1 性能优化 源码剖析\",\"RocketMQ ConsumeQueue 消费队列文件\",\"RocketMQ IndexFile 索引文件\",\"RocketMQ 消息消费 轮询机制 PullRequestHoldService\",\"RocketMQ 延迟消息（定时消息）源码解析\",\"RocketMQ 延迟消息（定时消息）4.9.3 版本优化 异步投递支持\",\"RocketMQ 过期文件删除机制 源码剖析\",\"RocketMQ 如何实现高性能消息读写？\",\"RocketMQ 4.9.3 版本 性能优化 源码剖析\",\"RocketMQ 实现高性能定时消息\",\"RocketMQ NameServer 详解 源码剖析\",\"RocketMQ ACL 权限控制 详解 & 源码剖析\",\"RocketMQ 消息轨迹\",\"RocketMQ 消息发送设计和原理详解 源码剖析\",\"RocketMQ Memory Store\",\"使用 Docker 和 docker-compose 快速部署 RocketMQ 集群 双主 / DLedger\",\"RocketMQ 消费者（1）概念和消费流程\",\"RocketMQ 消费者（2）客户端设计和启动流程详解 & 源码解析\",\"RocketMQ 消费者（3）重平衡 流程详解 & 源码解析\",\"RocketMQ 消费者（4）消息拉取 流程详解 & 源码解析\",\"RocketMQ 消费者（5）消息消费、消费进度上报 流程详解 & 源码解析\",\"RocketMQ 消费者（6）顺序消费 流程详解 & 源码解析\",\"RocketMQ 最佳实践\",\"RocketMQ 5.0：POP 消费模式 原理详解 & 源码解析\",\"RocketMQ 轻量级队列 Light Message Queue（RIP-28）原理详解 & 源码解析\",\"RocketMQ Netty 写缓冲区水位配置 NettyServerConfig#writeBufferHighWaterMark\",\"Rocketmq Filter 消息过滤（TAGS、SQL92）原理详解 & 源码解析\",\"Rocketmq 5.0 任意时间定时消息（RIP-43） 原理详解 & 源码解析\",\"Rocketmq 5 分级存储 Tieredstore（RIP-57、RIP-65） 原理详解 & 源码解析\",\"RocketMQ 事务消息原理详解 & 源码解析\",\"RocketMQ DLedger Leader 选举 流程详解 & 源码解析\",\"RocketMQ DLedger 日志复制 流程详解 & 源码解析\"]}},\"dirtCount\":0,\"index\":[[\"倪朋飞\",{\"1\":{\"1527\":1}}],[\"崩溃很长一段时间\",{\"1\":{\"1519\":1}}],[\"崩溃性错误\",{\"1\":{\"193\":1}}],[\"累加\",{\"1\":{\"1519\":1}}],[\"阈值为\",{\"1\":{\"1519\":3}}],[\"追加日志仲裁\",{\"1\":{\"1521\":1}}],[\"追加日志仲裁主逻辑循环\",{\"1\":{\"1521\":1}}],[\"追加日志条目到\",{\"1\":{\"1519\":1}}],[\"追加成功的日志序号\",{\"1\":{\"1519\":1}}],[\"追加的条目\",{\"1\":{\"1518\":1}}],[\"追加条目是异步过程\",{\"1\":{\"1516\":1}}],[\"追加条目\",{\"1\":{\"1514\":1}}],[\"追加前会先根据追加请求计算出\",{\"1\":{\"1509\":1}}],[\"序号\",{\"1\":{\"1511\":1}}],[\"序列化协议编码\",{\"1\":{\"894\":1}}],[\"序列化协议\",{\"1\":{\"894\":1}}],[\"序列化协议才能生效\",{\"1\":{\"894\":1}}],[\"序列化协议有俩\",{\"1\":{\"893\":1}}],[\"序列化\",{\"0\":{\"337\":1}}],[\"序列\",{\"1\":{\"186\":1}}],[\"≤\",{\"1\":{\"1508\":2}}],[\"认为本节点未准备好\",{\"1\":{\"1500\":1}}],[\"半数以上\",{\"1\":{\"1499\":1}}],[\"半消息偏移量\",{\"1\":{\"1468\":1}}],[\"半消息如何处理\",{\"1\":{\"1460\":2}}],[\"半消息发送成功且本地事务执行成功则告诉服务端让半消息复原\",{\"1\":{\"1459\":1}}],[\"仲裁线程\",{\"1\":{\"1514\":1,\"1519\":2}}],[\"仲裁一个条目是否已被超过半数节点存储\",{\"1\":{\"1514\":1}}],[\"仲裁日志复制结果\",{\"0\":{\"1512\":1}}],[\"仲裁成功的最大\",{\"1\":{\"1508\":1}}],[\"仲裁复制结果\",{\"1\":{\"1508\":1}}],[\"仲裁心跳响应结果\",{\"1\":{\"1499\":1}}],[\"仲裁队列使用在内存中\",{\"1\":{\"701\":1}}],[\"仲裁队列的所有消息一直会保存在内存中\",{\"1\":{\"702\":1}}],[\"仲裁队列的磁盘和内存配置与普通队列不同\",{\"1\":{\"699\":1}}],[\"仲裁队列的劣势\",{\"0\":{\"697\":1}}],[\"仲裁队列的优势\",{\"0\":{\"696\":1}}],[\"仲裁队列可以提供更高的性能\",{\"1\":{\"696\":1}}],[\"仲裁队列就是基于\",{\"1\":{\"694\":1}}],[\"仲裁队列旨在解决镜像队列的性能和同步问题\",{\"1\":{\"694\":1}}],[\"仲裁队列\",{\"0\":{\"692\":1,\"694\":1,\"701\":1},\"1\":{\"718\":1}}],[\"仲裁队列将是比传统队列镜像更好的选择\",{\"1\":{\"675\":1}}],[\"赞成票\",{\"1\":{\"1497\":2}}],[\"赞成投票数\",{\"1\":{\"1497\":1}}],[\"告知对方节点自己未准备好\",{\"1\":{\"1503\":1}}],[\"告知对方自己未准备好\",{\"1\":{\"1492\":1}}],[\"告诉对方轮次已经过期\",{\"1\":{\"1500\":2}}],[\"告诉对方\",{\"1\":{\"1489\":1,\"1500\":1}}],[\"告诉对方已经过期\",{\"1\":{\"1489\":1}}],[\"告诉内核即将要访问这部分文件\",{\"1\":{\"882\":1}}],[\"告诉编译器此处的值是什么类型\",{\"1\":{\"589\":1}}],[\"告诉系统要跟踪什么进程\",{\"1\":{\"261\":1}}],[\"告诉我们异常错误是如何生成的\",{\"1\":{\"194\":1}}],[\"投票仲裁线程\",{\"1\":{\"1521\":1}}],[\"投票给发起拉票请求的节点\",{\"1\":{\"1503\":1}}],[\"投票给自己\",{\"1\":{\"1502\":1}}],[\"投票轮次比\",{\"1\":{\"1499\":1}}],[\"投票轮次\",{\"1\":{\"1497\":1,\"1514\":2}}],[\"投票轮次大于当前轮次\",{\"1\":{\"1480\":1}}],[\"投票请求\",{\"1\":{\"1477\":1}}],[\"投递结果是否成功\",{\"1\":{\"1374\":1}}],[\"投递到\",{\"1\":{\"1360\":1,\"1374\":1}}],[\"投递定时消息\",{\"0\":{\"1360\":1,\"1374\":1}}],[\"投递时间戳\",{\"1\":{\"1346\":1}}],[\"投递时间点\",{\"1\":{\"845\":1,\"860\":1}}],[\"投递请求\",{\"1\":{\"1297\":1}}],[\"投递\",{\"0\":{\"1372\":1,\"1373\":1,\"1374\":1},\"1\":{\"1253\":1,\"1348\":1}}],[\"投递任务状态更新线程\",{\"1\":{\"933\":1}}],[\"投递任务未能放入队列\",{\"1\":{\"855\":1}}],[\"投递不完则到下个任务继续投\",{\"1\":{\"932\":1}}],[\"投递这\",{\"1\":{\"932\":1}}],[\"投递一条消息的逻辑很简单\",{\"1\":{\"930\":1}}],[\"投递线程\",{\"1\":{\"930\":1}}],[\"投递即在定时消息到期后把消息重新投递到\",{\"1\":{\"930\":1}}],[\"投递前永不删除\",{\"1\":{\"928\":1}}],[\"投递的步骤被分为三个任务\",{\"1\":{\"1357\":1}}],[\"投递的时候再查出来\",{\"1\":{\"1346\":1}}],[\"投递的偏移量之前的文件\",{\"1\":{\"864\":1}}],[\"投递的过程被放入阻塞队列\",{\"1\":{\"857\":1}}],[\"投递出错\",{\"1\":{\"861\":1}}],[\"投递异常等原因\",{\"1\":{\"860\":1}}],[\"投递过程状态更新线程\",{\"0\":{\"858\":1}}],[\"投递逻辑\",{\"1\":{\"855\":1}}],[\"投递失败则继续重试\",{\"1\":{\"855\":1}}],[\"投递失败\",{\"1\":{\"845\":1,\"860\":1}}],[\"投递成功则更新\",{\"1\":{\"855\":1,\"858\":1}}],[\"投递成功后更新该等级对应的\",{\"1\":{\"855\":1}}],[\"投递成功\",{\"1\":{\"845\":1}}],[\"投递消息时只需要借助索引文件就可以查找所有该时刻需要投递的消息\",{\"1\":{\"927\":1}}],[\"投递消息\",{\"1\":{\"689\":1,\"845\":2,\"860\":1}}],[\"稍后再回查\",{\"1\":{\"1468\":1}}],[\"坏处是这样会破坏\",{\"1\":{\"1453\":1}}],[\"枚举值\",{\"1\":{\"1442\":2}}],[\"枚举类\",{\"0\":{\"31\":1}}],[\"七\",{\"1\":{\"1437\":1}}],[\"谈谈mq\",{\"1\":{\"1537\":1}}],[\"谈谈\",{\"1\":{\"1437\":1}}],[\"拆分每条消息的\",{\"1\":{\"1432\":1}}],[\"拆分消息句柄字符串\",{\"1\":{\"1273\":1}}],[\"逆序遍历索引文件\",{\"1\":{\"1415\":1,\"1436\":1}}],[\"库来创建的内存缓存\",{\"1\":{\"1406\":1}}],[\"乘法减的流量控制机制\",{\"1\":{\"1404\":1}}],[\"真正将数据上传到二级存储\",{\"1\":{\"1403\":1}}],[\"真正删除文件是调用了\",{\"1\":{\"870\":1}}],[\"明确了起始位置之后\",{\"1\":{\"1403\":1}}],[\"明显的区别就是\",{\"1\":{\"116\":1}}],[\"链中的\",{\"1\":{\"1403\":1}}],[\"链当中\",{\"1\":{\"1403\":1}}],[\"链表中前一项\",{\"1\":{\"1372\":1}}],[\"链表中一个一个读取索引项\",{\"1\":{\"1372\":1}}],[\"链表前一个索引项的物理偏移量\",{\"1\":{\"1372\":1}}],[\"链表头\",{\"1\":{\"1351\":1}}],[\"链表尾\",{\"1\":{\"1351\":1}}],[\"链表越往后\",{\"1\":{\"787\":1}}],[\"链表下一项的逻辑下标\",{\"1\":{\"787\":1}}],[\"统一存储\",{\"1\":{\"1402\":1}}],[\"统计当前秒的速率\",{\"1\":{\"1519\":1}}],[\"统计响应结果\",{\"1\":{\"1499\":1}}],[\"统计投票结果\",{\"1\":{\"1497\":1}}],[\"统计选举超时\",{\"1\":{\"1480\":1}}],[\"统计\",{\"1\":{\"1173\":1}}],[\"统计各个函数被调用的次数\",{\"1\":{\"255\":1}}],[\"统计每秒操作数\",{\"1\":{\"11\":1}}],[\"冷存储的\",{\"1\":{\"1393\":1}}],[\"确实会向\",{\"1\":{\"1520\":1}}],[\"确认消息已经发送成功\",{\"1\":{\"1446\":1}}],[\"确定要读取消息数据的长度\",{\"1\":{\"1391\":1}}],[\"确保为\",{\"1\":{\"1519\":1}}],[\"确保是\",{\"1\":{\"1519\":1}}],[\"确保顺序消费\",{\"1\":{\"1203\":1}}],[\"确保没人有被炽热弹雨\",{\"1\":{\"464\":1}}],[\"确保在黑暗之拥的时候打断所有的灵魂之箭\",{\"1\":{\"451\":1}}],[\"确保不要被击退到黑水中\",{\"1\":{\"433\":1}}],[\"确保当其他关卡都失败时表达式的最后部分会被执行\",{\"1\":{\"188\":1}}],[\"确保当前目录是work目录\",{\"1\":{\"21\":1}}],[\"确保新注册的\",{\"1\":{\"124\":1}}],[\"决定\",{\"1\":{\"1510\":1}}],[\"决定是否要上传消息\",{\"1\":{\"1388\":1}}],[\"决定了在服务端对消息进行排序是完全不可接受的\",{\"1\":{\"925\":1}}],[\"纯异步上传\",{\"1\":{\"1388\":1}}],[\"纯采用第二层过滤\",{\"1\":{\"1325\":1}}],[\"层\",{\"1\":{\"1387\":1}}],[\"层面的封装让用户感觉像是\",{\"1\":{\"1094\":1}}],[\"讲解见\",{\"1\":{\"1386\":1}}],[\"讲起\",{\"1\":{\"1300\":1}}],[\"人力\",{\"1\":{\"1385\":1}}],[\"热数据的存储成本可以显著减小\",{\"1\":{\"1385\":1}}],[\"热数据使用本地块存储先顺序写\",{\"1\":{\"1385\":1}}],[\"热更新一下就行\",{\"1\":{\"273\":1}}],[\"禁用分级存储\",{\"1\":{\"1382\":1,\"1390\":1,\"1405\":1}}],[\"化的\",{\"1\":{\"1378\":1}}],[\"化生台\",{\"1\":{\"479\":5}}],[\"众多云厂商也希望提供\",{\"1\":{\"1378\":1}}],[\"需求\",{\"0\":{\"1378\":1}}],[\"需要发送\",{\"1\":{\"1520\":1}}],[\"需要发送的事务消息\",{\"1\":{\"1458\":1}}],[\"需要截断的日志序号\",{\"1\":{\"1519\":1}}],[\"需要开始截断的日志序号\",{\"1\":{\"1519\":2}}],[\"需要开启配置项才会存储扩展属性\",{\"1\":{\"1318\":1}}],[\"需要定时向\",{\"1\":{\"1510\":1}}],[\"需要定义哪些方法\",{\"1\":{\"1117\":1}}],[\"需要与\",{\"1\":{\"1510\":1}}],[\"需要放入的偏移量\",{\"1\":{\"1509\":1}}],[\"需要放在\",{\"1\":{\"983\":1}}],[\"需要加锁以保证线程安全\",{\"1\":{\"1500\":1}}],[\"需要更新消费偏移量并且重新存储\",{\"1\":{\"1468\":1}}],[\"需要回查\",{\"1\":{\"1468\":1}}],[\"需要移除\",{\"1\":{\"1468\":1}}],[\"需要执行事务状态检查\",{\"1\":{\"1442\":1}}],[\"需要解决\",{\"1\":{\"1378\":1}}],[\"需要解决的本质问题\",{\"0\":{\"278\":1}}],[\"需要引入新的存储文件\",{\"1\":{\"1347\":1}}],[\"需要建立这样的一个索引结构\",{\"1\":{\"1346\":1}}],[\"需要进一步匹配\",{\"1\":{\"1314\":1}}],[\"需要进行\",{\"1\":{\"1510\":1}}],[\"需要进行修改\",{\"1\":{\"1075\":1}}],[\"需要进行访问控制的对象\",{\"1\":{\"978\":1}}],[\"需要进行数据的同步或者恢复\",{\"1\":{\"693\":1}}],[\"需要设置如下配置\",{\"1\":{\"1308\":1}}],[\"需要设置\",{\"1\":{\"1308\":1}}],[\"需要显式指定拉取或订阅的队列信息才可以\",{\"1\":{\"1293\":1}}],[\"需要针对每个\",{\"1\":{\"1263\":1}}],[\"需要被移除\",{\"1\":{\"1468\":1}}],[\"需要被唤醒时做检查\",{\"1\":{\"1253\":1}}],[\"需要被用于其他目的\",{\"1\":{\"714\":1}}],[\"需要等待第一个消息先投递\",{\"1\":{\"1342\":1}}],[\"需要等待下一次重平衡时再尝试解锁\",{\"1\":{\"1225\":1}}],[\"需要等待一会然后重新投递\",{\"1\":{\"857\":1}}],[\"需要锁定的队列\",{\"1\":{\"1222\":1}}],[\"需要保证一个队列最多仅被一个线程消费\",{\"1\":{\"1207\":1}}],[\"需要保存消费进度\",{\"1\":{\"1103\":1}}],[\"需要重新选举\",{\"1\":{\"1489\":1,\"1500\":2}}],[\"需要重新加载分级存储文件句柄到内存\",{\"1\":{\"1395\":1}}],[\"需要重新启动\",{\"1\":{\"678\":1}}],[\"需要重试\",{\"1\":{\"1195\":1,\"1278\":1}}],[\"需要修改\",{\"1\":{\"1081\":1}}],[\"需要同时改动\",{\"1\":{\"1080\":1}}],[\"需要安装完成\",{\"1\":{\"1070\":1}}],[\"需要把消息发回去\",{\"1\":{\"1048\":1}}],[\"需要把整个函数定义括起来\",{\"1\":{\"330\":1}}],[\"需要从中选择一个队列进行发送\",{\"1\":{\"1041\":1}}],[\"需要处理客户端发送来的生产请求\",{\"1\":{\"1024\":1}}],[\"需要提交申请由运维团队审批\",{\"1\":{\"978\":1}}],[\"需要流控\",{\"1\":{\"933\":1}}],[\"需要的格子数太多怎么办\",{\"1\":{\"931\":1}}],[\"需要的数值\",{\"1\":{\"421\":1}}],[\"需要投递的消息都查出来放到时间轮里面\",{\"1\":{\"931\":1}}],[\"需要触发的所有任务\",{\"1\":{\"931\":1}}],[\"需要新增两种存储\",{\"1\":{\"929\":1}}],[\"需要实际压测\",{\"1\":{\"917\":1}}],[\"需要先引入消费组的概念\",{\"1\":{\"1088\":1}}],[\"需要先修改\",{\"1\":{\"1077\":1}}],[\"需要先初始化它的\",{\"1\":{\"897\":1}}],[\"需要先开启一致性哈希交换器插件\",{\"1\":{\"710\":1}}],[\"需要注意\",{\"1\":{\"866\":1}}],[\"需要注意的是value也是一个map类型\",{\"1\":{\"997\":1}}],[\"需要注意的是\",{\"1\":{\"833\":1,\"1102\":1,\"1300\":1}}],[\"需要注意的技能\",{\"1\":{\"475\":1}}],[\"需要将每个逻辑判断内容放入括号内\",{\"1\":{\"1308\":1}}],[\"需要将生产者分别注册到多个\",{\"1\":{\"1235\":1}}],[\"需要将\",{\"1\":{\"1075\":1}}],[\"需要将异步投递的任务放入处理队列\",{\"1\":{\"855\":1}}],[\"需要将消息同步给所有的\",{\"1\":{\"668\":1}}],[\"需要做流控\",{\"1\":{\"854\":1}}],[\"需要唤醒挂起的拉取请求\",{\"1\":{\"812\":1}}],[\"需要刷盘的索引文件\",{\"1\":{\"796\":1}}],[\"需要刷盘的数据超过getflushconsumequeueleastpages\",{\"1\":{\"758\":1}}],[\"需要有对应的规划和措施\",{\"1\":{\"702\":1}}],[\"需要有爆发\",{\"1\":{\"469\":1}}],[\"需要超过半数的队列副本都将消息写入磁盘以后才会向生产者进行确认\",{\"1\":{\"695\":1}}],[\"需要超过半数的副本同意\",{\"1\":{\"695\":1}}],[\"需要判断是否为undefined才能使用\",{\"1\":{\"551\":1}}],[\"需要在创建\",{\"1\":{\"1441\":1}}],[\"需要在一瞬间投递\",{\"1\":{\"1344\":1}}],[\"需要在\",{\"1\":{\"644\":1,\"1382\":1}}],[\"需要在两个集群都开启\",{\"1\":{\"630\":1}}],[\"需要在声明函数时\",{\"1\":{\"533\":1}}],[\"需要在pom\",{\"1\":{\"64\":1}}],[\"需要精确规划使用时机\",{\"1\":{\"482\":1}}],[\"需要组一个\",{\"1\":{\"433\":1}}],[\"需要特别注意的技能\",{\"1\":{\"428\":1}}],[\"需要打断的重要技能\",{\"1\":{\"475\":1}}],[\"需要打断\",{\"1\":{\"428\":1}}],[\"需要\",{\"1\":{\"411\":1}}],[\"需要根据\",{\"1\":{\"391\":1}}],[\"需要接入调度中心的应用依赖该\",{\"1\":{\"372\":1}}],[\"需要一些\",{\"1\":{\"253\":1}}],[\"需要一个类来管理\",{\"1\":{\"133\":1}}],[\"需要用\",{\"1\":{\"156\":1}}],[\"需要模拟依赖类的行为\",{\"1\":{\"81\":1}}],[\"需要管理员权限\",{\"1\":{\"68\":1}}],[\"需要声明\",{\"1\":{\"64\":1}}],[\"需要检查返回的inputstream是否为null\",{\"1\":{\"56\":1}}],[\"需要手动调用flush\",{\"1\":{\"54\":1}}],[\"求处理成功\",{\"1\":{\"1373\":1}}],[\"较大\",{\"1\":{\"1364\":1}}],[\"较大的消息会保存在消息存储中\",{\"1\":{\"687\":1}}],[\"暂停\",{\"1\":{\"1519\":1}}],[\"暂不处理\",{\"1\":{\"1446\":1}}],[\"暂存到消息属性中\",{\"1\":{\"1354\":1}}],[\"暂时没有为空\",{\"1\":{\"1352\":1}}],[\"暂时为\",{\"1\":{\"1352\":1}}],[\"备注\",{\"1\":{\"1352\":1}}],[\"呈链表结构\",{\"1\":{\"1346\":1}}],[\"亿条消息\",{\"1\":{\"1344\":1}}],[\"永远无法投递\",{\"1\":{\"1343\":1}}],[\"许多公司不满足于它的能力\",{\"1\":{\"1338\":1}}],[\"许多模块需要共享通用的记录定义\",{\"1\":{\"211\":1}}],[\"布隆过滤器的优点是它的空间占用率非常小\",{\"1\":{\"1322\":1}}],[\"布隆过滤器\",{\"0\":{\"1322\":1}}],[\"布隆过滤器可以用来判断某个元素是否可能存在于集合中\",{\"1\":{\"1315\":1}}],[\"布尔表达式\",{\"0\":{\"206\":1}}],[\"布尔值\",{\"0\":{\"206\":1},\"1\":{\"294\":1,\"606\":2}}],[\"低水位\",{\"1\":{\"1403\":1}}],[\"低水位线通过\",{\"1\":{\"1300\":1}}],[\"低于\",{\"1\":{\"922\":1}}],[\"父\",{\"1\":{\"1293\":1}}],[\"父类使用注解子类是否也默认定义\",{\"1\":{\"43\":1}}],[\"占用磁盘空间\",{\"1\":{\"1347\":1}}],[\"占用总\",{\"1\":{\"1325\":1}}],[\"占用大量磁盘存储空间和内存\",{\"1\":{\"1290\":1}}],[\"占用较大快的\",{\"1\":{\"914\":1}}],[\"场景下\",{\"1\":{\"1290\":1}}],[\"场景下树奶伤害不比猫奶低\",{\"1\":{\"401\":1}}],[\"轻量级队列分发准备\",{\"1\":{\"1296\":1}}],[\"轻量级队列\",{\"0\":{\"1282\":1},\"1\":{\"1538\":1}}],[\"距离上一次异常检查不到\",{\"1\":{\"1520\":1}}],[\"距离上次发送心跳超过\",{\"1\":{\"1496\":1}}],[\"距离上次收到心跳是否超过\",{\"1\":{\"1495\":1}}],[\"距离上次提交达到一定时间\",{\"1\":{\"1388\":1}}],[\"距离\",{\"1\":{\"1277\":1}}],[\"距离下次可重试\",{\"1\":{\"1275\":1}}],[\"供用户自行配置\",{\"1\":{\"1390\":1}}],[\"供\",{\"1\":{\"1263\":1}}],[\"供广大学生选择与参与\",{\"1\":{\"286\":1}}],[\"隔离\",{\"1\":{\"1263\":1}}],[\"隔离模式即单独选一个\",{\"1\":{\"1012\":1}}],[\"隔离模式\",{\"1\":{\"1004\":1,\"1012\":1}}],[\"入口是\",{\"1\":{\"1260\":1,\"1414\":1,\"1420\":2}}],[\"入门\",{\"0\":{\"78\":1}}],[\"迟迟无法被消费\",{\"1\":{\"1249\":1}}],[\"住导致队列消息堆积\",{\"1\":{\"1250\":1}}],[\"住\",{\"1\":{\"1249\":1}}],[\"住时其负载的队列可能会堆积的问题\",{\"1\":{\"1131\":1}}],[\"住时该队列的消息会堆积\",{\"1\":{\"1095\":1}}],[\"周期\",{\"1\":{\"1215\":1}}],[\"周期性启动定时任务\",{\"0\":{\"932\":1}}],[\"边界条件\",{\"0\":{\"1215\":1}}],[\"边搜索边高亮\",{\"1\":{\"143\":1}}],[\"似乎是一个可以优化的点\",{\"1\":{\"1207\":1}}],[\"然而为了能够实现顺序的消费\",{\"1\":{\"1203\":1}}],[\"然后立即向\",{\"1\":{\"1519\":1}}],[\"然后从\",{\"1\":{\"1519\":1}}],[\"然后由\",{\"1\":{\"1508\":1}}],[\"然后等待响应并仲裁结果\",{\"1\":{\"1485\":1}}],[\"然后等消息真正发送到\",{\"1\":{\"1039\":1}}],[\"然后推给\",{\"1\":{\"1481\":1}}],[\"然后推消费者和拉消费者接口分别扩展消费者接口\",{\"1\":{\"1116\":1}}],[\"然后向其他节点发起拉票请求\",{\"1\":{\"1480\":1}}],[\"然后向空对象添加属性\",{\"1\":{\"556\":1}}],[\"然后上报给\",{\"1\":{\"1451\":1}}],[\"然后生产者执行本地事务\",{\"1\":{\"1446\":1}}],[\"然后生产者可以重试之前阻塞的时候生产失败的消息\",{\"1\":{\"693\":1}}],[\"然后需要实现\",{\"1\":{\"1442\":1}}],[\"然后需要在奶一下呕吐点名对象\",{\"1\":{\"457\":1}}],[\"然后来看走预读缓存的场景\",{\"1\":{\"1409\":1}}],[\"然后释放\",{\"1\":{\"1403\":1}}],[\"然后分发到分级存储\",{\"1\":{\"1400\":1}}],[\"然后分析基于信用证的流控机制\",{\"1\":{\"621\":1}}],[\"然后如果配置了插件存储\",{\"1\":{\"1398\":1}}],[\"然后返回\",{\"1\":{\"1391\":1}}],[\"然后放入\",{\"1\":{\"1373\":1}}],[\"然后放治疗技能直接变回来\",{\"1\":{\"492\":1}}],[\"然后周期性扫描这个\",{\"1\":{\"1342\":1}}],[\"然后周期性调用\",{\"1\":{\"812\":1}}],[\"然后就可以在第一层过滤时初筛掉大部分无需消费这条消息的消费组\",{\"1\":{\"1325\":1}}],[\"然后就能生成能够解析该语法的扫描器和解析器的代码\",{\"1\":{\"1321\":1}}],[\"然后到达操作系统的底层的\",{\"1\":{\"1300\":1}}],[\"然后到打\",{\"1\":{\"399\":1}}],[\"然后下降到低水位线以下\",{\"1\":{\"1299\":1}}],[\"然后查询\",{\"1\":{\"1294\":1}}],[\"然后这个消息定时到\",{\"1\":{\"1259\":1}}],[\"然后这条消息会延迟相应的时间发送\",{\"1\":{\"833\":1}}],[\"然后定时持久化到磁盘\",{\"1\":{\"1190\":1}}],[\"然后复原\",{\"1\":{\"1188\":1}}],[\"然后复制到镜像\",{\"1\":{\"660\":1}}],[\"然后并发消费和顺序消费分别实现该接口\",{\"1\":{\"1187\":1}}],[\"然后重新放入队列\",{\"1\":{\"1158\":1}}],[\"然后重新投递到\",{\"1\":{\"836\":1}}],[\"然后重新投递\",{\"1\":{\"834\":1}}],[\"然后提交给消息消费服务处理\",{\"1\":{\"1152\":1}}],[\"然后提供心跳检测机制\",{\"1\":{\"941\":1}}],[\"然后指定消费回调函数\",{\"1\":{\"1117\":1}}],[\"然后创建一个\",{\"1\":{\"1112\":1,\"1443\":1}}],[\"然后调用本地存储的\",{\"1\":{\"1421\":1}}],[\"然后调用并发消费服务\",{\"1\":{\"1188\":1}}],[\"然后调用\",{\"1\":{\"1104\":1,\"1136\":1,\"1188\":1,\"1263\":1,\"1324\":1,\"1410\":1,\"1421\":1,\"1509\":1}}],[\"然后给顺序消费服务提交顺序消费任务\",{\"1\":{\"1219\":1}}],[\"然后给第二个\",{\"1\":{\"1097\":1}}],[\"然后给自己刷爆\",{\"1\":{\"433\":1}}],[\"然后启动成功\",{\"1\":{\"1079\":1}}],[\"然后访问\",{\"1\":{\"1078\":1}}],[\"然后运行\",{\"1\":{\"1077\":1,\"1081\":1}}],[\"然后构建镜像包\",{\"1\":{\"1072\":1}}],[\"然后选择一个队列进行发送\",{\"1\":{\"1029\":1}}],[\"然后发送\",{\"1\":{\"1020\":1,\"1519\":1}}],[\"然后发送请求给\",{\"1\":{\"1190\":1}}],[\"然后发送请求\",{\"1\":{\"989\":1}}],[\"然后进行签名\",{\"1\":{\"989\":1,\"995\":1}}],[\"然后进行分发处理\",{\"1\":{\"119\":1}}],[\"然后注册到客户端中\",{\"1\":{\"984\":1}}],[\"然后依次运行\",{\"1\":{\"1403\":1}}],[\"然后依次写入\",{\"1\":{\"953\":1}}],[\"然后依靠\",{\"1\":{\"930\":1}}],[\"然后初始化\",{\"1\":{\"947\":2,\"960\":1,\"961\":1}}],[\"然后站在开源\",{\"1\":{\"936\":1}}],[\"然后保存到消费队列索引的扩展存储中\",{\"1\":{\"1323\":1}}],[\"然后保存到\",{\"1\":{\"930\":1}}],[\"然后通过位置信息从消息存储文件\",{\"1\":{\"927\":1}}],[\"然后通过异步的方式由\",{\"1\":{\"879\":1}}],[\"然后的实现十分简单粗暴\",{\"1\":{\"925\":1}}],[\"然后设置这条消息延迟\",{\"1\":{\"920\":1}}],[\"然后可以启动\",{\"1\":{\"1075\":1}}],[\"然后可以使用\",{\"1\":{\"900\":1}}],[\"然后可以将\",{\"1\":{\"726\":1}}],[\"然后优化该方法\",{\"1\":{\"897\":1}}],[\"然后观察其火焰图中方法的时间占用百分比\",{\"1\":{\"887\":1}}],[\"然后异步写入\",{\"1\":{\"883\":1}}],[\"然后应用程序再从\",{\"1\":{\"879\":1}}],[\"然后遍历它们\",{\"1\":{\"1453\":1}}],[\"然后遍历它们处理\",{\"1\":{\"118\":1}}],[\"然后遍历这些队列\",{\"1\":{\"1453\":1}}],[\"然后遍历这些文件读取权限数据和全局白名单\",{\"1\":{\"998\":1}}],[\"然后遍历老索引文件\",{\"1\":{\"1394\":1}}],[\"然后遍历每个\",{\"1\":{\"871\":1}}],[\"然后关闭\",{\"1\":{\"870\":1}}],[\"然后移除\",{\"1\":{\"858\":1,\"1225\":1}}],[\"然后移除即可\",{\"1\":{\"394\":1}}],[\"然后投递\",{\"1\":{\"857\":1}}],[\"然后更新到本地路由表缓存\",{\"1\":{\"1039\":1}}],[\"然后更新\",{\"1\":{\"793\":1}}],[\"然后用请求中的\",{\"1\":{\"1511\":1}}],[\"然后用消费队列数据查询消息数据\",{\"1\":{\"1391\":1}}],[\"然后用订阅信息构造一个\",{\"1\":{\"1318\":1}}],[\"然后用\",{\"1\":{\"1070\":1}}],[\"然后用位图匹配的方式替换正则匹配\",{\"1\":{\"904\":1}}],[\"然后用偏移量从\",{\"1\":{\"782\":1}}],[\"然后用于回放\",{\"1\":{\"159\":1}}],[\"然后转发和构建\",{\"1\":{\"761\":1}}],[\"然后使用offset从consumequeue中获取相应位置的索引信息\",{\"1\":{\"757\":1}}],[\"然后根据响应的节点数量进行结果仲裁\",{\"1\":{\"1499\":1}}],[\"然后根据其从本地存储中查询消息\",{\"1\":{\"1427\":1}}],[\"然后根据消费索引从\",{\"1\":{\"1318\":1}}],[\"然后根据\",{\"1\":{\"845\":1,\"1492\":1}}],[\"然后根据这条请求传入的offset消费队列偏移量\",{\"1\":{\"757\":1,\"766\":1}}],[\"然后根据位置获取\",{\"1\":{\"751\":1}}],[\"然后根据节点数取模\",{\"1\":{\"385\":1,\"386\":1}}],[\"然后为没有加锁的队列新建\",{\"1\":{\"1214\":1}}],[\"然后为生产消息和消费消息的协议单独实现解码方法\",{\"1\":{\"891\":1}}],[\"然后为\",{\"1\":{\"741\":1}}],[\"然后把当前节点的状态\",{\"1\":{\"1491\":1}}],[\"然后把这些属性封装放入消息属性中\",{\"1\":{\"1294\":1}}],[\"然后把重平衡结果返回给客户端\",{\"1\":{\"1255\":1}}],[\"然后把预编码的数据放到\",{\"1\":{\"737\":1}}],[\"然后把读到的\",{\"1\":{\"729\":1}}],[\"然后被路由到环上位置等于或顺时针最接近的队列\",{\"1\":{\"716\":1}}],[\"然后在第二层过滤时将通过第一层过滤的消息信息进行\",{\"1\":{\"1315\":1}}],[\"然后在\",{\"1\":{\"711\":1}}],[\"然后我们创建\",{\"1\":{\"711\":1}}],[\"然后恢复上线之后\",{\"1\":{\"693\":1}}],[\"然后才处于上面的某种状态\",{\"1\":{\"690\":1}}],[\"然后消费者就有责任重新发行基本版\",{\"1\":{\"665\":1}}],[\"然后变熊吃尖刺\",{\"1\":{\"434\":1}}],[\"然后不停愈合\",{\"1\":{\"411\":1}}],[\"然后写小作文不断申请进本练习\",{\"1\":{\"399\":1}}],[\"然后越打越有信心很快就把\",{\"1\":{\"399\":1}}],[\"然后看各个博主的攻略视频研究手法\",{\"1\":{\"399\":1}}],[\"然后愈合打几下地鼠\",{\"1\":{\"399\":1}}],[\"然后对槽位总数\",{\"1\":{\"1367\":1}}],[\"然后对于超过\",{\"1\":{\"1042\":1}}],[\"然后对其进行压测\",{\"1\":{\"887\":1}}],[\"然后对这些请求调用\",{\"1\":{\"814\":1}}],[\"然后对错误进行处理\",{\"1\":{\"193\":1}}],[\"然后对它做一些操作\",{\"1\":{\"177\":1}}],[\"然后再读取文件句柄的元数据\",{\"1\":{\"1395\":1}}],[\"然后再经过\",{\"1\":{\"1300\":1}}],[\"然后再磁盘中匹配\",{\"1\":{\"1261\":1}}],[\"然后再重试查询\",{\"1\":{\"804\":1}}],[\"然后再从消息存储中查询具体的消息\",{\"1\":{\"687\":1}}],[\"然后再从该位置添加若干元素\",{\"1\":{\"298\":1}}],[\"然后再进一步处理\",{\"1\":{\"515\":1}}],[\"然后再添加两个元素\",{\"1\":{\"298\":1}}],[\"然后再按照键的排序比较键和值\",{\"1\":{\"192\":1}}],[\"然后再执行测试\",{\"1\":{\"4\":1}}],[\"然后舍去余数\",{\"1\":{\"174\":1}}],[\"然后将执行结果发回\",{\"1\":{\"1454\":1}}],[\"然后将执行异步上传操作\",{\"1\":{\"1403\":1}}],[\"然后将其作为回查请求体发送给生产者\",{\"1\":{\"1453\":1}}],[\"然后将读到的消息放入缓存\",{\"1\":{\"1409\":1}}],[\"然后将该消息发送到\",{\"1\":{\"1263\":1}}],[\"然后将处理队列整个放入消费任务\",{\"1\":{\"1217\":1}}],[\"然后将结果返回给消费者\",{\"1\":{\"825\":1}}],[\"然后将结果与左侧\",{\"1\":{\"173\":1}}],[\"然后将消息的\",{\"1\":{\"1463\":1}}],[\"然后将消息真正的\",{\"1\":{\"834\":1,\"839\":1,\"843\":1}}],[\"然后将消息投递到queue\",{\"1\":{\"668\":1}}],[\"然后将消息处理完后发给\",{\"1\":{\"621\":1}}],[\"然后将\",{\"1\":{\"387\":1,\"971\":1,\"1359\":1,\"1403\":1,\"1446\":1}}],[\"然后将接口方法\",{\"1\":{\"41\":1}}],[\"然后处理消费结果\",{\"1\":{\"1179\":1}}],[\"然后处理\",{\"1\":{\"124\":1}}],[\"然后执行本地事务\",{\"1\":{\"1449\":1}}],[\"然后执行默认的compiler\",{\"1\":{\"64\":1}}],[\"然后执行default生命周期并运行到package这个phase\",{\"1\":{\"62\":1}}],[\"然后\",{\"1\":{\"21\":1,\"368\":1,\"369\":1,\"411\":1,\"438\":1,\"570\":1,\"665\":1,\"845\":1,\"941\":1,\"995\":1,\"1300\":1}}],[\"覆盖原来未上传的\",{\"1\":{\"1417\":1}}],[\"覆盖\",{\"1\":{\"1198\":1}}],[\"覆盖高靠性\",{\"1\":{\"278\":1}}],[\"顾名思义\",{\"1\":{\"1179\":1}}],[\"步骤由\",{\"1\":{\"1323\":1}}],[\"步会将生成的\",{\"1\":{\"1258\":1}}],[\"步\",{\"1\":{\"1149\":1,\"1507\":4}}],[\"环形寻论平均分配\",{\"1\":{\"1138\":1}}],[\"环境准备\",{\"0\":{\"1070\":1}}],[\"仿照\",{\"1\":{\"1136\":1}}],[\"封装了实现\",{\"1\":{\"1482\":1}}],[\"封装\",{\"1\":{\"1249\":1}}],[\"封装成\",{\"1\":{\"1355\":1,\"1370\":1,\"1417\":1}}],[\"封装成消费请求\",{\"1\":{\"1179\":1}}],[\"封装成一个\",{\"1\":{\"1021\":1}}],[\"封装成一个发送任务提交给消息发送线程池处理\",{\"1\":{\"1021\":1}}],[\"封装的服务线程\",{\"1\":{\"1168\":1}}],[\"封装后返回给客户端\",{\"1\":{\"1153\":1}}],[\"封装很原始的消费者\",{\"1\":{\"1136\":1}}],[\"域\",{\"0\":{\"1133\":1}}],[\"域名要相同\",{\"1\":{\"350\":1}}],[\"感知到新消费者启动\",{\"1\":{\"1128\":1}}],[\"感觉和指令的串行执行和并行执行有点类似\",{\"1\":{\"116\":1}}],[\"着重讲解\",{\"1\":{\"1119\":1}}],[\"着重体现了长轮询逻辑\",{\"1\":{\"812\":1}}],[\"贝贝猫\",{\"1\":{\"1105\":1}}],[\"赵坤\",{\"1\":{\"1105\":1,\"1334\":1}}],[\"癫狂侠\",{\"1\":{\"1105\":1}}],[\"丁威\",{\"1\":{\"1105\":1,\"1334\":1,\"1473\":1,\"1527\":1}}],[\"批默认为\",{\"1\":{\"1104\":1}}],[\"批消息\",{\"1\":{\"1104\":1,\"1187\":1}}],[\"批量\",{\"1\":{\"1516\":1}}],[\"批量锁定消息队列\",{\"1\":{\"1222\":1}}],[\"批量消息\",{\"0\":{\"1044\":1},\"1\":{\"1025\":1,\"1028\":1,\"1044\":1}}],[\"批量从等待处理的消息轨迹队列中获取数据\",{\"1\":{\"1021\":1}}],[\"批量从待处理消息轨迹队列中取数据\",{\"1\":{\"1021\":1}}],[\"批量发送机制是为了提高效率\",{\"1\":{\"1021\":1}}],[\"批量拉任务进行通知\",{\"1\":{\"916\":1}}],[\"批量进行处理\",{\"1\":{\"915\":1}}],[\"红色的\",{\"1\":{\"1511\":1}}],[\"红色的可以去掉\",{\"1\":{\"403\":1}}],[\"红黑树保存消息的顺序\",{\"1\":{\"1104\":1}}],[\"级别配置\",{\"1\":{\"1128\":1}}],[\"级别的顺序消费\",{\"1\":{\"1102\":1}}],[\"级别的顺序消费的\",{\"1\":{\"1102\":1}}],[\"级别顺序消息\",{\"1\":{\"1028\":1}}],[\"挂掉或者消费者挂掉时\",{\"1\":{\"1101\":1}}],[\"挂起时间超时\",{\"1\":{\"1520\":1}}],[\"挂起时间未超时\",{\"1\":{\"1520\":1}}],[\"挂起最大时间\",{\"1\":{\"1171\":1}}],[\"挂起\",{\"1\":{\"822\":1}}],[\"挂起的时间戳\",{\"1\":{\"1519\":1}}],[\"挂起的\",{\"1\":{\"1519\":2}}],[\"挂起的推送请求数量如果超过\",{\"1\":{\"1510\":1}}],[\"挂起的最长时间\",{\"1\":{\"812\":1}}],[\"挂起的拉取请求会在这里进行保存\",{\"1\":{\"810\":1}}],[\"掉线等情况发生后\",{\"1\":{\"1098\":1}}],[\"富客户端\",{\"1\":{\"1095\":1}}],[\"登录访问\",{\"1\":{\"1077\":1}}],[\"⠿\",{\"1\":{\"1075\":4}}],[\"宿主机ip\",{\"1\":{\"1075\":3}}],[\"仓库\",{\"1\":{\"1070\":1}}],[\"走\",{\"1\":{\"1061\":2}}],[\"走原有\",{\"1\":{\"1061\":2}}],[\"走到文件末尾\",{\"1\":{\"771\":1}}],[\"待追加日志序号等于\",{\"1\":{\"1520\":1}}],[\"待追加日志序号小于等于\",{\"1\":{\"1520\":1}}],[\"待\",{\"1\":{\"1511\":3,\"1520\":3}}],[\"待收到\",{\"1\":{\"1488\":1,\"1491\":1,\"1497\":1}}],[\"待压缩文件\",{\"1\":{\"1435\":1}}],[\"待发送消息\",{\"1\":{\"1053\":1}}],[\"待拉取的\",{\"1\":{\"1169\":1}}],[\"待拉取的消费队列\",{\"1\":{\"1169\":1}}],[\"待拉取偏移量等于队列最大偏移量\",{\"1\":{\"819\":1}}],[\"待拉取消息的偏移量是否小于消费队列最大偏移量\",{\"1\":{\"815\":1}}],[\"汇报心跳给broker\",{\"1\":{\"1048\":1}}],[\"视\",{\"1\":{\"1028\":1}}],[\"视为两种不一样的类型\",{\"1\":{\"524\":1}}],[\"揭秘\",{\"1\":{\"1024\":1}}],[\"丢失\",{\"1\":{\"1520\":1}}],[\"丢失提交的日志\",{\"1\":{\"1520\":1}}],[\"丢失的任务会被tasktracker重新分发到可用的worker去\",{\"1\":{\"375\":1}}],[\"丢弃该请求\",{\"1\":{\"1519\":1}}],[\"丢弃该消费队列\",{\"1\":{\"1175\":1}}],[\"丢弃或跳过\",{\"1\":{\"1468\":1}}],[\"丢弃半消息\",{\"1\":{\"1446\":1}}],[\"丢弃的队列则向\",{\"1\":{\"1209\":1}}],[\"丢弃的消息个数\",{\"1\":{\"1021\":1}}],[\"丢弃老的处理队列\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"丢弃不再消费的队列\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"轨迹类型\",{\"1\":{\"1017\":1}}],[\"轨迹数据发送\",{\"0\":{\"1015\":1}}],[\"轨迹数据采集\",{\"0\":{\"1014\":1}}],[\"势必要对消息的写入作进一步优化\",{\"1\":{\"1363\":1}}],[\"势必使用异步发送\",{\"1\":{\"1010\":1}}],[\"势必会对性能造成非常大的损耗\",{\"1\":{\"1003\":1}}],[\"势必会用到类似定时任务地机制\",{\"1\":{\"924\":1}}],[\"采集消费完成的消息轨迹数据\",{\"1\":{\"1020\":1}}],[\"采集消息轨迹数据的最佳方法就是在发送和消费时在钩子函数中进行\",{\"1\":{\"1014\":1}}],[\"采集每条消息的轨迹数据\",{\"1\":{\"1020\":1}}],[\"采集数据并将该上下文信息交给轨迹数据异步发送线程池\",{\"1\":{\"1014\":1}}],[\"采集的轨迹数据要包含哪些数据\",{\"1\":{\"1010\":1}}],[\"采用链表的形式处理冲突\",{\"1\":{\"1393\":1}}],[\"采用时间轮的好处在于它可以循环使用\",{\"1\":{\"1351\":1}}],[\"采用时间轮的好处是它可以复用\",{\"1\":{\"1346\":1}}],[\"采用布隆过滤器确实可以减少消息拉取时过滤的耗时\",{\"1\":{\"1325\":1}}],[\"采用\",{\"1\":{\"668\":1}}],[\"采用回车符\",{\"1\":{\"288\":1}}],[\"采用回车+换行\",{\"1\":{\"288\":1}}],[\"采用换行符\",{\"1\":{\"288\":1}}],[\"采用了内部缓冲区的机制\",{\"1\":{\"54\":1}}],[\"互相之间几乎不影响\",{\"1\":{\"1338\":1}}],[\"互相解析的性能\",{\"0\":{\"741\":1}}],[\"互不影响\",{\"1\":{\"1004\":1}}],[\"扯皮\",{\"1\":{\"1003\":1}}],[\"官网文档\",{\"1\":{\"1001\":1}}],[\"官方提供了多语言客户端支持消息的发送和消费操作\",{\"1\":{\"1024\":1}}],[\"官方将消息轨迹存储的模式分为两种\",{\"1\":{\"1012\":1}}],[\"官方文档\",{\"1\":{\"884\":1,\"974\":1,\"1022\":1,\"1057\":1,\"1102\":1,\"1105\":1,\"1298\":1,\"1334\":1,\"1473\":1,\"1537\":1}}],[\"官方没有做运行环境\",{\"1\":{\"497\":1}}],[\"官方推荐的使用方法是使用\",{\"1\":{\"7\":1}}],[\"官方介绍如下\",{\"1\":{\"2\":1}}],[\"刷新全局配置\",{\"1\":{\"998\":1}}],[\"刷盘线程会将该文件刷盘\",{\"1\":{\"793\":1}}],[\"刷盘机制\",{\"0\":{\"783\":1}}],[\"刷盘\",{\"0\":{\"752\":1,\"758\":1,\"768\":1,\"796\":1,\"1533\":1},\"1\":{\"789\":1,\"1427\":1}}],[\"远程\",{\"1\":{\"997\":1}}],[\"验证当前状态下是否可以发送\",{\"1\":{\"1519\":1}}],[\"验证当前节点状态是否为转移中\",{\"1\":{\"1516\":1}}],[\"验证当前节点是否为\",{\"1\":{\"1516\":1}}],[\"验证请求集群是否为当前集群\",{\"1\":{\"1516\":1}}],[\"验证请求目的节点是否为当前节点\",{\"1\":{\"1516\":1}}],[\"验证请求合理性\",{\"1\":{\"1516\":1}}],[\"验证成功\",{\"1\":{\"1464\":1}}],[\"验证事务半消息的必要字段\",{\"1\":{\"1464\":1}}],[\"验证队列是否丢弃\",{\"1\":{\"1195\":1}}],[\"验证该消息队列是否可用\",{\"1\":{\"1052\":1}}],[\"验证消息是否符合规范\",{\"1\":{\"1050\":1}}],[\"验证合法性\",{\"1\":{\"1050\":1}}],[\"验证是否有某资源的访问权限\",{\"1\":{\"1000\":1}}],[\"验证资源访问权限\",{\"1\":{\"991\":1,\"1000\":1}}],[\"验证与客户端计算的签名是否一致\",{\"1\":{\"991\":1,\"1000\":1}}],[\"白云鹏\",{\"1\":{\"1105\":1}}],[\"白名单配置\",{\"1\":{\"998\":1}}],[\"白名单\",{\"1\":{\"978\":1,\"983\":1}}],[\"白白产生\",{\"1\":{\"741\":1}}],[\"白白空转\",{\"1\":{\"733\":1}}],[\"订阅\",{\"1\":{\"1290\":1,\"1293\":1}}],[\"订阅多个\",{\"1\":{\"1239\":1}}],[\"订阅配置不存在\",{\"1\":{\"1198\":1}}],[\"订阅信息查找消息\",{\"1\":{\"1173\":1}}],[\"订阅信息和重试\",{\"1\":{\"1120\":1,\"1122\":1}}],[\"订阅关系版本号\",{\"1\":{\"1171\":1}}],[\"订阅的主题\",{\"1\":{\"1117\":1}}],[\"订阅之后可以收到来自该主题的消息\",{\"1\":{\"1117\":1}}],[\"订阅主题\",{\"1\":{\"1117\":1}}],[\"订阅权限\",{\"1\":{\"978\":1}}],[\"订阅模型会造成更严重的写入放大\",{\"1\":{\"701\":1}}],[\"订阅模型下\",{\"1\":{\"700\":1}}],[\"拒绝并告知对方已有的\",{\"1\":{\"1503\":1}}],[\"拒绝拉票请求\",{\"1\":{\"1492\":1,\"1503\":1}}],[\"拒绝投票\",{\"1\":{\"1492\":1,\"1503\":3}}],[\"拒绝提交\",{\"1\":{\"1194\":2}}],[\"拒绝\",{\"1\":{\"978\":1,\"1497\":6,\"1503\":3}}],[\"密码\",{\"1\":{\"978\":1}}],[\"段进行白名单控制\",{\"1\":{\"976\":1}}],[\"软件\",{\"1\":{\"976\":1}}],[\"权限映射配置表\",{\"1\":{\"997\":1}}],[\"权限验证主要逻辑都在\",{\"1\":{\"1000\":1}}],[\"权限验证的逻辑在\",{\"1\":{\"991\":1}}],[\"权限验证\",{\"0\":{\"991\":1,\"1000\":1},\"1\":{\"986\":1}}],[\"权限\",{\"1\":{\"976\":1,\"978\":4,\"1198\":1}}],[\"权限控制\",{\"0\":{\"975\":1},\"1\":{\"1001\":2,\"1538\":1}}],[\"权重越高\",{\"1\":{\"711\":1}}],[\"初次请求时为空\",{\"1\":{\"970\":1}}],[\"初始状态是\",{\"1\":{\"1510\":1}}],[\"初始状态\",{\"1\":{\"1394\":1,\"1412\":1}}],[\"初始的延迟为\",{\"1\":{\"1180\":1}}],[\"初始延迟\",{\"1\":{\"869\":1}}],[\"初始化配置类\",{\"1\":{\"1523\":1}}],[\"初始化分级存储实现\",{\"0\":{\"1424\":1}}],[\"初始化分级存储消息数据文件时\",{\"1\":{\"1421\":1}}],[\"初始化分级存储时会将分级存储\",{\"1\":{\"1403\":1}}],[\"初始化消息消费服务\",{\"1\":{\"1120\":1,\"1122\":1}}],[\"初始化消费进度\",{\"1\":{\"1120\":1,\"1122\":1}}],[\"初始化消费者的重平衡实现\",{\"1\":{\"1120\":1}}],[\"初始化前\",{\"1\":{\"980\":1}}],[\"初始化线程池\",{\"1\":{\"961\":1}}],[\"初始化通信层\",{\"1\":{\"961\":1}}],[\"初始化的时候就设定长度呢\",{\"1\":{\"906\":1}}],[\"初始化hashedwheeltimerfuture对象并添加到waitingtasks队列\",{\"1\":{\"379\":1}}],[\"初始化执行线程池taskprocesspool\",{\"1\":{\"379\":1}}],[\"初始化执行器开始处理\",{\"1\":{\"372\":1}}],[\"初始化轮盘\",{\"1\":{\"379\":1}}],[\"初始化status为waiting\",{\"1\":{\"374\":1}}],[\"初始化新对象\",{\"1\":{\"339\":1}}],[\"初始化数据表\",{\"1\":{\"253\":1}}],[\"初始化时会创建\",{\"1\":{\"990\":1,\"996\":1}}],[\"初始化时会创建一个\",{\"1\":{\"834\":1}}],[\"初始化时\",{\"1\":{\"135\":1,\"1398\":1}}],[\"初始化为\",{\"1\":{\"125\":1}}],[\"初始化\",{\"0\":{\"89\":1,\"124\":1,\"980\":1,\"990\":1,\"996\":1},\"1\":{\"827\":1,\"947\":1,\"960\":7,\"980\":1,\"986\":1,\"990\":1,\"996\":2,\"1037\":1,\"1122\":1,\"1137\":1}}],[\"初始化方法\",{\"1\":{\"9\":1,\"961\":1}}],[\"钩子方法中采集消息轨迹数据\",{\"0\":{\"1020\":1}}],[\"钩子函数的\",{\"1\":{\"981\":1}}],[\"钩子函数\",{\"1\":{\"960\":1,\"1053\":1}}],[\"钩下来用一根矛\",{\"1\":{\"459\":1}}],[\"宕机重启后\",{\"1\":{\"1511\":1,\"1520\":1}}],[\"宕机\",{\"1\":{\"954\":1}}],[\"宕机了\",{\"1\":{\"941\":1}}],[\"心跳的时间戳\",{\"1\":{\"1500\":2}}],[\"心跳的信息就包含消费者的订阅信息\",{\"1\":{\"1312\":1}}],[\"心跳响应回调\",{\"1\":{\"1499\":1}}],[\"心跳超时\",{\"1\":{\"1477\":1}}],[\"心跳请求后变为\",{\"1\":{\"1497\":1}}],[\"心跳请求处理\",{\"0\":{\"1489\":1}}],[\"心跳请求发送\",{\"0\":{\"1488\":1}}],[\"心跳请求\",{\"0\":{\"1487\":1,\"1498\":1},\"1\":{\"1477\":1,\"1478\":1,\"1479\":1,\"1480\":2,\"1500\":1}}],[\"心跳信息\",{\"1\":{\"971\":1}}],[\"心跳包发送的响应列表\",{\"1\":{\"970\":1}}],[\"心跳包的请求头中包含\",{\"1\":{\"952\":1}}],[\"心跳上报\",{\"1\":{\"967\":1}}],[\"心能注入\",{\"1\":{\"454\":1}}],[\"均每\",{\"1\":{\"945\":1}}],[\"划分多个zookeeper集群来解决\",{\"1\":{\"942\":1}}],[\"版控制台不支持消息堆积查询\",{\"1\":{\"1090\":1}}],[\"版保证每条消息至少被每台客户端消费一次\",{\"1\":{\"1090\":1}}],[\"版任意时间定时消息特性\",{\"1\":{\"937\":1}}],[\"版本源码详解日志复制的设计和流程\",{\"1\":{\"1506\":1}}],[\"版本源码详解\",{\"1\":{\"1475\":1}}],[\"版本以前\",{\"1\":{\"1475\":2,\"1506\":2}}],[\"版本之后\",{\"1\":{\"1441\":1}}],[\"版本拉取\",{\"1\":{\"1073\":1}}],[\"版本正式引入了消息轨迹功能\",{\"1\":{\"1003\":1}}],[\"版本引入了\",{\"1\":{\"976\":1,\"1294\":1}}],[\"版本号\",{\"1\":{\"952\":1}}],[\"版本后被废弃\",{\"1\":{\"944\":1}}],[\"版本发布\",{\"1\":{\"889\":1,\"892\":1}}],[\"版本优化\",{\"0\":{\"849\":1},\"1\":{\"1338\":1,\"1538\":1}}],[\"版本中的性能优化\",{\"1\":{\"917\":1}}],[\"版本中的性能优化点\",{\"1\":{\"886\":1}}],[\"版本中被引进\",{\"1\":{\"902\":1}}],[\"版本中对延迟消息的优化已经在另一篇文章中详解\",{\"1\":{\"886\":1}}],[\"版本中\",{\"1\":{\"850\":1,\"1284\":1,\"1299\":1,\"1300\":1}}],[\"版本中新的\",{\"0\":{\"773\":1}}],[\"版本中最重要的改动那非仲裁队列\",{\"1\":{\"692\":1}}],[\"版本这个锁是\",{\"1\":{\"733\":1}}],[\"版本针对\",{\"1\":{\"720\":1}}],[\"版本问世之前\",{\"1\":{\"692\":1}}],[\"版本的启动脚本\",{\"1\":{\"1074\":1}}],[\"版本的优化后不仅支持高性能异步投递\",{\"1\":{\"932\":1}}],[\"版本的优化\",{\"1\":{\"925\":1}}],[\"版本的优化做了深入分析\",{\"1\":{\"886\":1}}],[\"版本的\",{\"1\":{\"645\":1}}],[\"版本的安装\",{\"1\":{\"641\":1}}],[\"版本依赖\",{\"1\":{\"642\":1}}],[\"版本开始支持分布式事务消息\",{\"1\":{\"1439\":1}}],[\"版本开始\",{\"1\":{\"614\":1,\"617\":1}}],[\"版本更新后又进行了更新\",{\"1\":{\"398\":1}}],[\"版本\",{\"0\":{\"25\":1,\"641\":1,\"885\":1},\"1\":{\"498\":1,\"642\":1,\"644\":1,\"645\":1,\"718\":1,\"886\":2,\"889\":1,\"892\":1,\"913\":1,\"1072\":1,\"1294\":1,\"1538\":1}}],[\"繁忙\",{\"1\":{\"931\":1}}],[\"箭头按顺时针方向以固定频率移动\",{\"1\":{\"931\":1}}],[\"箭头函数\",{\"0\":{\"331\":1,\"535\":1}}],[\"侵入小\",{\"1\":{\"928\":1}}],[\"侵蚀喷涌\",{\"1\":{\"447\":1}}],[\"易于管理\",{\"1\":{\"928\":1}}],[\"易失\",{\"1\":{\"247\":1}}],[\"日益增长的客户诉求促使我们探究任意时间定时消息的实现\",{\"1\":{\"925\":1}}],[\"日志不相交\",{\"1\":{\"1519\":1}}],[\"日志实现\",{\"1\":{\"1519\":1}}],[\"日志条目在\",{\"1\":{\"1520\":1}}],[\"日志条目\",{\"1\":{\"1517\":1,\"1519\":1}}],[\"日志序号的\",{\"1\":{\"1521\":1}}],[\"日志序号存在\",{\"1\":{\"1520\":1}}],[\"日志序号\",{\"1\":{\"1514\":2,\"1519\":3,\"1521\":1}}],[\"日志提交\",{\"1\":{\"1510\":1}}],[\"日志追加\",{\"1\":{\"1510\":1,\"1520\":1,\"1521\":1}}],[\"日志截断\",{\"1\":{\"1510\":1}}],[\"日志对比\",{\"1\":{\"1510\":1}}],[\"日志转发器投票轮次与状态机投票轮次不相等\",{\"1\":{\"1519\":1}}],[\"日志转发的流程由\",{\"1\":{\"1510\":1}}],[\"日志转发线程同时唤醒结果仲裁线程\",{\"1\":{\"1507\":1}}],[\"日志转发线程将消息转发到\",{\"1\":{\"1507\":1}}],[\"日志转发线程从上次转发的位置开始扫描\",{\"1\":{\"1507\":1}}],[\"日志存储\",{\"0\":{\"1509\":1,\"1515\":1}}],[\"日志存储类\",{\"1\":{\"1482\":1}}],[\"日志复制中用到的容易混淆的几个\",{\"1\":{\"1508\":1}}],[\"日志复制分成\",{\"1\":{\"1508\":1}}],[\"日志复制\",{\"0\":{\"1505\":1},\"1\":{\"1538\":1}}],[\"日志末尾序号\",{\"1\":{\"1517\":1}}],[\"日志末尾\",{\"1\":{\"1497\":1}}],[\"日志的打印可能会占用较多\",{\"1\":{\"722\":1}}],[\"日志\",{\"1\":{\"85\":1,\"1079\":1,\"1519\":1}}],[\"站在开源\",{\"1\":{\"925\":1}}],[\"站在巨人的肩膀上\",{\"0\":{\"925\":1}}],[\"站位\",{\"1\":{\"491\":1}}],[\"华为云已经上线分布式消息服务\",{\"1\":{\"937\":1}}],[\"华为云\",{\"0\":{\"937\":1},\"1\":{\"922\":1}}],[\"华为云中间件可靠性技术专家\",{\"1\":{\"286\":1}}],[\"华为云中间件消息产品家族也是唯一一个全面通过验收标准的厂商\",{\"1\":{\"286\":1}}],[\"腾讯云\",{\"1\":{\"922\":1}}],[\"腾出\",{\"1\":{\"492\":1}}],[\"×\",{\"1\":{\"922\":10,\"1508\":3}}],[\"刚进入\",{\"1\":{\"1480\":1}}],[\"刚初始化\",{\"1\":{\"1403\":1}}],[\"刚好能完全分配队列给所有消费者\",{\"1\":{\"1137\":1}}],[\"刚才发的延迟消息也不再需要被投递\",{\"1\":{\"921\":1,\"1337\":1}}],[\"刚开始玩的时候觉得和以前的\",{\"1\":{\"399\":1}}],[\"客户下单后并不会马上付款\",{\"1\":{\"921\":1,\"1337\":1}}],[\"客户端追加日志请求\",{\"1\":{\"1521\":1}}],[\"客户端向\",{\"1\":{\"1507\":1}}],[\"客户端实现\",{\"1\":{\"1440\":1}}],[\"客户端实例启动时的定时任务每\",{\"1\":{\"1183\":1}}],[\"客户端实例启动时会启动定时任务\",{\"1\":{\"1182\":1}}],[\"客户端实例中的所有推模式消费者共用这个拉取线程\",{\"1\":{\"1152\":1}}],[\"客户端实例中的重平衡服务进行重平衡\",{\"1\":{\"1119\":1}}],[\"客户端实例包含一个消息拉取线程\",{\"1\":{\"1152\":1}}],[\"客户端实例的该方法没有具体逻辑\",{\"1\":{\"1137\":1}}],[\"客户端实例持有\",{\"1\":{\"1129\":1}}],[\"客户端实例\",{\"1\":{\"1118\":1,\"1120\":1,\"1191\":1}}],[\"客户端过滤\",{\"0\":{\"1329\":1}}],[\"客户端之后\",{\"1\":{\"1307\":1}}],[\"客户端的重平衡服务重平衡时会向\",{\"1\":{\"1255\":1}}],[\"客户端只需要不断发送\",{\"1\":{\"1250\":1}}],[\"客户端只会获取它生产或者消费的\",{\"1\":{\"956\":1}}],[\"客户端代码逻辑较重\",{\"1\":{\"1249\":1}}],[\"客户端代码中消费者相关的类图\",{\"1\":{\"1109\":1}}],[\"客户端消费进度管理器持久化消费进度\",{\"0\":{\"1200\":1}}],[\"客户端自动决定延迟等级\",{\"1\":{\"1198\":1}}],[\"客户端要再次对消息进行了过滤\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"客户端是否提交了消费进度\",{\"1\":{\"1173\":1}}],[\"客户端是否输入换行符\",{\"1\":{\"128\":1}}],[\"客户端处理返回的消息\",{\"1\":{\"1156\":1}}],[\"客户端拉取超时\",{\"1\":{\"1171\":1}}],[\"客户端拉取流程设计\",{\"0\":{\"1150\":1}}],[\"客户端拉取路由信息\",{\"0\":{\"955\":1}}],[\"客户端设计和启动流程详解\",{\"0\":{\"1106\":1},\"1\":{\"1538\":1}}],[\"客户端就是基于\",{\"1\":{\"1095\":1}}],[\"客户端逻辑比较重\",{\"1\":{\"1095\":1}}],[\"客户端每一次重启都会从最新消息消费\",{\"1\":{\"1090\":1}}],[\"客户端每输入一个字符就会触发\",{\"1\":{\"125\":1}}],[\"客户端去连接会发现连不上\",{\"1\":{\"1075\":1}}],[\"客户端提供了丰富的消息发送\",{\"1\":{\"1025\":1}}],[\"客户端做的是向\",{\"1\":{\"1024\":1}}],[\"客户端采集到的轨迹上下文提交给线程池处理\",{\"1\":{\"1021\":1}}],[\"客户端使用\",{\"1\":{\"987\":1}}],[\"客户端使用datagramsocket\",{\"1\":{\"73\":1}}],[\"客户端发送请求\",{\"1\":{\"981\":1}}],[\"客户端发起消息消费请求\",{\"1\":{\"757\":1,\"766\":1}}],[\"客户端初始化时注册该\",{\"1\":{\"980\":1}}],[\"客户端初始化\",{\"1\":{\"980\":1}}],[\"客户端需要标明每个请求的用户\",{\"1\":{\"979\":1}}],[\"客户端需要自己定时从\",{\"1\":{\"955\":1}}],[\"客户端路由信息\",{\"0\":{\"968\":1}}],[\"客户端中注册定时任务的方法是\",{\"1\":{\"956\":1}}],[\"客户端中会启动一个定时任务\",{\"1\":{\"955\":1}}],[\"客户端中的路由信息保存在\",{\"1\":{\"950\":1}}],[\"客户端保存的路由信息\",{\"0\":{\"950\":1}}],[\"客户端在被停止期间发送至服务端的消息将会被自动跳过\",{\"1\":{\"1090\":1}}],[\"客户端在发送消息时会调用\",{\"1\":{\"902\":1}}],[\"客户端在面对etcd内部错误时\",{\"1\":{\"284\":1}}],[\"客户端请求需要的资源权限\",{\"1\":{\"1000\":1}}],[\"客户端请求路由信息\",{\"0\":{\"956\":1}}],[\"客户端请求\",{\"1\":{\"822\":1,\"1479\":1}}],[\"客户端不需要改变它们生产和订阅的方法\",{\"1\":{\"696\":1}}],[\"客户端连接从节点\",{\"0\":{\"669\":1}}],[\"客户端连接主节点\",{\"0\":{\"668\":1}}],[\"客户端连接事件到来时\",{\"1\":{\"135\":1}}],[\"客户端才会收到\",{\"1\":{\"663\":1}}],[\"客户端关闭了连接\",{\"1\":{\"125\":1}}],[\"客户端\",{\"0\":{\"70\":1,\"73\":1,\"230\":1,\"987\":1,\"993\":1,\"1252\":1},\"1\":{\"118\":1,\"124\":1,\"369\":1,\"695\":1,\"941\":1,\"978\":1,\"979\":1,\"986\":1,\"1017\":1,\"1222\":1,\"1235\":1}}],[\"网约车资源\",{\"1\":{\"921\":1,\"1337\":1}}],[\"网约车等业务中都会出现的订单场景\",{\"1\":{\"921\":1,\"1337\":1}}],[\"网络配置\",{\"1\":{\"960\":1}}],[\"网络上的很多资料都指向一个方案\",{\"1\":{\"931\":1}}],[\"网络通信时都会用到\",{\"1\":{\"890\":1}}],[\"网络通道\",{\"1\":{\"819\":1,\"1173\":1}}],[\"网络异常后两个节点交互决策\",{\"1\":{\"659\":1}}],[\"网络可以通过\",{\"1\":{\"635\":1}}],[\"网络分区导致的脑裂等问题做定制检测\",{\"1\":{\"282\":1}}],[\"网络号是ip地址通过子网掩码过滤后得到的\",{\"1\":{\"67\":1}}],[\"网络编程基础\",{\"0\":{\"67\":1}}],[\"网络编程\",{\"0\":{\"66\":1}}],[\"工作线程用一个死循环\",{\"1\":{\"1021\":1}}],[\"工作线程\",{\"1\":{\"1021\":1}}],[\"工作线程每次消费一批轨迹数据\",{\"1\":{\"1015\":1}}],[\"工作线程每次从队列中\",{\"1\":{\"915\":1}}],[\"工作线程的\",{\"1\":{\"915\":1}}],[\"工作流等信息的配置与管理\",{\"1\":{\"372\":1}}],[\"拼接的逻辑\",{\"1\":{\"909\":1}}],[\"拼接和处理方法\",{\"1\":{\"896\":1}}],[\"寻址间距短\",{\"1\":{\"904\":1}}],[\"寻找优化点\",{\"0\":{\"890\":1,\"896\":1,\"899\":1,\"902\":1,\"908\":1,\"911\":1,\"914\":1}}],[\"寻找java中string\",{\"1\":{\"743\":1}}],[\"栈无需释放内存和进行随机寻址\",{\"1\":{\"904\":1}}],[\"栈没有碎片\",{\"1\":{\"904\":1}}],[\"栈操作可以被\",{\"1\":{\"904\":1}}],[\"栈上分配的数据\",{\"1\":{\"904\":1}}],[\"栈上存储的数据\",{\"1\":{\"904\":1}}],[\"栈跟踪\",{\"0\":{\"197\":1}}],[\"范围内\",{\"1\":{\"904\":1}}],[\"范围是0～65535\",{\"1\":{\"68\":1}}],[\"功能时必须用\",{\"1\":{\"987\":1}}],[\"功能领先所有开源消息队列和云化消息队列\",{\"1\":{\"922\":1}}],[\"功能\",{\"1\":{\"922\":1,\"983\":1,\"1067\":1}}],[\"功能在\",{\"1\":{\"902\":1}}],[\"功能性\",{\"1\":{\"400\":1}}],[\"说的不是操作系统层面上的零拷贝\",{\"1\":{\"894\":1}}],[\"说明前面挂起的请求已经全部处理完毕\",{\"1\":{\"1521\":1}}],[\"说明从节点已经存储该条日志\",{\"1\":{\"1520\":1}}],[\"说明已经\",{\"1\":{\"1519\":1}}],[\"说明可能存在\",{\"1\":{\"1511\":1}}],[\"说明发起拉票节点的日志复制进度比当前节点低\",{\"1\":{\"1503\":2}}],[\"说明请求拉票节点已经过期\",{\"1\":{\"1492\":1}}],[\"说明拉票节点的日志复制进度比当前低\",{\"1\":{\"1492\":2}}],[\"说明这条是新的事务半消息存储进来\",{\"1\":{\"1468\":1}}],[\"说明这个消息重复生成consumequeue\",{\"1\":{\"765\":1}}],[\"说明没有全部刷盘成功\",{\"1\":{\"1427\":1}}],[\"说明消息已经到期\",{\"1\":{\"1356\":1,\"1371\":1}}],[\"说明消息的\",{\"1\":{\"1314\":1}}],[\"说明处理队列为空\",{\"1\":{\"1230\":1}}],[\"说明该日志没有正常写入\",{\"1\":{\"1520\":1}}],[\"说明该事务半消息已经被提交或者回滚\",{\"1\":{\"1468\":1}}],[\"说明该消费组不支持重试\",{\"1\":{\"1198\":1}}],[\"说明该文件在不久的将来要被访问\",{\"1\":{\"882\":1}}],[\"说明consumer设置了标志位\",{\"1\":{\"1173\":1}}],[\"说明是首次调用\",{\"1\":{\"1173\":1}}],[\"说明是重复写入\",{\"1\":{\"765\":1}}],[\"说明了当今企业对消息队列定时消息能力的强烈需求和当下主流消息队列对定时消息能力支持不完美现状\",{\"1\":{\"936\":1}}],[\"说明不需要删除任何文件\",{\"1\":{\"872\":1}}],[\"说明有新的消息可以被拉取\",{\"1\":{\"825\":2}}],[\"说明也有新消息到达\",{\"1\":{\"812\":1}}],[\"说明需要创建新的索引文件\",{\"1\":{\"797\":1}}],[\"说明当前存储单元有效\",{\"1\":{\"771\":1}}],[\"说明它们最近处于流控状态\",{\"1\":{\"622\":1}}],[\"说明\",{\"1\":{\"60\":1,\"658\":1,\"659\":1,\"660\":1,\"1308\":2,\"1386\":1}}],[\"想要摆脱消息默认过期时间的限制\",{\"1\":{\"928\":1}}],[\"想要实现任意时间的定时消息\",{\"1\":{\"926\":1}}],[\"想要优化性能\",{\"1\":{\"887\":1}}],[\"想要让节点数量改变后计算结果尽可能保持稳定\",{\"1\":{\"387\":1}}],[\"技术全面揭秘\",{\"1\":{\"1527\":1}}],[\"技术复杂度都有一定上升\",{\"1\":{\"1385\":1}}],[\"技术架构选型\",{\"0\":{\"1385\":1}}],[\"技术内幕\",{\"1\":{\"884\":1,\"974\":1,\"1057\":1,\"1504\":1,\"1522\":1}}],[\"技能提示\",{\"1\":{\"491\":1}}],[\"技能优先级\",{\"0\":{\"410\":1}}],[\"技能循环\",{\"0\":{\"408\":1}}],[\"技能\",{\"1\":{\"399\":1,\"491\":1}}],[\"阻止操作系统将相关的内存页调度到交换空间\",{\"1\":{\"882\":1}}],[\"阻塞队列\",{\"1\":{\"1168\":1}}],[\"阻塞队列的大小可以配置\",{\"1\":{\"855\":1}}],[\"阻塞该延迟等级的消息投递\",{\"1\":{\"860\":1}}],[\"阻塞当前延迟等级对应的线程\",{\"1\":{\"854\":1}}],[\"阻塞当前线程\",{\"1\":{\"118\":1}}],[\"阻塞式\",{\"1\":{\"114\":1}}],[\"阻塞\",{\"1\":{\"109\":1,\"122\":1,\"860\":2,\"1270\":1}}],[\"阻塞等待\",{\"1\":{\"69\":1}}],[\"映射的监听\",{\"1\":{\"1075\":1}}],[\"映射\",{\"1\":{\"882\":1}}],[\"映射组在比较时首先会比大小\",{\"1\":{\"192\":1}}],[\"映射组在系统内部是作为有序集合存储的\",{\"1\":{\"192\":1}}],[\"起始偏移量\",{\"1\":{\"1420\":1}}],[\"起始位置的计算方式如下\",{\"1\":{\"1403\":1}}],[\"起始的时候\",{\"1\":{\"276\":1}}],[\"起了一个后台线程\",{\"1\":{\"881\":1}}],[\"充分适应消息系统消峰填谷的需求\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"充分利用了\",{\"1\":{\"879\":1}}],[\"充当worker集群中的\",{\"1\":{\"372\":1}}],[\"拥有金融级别稳定性的高性能消息队列\",{\"1\":{\"1529\":1}}],[\"拥有强大的消息过滤能力\",{\"1\":{\"1303\":1}}],[\"拥有重试机制和死信机制来保证消息消费的可靠性\",{\"1\":{\"1100\":1}}],[\"拥有了不错的性能\",{\"1\":{\"925\":1}}],[\"拥有接近\",{\"1\":{\"874\":1}}],[\"拥有该进程字典的进程会被阻塞\",{\"1\":{\"624\":1}}],[\"偏移量非法\",{\"1\":{\"1175\":1}}],[\"偏移量提交计算\",{\"1\":{\"1170\":1}}],[\"偏移量\",{\"0\":{\"1296\":1},\"1\":{\"872\":1,\"1169\":1,\"1348\":2,\"1357\":1}}],[\"危险情况\",{\"1\":{\"870\":1}}],[\"触发生产者上报本地事务执行状态\",{\"1\":{\"1453\":1}}],[\"触发一次\",{\"1\":{\"1453\":1}}],[\"触发一次重平衡\",{\"1\":{\"1128\":1}}],[\"触发上传的条件有两个\",{\"1\":{\"1388\":1}}],[\"触发上报\",{\"1\":{\"952\":1}}],[\"触发消费进度管理器的持久化方法\",{\"1\":{\"1191\":1}}],[\"触发流控\",{\"1\":{\"1170\":3}}],[\"触发点\",{\"1\":{\"1136\":1}}],[\"触发方式分主动触发和定时触发\",{\"1\":{\"1128\":1}}],[\"触发则会设manualdeletefileseveraltimes为20\",{\"1\":{\"870\":1}}],[\"触发\",{\"1\":{\"870\":1,\"1511\":1,\"1520\":1}}],[\"触发更多新绿\",{\"1\":{\"411\":1}}],[\"释放提交锁\",{\"1\":{\"1428\":1}}],[\"释放和申请\",{\"1\":{\"1219\":1}}],[\"释放\",{\"1\":{\"1218\":1}}],[\"释放锁\",{\"1\":{\"1209\":1}}],[\"释放写锁\",{\"1\":{\"953\":1,\"954\":1,\"971\":1,\"972\":1}}],[\"释放时只需要通过移动栈顶指针\",{\"1\":{\"904\":1}}],[\"释放磁盘空间\",{\"1\":{\"863\":1}}],[\"释放排放口技能的时候准备一个万灵来应对大额\",{\"1\":{\"440\":1}}],[\"跳出\",{\"1\":{\"1519\":4,\"1520\":1}}],[\"跳出该投递任务\",{\"1\":{\"933\":1}}],[\"跳过拉取\",{\"1\":{\"1224\":1}}],[\"跳过\",{\"1\":{\"861\":1,\"1279\":1,\"1453\":1,\"1468\":1}}],[\"跳转\",{\"1\":{\"167\":1}}],[\"跳转到第n个缓冲区\",{\"1\":{\"152\":1}}],[\"跳转到上一个\",{\"1\":{\"149\":1}}],[\"跳转到屏幕开头head\",{\"1\":{\"145\":1}}],[\"页缓存\",{\"0\":{\"879\":1}}],[\"页缓存等方案加速了\",{\"1\":{\"874\":1}}],[\"页缓存可能会繁忙\",{\"1\":{\"854\":1}}],[\"页面移动\",{\"1\":{\"145\":1}}],[\"社区在讨论什么\",{\"1\":{\"1375\":1}}],[\"社区有一个pr\",{\"1\":{\"848\":1}}],[\"社区已经提出这个错误\",{\"1\":{\"786\":1}}],[\"云原生化的要求催生着一种能够解决这些痛点的新消费模式诞生\",{\"1\":{\"1249\":1}}],[\"云原生分布式架构的演进正在朝着组装式架构\",{\"1\":{\"277\":1}}],[\"云服务竞争力体现\",{\"1\":{\"847\":1}}],[\"跟不上\",{\"1\":{\"910\":1}}],[\"跟现在的时间戳比较\",{\"1\":{\"845\":1}}],[\"跟踪事件本身是通过调用\",{\"1\":{\"261\":1}}],[\"跟踪垃圾收集何时进行\",{\"1\":{\"261\":1}}],[\"跟踪所有正在发送的消息\",{\"1\":{\"261\":1}}],[\"跟踪消息与进程执行\",{\"0\":{\"261\":1}}],[\"扫描时间轮中到期的消息\",{\"0\":{\"1358\":1,\"1372\":1}}],[\"扫描到了之后将消息从\",{\"1\":{\"1355\":1}}],[\"扫描定时消息\",{\"0\":{\"1355\":1,\"1370\":1}}],[\"扫描已经完成的\",{\"1\":{\"1277\":1}}],[\"扫描内存中的\",{\"1\":{\"1277\":1}}],[\"扫描一次\",{\"1\":{\"961\":1,\"1394\":1}}],[\"扫描\",{\"1\":{\"945\":1,\"947\":1,\"961\":1,\"1364\":1}}],[\"扫描投递任务的状态\",{\"1\":{\"933\":1}}],[\"扫描消息并且检查是否到投递时间的主要逻辑都在这个函数里面\",{\"1\":{\"841\":1}}],[\"扫描指定的package获取所有entity\",{\"1\":{\"89\":1}}],[\"填充结果\",{\"1\":{\"1518\":1}}],[\"填充responseheader\",{\"1\":{\"1173\":1}}],[\"填充进\",{\"1\":{\"957\":1,\"973\":1}}],[\"填充\",{\"1\":{\"957\":1,\"973\":1,\"1468\":1}}],[\"填充key和value\",{\"1\":{\"822\":1}}],[\"填充空的消息索引\",{\"1\":{\"765\":1}}],[\"何时需要提醒长轮询新消息已经到达\",{\"1\":{\"814\":1}}],[\"校验consumergroup配置是否可消费\",{\"1\":{\"1173\":1}}],[\"校验consumergroup配置是否存在\",{\"1\":{\"1173\":1}}],[\"校验\",{\"1\":{\"814\":1,\"1273\":1,\"1517\":1}}],[\"校验成功则更新当前文件的最大可用偏移量\",{\"1\":{\"759\":1,\"771\":1}}],[\"立刻拉取最新消息\",{\"1\":{\"828\":1}}],[\"立刻唤醒相应队列的拉取请求\",{\"1\":{\"811\":1}}],[\"立即发起一轮投票\",{\"1\":{\"1500\":1}}],[\"立即发起选举\",{\"1\":{\"1489\":1}}],[\"立即发送下一次心跳\",{\"1\":{\"1488\":1,\"1499\":1}}],[\"立即从二级存储中拉消息\",{\"1\":{\"1431\":1}}],[\"立即从二级存储中拉取消息\",{\"1\":{\"1391\":1}}],[\"立即进行下一次提交\",{\"1\":{\"1427\":2}}],[\"立即重新拉票\",{\"1\":{\"1491\":1,\"1497\":1}}],[\"立即重试上次刷盘\",{\"1\":{\"1427\":1}}],[\"立即重平衡\",{\"1\":{\"1128\":1}}],[\"立即将拉取请求放入队列\",{\"1\":{\"1168\":1}}],[\"立即执行拉取消息请求\",{\"1\":{\"1168\":1}}],[\"立即执行重平衡\",{\"1\":{\"1120\":1,\"1122\":1}}],[\"立即停止系统\",{\"1\":{\"171\":1}}],[\"立即生效\",{\"1\":{\"124\":1}}],[\"立即唤醒重平衡线程执行本地重平衡\",{\"1\":{\"1136\":1}}],[\"立即唤醒挂起的拉取请求\",{\"1\":{\"814\":1}}],[\"立即唤醒挂起的消息拉取请求\",{\"1\":{\"762\":1,\"827\":1}}],[\"立即唤醒可能正在阻塞的\",{\"1\":{\"124\":1}}],[\"立即唤醒\",{\"1\":{\"124\":1,\"128\":1}}],[\"尝试查找最老的\",{\"1\":{\"1519\":1}}],[\"尝试存入\",{\"1\":{\"1332\":1}}],[\"尝试将\",{\"1\":{\"1259\":1}}],[\"尝试获取事务消息标识\",{\"1\":{\"1462\":1}}],[\"尝试获取队列的消费锁\",{\"1\":{\"1225\":1}}],[\"尝试获取缓存的路由信息\",{\"1\":{\"1051\":1}}],[\"尝试向\",{\"1\":{\"1224\":1}}],[\"尝试给处理队列加锁\",{\"1\":{\"1224\":1}}],[\"尝试加锁\",{\"1\":{\"1214\":1}}],[\"尝试释放\",{\"1\":{\"1213\":1}}],[\"尝试持久化消息消费进度\",{\"1\":{\"1175\":1}}],[\"尝试从规避的\",{\"1\":{\"1052\":1}}],[\"尝试从存储的消息中拉取消息\",{\"1\":{\"806\":1}}],[\"尝试恢复这些文件\",{\"1\":{\"770\":1}}],[\"短信通知\",{\"1\":{\"1027\":1}}],[\"短时间内对于生产者和消费者并不会产生太大影响\",{\"1\":{\"942\":1}}],[\"短轮询默认等待\",{\"1\":{\"815\":1}}],[\"短轮询的配置决定\",{\"1\":{\"815\":1}}],[\"短轮询等待时间\",{\"1\":{\"810\":1}}],[\"短轮询等待\",{\"1\":{\"806\":1}}],[\"短轮询\",{\"1\":{\"805\":1}}],[\"短路布尔表达式\",{\"0\":{\"219\":1}}],[\"长轮询相关介绍见本文\",{\"1\":{\"1163\":1}}],[\"长轮询相关逻辑请移步之前的分析\",{\"1\":{\"906\":1}}],[\"长轮询模式\",{\"1\":{\"829\":1}}],[\"长轮询请求管理线程\",{\"1\":{\"810\":1}}],[\"长轮询等待\",{\"1\":{\"806\":1,\"815\":1}}],[\"长轮询\",{\"1\":{\"805\":1,\"810\":1,\"819\":1,\"1173\":1,\"1269\":1}}],[\"长轮询和短轮询\",{\"0\":{\"805\":1}}],[\"长者织影\",{\"1\":{\"435\":1}}],[\"询问是否有新消息可供消费\",{\"1\":{\"803\":1}}],[\"轮次相同\",{\"1\":{\"1500\":2}}],[\"轮次等于当前\",{\"1\":{\"1479\":1}}],[\"轮次小于当前节点\",{\"1\":{\"1500\":1}}],[\"轮次小于当前\",{\"1\":{\"1479\":1}}],[\"轮次小于等于当前\",{\"1\":{\"1479\":1}}],[\"轮次大于当前\",{\"1\":{\"1479\":2}}],[\"轮询选择一个可用的生产者客户端通道\",{\"1\":{\"1469\":1}}],[\"轮询选一个\",{\"1\":{\"1269\":1}}],[\"轮询一个生产者\",{\"1\":{\"1453\":1}}],[\"轮询获取一个消息队列\",{\"1\":{\"1052\":1}}],[\"轮询队列\",{\"1\":{\"1052\":1}}],[\"轮询后会检查每个挂起的拉取请求的挂起时间是否超过挂起时间阈值\",{\"1\":{\"806\":1}}],[\"轮询时间为\",{\"1\":{\"805\":2}}],[\"轮询机制\",{\"0\":{\"799\":1},\"1\":{\"914\":1,\"1538\":1}}],[\"轮流与\",{\"1\":{\"187\":1}}],[\"部分消息未被消费\",{\"1\":{\"1239\":1}}],[\"部分为\",{\"1\":{\"1156\":2}}],[\"部分为客户端发送拉取请求\",{\"1\":{\"1156\":1}}],[\"部分长度都是固定的\",{\"1\":{\"787\":1}}],[\"部分存储固定数量的索引项\",{\"1\":{\"787\":1}}],[\"部分存储固定数量的\",{\"1\":{\"787\":1}}],[\"部分是定长的\",{\"1\":{\"787\":1}}],[\"部署多个调度服务器可以同时实现高可用和性能的提升\",{\"1\":{\"371\":1}}],[\"槽中所有的索引项\",{\"1\":{\"1435\":1}}],[\"槽中的索引项起始位置和总长度\",{\"1\":{\"1415\":1,\"1436\":1}}],[\"槽\",{\"1\":{\"1435\":2,\"1436\":1}}],[\"槽数据\",{\"1\":{\"1435\":1}}],[\"槽数\",{\"1\":{\"1435\":1}}],[\"槽总\",{\"1\":{\"1435\":1}}],[\"槽从\",{\"1\":{\"1435\":1}}],[\"槽所有索引项的总长度\",{\"1\":{\"1418\":1,\"1435\":1}}],[\"槽所对应的\",{\"1\":{\"1393\":1}}],[\"槽索引项的起始位置\",{\"1\":{\"1418\":1,\"1435\":1}}],[\"槽大小从\",{\"1\":{\"1418\":1}}],[\"槽的值\",{\"1\":{\"1436\":1}}],[\"槽的所有索引项查出来\",{\"1\":{\"1418\":1}}],[\"槽的所有索引项时\",{\"1\":{\"1418\":1}}],[\"槽的索引项在物理位置上连续排列\",{\"1\":{\"1418\":1}}],[\"槽的链表项\",{\"1\":{\"1418\":1}}],[\"槽的开头\",{\"1\":{\"1393\":1}}],[\"槽写入新文件\",{\"1\":{\"1417\":1}}],[\"槽对应的链表时\",{\"1\":{\"1393\":1}}],[\"槽就对应了一条按照插入时间倒序排列的链表\",{\"1\":{\"1393\":1}}],[\"槽个数\",{\"1\":{\"787\":1}}],[\"槽和索引项数量不变\",{\"1\":{\"1418\":1}}],[\"槽和索引项\",{\"1\":{\"1417\":1}}],[\"槽和\",{\"1\":{\"787\":1}}],[\"槽位置查询\",{\"1\":{\"1436\":1}}],[\"槽位置\",{\"1\":{\"1415\":1,\"1436\":2}}],[\"槽位下标\",{\"1\":{\"1367\":1}}],[\"槽位总数\",{\"1\":{\"1367\":1}}],[\"槽位中保存了指向\",{\"1\":{\"1351\":1}}],[\"槽位\",{\"1\":{\"479\":1,\"480\":1,\"1367\":1}}],[\"举例\",{\"1\":{\"787\":1}}],[\"举个例子\",{\"1\":{\"421\":1,\"700\":1}}],[\"越频繁\",{\"1\":{\"924\":1}}],[\"越晚到达的消息在链表越前面\",{\"1\":{\"786\":1}}],[\"越新的消息在链表越前面\",{\"1\":{\"780\":1}}],[\"越来越多的cio\",{\"1\":{\"276\":1}}],[\"形如\",{\"1\":{\"960\":1}}],[\"形式存储数据\",{\"1\":{\"780\":1}}],[\"形成一个组\",{\"1\":{\"673\":1}}],[\"迦南地\",{\"1\":{\"774\":1}}],[\"留了8字节的保留字段\",{\"1\":{\"773\":1}}],[\"留爆发打盾\",{\"1\":{\"439\":1}}],[\"元数据和额外属性\",{\"1\":{\"1402\":1}}],[\"元数据文件包括两类\",{\"1\":{\"1420\":1}}],[\"元数据文件分为两类\",{\"1\":{\"1395\":1}}],[\"元数据文件默认保存的位置是\",{\"1\":{\"1395\":1}}],[\"元数据管理和索引文件的实现\",{\"1\":{\"1380\":1}}],[\"元数据上\",{\"1\":{\"1290\":1}}],[\"元数据被更新的次数\",{\"1\":{\"967\":1}}],[\"元数据\",{\"0\":{\"1420\":1},\"1\":{\"950\":1,\"968\":1,\"1395\":1,\"1421\":2}}],[\"元素更多\",{\"1\":{\"773\":1}}],[\"元组使用扩展运算符\",{\"1\":{\"529\":1}}],[\"元组的成员类型是写在方括号里面\",{\"1\":{\"527\":1}}],[\"元组会被排序\",{\"1\":{\"248\":1}}],[\"元组里的某一个元素\",{\"1\":{\"248\":1}}],[\"元组里的字段没有名字\",{\"1\":{\"176\":1}}],[\"元组用于保存固定数量的元素\",{\"1\":{\"190\":1}}],[\"元组\",{\"0\":{\"176\":1,\"526\":1},\"1\":{\"195\":1,\"261\":1}}],[\"格式化\",{\"0\":{\"907\":1}}],[\"格式\",{\"1\":{\"773\":1}}],[\"格瑞姆巴托\",{\"0\":{\"469\":1},\"1\":{\"479\":1,\"480\":3}}],[\"格瑞\",{\"1\":{\"422\":1}}],[\"期望填充满\",{\"1\":{\"1257\":1}}],[\"期望写入的位置应该等于被写过的位置\",{\"1\":{\"765\":1}}],[\"期间整个集群都处于不可用的状态\",{\"1\":{\"942\":1}}],[\"期间注意被深渊轰击\",{\"1\":{\"448\":1}}],[\"纠正mappedfile逻辑队列索引顺序\",{\"1\":{\"765\":1}}],[\"纠结使用\",{\"1\":{\"2\":1}}],[\"码列表中\",{\"1\":{\"1319\":1}}],[\"码是否在过滤规则允许的\",{\"1\":{\"1319\":1}}],[\"码可能相同\",{\"1\":{\"1314\":1}}],[\"码一致\",{\"1\":{\"1314\":1}}],[\"码表\",{\"1\":{\"1278\":1}}],[\"码表每一位\",{\"1\":{\"1277\":1}}],[\"码表为\",{\"1\":{\"1276\":1,\"1278\":1}}],[\"码\",{\"1\":{\"749\":1,\"1314\":2,\"1318\":1,\"1319\":2}}],[\"└─0\",{\"1\":{\"749\":1}}],[\"└─b4b690a3\",{\"1\":{\"749\":1}}],[\"└───────┘\",{\"1\":{\"78\":1}}],[\"└─────────────────────────┘\",{\"1\":{\"33\":1}}],[\"└─────────────────────┘\",{\"1\":{\"33\":1}}],[\"└─────────────────┘└───────────┘\",{\"1\":{\"33\":1}}],[\"└─────────────────┘\",{\"1\":{\"33\":1}}],[\"└───────────┘\",{\"1\":{\"33\":4,\"78\":1}}],[\"└─────┘└─────────────────┘└────────────────┘└────────────┘\",{\"1\":{\"46\":1}}],[\"└────┘\",{\"1\":{\"46\":1}}],[\"└──\",{\"1\":{\"21\":11}}],[\"├─consumequeue\",{\"1\":{\"749\":1}}],[\"├─commitlog\",{\"1\":{\"749\":1}}],[\"├───────────┤\",{\"1\":{\"78\":2}}],[\"├──\",{\"1\":{\"21\":3}}],[\"索引数量超过最大值\",{\"1\":{\"1414\":1,\"1434\":1}}],[\"索引构建流程\",{\"0\":{\"1394\":1}}],[\"索引构建线程\",{\"1\":{\"1294\":1}}],[\"索引重排\",{\"0\":{\"1393\":1}}],[\"索引设计\",{\"0\":{\"1392\":1}}],[\"索引每个\",{\"1\":{\"927\":1}}],[\"索引的\",{\"1\":{\"839\":1}}],[\"索引的逻辑下标\",{\"1\":{\"787\":1}}],[\"索引项写入到新索引文件\",{\"1\":{\"1435\":1}}],[\"索引项写入位置\",{\"1\":{\"1435\":1}}],[\"索引项数\",{\"1\":{\"1435\":1}}],[\"索引项总\",{\"1\":{\"1435\":1}}],[\"索引项开始写入位置\",{\"1\":{\"1435\":1}}],[\"索引项经过排序\",{\"1\":{\"1418\":1}}],[\"索引项\",{\"1\":{\"1372\":1,\"1435\":1}}],[\"索引项对应的消息\",{\"1\":{\"1371\":1}}],[\"索引项在\",{\"1\":{\"1371\":2}}],[\"索引项个数+1\",{\"1\":{\"797\":1}}],[\"索引项的结构很简单\",{\"1\":{\"755\":1}}],[\"索引服务\",{\"1\":{\"789\":1}}],[\"索引文件压缩重排\",{\"0\":{\"1435\":1}}],[\"索引文件会更新并持久化到本地文件中\",{\"1\":{\"1419\":1}}],[\"索引文件重排的入口是\",{\"1\":{\"1417\":1}}],[\"索引文件重排\",{\"0\":{\"1416\":1}}],[\"索引文件仅在根据\",{\"1\":{\"1414\":1}}],[\"索引文件读写\",{\"0\":{\"1413\":1}}],[\"索引文件表\",{\"1\":{\"1412\":1}}],[\"索引文件状态\",{\"1\":{\"1412\":1}}],[\"索引文件类设计\",{\"0\":{\"1412\":1}}],[\"索引文件服务启动一个线程\",{\"1\":{\"1394\":1}}],[\"索引文件在消息上传到二级存储后开始构建\",{\"1\":{\"1394\":1}}],[\"索引文件被删除\",{\"1\":{\"845\":1}}],[\"索引文件刷盘\",{\"1\":{\"796\":2}}],[\"索引文件列表\",{\"1\":{\"789\":1}}],[\"索引文件涉及到的类\",{\"0\":{\"788\":1}}],[\"索引文件可以有多个\",{\"1\":{\"787\":1}}],[\"索引文件可以通过\",{\"1\":{\"778\":1,\"868\":1}}],[\"索引文件底层使用\",{\"1\":{\"787\":1}}],[\"索引文件中存储着\",{\"1\":{\"782\":1}}],[\"索引文件的写入在前面写过的分级存储\",{\"1\":{\"1414\":1}}],[\"索引文件的刷盘机制并不是采取定时刷盘机制\",{\"1\":{\"783\":1}}],[\"索引文件的\",{\"1\":{\"780\":2,\"927\":1}}],[\"索引文件的应用场景其实比较局限\",{\"1\":{\"778\":1}}],[\"索引文件结构\",{\"0\":{\"780\":1,\"785\":1}}],[\"索引文件作用\",{\"0\":{\"778\":1}}],[\"索引文件是什么\",{\"0\":{\"777\":1}}],[\"索引文件\",{\"0\":{\"775\":1,\"1411\":1,\"1433\":1},\"1\":{\"790\":1,\"1386\":1,\"1393\":1,\"1538\":1}}],[\"索引\",{\"1\":{\"746\":1,\"811\":1,\"1509\":1,\"1521\":1}}],[\"索引超过了范围\",{\"1\":{\"298\":1}}],[\"离物理极限性能还差多远\",{\"1\":{\"743\":1}}],[\"离线并再次恢复时\",{\"1\":{\"677\":1}}],[\"离线后重新上线\",{\"0\":{\"677\":1}}],[\"离线系统的复杂架构不断被融合\",{\"1\":{\"276\":1}}],[\"各实例间相互不进行信息通讯\",{\"1\":{\"941\":1}}],[\"各大开源消息队列和云厂商没有实现完美的定时消息\",{\"1\":{\"924\":1}}],[\"各大云厂商将该功能作为一个竞争力项\",{\"1\":{\"922\":1}}],[\"各大消息队列对定时消息支持的现状\",{\"0\":{\"922\":1}}],[\"各不相同\",{\"1\":{\"742\":1}}],[\"各个consumergroup的权限\",{\"1\":{\"983\":1}}],[\"各个topic的权限\",{\"1\":{\"983\":1}}],[\"各个成员的类型可以不同的数组\",{\"1\":{\"527\":1}}],[\"各个注解的含义和用法\",{\"1\":{\"12\":1}}],[\"懒加载\",{\"0\":{\"738\":1}}],[\"理论\",{\"1\":{\"942\":1}}],[\"理论上这里只要往\",{\"1\":{\"736\":1}}],[\"理解游戏机制\",{\"0\":{\"418\":1}}],[\"理解与洞察较少\",{\"1\":{\"277\":1}}],[\"锁容器读写锁\",{\"1\":{\"1222\":1}}],[\"锁管理器将锁创建后放入锁容器\",{\"1\":{\"1214\":1}}],[\"锁的容器是两层\",{\"1\":{\"1212\":1}}],[\"锁的使用也更少\",{\"1\":{\"117\":1}}],[\"锁定状态机\",{\"1\":{\"1517\":1}}],[\"锁定状态机对象\",{\"1\":{\"1503\":1}}],[\"锁定\",{\"1\":{\"1228\":1}}],[\"锁定消息队列\",{\"1\":{\"1226\":1}}],[\"锁定处理队列失败\",{\"1\":{\"1224\":1}}],[\"锁定需要锁定的队列\",{\"1\":{\"1222\":1}}],[\"锁定成功的消息队列\",{\"1\":{\"1222\":1}}],[\"锁定队列和消费者的关系\",{\"1\":{\"1102\":1}}],[\"锁定该文件的\",{\"1\":{\"882\":1}}],[\"锁\",{\"1\":{\"1102\":1}}],[\"锁内的操作尽量移动到锁外进行\",{\"1\":{\"917\":1}}],[\"锁内操作\",{\"0\":{\"736\":1}}],[\"既然有\",{\"1\":{\"733\":1}}],[\"既可以作为值\",{\"1\":{\"506\":1}}],[\"既可以是判断函数\",{\"1\":{\"184\":1}}],[\"逻辑或\",{\"1\":{\"1308\":1}}],[\"逻辑与\",{\"1\":{\"1308\":1}}],[\"逻辑中更新该时间戳\",{\"1\":{\"1297\":1}}],[\"逻辑改成了\",{\"1\":{\"1206\":1}}],[\"逻辑前\",{\"1\":{\"990\":1}}],[\"逻辑\",{\"0\":{\"1483\":1},\"1\":{\"989\":1,\"995\":1}}],[\"逻辑消费队列\",{\"1\":{\"816\":1}}],[\"逻辑结构\",{\"0\":{\"786\":1}}],[\"逻辑处理器数\",{\"1\":{\"733\":1}}],[\"逻辑如下\",{\"1\":{\"378\":1,\"1294\":1,\"1409\":1,\"1410\":1,\"1415\":1,\"1512\":1}}],[\"故意返回\",{\"1\":{\"1442\":1}}],[\"故可以换成自旋锁\",{\"1\":{\"725\":1}}],[\"故障延迟机制走不同逻辑\",{\"1\":{\"1052\":1}}],[\"故障延迟机制关闭\",{\"1\":{\"1052\":1}}],[\"故障延迟机制是为了能够在消息发送的时候尽量避开上次发送失败的\",{\"1\":{\"1041\":1}}],[\"故障延迟机制\",{\"0\":{\"1041\":1},\"1\":{\"1041\":1,\"1052\":5}}],[\"故障规避机制\",{\"1\":{\"1032\":1}}],[\"故障转移与恢复\",{\"1\":{\"371\":1}}],[\"故障期间集群表现不一致\",{\"1\":{\"284\":1}}],[\"故障期间是否出现系统不可用\",{\"1\":{\"283\":1}}],[\"故障下是否满足预期的分区顺序性\",{\"1\":{\"283\":1}}],[\"故障恢复情况\",{\"1\":{\"283\":1}}],[\"产生抖动\",{\"1\":{\"881\":1}}],[\"产生待复制的消息\",{\"1\":{\"724\":1}}],[\"产生一个特定的指标输出\",{\"1\":{\"276\":1}}],[\"示意图如下\",{\"1\":{\"716\":1}}],[\"示例\",{\"1\":{\"60\":1,\"1308\":1}}],[\"平均分配\",{\"1\":{\"1138\":1}}],[\"平均地分布在每个节点上\",{\"1\":{\"707\":1}}],[\"平平无奇\",{\"1\":{\"1119\":1}}],[\"平时不会启动\",{\"1\":{\"864\":1}}],[\"平衡\",{\"1\":{\"419\":1}}],[\"延长了不可见时间\",{\"1\":{\"1251\":1}}],[\"延长增益效果\",{\"1\":{\"439\":1}}],[\"延时消息的写入速度与读取速度难以平衡\",{\"1\":{\"1364\":1}}],[\"延时消息\",{\"1\":{\"1025\":1}}],[\"延时消息常见实现方案\",{\"1\":{\"938\":1}}],[\"延迟与性能\",{\"1\":{\"1385\":1}}],[\"延迟故障规避\",{\"0\":{\"1234\":1}}],[\"延迟一段时间后再次进行消费\",{\"1\":{\"1195\":1}}],[\"延迟指定时间后投递\",{\"1\":{\"1188\":1}}],[\"延迟到期后该消息将被重新投递到消费者\",{\"1\":{\"1180\":1}}],[\"延迟到期执行\",{\"1\":{\"845\":1}}],[\"延迟3s后拉取\",{\"1\":{\"1170\":1}}],[\"延迟50ms之后重新拉取\",{\"1\":{\"1170\":2}}],[\"延迟1s后再拉取\",{\"1\":{\"1170\":1}}],[\"延迟时间不限\",{\"1\":{\"928\":2}}],[\"延迟时间受限\",{\"1\":{\"928\":1}}],[\"延迟时间\",{\"1\":{\"922\":2,\"924\":1,\"1351\":1}}],[\"延迟变高的原因是\",{\"1\":{\"915\":1}}],[\"延迟等级处理线程周期性扫描对应的延迟等级\",{\"1\":{\"834\":1}}],[\"延迟等级个数\",{\"1\":{\"834\":1}}],[\"延迟消息指定延迟的时间\",{\"1\":{\"1338\":1}}],[\"延迟消息与定时消息\",{\"0\":{\"1338\":1}}],[\"延迟消息实现的基础上\",{\"1\":{\"936\":1}}],[\"延迟消息的流程图\",{\"1\":{\"925\":2}}],[\"延迟消息的投递逻辑全部在\",{\"1\":{\"856\":1}}],[\"延迟消息处理服务启动时会在\",{\"1\":{\"857\":1}}],[\"延迟消息投递服务中维护了一个\",{\"1\":{\"857\":1}}],[\"延迟消息到期投递到\",{\"1\":{\"850\":1}}],[\"延迟消息服务启动\",{\"1\":{\"844\":1}}],[\"延迟消息每个消息的投递时间不确定\",{\"1\":{\"836\":1}}],[\"延迟消息在\",{\"1\":{\"835\":1}}],[\"延迟消息保存后\",{\"1\":{\"834\":1}}],[\"延迟消息\",{\"0\":{\"830\":1,\"849\":1},\"1\":{\"850\":1,\"920\":1,\"1028\":1,\"1337\":1,\"1338\":2,\"1538\":2}}],[\"延迟\",{\"0\":{\"704\":1},\"1\":{\"1194\":2,\"1339\":2}}],[\"虽然是随机读\",{\"1\":{\"878\":1}}],[\"虽然这种场景出现的可能性较小\",{\"1\":{\"703\":1}}],[\"虽然整个\",{\"1\":{\"380\":1}}],[\"失去多数节点时意味着队列不可用\",{\"0\":{\"703\":1}}],[\"失败可能是内存匹配未开启\",{\"1\":{\"1273\":1}}],[\"失败则有可能是内存匹配未开启\",{\"1\":{\"1260\":1}}],[\"失败则重试\",{\"1\":{\"1195\":1}}],[\"失败数量\",{\"1\":{\"1195\":1}}],[\"失败\",{\"1\":{\"348\":1,\"351\":2,\"1197\":1}}],[\"条目和索引\",{\"1\":{\"1517\":1}}],[\"条目接收处理线程\",{\"1\":{\"1514\":1}}],[\"条目推送器\",{\"1\":{\"1514\":1}}],[\"条目中的哈希码进行过滤\",{\"1\":{\"1174\":1}}],[\"条数据\",{\"1\":{\"724\":4,\"1017\":1}}],[\"条消息是\",{\"1\":{\"1445\":3}}],[\"条消息\",{\"1\":{\"701\":1,\"711\":1,\"712\":1,\"1090\":2,\"1188\":1,\"1445\":1}}],[\"条消息存储到集群中\",{\"1\":{\"700\":1}}],[\"条\",{\"1\":{\"700\":1,\"1104\":1,\"1218\":1,\"1230\":1,\"1468\":1}}],[\"条件是a\",{\"1\":{\"184\":1}}],[\"惰性队列\",{\"1\":{\"698\":1}}],[\"莫属\",{\"1\":{\"692\":1}}],[\"垃圾数据大小\",{\"1\":{\"688\":1}}],[\"合入pr\",{\"1\":{\"1284\":1}}],[\"合并后返回\",{\"1\":{\"1410\":1}}],[\"合并了\",{\"1\":{\"731\":1}}],[\"合并机制\",{\"0\":{\"688\":1}}],[\"合剂\",{\"1\":{\"485\":1}}],[\"持久化消费进度到磁盘\",{\"1\":{\"1200\":1,\"1201\":1}}],[\"持久化消费进度\",{\"1\":{\"1191\":1,\"1200\":3,\"1201\":2,\"1225\":1}}],[\"持久化消息存储\",{\"1\":{\"687\":1}}],[\"持久化时先保存到本地缓存\",{\"1\":{\"1190\":1}}],[\"持久化时保存到消费者本地\",{\"1\":{\"1190\":1}}],[\"持久化的机制来带的问题\",{\"1\":{\"942\":1}}],[\"持久化的过程是通过后台服务\",{\"1\":{\"768\":1}}],[\"持久化指的是数据保存在磁盘中\",{\"1\":{\"683\":1}}],[\"持久化\",{\"0\":{\"683\":1},\"1\":{\"1508\":1}}],[\"持续消费一个队列的消息\",{\"1\":{\"1206\":1}}],[\"持续直到取消或进行移动\",{\"1\":{\"487\":1}}],[\"持续多次高额\",{\"1\":{\"442\":1}}],[\"持续\",{\"1\":{\"431\":1,\"446\":1}}],[\"持续时间缩短25\",{\"1\":{\"405\":1}}],[\"意味着暂停该消息队列的消息拉取\",{\"1\":{\"1175\":1}}],[\"意味着暂时不返回给客户端\",{\"1\":{\"1173\":1}}],[\"意味着processqueue中拉取的消息将停止消费\",{\"1\":{\"1175\":1}}],[\"意味着将当前消息从\",{\"1\":{\"677\":1}}],[\"意思就是用javascript执行异步网络请求\",{\"1\":{\"347\":1}}],[\"意思是把消息\",{\"1\":{\"229\":1}}],[\"管理器\",{\"0\":{\"1222\":1}}],[\"管理的分布式锁\",{\"0\":{\"1209\":1}}],[\"管理员\",{\"1\":{\"978\":2}}],[\"管理员需要做出决定\",{\"1\":{\"677\":1}}],[\"管理\",{\"1\":{\"941\":1,\"1047\":1,\"1212\":1}}],[\"管理页面可以创建\",{\"1\":{\"711\":1}}],[\"管理页面使用\",{\"0\":{\"711\":1}}],[\"管理界面配置\",{\"0\":{\"652\":1}}],[\"鼓励读者熟悉仲裁队列\",{\"1\":{\"675\":1}}],[\"旨在完全代替原有的镜像队列\",{\"1\":{\"675\":1}}],[\"旨在编写更可伸缩高性能的应用\",{\"1\":{\"119\":1}}],[\"顺带一提\",{\"1\":{\"1300\":1}}],[\"顺便补上了之前遗漏的关于\",{\"1\":{\"736\":1}}],[\"顺着节点链表发送\",{\"1\":{\"674\":1}}],[\"顺着链表传送到所有的节点\",{\"1\":{\"673\":1}}],[\"顺序模式下\",{\"1\":{\"1187\":1}}],[\"顺序消费模式下重试次数配置无效\",{\"1\":{\"1241\":1}}],[\"顺序消费任务以时长计算\",{\"1\":{\"1230\":1}}],[\"顺序消费任务\",{\"0\":{\"1230\":1}}],[\"顺序消费时使用\",{\"1\":{\"1226\":1}}],[\"顺序消费流程\",{\"0\":{\"1219\":1}}],[\"顺序消费服务的消费线程池执行消费任务\",{\"1\":{\"1219\":1}}],[\"顺序消费服务的定时任务会每\",{\"1\":{\"1209\":1}}],[\"顺序消费服务中还包含了消费队列锁\",{\"1\":{\"1187\":1}}],[\"顺序消费还有一个敌人\",{\"1\":{\"1208\":1}}],[\"顺序消费的消费任务也由拉取任务提交\",{\"1\":{\"1206\":1}}],[\"顺序消费的设计的要点主要有两个\",{\"1\":{\"1204\":1}}],[\"顺序消费的设计和流程\",{\"1\":{\"1203\":1}}],[\"顺序消费的大致原理是依靠两组锁\",{\"1\":{\"1102\":1}}],[\"顺序消费\",{\"0\":{\"1202\":1},\"1\":{\"1224\":1,\"1270\":2,\"1538\":1}}],[\"顺序消费将会在下一篇进行讲解\",{\"1\":{\"1177\":1}}],[\"顺序消费则使用\",{\"1\":{\"1102\":1}}],[\"顺序消息逻辑主要在步骤\",{\"1\":{\"1203\":1}}],[\"顺序消息\",{\"1\":{\"1025\":1,\"1090\":1,\"1260\":1,\"1273\":1}}],[\"顺序消息的配置\",{\"1\":{\"950\":1,\"968\":1}}],[\"顺序生产的方式为串行生产\",{\"1\":{\"1102\":1}}],[\"顺序先分配第一个\",{\"1\":{\"1097\":1}}],[\"顺序写\",{\"0\":{\"877\":1},\"1\":{\"1394\":1,\"1412\":1}}],[\"顺序读写相比于随机读写省去了大部分的寻址时间\",{\"1\":{\"876\":1}}],[\"顺序读写\",{\"0\":{\"876\":1}}],[\"顺序程序的错误处理\",{\"0\":{\"193\":1}}],[\"顺序编程补遗\",{\"0\":{\"199\":1}}],[\"顺序编程\",{\"0\":{\"169\":1}}],[\"仍会重试\",{\"1\":{\"1100\":1}}],[\"仍旧进行协议相关的消息处理\",{\"1\":{\"672\":1}}],[\"仍然可以被写入\",{\"1\":{\"1300\":1}}],[\"仍然被阻塞\",{\"1\":{\"627\":1}}],[\"仍然能在关键伤害时治疗\",{\"1\":{\"405\":1}}],[\"仍然需要使用socket\",{\"1\":{\"71\":1}}],[\"效率更高\",{\"1\":{\"894\":1}}],[\"效率很低\",{\"1\":{\"890\":1}}],[\"效率较高\",{\"1\":{\"668\":1}}],[\"效果是\",{\"1\":{\"633\":1}}],[\"效果\",{\"1\":{\"421\":1}}],[\"您可以手动完全同步队列\",{\"1\":{\"658\":1}}],[\"磁盘的顺序读写性能要远好于随机读写\",{\"1\":{\"876\":1}}],[\"磁盘满了\",{\"1\":{\"870\":1}}],[\"磁盘空间大于85\",{\"1\":{\"870\":1}}],[\"磁盘空间不充足\",{\"1\":{\"870\":1}}],[\"磁盘空间是否不足\",{\"1\":{\"870\":1}}],[\"磁盘空间超过\",{\"1\":{\"864\":1}}],[\"磁盘容量达到\",{\"1\":{\"866\":1}}],[\"磁盘使用\",{\"0\":{\"699\":1}}],[\"磁盘\",{\"1\":{\"662\":1}}],[\"磁盘i\",{\"1\":{\"657\":1,\"1527\":1}}],[\"磁盘低水位\",{\"0\":{\"613\":1}}],[\"镜像\",{\"0\":{\"1072\":1}}],[\"镜像准备\",{\"0\":{\"1071\":1}}],[\"镜像打包实现\",{\"1\":{\"1069\":1}}],[\"镜像已恢复在线\",{\"1\":{\"677\":1}}],[\"镜像到所有节点会增加所有集群节点的负载\",{\"1\":{\"662\":1}}],[\"镜像到所有节点会给所有集群节点带来额外的负担\",{\"1\":{\"657\":1}}],[\"镜像数=节点数\",{\"1\":{\"657\":1}}],[\"镜像策略\",{\"0\":{\"657\":1}}],[\"镜像定义\",{\"1\":{\"652\":1}}],[\"镜像队列会选择一个主队列和多个从队列\",{\"1\":{\"693\":1}}],[\"镜像队列主要的问题是消息同步的性能\",{\"1\":{\"693\":1}}],[\"镜像队列主节点出现故障时\",{\"1\":{\"659\":1}}],[\"镜像队列是实现数据高可用的唯一手段\",{\"1\":{\"692\":1}}],[\"镜像队列master故障后的处理\",{\"1\":{\"679\":1}}],[\"镜像队列有如下几个设计缺陷\",{\"1\":{\"676\":1}}],[\"镜像队列有许多配置参数\",{\"1\":{\"656\":1}}],[\"镜像队列最大的问题是其同步算法造成的低性能\",{\"1\":{\"676\":1}}],[\"镜像队列实践\",{\"0\":{\"675\":1}}],[\"镜像队列同样由这两部分组成\",{\"1\":{\"672\":1}}],[\"镜像队列同时支持生产者确认和事务机制\",{\"1\":{\"663\":1}}],[\"镜像队列结构\",{\"0\":{\"672\":1}}],[\"镜像队列中的\",{\"1\":{\"668\":1}}],[\"镜像队列的性能会比较低下\",{\"1\":{\"693\":1}}],[\"镜像队列的设计缺陷\",{\"0\":{\"693\":1}}],[\"镜像队列的缺点\",{\"0\":{\"676\":1}}],[\"镜像队列的实现原理\",{\"0\":{\"670\":1}}],[\"镜像队列的gm算法实现\",{\"1\":{\"668\":1}}],[\"镜像队列的\",{\"1\":{\"668\":1}}],[\"镜像队列的数据流\",{\"0\":{\"667\":1},\"1\":{\"679\":1}}],[\"镜像队列原理\",{\"0\":{\"666\":1}}],[\"镜像队列显示的蓝色\",{\"1\":{\"655\":1}}],[\"镜像队列配置观测\",{\"0\":{\"655\":1}}],[\"镜像队列概述\",{\"0\":{\"649\":1}}],[\"镜像队列通过将一个队列镜像\",{\"1\":{\"648\":1}}],[\"镜像队列\",{\"0\":{\"647\":1},\"1\":{\"649\":1,\"679\":1,\"718\":1}}],[\"卸载\",{\"0\":{\"646\":1}}],[\"满足以下\",{\"1\":{\"1468\":1}}],[\"满足了阈值条件其中之一才进行上传\",{\"1\":{\"1403\":1}}],[\"满足的是\",{\"1\":{\"942\":1}}],[\"满足下列条件之一将继续删除\",{\"1\":{\"870\":1}}],[\"满足\",{\"1\":{\"870\":1}}],[\"满足使用前提\",{\"1\":{\"636\":1}}],[\"满分\",{\"1\":{\"400\":1}}],[\"授予它更多信用\",{\"1\":{\"627\":1}}],[\"若采用\",{\"1\":{\"1364\":1}}],[\"若\",{\"1\":{\"1364\":1}}],[\"若要避免这个情况\",{\"1\":{\"1363\":1}}],[\"若已经到期\",{\"1\":{\"1360\":1}}],[\"若当前连接处于blocked状态\",{\"1\":{\"625\":1}}],[\"若判断当前任务所有子任务已结束\",{\"1\":{\"378\":1}}],[\"达到流控效果\",{\"1\":{\"1355\":1,\"1370\":1}}],[\"达到请求的最大消息数量\",{\"1\":{\"1257\":1}}],[\"达到高可用的效果\",{\"1\":{\"941\":1}}],[\"达到更长的延迟时间\",{\"1\":{\"928\":1}}],[\"达到\",{\"1\":{\"915\":1}}],[\"达到消息不丢失\",{\"1\":{\"729\":1}}],[\"达成无限循环的效果\",{\"1\":{\"625\":1}}],[\"达加\",{\"0\":{\"473\":1}}],[\"见上\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"见上面天赋那栏\",{\"1\":{\"423\":1,\"429\":1,\"436\":1,\"449\":1,\"462\":1,\"469\":1}}],[\"见下面credit\",{\"1\":{\"624\":1}}],[\"井且也有若干个对应的队列处于flow状态时\",{\"1\":{\"622\":1}}],[\"尤其是对于\",{\"1\":{\"722\":1}}],[\"尤其是在发送大量较大的持久化消息时\",{\"1\":{\"622\":1}}],[\"尤其是在发送大量较小的持久化消息时\",{\"1\":{\"622\":1}}],[\"尤其是在发送大量较小的非持久化消息时\",{\"1\":{\"622\":1}}],[\"尤其通过强化学习\",{\"1\":{\"277\":1}}],[\"快\",{\"1\":{\"622\":1}}],[\"快速失败机制\",{\"1\":{\"1520\":1}}],[\"快速部署\",{\"0\":{\"1068\":1},\"1\":{\"1538\":1}}],[\"快速移除冰冻之血\",{\"1\":{\"432\":1}}],[\"快速移动\",{\"0\":{\"145\":1}}],[\"快速生长\",{\"1\":{\"405\":1}}],[\"快速获取当前页面的域名和路径\",{\"1\":{\"316\":1}}],[\"快速入门\",{\"0\":{\"292\":1}}],[\"快速排序\",{\"1\":{\"184\":1}}],[\"快速跳转插件\",{\"0\":{\"167\":1}}],[\"快速跳转到最后一次编辑的地方并进入插入模式\",{\"1\":{\"142\":1}}],[\"快速查询\",{\"0\":{\"149\":1}}],[\"快速修改\",{\"0\":{\"148\":1}}],[\"快速删除字符\",{\"1\":{\"147\":1}}],[\"快速删除\",{\"0\":{\"147\":1}}],[\"快速增删改查\",{\"0\":{\"146\":1}}],[\"快速返回\",{\"1\":{\"145\":1}}],[\"快速开始\",{\"0\":{\"5\":1}}],[\"协议集群节点的封装\",{\"1\":{\"1482\":1}}],[\"协议时\",{\"1\":{\"1290\":1}}],[\"协议中节点的\",{\"1\":{\"1477\":1}}],[\"协议中\",{\"1\":{\"1290\":1}}],[\"协议的\",{\"1\":{\"1290\":1}}],[\"协议的兼容\",{\"1\":{\"1284\":1,\"1291\":1}}],[\"协议的各种方法\",{\"1\":{\"621\":1}}],[\"协议可能需要的海量队列的场景\",{\"1\":{\"1284\":1}}],[\"协议对每一个写请求\",{\"1\":{\"942\":1}}],[\"协议\",{\"1\":{\"704\":1,\"1477\":1}}],[\"协议比镜像队列的算法更有效率\",{\"1\":{\"696\":1}}],[\"协议下的消息复制\",{\"0\":{\"695\":1}}],[\"协议连接\",{\"1\":{\"635\":1}}],[\"协议数据包\",{\"1\":{\"621\":1}}],[\"协议要相同\",{\"1\":{\"350\":1}}],[\"信息表\",{\"1\":{\"971\":1}}],[\"信息列表等数据\",{\"1\":{\"950\":1}}],[\"信息\",{\"1\":{\"944\":1,\"953\":1,\"954\":1,\"971\":1,\"972\":1,\"1053\":1,\"1188\":1,\"1294\":1}}],[\"信用值减一的操作仍然在rabbit\",{\"1\":{\"624\":1}}],[\"信用值耗尽后\",{\"1\":{\"622\":1}}],[\"信用值\",{\"1\":{\"621\":1}}],[\"信用证初始化时\",{\"1\":{\"621\":1}}],[\"信用证流控的两个参数可以通过查询环境变量的方式找到\",{\"1\":{\"618\":1}}],[\"信用证配置\",{\"0\":{\"618\":1}}],[\"信号\",{\"1\":{\"193\":1}}],[\"信号驱动\",{\"1\":{\"109\":1}}],[\"至此\",{\"1\":{\"932\":1,\"934\":1}}],[\"至此发送消息的动作才执行完毕\",{\"1\":{\"615\":1}}],[\"至少刷\",{\"1\":{\"769\":1}}],[\"至少会内部扩展\",{\"1\":{\"741\":1}}],[\"至少保证\",{\"1\":{\"434\":1}}],[\"端回查后发出的请求\",{\"1\":{\"1472\":1}}],[\"端过滤\",{\"0\":{\"1328\":1}}],[\"端消息拉取请求的入口\",{\"1\":{\"1318\":1}}],[\"端消费进度管理器\",{\"0\":{\"1201\":1}}],[\"端消费进度管理器会定时将消费进度表持久化到磁盘\",{\"1\":{\"1191\":1}}],[\"端心跳处理方法调用\",{\"1\":{\"1317\":1}}],[\"端有一个专门的消费者过滤信息管理器\",{\"1\":{\"1312\":1}}],[\"端完成\",{\"1\":{\"1255\":1}}],[\"端重平衡入口为\",{\"1\":{\"1255\":1}}],[\"端重平衡\",{\"0\":{\"1255\":1,\"1265\":1},\"1\":{\"1266\":1}}],[\"端发起请求\",{\"1\":{\"1252\":1}}],[\"端发送心跳\",{\"1\":{\"1312\":1}}],[\"端发送查询请求\",{\"1\":{\"1255\":1}}],[\"端发送请求\",{\"1\":{\"1252\":1}}],[\"端发送持久化请求\",{\"1\":{\"1183\":1}}],[\"端发送信号给所有消费者触发\",{\"1\":{\"1130\":1}}],[\"端并非毫无办法\",{\"1\":{\"1251\":1}}],[\"端会为这批消息保存一个\",{\"1\":{\"1251\":1}}],[\"端来分配每次拉取请求要拉取的队列并返回消息\",{\"1\":{\"1250\":1}}],[\"端做的\",{\"1\":{\"1245\":1}}],[\"端被设了过期时间\",{\"1\":{\"1209\":1}}],[\"端控制延迟时间\",{\"1\":{\"1198\":1}}],[\"端控制延迟等级\",{\"1\":{\"1197\":1}}],[\"端处理拉取消息请求时\",{\"1\":{\"1321\":1}}],[\"端处理拉取请求\",{\"0\":{\"1162\":1}}],[\"端处理拉取请求从存储中查询消息返回\",{\"1\":{\"1156\":1}}],[\"端处理消费者的拉取消息请求时执行\",{\"1\":{\"1313\":1}}],[\"端处理是由\",{\"1\":{\"1257\":1}}],[\"端处理客户端发回的消息\",{\"0\":{\"1198\":1}}],[\"端将延迟等级设置为重试消费次数\",{\"1\":{\"1197\":1}}],[\"端存储\",{\"1\":{\"1190\":1}}],[\"端存储着所有的消息\",{\"1\":{\"1188\":1}}],[\"端也有一个消费进度管理器\",{\"1\":{\"1191\":1}}],[\"端也有一个对应的消费进度管理器\",{\"1\":{\"1190\":1}}],[\"端也包含一个消费进度内存缓存表\",{\"1\":{\"1183\":1}}],[\"端也先放到内存\",{\"1\":{\"1104\":1}}],[\"端比较好\",{\"1\":{\"1181\":1}}],[\"端响应后会调用\",{\"1\":{\"1155\":1}}],[\"端拉取结果的响应\",{\"1\":{\"1155\":1}}],[\"端拉取流程设计\",{\"0\":{\"1153\":1}}],[\"端收到拉取请求后要做的就是将消息从磁盘中查询出来\",{\"1\":{\"1153\":1}}],[\"端\",{\"0\":{\"1256\":1,\"1260\":1,\"1261\":1,\"1268\":1,\"1272\":1,\"1274\":1},\"1\":{\"1102\":1,\"1149\":1,\"1183\":1,\"1214\":1,\"1250\":1,\"1314\":1,\"1319\":1}}],[\"端高可用\",{\"0\":{\"1033\":1}}],[\"端和客户端都需要进行一些配置\",{\"1\":{\"1004\":1}}],[\"端记录消息的方式\",{\"1\":{\"1003\":1}}],[\"端调用底层\",{\"1\":{\"994\":1}}],[\"端配置\",{\"0\":{\"983\":1,\"1005\":1}}],[\"端需要先在配置文件\",{\"1\":{\"979\":1}}],[\"端需要将消息根据投递时间排序后投递\",{\"1\":{\"836\":1}}],[\"端共同完成\",{\"1\":{\"979\":1}}],[\"端保存的路由信息\",{\"0\":{\"949\":1}}],[\"端只需要在消息上额外设置延迟等级即可\",{\"1\":{\"835\":1}}],[\"端通过\",{\"1\":{\"833\":1}}],[\"端不断地从数据存储对象\",{\"1\":{\"816\":1}}],[\"端参数\",{\"1\":{\"805\":1}}],[\"端无法监听和做出处理\",{\"1\":{\"614\":1}}],[\"端的高可用是用数据同步的方式\",{\"1\":{\"1033\":1}}],[\"端的流程\",{\"1\":{\"835\":1}}],[\"端的\",{\"1\":{\"614\":1,\"1212\":1,\"1253\":1}}],[\"端口进入\",{\"1\":{\"1081\":1}}],[\"端口号要相同\",{\"1\":{\"350\":1}}],[\"端口号总是由操作系统分配\",{\"1\":{\"68\":1}}],[\"端口的行为就像一个\",{\"1\":{\"241\":1}}],[\"描述这个对象\",{\"1\":{\"606\":1}}],[\"逐级向上层目录查找是否存在子目录node\",{\"1\":{\"600\":1}}],[\"逐一定义每一种情况的类型\",{\"1\":{\"547\":1}}],[\"省略模块文件的后缀名\",{\"1\":{\"591\":1}}],[\"暴露给外部的接口\",{\"1\":{\"591\":1}}],[\"暴击\",{\"1\":{\"421\":3,\"476\":1}}],[\"绕过排序\",{\"1\":{\"925\":1}}],[\"绕过\",{\"1\":{\"589\":1}}],[\"问题\",{\"0\":{\"580\":1}}],[\"问号后缀表示该成员是可选的\",{\"1\":{\"527\":1}}],[\"抽象成员\",{\"0\":{\"579\":1}}],[\"抽象类\",{\"0\":{\"579\":1},\"1\":{\"579\":1}}],[\"抽脸者\",{\"1\":{\"468\":1}}],[\"修正偏移量后继续查询事务半消息\",{\"1\":{\"1468\":1}}],[\"修复已知问题\",{\"1\":{\"1380\":1}}],[\"修饰符\",{\"1\":{\"577\":1}}],[\"修改了模型抽象\",{\"1\":{\"1380\":1}}],[\"修改内存配置\",{\"0\":{\"1080\":1}}],[\"修改监听端口\",{\"1\":{\"1075\":1}}],[\"修改映射到宿主机的\",{\"1\":{\"1075\":1}}],[\"修改一下\",{\"1\":{\"1075\":1}}],[\"修改过后在火焰图上已经几乎看不到该方法的用时\",{\"1\":{\"897\":1}}],[\"修改后\",{\"1\":{\"737\":1,\"1077\":1}}],[\"修改前\",{\"1\":{\"737\":1}}],[\"修改点\",{\"1\":{\"726\":1}}],[\"修改最大镜头距离\",{\"1\":{\"490\":1}}],[\"修改代码\",{\"1\":{\"271\":1}}],[\"修改配色\",{\"1\":{\"163\":1}}],[\"修改文件\",{\"1\":{\"152\":1}}],[\"修改\",{\"1\":{\"125\":2,\"978\":1,\"1075\":1}}],[\"别名\",{\"1\":{\"570\":1}}],[\"别去近战位贪那点输出\",{\"1\":{\"427\":1}}],[\"存到\",{\"1\":{\"1323\":1}}],[\"存到布隆过滤器中\",{\"1\":{\"1323\":1}}],[\"存到本地路由表\",{\"1\":{\"971\":1}}],[\"存盘\",{\"1\":{\"1277\":1}}],[\"存入位数组\",{\"1\":{\"1323\":1}}],[\"存入的原理是\",{\"1\":{\"1322\":1}}],[\"存入磁盘\",{\"1\":{\"1262\":1}}],[\"存入内存和磁盘\",{\"1\":{\"1258\":1}}],[\"存入之后统计数据并返回结果\",{\"1\":{\"1198\":1}}],[\"存入属性\",{\"1\":{\"1188\":1,\"1198\":1}}],[\"存入\",{\"1\":{\"1021\":1,\"1198\":1,\"1323\":1}}],[\"存入轨迹上下文\",{\"1\":{\"1020\":1}}],[\"存入调用上下文\",{\"1\":{\"1020\":1}}],[\"存活状态信息\",{\"1\":{\"971\":1}}],[\"存活状态\",{\"1\":{\"953\":1,\"954\":1,\"971\":1}}],[\"存在则返回\",{\"1\":{\"1511\":1}}],[\"存在多余的数据\",{\"1\":{\"1510\":1}}],[\"存在操作消息\",{\"1\":{\"1468\":1}}],[\"存在跨可用区的延迟\",{\"1\":{\"1385\":1}}],[\"存在消费队列中消息的\",{\"1\":{\"1318\":1}}],[\"存在消息丢失的可能\",{\"1\":{\"1090\":1}}],[\"存在一种边界条件\",{\"1\":{\"1215\":1}}],[\"存在同时运行的多个任务都是消费同一个队列的可能\",{\"1\":{\"1206\":1}}],[\"存在\",{\"1\":{\"1010\":1,\"1293\":1,\"1520\":1}}],[\"存在扩容可能性\",{\"1\":{\"909\":1}}],[\"存在性能上限\",{\"1\":{\"648\":1}}],[\"存放其他地方\",{\"1\":{\"1155\":1}}],[\"存放消费者的拉取请求\",{\"1\":{\"1152\":1}}],[\"存放到消息\",{\"1\":{\"839\":1,\"843\":1}}],[\"存放数据\",{\"1\":{\"787\":1}}],[\"存放一些基本信息\",{\"1\":{\"787\":1}}],[\"存储协议进行封装\",{\"1\":{\"1517\":1}}],[\"存储日志\",{\"0\":{\"1511\":1,\"1520\":1}}],[\"存储到\",{\"1\":{\"1464\":1}}],[\"存储分级存储中\",{\"1\":{\"1402\":2}}],[\"存储单个队列中的消息数据\",{\"1\":{\"1386\":1}}],[\"存储层存在两个瓶颈\",{\"1\":{\"1378\":1}}],[\"存储层查询消息的入口是\",{\"1\":{\"766\":1}}],[\"存储可变的body\",{\"1\":{\"1352\":1}}],[\"存储着\",{\"1\":{\"1346\":1}}],[\"存储所有消费者名称经过\",{\"1\":{\"1323\":1}}],[\"存储中匹配也由一个线程\",{\"1\":{\"1263\":1}}],[\"存储consumer消费进度\",{\"1\":{\"1173\":1}}],[\"存储消费者消费进度\",{\"1\":{\"1163\":1}}],[\"存储线程池发送任务\",{\"1\":{\"1021\":1}}],[\"存储每个消息轨迹的上下文\",{\"1\":{\"1021\":1}}],[\"存储时间\",{\"1\":{\"1017\":1}}],[\"存储在本地磁盘上\",{\"1\":{\"1394\":1,\"1412\":1}}],[\"存储在内存中\",{\"1\":{\"1290\":1}}],[\"存储在\",{\"1\":{\"1010\":1}}],[\"存储在堆外内存的数据会丢失\",{\"1\":{\"883\":1}}],[\"存储集群中所有\",{\"1\":{\"949\":1}}],[\"存储已经搞定了\",{\"1\":{\"930\":1}}],[\"存储和投递\",{\"1\":{\"930\":1}}],[\"存储最终方案\",{\"0\":{\"929\":1}}],[\"存储设计面临的两个最大的问题就是\",{\"1\":{\"926\":1}}],[\"存储设计是最重要的\",{\"1\":{\"926\":1}}],[\"存储设计\",{\"0\":{\"926\":1,\"1012\":1}}],[\"存储包\",{\"1\":{\"827\":1}}],[\"存储\",{\"1\":{\"790\":1,\"970\":1,\"1061\":2,\"1103\":1,\"1514\":1,\"1519\":1}}],[\"存储的该条日志内容与\",{\"1\":{\"1520\":1}}],[\"存储的该条日志与\",{\"1\":{\"1520\":1}}],[\"存储的内容与请求的一致返回\",{\"1\":{\"1511\":1}}],[\"存储的最大日志序号相同\",{\"1\":{\"1519\":1}}],[\"存储的最大日志序号\",{\"1\":{\"1511\":3,\"1520\":6}}],[\"存储的低成本和速度无法兼得\",{\"1\":{\"1378\":1}}],[\"存储的\",{\"1\":{\"1065\":1}}],[\"存储的每个值是在索引文件中\",{\"1\":{\"787\":1}}],[\"存储的消息的最大物理偏移量\",{\"1\":{\"787\":1}}],[\"存储的消息的最小物理偏移量\",{\"1\":{\"787\":1}}],[\"存储的一部分\",{\"1\":{\"777\":1}}],[\"存储功能\",{\"1\":{\"777\":1}}],[\"存储系统的一部分\",{\"1\":{\"746\":1}}],[\"存储模型与抽象\",{\"0\":{\"1386\":1}}],[\"存储模型\",{\"0\":{\"1402\":1},\"1\":{\"700\":1}}],[\"存储结构如下图所示\",{\"1\":{\"1346\":1}}],[\"存储结构\",{\"0\":{\"687\":1,\"787\":1}}],[\"存储机制\",{\"0\":{\"680\":1,\"686\":1},\"1\":{\"718\":1}}],[\"存储数据\",{\"0\":{\"247\":1}}],[\"存值器用来写入属性\",{\"1\":{\"567\":1}}],[\"存取器\",{\"1\":{\"567\":1}}],[\"存取器方法\",{\"0\":{\"567\":1}}],[\"综上所述\",{\"1\":{\"564\":1,\"668\":1}}],[\"额外在对象外部给出函数方法的实现\",{\"1\":{\"558\":1}}],[\"兼容前面的重载\",{\"1\":{\"547\":1}}],[\"声明\",{\"1\":{\"547\":1}}],[\"声明其他类型\",{\"1\":{\"545\":1}}],[\"局部类型\",{\"0\":{\"545\":1}}],[\"局部作用域\",{\"0\":{\"314\":1}}],[\"断言\",{\"0\":{\"524\":1},\"1\":{\"589\":1}}],[\"断开连接\",{\"1\":{\"125\":1}}],[\"赋值过程省略\",{\"1\":{\"1271\":1}}],[\"赋值时会自动更新类型推断\",{\"1\":{\"523\":1}}],[\"赋值为包装对象就会报错\",{\"1\":{\"509\":1}}],[\"凡是可以使用父类型的地方\",{\"1\":{\"520\":1}}],[\"交互模式\",{\"1\":{\"1171\":1}}],[\"交互流程\",{\"0\":{\"1149\":1}}],[\"交互的客户端实例\",{\"1\":{\"950\":1}}],[\"交互\",{\"0\":{\"945\":1}}],[\"交换\",{\"1\":{\"725\":1}}],[\"交换器和仲裁队列一起使用不太合适\",{\"1\":{\"701\":1}}],[\"交叉类型a\",{\"1\":{\"516\":1}}],[\"交叉类型\",{\"0\":{\"516\":1}}],[\"交付与运维系统的方式变的越发复杂\",{\"1\":{\"276\":1}}],[\"区分的消息轨迹数据表\",{\"1\":{\"1021\":1}}],[\"区分该值到底属于哪一种类型\",{\"1\":{\"515\":1}}],[\"区别是分级存储的\",{\"1\":{\"1402\":1}}],[\"区别在于\",{\"1\":{\"1245\":1}}],[\"区别\",{\"1\":{\"564\":1}}],[\"区块\",{\"1\":{\"194\":1}}],[\"紫\",{\"1\":{\"515\":1}}],[\"紫卵\",{\"1\":{\"483\":1}}],[\"青\",{\"1\":{\"515\":1}}],[\"绿\",{\"1\":{\"515\":1}}],[\"绿色的\",{\"1\":{\"120\":1,\"1511\":1}}],[\"黄色为主动触发\",{\"1\":{\"1136\":1}}],[\"黄\",{\"1\":{\"515\":1}}],[\"橙色\",{\"1\":{\"1156\":1}}],[\"橙\",{\"1\":{\"515\":1}}],[\"赤\",{\"1\":{\"515\":1}}],[\"联想\",{\"1\":{\"1346\":1}}],[\"联合类型可以与值类型相结合\",{\"1\":{\"515\":1}}],[\"联合类型a|b表示\",{\"1\":{\"515\":1}}],[\"联合类型\",{\"0\":{\"515\":1},\"1\":{\"515\":1}}],[\"联系\",{\"1\":{\"398\":1}}],[\"遇到const命令声明的变量\",{\"1\":{\"514\":1}}],[\"建议关闭主动触发\",{\"1\":{\"1128\":1}}],[\"建议为消息指定\",{\"1\":{\"1006\":1}}],[\"建议至少\",{\"1\":{\"734\":1}}],[\"建议复制到\",{\"1\":{\"662\":1}}],[\"建议设置的副本值为大多数节点n\",{\"1\":{\"657\":1}}],[\"建议优先使用\",{\"1\":{\"564\":1}}],[\"建议总是使用小写类型object\",{\"1\":{\"512\":1}}],[\"建议只使用小写类型\",{\"1\":{\"509\":1}}],[\"剩下的消息再根据消息详情过滤\",{\"1\":{\"1313\":1}}],[\"剩下三种可以\",{\"1\":{\"508\":1}}],[\"剩下元素是列表尾\",{\"1\":{\"177\":1}}],[\"五种原始类型的值\",{\"1\":{\"508\":1}}],[\"五种属于原始类型\",{\"1\":{\"508\":1}}],[\"缩容的场景下\",{\"1\":{\"1379\":1}}],[\"缩小\",{\"1\":{\"503\":1}}],[\"缩短的冷却时间就越多\",{\"1\":{\"405\":1}}],[\"污染问题\",{\"0\":{\"1363\":1}}],[\"污染\",{\"1\":{\"502\":1}}],[\"底层是分级存储\",{\"1\":{\"1402\":1}}],[\"底层是一个\",{\"1\":{\"815\":1}}],[\"底层存储之那些你不知道的事\",{\"1\":{\"884\":1,\"1537\":1}}],[\"底层存储实现\",{\"1\":{\"790\":1}}],[\"底层使用内存映射文件\",{\"1\":{\"790\":1}}],[\"底层类型\",{\"1\":{\"501\":1}}],[\"底层通信走的仍然是安全的ssl\",{\"1\":{\"368\":1}}],[\"报错\",{\"1\":{\"503\":2,\"509\":1,\"512\":3,\"514\":1,\"524\":3,\"540\":1,\"545\":1,\"552\":2,\"555\":1,\"579\":1,\"592\":1}}],[\"报错就停止编译\",{\"1\":{\"498\":1}}],[\"报告匹配的次数而不替换\",{\"1\":{\"150\":1}}],[\"属于内核空间\",{\"1\":{\"880\":1}}],[\"属于\",{\"1\":{\"777\":1}}],[\"属于静态类型语言\",{\"1\":{\"495\":1}}],[\"属性a存在且属性a的值为abc或a的值不为def\",{\"1\":{\"1308\":1}}],[\"属性a存在且属性a的值为abc或def\",{\"1\":{\"1308\":1}}],[\"属性a存在且属性a的值小于10或大于100\",{\"1\":{\"1308\":1}}],[\"属性a存在且属性a的值大于等于10且小于等于100\",{\"1\":{\"1308\":1}}],[\"属性a存在且属性a的值大于100或属性b不存在\",{\"1\":{\"1308\":1}}],[\"属性a存在且属性a的值大于100\",{\"1\":{\"1308\":1}}],[\"属性a存在\",{\"1\":{\"1308\":1}}],[\"属性a不存在\",{\"1\":{\"1308\":1}}],[\"属性进行配置\",{\"1\":{\"850\":1}}],[\"属性中\",{\"1\":{\"834\":1}}],[\"属性来进行路由\",{\"1\":{\"715\":1}}],[\"属性设置为\",{\"1\":{\"684\":1,\"1449\":1}}],[\"属性名等\",{\"1\":{\"606\":1}}],[\"属性名的索引类型\",{\"0\":{\"553\":1}}],[\"属性索引\",{\"0\":{\"568\":1},\"1\":{\"558\":1}}],[\"属性类型以逗号结尾\",{\"1\":{\"550\":1}}],[\"属性优先级\",{\"0\":{\"476\":1}}],[\"属性数值和它对应的效果是线性增长的\",{\"1\":{\"421\":1}}],[\"属性\",{\"0\":{\"202\":1},\"1\":{\"421\":1,\"714\":1,\"837\":1,\"1188\":1,\"1240\":1,\"1287\":1,\"1293\":1,\"1294\":1,\"1296\":1,\"1424\":1,\"1450\":1}}],[\"阮一峰\",{\"0\":{\"493\":1}}],[\"蓝色为被动触发\",{\"1\":{\"1136\":1}}],[\"蓝\",{\"1\":{\"515\":1}}],[\"蓝耗\",{\"1\":{\"492\":1}}],[\"蓝量也可能吃紧\",{\"1\":{\"403\":1}}],[\"队列未满\",{\"1\":{\"1516\":1}}],[\"队列构成\",{\"1\":{\"1402\":2}}],[\"队列剩余消息\",{\"1\":{\"1270\":1}}],[\"队列剩余消息数量\",{\"1\":{\"1270\":1}}],[\"队列中没有\",{\"1\":{\"1371\":1}}],[\"队列中的第一个消息延迟\",{\"1\":{\"1342\":1}}],[\"队列中的多个消息并发消费\",{\"1\":{\"1203\":1}}],[\"队列中消息的逻辑\",{\"1\":{\"1278\":1}}],[\"队列中剩余的消息数量\",{\"1\":{\"1269\":1}}],[\"队列分配完成后对队列进行解锁和加锁\",{\"1\":{\"1224\":1}}],[\"队列分配策略\",{\"1\":{\"1138\":1}}],[\"队列间并发消费\",{\"1\":{\"1203\":1}}],[\"队列offset\",{\"1\":{\"1173\":1}}],[\"队列负载机制\",{\"0\":{\"1097\":1}}],[\"队列负载机制与重平衡\",{\"0\":{\"1096\":1,\"1101\":1}}],[\"队列独占\",{\"1\":{\"1095\":1}}],[\"队列级别顺序消息\",{\"1\":{\"1028\":1}}],[\"队列信息\",{\"1\":{\"953\":1,\"971\":1}}],[\"队列信息中包含了其所在的\",{\"1\":{\"944\":1}}],[\"队列路由信息发送给\",{\"1\":{\"952\":1}}],[\"队列元数据\",{\"1\":{\"950\":1,\"968\":1}}],[\"队列下的消费\",{\"1\":{\"913\":1}}],[\"队列编号\",{\"1\":{\"822\":1}}],[\"队列id\",{\"1\":{\"767\":1,\"1174\":1}}],[\"队列仍然没有办法恢复\",{\"1\":{\"703\":1}}],[\"队列仍然可以提供服务的效果\",{\"1\":{\"692\":1}}],[\"队列的路由信息\",{\"1\":{\"945\":1}}],[\"队列的第一个文件\",{\"1\":{\"866\":1}}],[\"队列的规划和监控边得比普通场景下更为重要\",{\"1\":{\"702\":1}}],[\"队列的master位于节点a上\",{\"1\":{\"659\":1}}],[\"队列消息不断堆积\",{\"1\":{\"702\":1}}],[\"队列长度限制可用\",{\"1\":{\"698\":1}}],[\"队列结构\",{\"0\":{\"689\":1}}],[\"队列索引\",{\"1\":{\"687\":1}}],[\"队列索引和消息存储\",{\"1\":{\"687\":1}}],[\"队列持久化仅仅指的是队列元数据持久化\",{\"1\":{\"684\":1}}],[\"队列持久化\",{\"0\":{\"684\":1}}],[\"队列master进程所在的节点是2进2出\",{\"1\":{\"669\":1}}],[\"队列\",{\"1\":{\"668\":1,\"689\":1,\"698\":1,\"716\":1,\"1267\":1,\"1269\":1,\"1271\":1,\"1275\":1,\"1372\":1,\"1463\":1,\"1464\":1}}],[\"队列同步是一个阻塞操作\",{\"1\":{\"658\":1}}],[\"队列将自动同步\",{\"1\":{\"658\":1}}],[\"队列将被镜像到该节点\",{\"1\":{\"657\":1}}],[\"队列被镜像到节点名中列出的节点\",{\"1\":{\"657\":1}}],[\"队列跨集群中的所有节点镜像\",{\"1\":{\"657\":1}}],[\"队列镜像将根据配置的镜像提升策略自动提升到主服务器\",{\"1\":{\"657\":1}}],[\"队友技能等等都有语音提示\",{\"1\":{\"491\":1}}],[\"队伍尽量集合站在百花齐放圈里\",{\"1\":{\"434\":1}}],[\"她的语音提示基本上把大米轮椅化了\",{\"1\":{\"491\":1}}],[\"姓名版\",{\"1\":{\"491\":1}}],[\"监控\",{\"1\":{\"491\":1}}],[\"监听acl配置文件变化\",{\"1\":{\"999\":1}}],[\"监听配置文件变化\",{\"1\":{\"996\":1}}],[\"监听读取操作\",{\"1\":{\"124\":1}}],[\"监听客户端连接上的\",{\"1\":{\"124\":1}}],[\"监听某个端口进来的客户端连接和请求\",{\"1\":{\"121\":1}}],[\"监听\",{\"1\":{\"119\":1,\"132\":2,\"133\":1}}],[\"监听事件的集合\",{\"1\":{\"118\":1}}],[\"监听端口\",{\"1\":{\"73\":1}}],[\"监听指定端口\",{\"1\":{\"69\":1,\"72\":1}}],[\"阐明了大米中使用的插件和用法\",{\"1\":{\"491\":1}}],[\"清除投票轮次与当前轮次不同的水位线\",{\"1\":{\"1521\":1}}],[\"清除已过期的节点日志保存水位线\",{\"1\":{\"1521\":1}}],[\"清除\",{\"1\":{\"1521\":1}}],[\"清除过期的\",{\"1\":{\"1512\":1,\"1521\":1}}],[\"清除离线的broker\",{\"1\":{\"1048\":1}}],[\"清除腐蚀\",{\"1\":{\"490\":2}}],[\"清理完多余的数据\",{\"1\":{\"1519\":1}}],[\"清理的策略一般是\",{\"1\":{\"879\":1}}],[\"清理的条件比较多\",{\"1\":{\"870\":1}}],[\"清理\",{\"1\":{\"869\":2,\"871\":1,\"872\":2}}],[\"清空挂起的日志转发请求\",{\"1\":{\"1519\":1}}],[\"清空旧数据\",{\"1\":{\"125\":1}}],[\"清空\",{\"1\":{\"125\":1,\"1428\":1}}],[\"清空就绪通道的\",{\"1\":{\"122\":1}}],[\"清空输出流\",{\"1\":{\"54\":1}}],[\"敌方安抚\",{\"1\":{\"490\":1}}],[\"友方清除腐蚀\",{\"1\":{\"490\":1}}],[\"横扫\",{\"1\":{\"490\":2}}],[\"横扫攒豆\",{\"1\":{\"412\":1}}],[\"狂暴回复\",{\"1\":{\"490\":1}}],[\"狂野风暴\",{\"1\":{\"468\":1}}],[\"熊形态\",{\"1\":{\"490\":2}}],[\"急奔\",{\"1\":{\"490\":1}}],[\"急速到\",{\"1\":{\"476\":1}}],[\"急速只提供\",{\"1\":{\"421\":1}}],[\"急速加成\",{\"1\":{\"421\":2}}],[\"急速效果加成\",{\"1\":{\"421\":1}}],[\"急速提供\",{\"1\":{\"421\":1}}],[\"急速之前\",{\"1\":{\"421\":1}}],[\"急速\",{\"1\":{\"421\":3,\"476\":1}}],[\"旅行形态\",{\"1\":{\"490\":3}}],[\"猎豹形态\",{\"1\":{\"490\":4}}],[\"潜行\",{\"1\":{\"490\":3}}],[\"赶路\",{\"1\":{\"490\":1}}],[\"迎头痛击\",{\"1\":{\"490\":2}}],[\"焦点打断\",{\"1\":{\"490\":1}}],[\"乌索尔旋风\",{\"1\":{\"489\":2}}],[\"乌索尔旋风鼠标指向\",{\"1\":{\"489\":1}}],[\"乌比斯将军\",{\"0\":{\"471\":1}}],[\"愤怒\",{\"1\":{\"489\":3}}],[\"愤怒鞭挞\",{\"1\":{\"454\":1}}],[\"鼠标指向宏\",{\"0\":{\"489\":1}}],[\"涵盖几乎原文提供的宏\",{\"1\":{\"488\":1}}],[\"激活\",{\"1\":{\"490\":2,\"1514\":2}}],[\"激活自己\",{\"1\":{\"490\":1}}],[\"激活之后遁入阴影\",{\"1\":{\"487\":1}}],[\"激流破奔是这个\",{\"1\":{\"466\":1}}],[\"影遁\",{\"1\":{\"487\":1}}],[\"影遁在某些副本中非常重要\",{\"1\":{\"487\":1}}],[\"影响\",{\"0\":{\"249\":1}}],[\"焰心威权\",{\"1\":{\"486\":1}}],[\"绚灿急速\",{\"1\":{\"486\":1}}],[\"卫士进击\",{\"1\":{\"486\":1}}],[\"夕阳魔线\",{\"1\":{\"486\":1}}],[\"腿\",{\"1\":{\"486\":1}}],[\"腿部\",{\"1\":{\"479\":1,\"480\":1}}],[\"晶脉辉煌\",{\"1\":{\"486\":1}}],[\"晶化强化符文\",{\"1\":{\"485\":1}}],[\"胸部\",{\"1\":{\"486\":1}}],[\"胸甲\",{\"1\":{\"479\":1,\"480\":1}}],[\"迅捷蓝玉\",{\"1\":{\"485\":1}}],[\"迅捷翡翠\",{\"1\":{\"485\":1}}],[\"迅捷治愈\",{\"1\":{\"489\":2}}],[\"迅捷治愈+树人\",{\"1\":{\"489\":1}}],[\"迅捷治愈的治疗效果提高\",{\"1\":{\"409\":1}}],[\"迅捷治愈的冷却时间缩短最多40\",{\"1\":{\"405\":1}}],[\"迅捷治愈不再消耗一个持续治疗效果\",{\"1\":{\"405\":2}}],[\"顶级开源分布式高可用消息队列\",{\"1\":{\"919\":1}}],[\"顶级java才懂的\",{\"1\":{\"15\":1}}],[\"顶层类型\",{\"1\":{\"501\":1}}],[\"顶峰渎神玉\",{\"1\":{\"485\":1}}],[\"头插法\",{\"1\":{\"1393\":1}}],[\"头盔\",{\"1\":{\"486\":1}}],[\"头\",{\"1\":{\"485\":1,\"1042\":1}}],[\"头部\",{\"1\":{\"479\":1,\"480\":1}}],[\"拍卖行可买\",{\"1\":{\"485\":1}}],[\"项链\",{\"1\":{\"485\":1}}],[\"项目就应用了\",{\"1\":{\"1284\":1}}],[\"项目是\",{\"1\":{\"1076\":1}}],[\"项目已经将\",{\"1\":{\"1075\":1}}],[\"项目中增加依赖\",{\"1\":{\"272\":1}}],[\"项目\",{\"1\":{\"269\":1}}],[\"宝石\",{\"1\":{\"485\":1}}],[\"淬火药水\",{\"1\":{\"485\":1}}],[\"淬火矫健合剂\",{\"1\":{\"485\":1}}],[\"洞穴住民的挚爱\",{\"1\":{\"485\":1}}],[\"战治疗压力低的时候进行输出顺便回蓝\",{\"1\":{\"492\":1}}],[\"战斗药水\",{\"1\":{\"485\":1}}],[\"战队治疗组智囊\",{\"1\":{\"398\":1}}],[\"降为\",{\"1\":{\"1497\":1}}],[\"降级为\",{\"1\":{\"1492\":1}}],[\"降圣白昼盛宴\",{\"1\":{\"485\":1}}],[\"降低网络传输次数\",{\"1\":{\"1028\":1}}],[\"降低敌人侦测到你的几率\",{\"1\":{\"487\":1}}],[\"降低万灵的\",{\"1\":{\"405\":1}}],[\"降低debug成本\",{\"1\":{\"371\":1}}],[\"降低了响应速度\",{\"1\":{\"130\":1}}],[\"食物\",{\"1\":{\"485\":1}}],[\"倍的心跳超时\",{\"1\":{\"1477\":1}}],[\"倍的扬升效果\",{\"1\":{\"484\":1}}],[\"倍以上\",{\"1\":{\"1388\":1}}],[\"倍左右\",{\"1\":{\"850\":1,\"853\":1}}],[\"倍性能的提升\",{\"1\":{\"742\":1}}],[\"倍\",{\"1\":{\"700\":1,\"701\":1,\"734\":1,\"850\":1}}],[\"倍伤害\",{\"1\":{\"401\":1}}],[\"神话装备最高是\",{\"1\":{\"484\":1}}],[\"神牧\",{\"1\":{\"398\":1}}],[\"蠕动装甲带\",{\"1\":{\"484\":1}}],[\"美团技术团队\",{\"1\":{\"1527\":1}}],[\"美化\",{\"0\":{\"484\":1}}],[\"美国国家标准学会\",{\"1\":{\"27\":1}}],[\"卵囊\",{\"1\":{\"483\":1}}],[\"据很多人说甲虫饰品也是大米高层一个不错的选择\",{\"1\":{\"482\":1}}],[\"间的复制\",{\"1\":{\"633\":1}}],[\"间谍大师裹网\",{\"1\":{\"482\":1}}],[\"间隔为30秒\",{\"1\":{\"284\":1}}],[\"聊天框输入\",{\"1\":{\"480\":1}}],[\"聊聊netty那些事儿之从内核角度看io模型\",{\"1\":{\"136\":1}}],[\"露露插件包默认已经整合\",{\"1\":{\"480\":1}}],[\"护存暗渊之桶\",{\"1\":{\"480\":1}}],[\"护腕\",{\"1\":{\"479\":1,\"480\":1,\"485\":1}}],[\"唤醒心跳线程\",{\"1\":{\"1499\":1}}],[\"唤醒的消息发到重试\",{\"1\":{\"1280\":1}}],[\"唤醒没有被\",{\"1\":{\"1280\":2}}],[\"唤醒队列\",{\"1\":{\"1270\":1}}],[\"唤醒重试的时间\",{\"1\":{\"1259\":1}}],[\"唤醒重平衡线程\",{\"1\":{\"1120\":1,\"1122\":1}}],[\"唤醒\",{\"1\":{\"1253\":1,\"1511\":1,\"1519\":2}}],[\"唤醒本地的重平衡线程\",{\"1\":{\"1128\":1}}],[\"唤醒长轮询的消费端请求\",{\"1\":{\"825\":1}}],[\"唤醒对应队列挂起的拉取请求\",{\"1\":{\"815\":1}}],[\"唤焰者的便鞋\",{\"1\":{\"480\":1}}],[\"唤雾者\",{\"0\":{\"452\":1}}],[\"荧光之线马裤\",{\"1\":{\"480\":1}}],[\"钢铁掠夺者手套\",{\"1\":{\"480\":1}}],[\"涂脏大衣\",{\"1\":{\"480\":1}}],[\"砧皮斗篷\",{\"1\":{\"480\":1}}],[\"钥匙链\",{\"1\":{\"480\":1}}],[\"紧急制动\",{\"1\":{\"480\":1}}],[\"紧接着就是不断打本练习\",{\"1\":{\"399\":1}}],[\"副手\",{\"1\":{\"480\":1}}],[\"副手副手\",{\"1\":{\"479\":1}}],[\"副本镜像队列\",{\"1\":{\"700\":1}}],[\"副本镜像\",{\"1\":{\"652\":1}}],[\"副本\",{\"0\":{\"422\":1}}],[\"副本同键\",{\"1\":{\"248\":1}}],[\"武器油\",{\"1\":{\"485\":1}}],[\"武器\",{\"1\":{\"479\":1,\"486\":1}}],[\"饰品\",{\"0\":{\"481\":1},\"1\":{\"479\":2,\"480\":2}}],[\"缝肉的错位玺戒\",{\"1\":{\"479\":1,\"480\":1}}],[\"戒指可以用卓越珠宝师的底座\",{\"1\":{\"485\":1}}],[\"戒指\",{\"1\":{\"479\":2,\"486\":1}}],[\"靴子\",{\"1\":{\"479\":1,\"480\":1}}],[\"腰带可以用蛛魔宝石编织者\",{\"1\":{\"485\":1}}],[\"腰带\",{\"1\":{\"479\":1,\"480\":1}}],[\"制造业装等是\",{\"1\":{\"484\":1}}],[\"制造业\",{\"1\":{\"479\":2}}],[\"制定了一套英文字母\",{\"1\":{\"27\":1}}],[\"悲碎之翼\",{\"1\":{\"479\":1}}],[\"披风\",{\"1\":{\"479\":1,\"480\":1,\"486\":1}}],[\"‍nerubian\",{\"1\":{\"486\":1}}],[\"‍仙曲钢铁乐杖\",{\"1\":{\"480\":1}}],[\"‍折翼肩章\",{\"1\":{\"480\":1}}],[\"‍具现毒瘴节杖\",{\"1\":{\"479\":1}}],[\"‍大山猫开膛之爪\",{\"1\":{\"479\":1}}],[\"‍大山猫之皮\",{\"1\":{\"479\":1}}],[\"‍大山猫之喉\",{\"1\":{\"479\":1}}],[\"‍密道兜帽\",{\"1\":{\"479\":1,\"480\":1}}],[\"肩部\",{\"1\":{\"479\":1,\"480\":1}}],[\"团队框架\",{\"1\":{\"491\":1}}],[\"团队会受到暗影之幕吸奶盾\",{\"1\":{\"445\":1}}],[\"团本\",{\"0\":{\"480\":1}}],[\"团本老二\",{\"1\":{\"479\":1}}],[\"团本老四\",{\"1\":{\"479\":1}}],[\"团本老三\",{\"1\":{\"479\":1}}],[\"席克兰\",{\"1\":{\"479\":1}}],[\"苏雷吉狂热者的徽章\",{\"1\":{\"479\":1}}],[\"苏雷吉缚丝者\",{\"1\":{\"435\":1}}],[\"颈部\",{\"1\":{\"479\":1,\"480\":1}}],[\"物理文件正在被删除\",{\"1\":{\"1174\":1}}],[\"物理\",{\"1\":{\"767\":1,\"1004\":1,\"1012\":1}}],[\"物理节点\",{\"1\":{\"396\":1}}],[\"物品\",{\"1\":{\"479\":1,\"480\":1}}],[\"装备\",{\"0\":{\"478\":1}}],[\"装饰器的结构\",{\"0\":{\"606\":1}}],[\"装饰器用来在定义时修改类的行为\",{\"1\":{\"605\":1}}],[\"装饰器\",{\"0\":{\"320\":1,\"604\":1}}],[\"衰减阈值\",{\"1\":{\"476\":1}}],[\"智力\",{\"1\":{\"476\":1}}],[\"腐蚀\",{\"1\":{\"475\":1}}],[\"怒火渐燃\",{\"1\":{\"475\":1}}],[\"暗月徽记\",{\"1\":{\"484\":1}}],[\"暗影飓风\",{\"1\":{\"479\":1,\"480\":1}}],[\"暗影之伤\",{\"1\":{\"475\":1}}],[\"暗影烈焰笼罩\",{\"1\":{\"475\":1}}],[\"暗黑法球\",{\"1\":{\"448\":1}}],[\"造成写放大\",{\"1\":{\"1468\":1}}],[\"造成随机读写\",{\"1\":{\"1453\":1}}],[\"造成多线程情况下可能会等待直到超时\",{\"1\":{\"915\":1}}],[\"造成灼烧炽热的群体\",{\"1\":{\"475\":1}}],[\"造成的是物理伤害\",{\"1\":{\"425\":1}}],[\"扬升\",{\"1\":{\"484\":1}}],[\"扬升和黑暗喷发\",{\"1\":{\"475\":1}}],[\"扬升者维斯可里亚\",{\"1\":{\"448\":2}}],[\"鲁莽战术\",{\"1\":{\"475\":1}}],[\"思维链\",{\"1\":{\"475\":1}}],[\"思莹\",{\"1\":{\"286\":1}}],[\"暮光执行者\",{\"1\":{\"475\":1}}],[\"暮光术士\",{\"1\":{\"475\":1}}],[\"暮光熔岩操纵使\",{\"1\":{\"475\":1}}],[\"暮光监督者\",{\"1\":{\"475\":1}}],[\"暮光毁灭者\",{\"1\":{\"475\":1}}],[\"暮光欺诈者\",{\"1\":{\"475\":1}}],[\"暮光唤地者\",{\"1\":{\"475\":1}}],[\"剧烈震颤\",{\"1\":{\"475\":1}}],[\"埃鲁达克\",{\"0\":{\"474\":1}}],[\"燃影者\",{\"0\":{\"473\":1}}],[\"燃烧之影被驱散掉之后\",{\"1\":{\"445\":1}}],[\"铸炉之主索朗格斯\",{\"0\":{\"472\":1}}],[\"碾压重击\",{\"1\":{\"468\":1}}],[\"瞄准火炮\",{\"1\":{\"468\":1}}],[\"炽热弹雨\",{\"1\":{\"468\":1}}],[\"炽烈弹射的目标要开减伤\",{\"1\":{\"465\":1}}],[\"火焰炸弹\",{\"1\":{\"468\":1}}],[\"雕骨执行者\",{\"1\":{\"468\":1}}],[\"恶臭喷吐\",{\"1\":{\"468\":1}}],[\"恶臭齐射\",{\"1\":{\"428\":1}}],[\"窒息之水\",{\"1\":{\"468\":1}}],[\"水位\",{\"1\":{\"1514\":1}}],[\"水位表中包含了集群中所有节点的当前日志复制水位\",{\"1\":{\"1512\":1}}],[\"水位线\",{\"1\":{\"1508\":1,\"1519\":1}}],[\"水位线只是一个警示\",{\"1\":{\"1300\":1}}],[\"水鼠帮歼灭者\",{\"1\":{\"468\":1}}],[\"水鼠帮劫掠者\",{\"1\":{\"468\":1}}],[\"水鼠帮唤风者\",{\"1\":{\"468\":1}}],[\"水平扩容指部署\",{\"1\":{\"648\":1}}],[\"水平分割\",{\"1\":{\"153\":1}}],[\"水平移动\",{\"1\":{\"145\":1}}],[\"强制滚动时间\",{\"1\":{\"1382\":1}}],[\"强制读取分级存储\",{\"1\":{\"1382\":1}}],[\"强制删除\",{\"1\":{\"870\":1}}],[\"强制刷盘\",{\"1\":{\"796\":1}}],[\"强制将写满的文件刷盘\",{\"1\":{\"789\":1}}],[\"强制通过var申明变量\",{\"1\":{\"296\":1}}],[\"强化符文\",{\"1\":{\"485\":1}}],[\"强化怒吼\",{\"1\":{\"468\":1}}],[\"强能水晶\",{\"1\":{\"483\":1}}],[\"艾什凡观察员\",{\"1\":{\"468\":1}}],[\"艾什凡指挥官\",{\"1\":{\"468\":2}}],[\"艾泽里特炸药\",{\"1\":{\"468\":1}}],[\"艾拉\",{\"0\":{\"423\":1},\"1\":{\"480\":1}}],[\"承受腐败之水\",{\"1\":{\"467\":1}}],[\"承诺将来会执行\",{\"1\":{\"351\":1}}],[\"猛击\",{\"1\":{\"467\":1}}],[\"维持当前投票轮次\",{\"1\":{\"1486\":1,\"1497\":1}}],[\"维持统治\",{\"1\":{\"1479\":1}}],[\"维度上加锁\",{\"1\":{\"1253\":1}}],[\"维度严格的顺序\",{\"1\":{\"1203\":1}}],[\"维度拉取大小流控\",{\"1\":{\"1145\":1}}],[\"维度拉取流控\",{\"1\":{\"1137\":1}}],[\"维度流控\",{\"1\":{\"1145\":1}}],[\"维度进行重平衡\",{\"1\":{\"1130\":1}}],[\"维度来保存消息在\",{\"1\":{\"877\":1}}],[\"维护的内部缓冲区进行排队\",{\"1\":{\"1300\":1}}],[\"维护和定位问题较困难\",{\"1\":{\"942\":1}}],[\"维护了预期执行时间以及任务的状态\",{\"1\":{\"379\":1}}],[\"维克戈斯\",{\"0\":{\"467\":1}}],[\"哈达尔\",{\"0\":{\"466\":1}}],[\"哈希码表中是否包含发送消息的哈希码\",{\"1\":{\"1328\":1}}],[\"哈希算法\",{\"0\":{\"390\":1},\"1\":{\"397\":1}}],[\"哈希算法是将\",{\"1\":{\"386\":1}}],[\"哈希环位置\",{\"1\":{\"396\":1}}],[\"哈希环实际上是一个\",{\"1\":{\"391\":1}}],[\"哈希环\",{\"0\":{\"387\":1,\"391\":1}}],[\"哈希仍然能够得到同样的结果\",{\"1\":{\"385\":1}}],[\"撞炸弹易伤可以去打输出\",{\"1\":{\"464\":1}}],[\"屠夫\",{\"0\":{\"464\":1}}],[\"守门人\",{\"1\":{\"461\":1}}],[\"守护\",{\"1\":{\"419\":1}}],[\"稳一点就提前预铺满\",{\"1\":{\"461\":1}}],[\"稳坐钓鱼船\",{\"1\":{\"286\":1}}],[\"脊锤重压\",{\"1\":{\"461\":1}}],[\"忠诚的造物\",{\"1\":{\"461\":1}}],[\"切肉飞刀\",{\"1\":{\"461\":1}}],[\"切换日志转发器状态为\",{\"1\":{\"1519\":1}}],[\"切换状态到\",{\"1\":{\"1510\":1}}],[\"切换\",{\"1\":{\"1510\":2}}],[\"切换时\",{\"1\":{\"1510\":1}}],[\"切换角色成为\",{\"1\":{\"1500\":1}}],[\"切换角色为\",{\"1\":{\"1489\":1}}],[\"切换消息拉取模式为\",{\"1\":{\"1252\":1}}],[\"切换至下一个文件\",{\"1\":{\"771\":1}}],[\"切换成\",{\"1\":{\"1491\":1,\"1497\":1,\"1499\":2}}],[\"切换成读模式\",{\"1\":{\"1435\":1}}],[\"切换成读取模式\",{\"1\":{\"125\":1}}],[\"切换成发送状态\",{\"1\":{\"128\":1}}],[\"切换成处理中状态\",{\"1\":{\"128\":1}}],[\"切换到\",{\"1\":{\"1519\":1}}],[\"切换到上一标签页\",{\"1\":{\"154\":1}}],[\"切换到上边的窗口\",{\"1\":{\"153\":1}}],[\"切换到下一标签页\",{\"1\":{\"154\":1}}],[\"切换到下边的窗口\",{\"1\":{\"153\":1}}],[\"切换到编号为\",{\"1\":{\"154\":1}}],[\"切换到右边的窗口\",{\"1\":{\"153\":1}}],[\"切换到左边的窗口\",{\"1\":{\"153\":1}}],[\"切换到读取模式\",{\"1\":{\"125\":1}}],[\"切换到响应状态\",{\"1\":{\"125\":1}}],[\"恐怖船长洛克伍德\",{\"0\":{\"465\":1}}],[\"恐怖顺劈\",{\"1\":{\"461\":1}}],[\"恐惧猛击\",{\"1\":{\"448\":1}}],[\"恐惧\",{\"1\":{\"428\":1}}],[\"严格字面量检查\",{\"0\":{\"555\":1}}],[\"严格来说\",{\"1\":{\"178\":1}}],[\"严酷命运\",{\"1\":{\"461\":1}}],[\"纳组达\",{\"1\":{\"461\":1}}],[\"纳克特\",{\"1\":{\"428\":1}}],[\"佐尔拉姆斯通灵师\",{\"1\":{\"461\":1}}],[\"寒冰箭雨\",{\"1\":{\"461\":1}}],[\"寒冰镰刀要准备一个治疗手牌来应对\",{\"1\":{\"432\":1}}],[\"脆骨法师\",{\"1\":{\"461\":1}}],[\"瘀液喷撒\",{\"1\":{\"461\":1}}],[\"尸体采集者\",{\"1\":{\"461\":1}}],[\"尸体收割者\",{\"1\":{\"461\":1}}],[\"刺耳尖啸\",{\"1\":{\"461\":1}}],[\"骷髅劫掠者\",{\"1\":{\"461\":2}}],[\"出的消息的相对偏移量\",{\"1\":{\"1259\":1}}],[\"出一条消息后\",{\"1\":{\"1251\":1}}],[\"出问题\",{\"1\":{\"883\":1}}],[\"出处\",{\"1\":{\"852\":1}}],[\"出现重复消费的概率稍大于集群模式\",{\"1\":{\"1090\":1}}],[\"出现数据丢失可能会导致出现严重后果\",{\"1\":{\"659\":1}}],[\"出现了性能瓶颈\",{\"1\":{\"622\":1}}],[\"出盾的时候甚至可以用万灵来打掉\",{\"1\":{\"460\":1}}],[\"出球之后变猫去吃\",{\"1\":{\"433\":1}}],[\"冰缚之盾时开减伤\",{\"1\":{\"460\":1}}],[\"缚霜者纳尔佐\",{\"0\":{\"460\":1}}],[\"呕吐前可以读个野性成长\",{\"1\":{\"457\":1}}],[\"凋骨\",{\"0\":{\"457\":1}}],[\"路径为\",{\"1\":{\"1394\":2,\"1412\":2}}],[\"路径映射\",{\"0\":{\"601\":1}}],[\"路线\",{\"1\":{\"469\":1}}],[\"路线参考\",{\"1\":{\"455\":1}}],[\"路由机制\",{\"0\":{\"1029\":1}}],[\"路由发现\",{\"0\":{\"955\":1,\"973\":1}}],[\"路由删除逻辑如下\",{\"1\":{\"954\":1,\"972\":1}}],[\"路由删除\",{\"0\":{\"954\":1,\"972\":1}}],[\"路由注册需要加写锁\",{\"1\":{\"971\":1}}],[\"路由注册包含两个方面\",{\"1\":{\"951\":1}}],[\"路由注册\",{\"0\":{\"951\":1,\"969\":1}}],[\"路由注册中心\",{\"1\":{\"941\":1}}],[\"路由信息后\",{\"1\":{\"1041\":1}}],[\"路由信息来检查消息的\",{\"1\":{\"1030\":1}}],[\"路由信息\",{\"0\":{\"948\":1,\"962\":1,\"963\":1,\"1039\":1},\"1\":{\"945\":1,\"950\":2,\"956\":1,\"957\":1,\"973\":1,\"1030\":1,\"1037\":1,\"1038\":1,\"1039\":4,\"1053\":1,\"1120\":1}}],[\"路由信息管理\",{\"1\":{\"941\":1}}],[\"路由管理模块\",{\"1\":{\"944\":1}}],[\"路由函数接收一个路由键\",{\"1\":{\"395\":1}}],[\"路由\",{\"0\":{\"395\":1}}],[\"尖刺伤害时变熊\",{\"1\":{\"492\":1}}],[\"尖刺\",{\"1\":{\"454\":1}}],[\"酸性新星\",{\"1\":{\"454\":1}}],[\"酸蚀排放这个描述就很灵性\",{\"1\":{\"453\":1}}],[\"迷雾噬咬\",{\"1\":{\"454\":1}}],[\"迷雾结界\",{\"1\":{\"454\":1}}],[\"纱雾钉刺蛾\",{\"1\":{\"454\":1}}],[\"纱雾追猎者\",{\"1\":{\"454\":1}}],[\"纱雾防御者\",{\"1\":{\"454\":1}}],[\"仙木灵居民\",{\"1\":{\"454\":1}}],[\"仙林是奶德最适合输出的一个本\",{\"1\":{\"449\":1}}],[\"仙林\",{\"0\":{\"449\":1},\"1\":{\"422\":1,\"479\":3,\"480\":3}}],[\"仙林刷满了鎏金\",{\"1\":{\"399\":1}}],[\"削弱怪物也削弱玩家\",{\"1\":{\"454\":1}}],[\"濒死之息\",{\"1\":{\"454\":1}}],[\"德鲁斯特碎枝者\",{\"1\":{\"454\":1}}],[\"德鲁斯特恶爪者\",{\"1\":{\"454\":1}}],[\"德鲁斯特收割者\",{\"1\":{\"454\":1}}],[\"锥喉鹿角巨虫\",{\"1\":{\"454\":2}}],[\"特殊消息类型\",{\"0\":{\"1028\":1}}],[\"特性就是为了解决\",{\"1\":{\"1284\":1}}],[\"特性\",{\"1\":{\"1284\":1}}],[\"特性更少\",{\"0\":{\"698\":1}}],[\"特性聚焦\",{\"0\":{\"692\":1},\"1\":{\"718\":1}}],[\"特有的输入类型\",{\"1\":{\"593\":1}}],[\"特有的数据类型\",{\"1\":{\"527\":1}}],[\"特雷德奥瓦\",{\"0\":{\"453\":1}}],[\"特别提需要确定的几个关键值\",{\"1\":{\"927\":1}}],[\"特别多时的消费速度\",{\"1\":{\"910\":1}}],[\"特别容易\",{\"1\":{\"468\":1}}],[\"特别猛\",{\"1\":{\"448\":1}}],[\"特别痛很容易减员\",{\"1\":{\"448\":1}}],[\"特别痛\",{\"1\":{\"428\":1}}],[\"特别是在写性能要求高的程序时\",{\"1\":{\"2\":1}}],[\"猜谜游戏前进行预铺和减伤\",{\"1\":{\"452\":1}}],[\"英格拉\",{\"0\":{\"451\":1}}],[\"英雄天赋选了种植\",{\"1\":{\"403\":1}}],[\"英雄天赋\",{\"0\":{\"401\":1,\"407\":1}}],[\"够就比较轻松\",{\"1\":{\"449\":1}}],[\"落地第一个\",{\"1\":{\"448\":1}}],[\"死信消息处理\",{\"1\":{\"1198\":1}}],[\"死信机制\",{\"0\":{\"1100\":1},\"1\":{\"1100\":1}}],[\"死信队列名称为\",{\"1\":{\"1188\":1}}],[\"死信队列\",{\"1\":{\"1056\":1}}],[\"死人\",{\"1\":{\"468\":1}}],[\"死亡尖啸者艾肯塔克\",{\"1\":{\"448\":2}}],[\"死循环\",{\"1\":{\"122\":1}}],[\"招引增援\",{\"1\":{\"448\":1}}],[\"坚不可摧的伊克斯雷腾\",{\"1\":{\"448\":1}}],[\"折磨光束\",{\"1\":{\"448\":1}}],[\"深入剖析\",{\"1\":{\"1537\":1}}],[\"深入剖析rocketmq源码\",{\"1\":{\"974\":1}}],[\"深入理解\",{\"0\":{\"414\":1}}],[\"深渊轰击\",{\"1\":{\"448\":3}}],[\"深渊嗥叫\",{\"1\":{\"448\":1}}],[\"夜幕黑暗建筑师\",{\"1\":{\"448\":1}}],[\"夜幕祭师\",{\"1\":{\"448\":1}}],[\"夜幕司令官\",{\"1\":{\"448\":1}}],[\"夜幕影法师\",{\"1\":{\"448\":1}}],[\"诱捕暗影\",{\"1\":{\"448\":1}}],[\"捡炸弹的时候注意群刷\",{\"1\":{\"447\":1}}],[\"拉票\",{\"1\":{\"1502\":1}}],[\"拉票请求的\",{\"1\":{\"1503\":3}}],[\"拉票请求处理\",{\"0\":{\"1492\":1}}],[\"拉票请求发送\",{\"0\":{\"1491\":1}}],[\"拉票请求\",{\"0\":{\"1490\":1,\"1501\":1},\"1\":{\"1478\":1,\"1479\":1,\"1480\":1,\"1503\":1}}],[\"拉模式不涉及自动拉取消息\",{\"1\":{\"1155\":1}}],[\"拉模式主动拉取消息\",{\"1\":{\"1147\":1}}],[\"拉模式消费者则需要用户自行调用消费者的方法触发消费进度更新\",{\"1\":{\"1184\":1}}],[\"拉模式消费者由于需要主动进行拉取\",{\"1\":{\"1151\":1}}],[\"拉模式消费者拉取\",{\"0\":{\"1151\":1}}],[\"拉模式消费者需要手动拉取消息进行消费\",{\"1\":{\"1119\":1}}],[\"拉模式消费者的消费步骤为\",{\"1\":{\"1117\":1}}],[\"拉\",{\"0\":{\"1117\":1}}],[\"拉和推消费者实现拉消费和推消费方法\",{\"1\":{\"1116\":1}}],[\"拉取一批\",{\"1\":{\"1468\":1}}],[\"拉取一批消息成功后\",{\"1\":{\"1119\":1}}],[\"拉取时用两层过滤\",{\"1\":{\"1325\":1}}],[\"拉取对应的队列\",{\"1\":{\"1269\":1}}],[\"拉取重试消息\",{\"1\":{\"1269\":1}}],[\"拉取前再次判断队列\",{\"1\":{\"1219\":1}}],[\"拉取到后放入缓存\",{\"1\":{\"1391\":1}}],[\"拉取到消息之后调用\",{\"1\":{\"1194\":1}}],[\"拉取到的消息系统属性中有一个比较重要的属性叫做\",{\"1\":{\"1251\":1}}],[\"拉取到的消息会暂存在处理队列\",{\"1\":{\"1155\":1}}],[\"拉取到的消息存放在哪\",{\"1\":{\"1152\":1}}],[\"拉取结果\",{\"1\":{\"1171\":1}}],[\"拉取成功\",{\"1\":{\"1329\":1}}],[\"拉取成功回调函数\",{\"1\":{\"1171\":1}}],[\"拉取成功后的\",{\"1\":{\"1219\":1}}],[\"拉取成功后将拉取到的消息存入处理队列\",{\"1\":{\"1152\":1}}],[\"拉取成功后调用\",{\"1\":{\"1117\":1}}],[\"拉取最大数量\",{\"1\":{\"1171\":1}}],[\"拉取偏移量\",{\"1\":{\"1171\":1}}],[\"拉取系统标记\",{\"1\":{\"1170\":1}}],[\"拉取线程中应用了生产\",{\"1\":{\"1155\":1}}],[\"拉取完成之后更新拉取偏移量\",{\"1\":{\"1152\":1}}],[\"拉取完成后\",{\"1\":{\"1104\":1}}],[\"拉取模式消费者提供了同步和异步的拉取方法\",{\"1\":{\"1151\":1}}],[\"拉取路由\",{\"1\":{\"1120\":1,\"1123\":1}}],[\"拉取路由信息\",{\"1\":{\"955\":1,\"1030\":1,\"1039\":1}}],[\"拉取后执行消费消息逻辑\",{\"1\":{\"1119\":1}}],[\"拉取超时时间\",{\"1\":{\"1117\":1}}],[\"拉取的这批消息将生成一个\",{\"1\":{\"1258\":1}}],[\"拉取的一批消息总数小于每批次可以消费的消息数\",{\"1\":{\"1194\":1}}],[\"拉取的消息在消费队列中的偏移量\",{\"1\":{\"1117\":1}}],[\"拉取的队列\",{\"1\":{\"1117\":1}}],[\"拉取的另一种实现\",{\"1\":{\"1095\":1}}],[\"拉取远程\",{\"0\":{\"1073\":1}}],[\"拉取官方打包的镜像都可以\",{\"1\":{\"1071\":1}}],[\"拉取\",{\"1\":{\"1037\":1,\"1039\":1,\"1042\":1,\"1070\":1,\"1094\":1}}],[\"拉取该主题订阅信息\",{\"1\":{\"1170\":1}}],[\"拉取该\",{\"1\":{\"945\":1}}],[\"拉取消息结果处理\",{\"1\":{\"1329\":1}}],[\"拉取消息时会先根据拉取消息的消费者信息\",{\"1\":{\"1319\":1}}],[\"拉取消息时也会将队列的消息偏移量提交到\",{\"1\":{\"1103\":1}}],[\"拉取消息时也会提交消费偏移量\",{\"1\":{\"1103\":1}}],[\"拉取消息后调用\",{\"1\":{\"1271\":1}}],[\"拉取消息成功\",{\"1\":{\"1269\":1}}],[\"拉取消息成功后的回调方法\",{\"1\":{\"1170\":1}}],[\"拉取消息服务发送\",{\"1\":{\"1252\":1}}],[\"拉取消息服务最终会调用\",{\"1\":{\"1155\":1}}],[\"拉取消息前判断该队列的消息是否被消费完\",{\"1\":{\"1207\":1}}],[\"拉取消息数量\",{\"1\":{\"1173\":1}}],[\"拉取消息入口\",{\"1\":{\"1170\":1,\"1228\":1}}],[\"拉取消息\",{\"1\":{\"890\":1,\"1093\":1,\"1095\":1,\"1117\":1,\"1119\":1,\"1158\":1,\"1168\":1,\"1171\":1}}],[\"拉取消息请求\",{\"1\":{\"822\":1}}],[\"拉取等等\",{\"1\":{\"890\":1}}],[\"拉取请求指定了队列\",{\"1\":{\"1269\":1}}],[\"拉取请求队列\",{\"1\":{\"1168\":1}}],[\"拉取请求放入阻塞队列的时机主要有三个\",{\"1\":{\"1158\":1}}],[\"拉取请求从哪放入阻塞队列\",{\"1\":{\"1152\":1}}],[\"拉取请求\",{\"1\":{\"1137\":1,\"1169\":1,\"1170\":1,\"1228\":1}}],[\"拉取请求在一次拉取消息完成之后会复用\",{\"1\":{\"1104\":1}}],[\"拉取请求暂时挂起\",{\"1\":{\"815\":1}}],[\"拉取请求时调用\",{\"1\":{\"814\":1}}],[\"拉取请求的入口方法\",{\"1\":{\"814\":1}}],[\"拉取请求挂起时间超过阈值\",{\"1\":{\"825\":1}}],[\"拉取请求挂起时间\",{\"1\":{\"805\":1}}],[\"拉取清求的入口类\",{\"1\":{\"809\":1,\"814\":1}}],[\"拉断连线前就远离\",{\"1\":{\"453\":1}}],[\"拉夏南\",{\"0\":{\"447\":1},\"1\":{\"479\":1}}],[\"拉到靠近蛋的位置\",{\"1\":{\"425\":1}}],[\"借鉴这个方法\",{\"1\":{\"932\":1}}],[\"借鉴之前索引文件的涉及\",{\"1\":{\"928\":1}}],[\"借鉴了\",{\"1\":{\"874\":1}}],[\"借用一个奶德群群友的图片供参考\",{\"1\":{\"446\":1}}],[\"借助javascript天生的事件驱动机制加v8高性能引擎\",{\"1\":{\"360\":1}}],[\"借助中间函数f实现原型链继承\",{\"1\":{\"342\":1}}],[\"铁木树皮\",{\"1\":{\"489\":3}}],[\"铁木树皮提供\",{\"1\":{\"406\":1}}],[\"铁潮火枪手\",{\"1\":{\"468\":1}}],[\"铁潮袭击者\",{\"1\":{\"468\":1}}],[\"铁钩\",{\"1\":{\"468\":2}}],[\"铁钩之后是点名\",{\"1\":{\"464\":1}}],[\"铁皮基本上可以保证你三分之一的时间都有减伤了\",{\"1\":{\"492\":1}}],[\"铁皮\",{\"1\":{\"446\":1}}],[\"球\",{\"1\":{\"446\":4}}],[\"规避策略只在当前消息发送失败重试时失效\",{\"1\":{\"1234\":1}}],[\"规避注册过不可用的\",{\"1\":{\"1052\":1}}],[\"规避上次发送的\",{\"1\":{\"1052\":1}}],[\"规避时间将越来越长\",{\"1\":{\"1041\":1}}],[\"规避和故障延迟机制\",{\"1\":{\"1041\":1}}],[\"规划好手牌以后没那么可怕\",{\"1\":{\"446\":1}}],[\"规范\",{\"0\":{\"362\":1}}],[\"规范路径\",{\"1\":{\"52\":1}}],[\"晦暗之风\",{\"1\":{\"475\":1}}],[\"晦影腐朽\",{\"1\":{\"446\":1,\"448\":1}}],[\"晦幽纺纱\",{\"1\":{\"435\":1}}],[\"流量削峰\",{\"1\":{\"1439\":1}}],[\"流量较大的场景下\",{\"1\":{\"1027\":1}}],[\"流程较简单\",{\"1\":{\"1364\":1}}],[\"流程详解\",{\"0\":{\"1124\":1,\"1146\":1,\"1176\":1,\"1202\":1,\"1474\":1,\"1505\":1},\"1\":{\"1538\":6}}],[\"流程固定的\",{\"1\":{\"445\":1}}],[\"流控和重试意味着任务暂时等待\",{\"1\":{\"931\":1}}],[\"流控\",{\"0\":{\"664\":1,\"933\":1},\"1\":{\"860\":2,\"1170\":2}}],[\"流控详细流程\",{\"0\":{\"621\":1}}],[\"流控时发送消息被完全阻塞\",{\"1\":{\"613\":1}}],[\"流控主要是为了防止生产者生产消息速度过快\",{\"1\":{\"611\":1}}],[\"流浪者的火炬\",{\"1\":{\"479\":1}}],[\"流丝缠缚\",{\"1\":{\"435\":1}}],[\"尽量的放到锁的外面去做\",{\"1\":{\"736\":1}}],[\"尽管仲裁队列的吞吐量更高\",{\"1\":{\"704\":1}}],[\"尽管这里是在rabbit\",{\"1\":{\"624\":1}}],[\"尽可能让它有更远的飞行距离\",{\"1\":{\"446\":1}}],[\"尽可能节省场地\",{\"1\":{\"425\":1}}],[\"尽快驱散燃烧之影\",{\"1\":{\"445\":1}}],[\"好了就用\",{\"1\":{\"482\":1}}],[\"好了就去打\",{\"1\":{\"443\":1}}],[\"好的车队可以最大化它的作用\",{\"1\":{\"405\":1}}],[\"爆发药\",{\"1\":{\"485\":1}}],[\"爆地图腾\",{\"1\":{\"442\":1}}],[\"爆裂增生\",{\"1\":{\"401\":1}}],[\"咒炉塑石者\",{\"1\":{\"442\":1}}],[\"咒炉荣誉卫兵\",{\"1\":{\"442\":1}}],[\"叠层伤害增加\",{\"1\":{\"442\":1}}],[\"巨石碾压\",{\"1\":{\"442\":1}}],[\"巨熊活力可以无限重复触发\",{\"1\":{\"406\":1}}],[\"巨熊活力\",{\"1\":{\"406\":1}}],[\"击退\",{\"1\":{\"442\":1}}],[\"击退的时候变熊\",{\"1\":{\"433\":1}}],[\"击石者\",{\"1\":{\"442\":1}}],[\"熔岩觉醒\",{\"1\":{\"475\":1}}],[\"熔岩迫击炮\",{\"1\":{\"442\":1}}],[\"熔核巨人\",{\"1\":{\"475\":1}}],[\"熔炉装货工\",{\"1\":{\"442\":1}}],[\"穿透哀嚎\",{\"1\":{\"442\":1}}],[\"穿刺单变熊吃都不会死\",{\"1\":{\"426\":1}}],[\"咆哮恐惧\",{\"1\":{\"442\":1}}],[\"阴森的虚空之魂\",{\"1\":{\"442\":1}}],[\"防止\",{\"1\":{\"1521\":1}}],[\"防止丢失pullrequest\",{\"1\":{\"1170\":1}}],[\"防止请求数据被篡改\",{\"1\":{\"989\":1}}],[\"防止并发修改\",{\"1\":{\"971\":1}}],[\"防止其被交换到\",{\"1\":{\"882\":1}}],[\"防止被放入swap分区\",{\"1\":{\"882\":1}}],[\"防止在写入消息时发生缺页异常\",{\"1\":{\"882\":1}}],[\"防止在消息写入的过程中分配文件\",{\"1\":{\"881\":1}}],[\"防止放水造成减员\",{\"1\":{\"441\":1}}],[\"防护愈合\",{\"1\":{\"401\":1}}],[\"排它队列\",{\"1\":{\"698\":1}}],[\"排干体液\",{\"1\":{\"461\":1}}],[\"排名第一的奶德\",{\"1\":{\"455\":1}}],[\"排放口上的地板有岩浆的时候开树皮\",{\"1\":{\"440\":1}}],[\"排序的\",{\"1\":{\"391\":1}}],[\"排序\",{\"1\":{\"298\":1,\"391\":1,\"989\":1,\"995\":1,\"1137\":1,\"1266\":1,\"1363\":1}}],[\"黑油投弹者\",{\"1\":{\"468\":1}}],[\"黑渊\",{\"0\":{\"466\":1}}],[\"黑暗法球不要朝墙放\",{\"1\":{\"446\":1}}],[\"黑暗脉动的时候每个人必须开个减\",{\"1\":{\"433\":1}}],[\"黑球\",{\"1\":{\"439\":1}}],[\"斯卡莫拉克\",{\"0\":{\"439\":1}}],[\"怎么理解内存中的buffer和cache\",{\"1\":{\"1527\":1}}],[\"怎么办\",{\"1\":{\"927\":1}}],[\"怎么消要提前和队友商量好\",{\"1\":{\"438\":1}}],[\"怎么提高效率\",{\"1\":{\"2\":1}}],[\"震颤猛击\",{\"1\":{\"435\":1}}],[\"震颤猛击或晦幽纺纱的时候变熊来承受尖刺伤害\",{\"1\":{\"434\":1}}],[\"魁梧的战甲尉\",{\"1\":{\"435\":1}}],[\"群体高额\",{\"1\":{\"435\":1}}],[\"贪婪之虫\",{\"1\":{\"435\":1}}],[\"皇家虫群卫士\",{\"1\":{\"435\":1}}],[\"虚缚抢劫者\",{\"1\":{\"442\":1}}],[\"虚缚嚎叫者\",{\"1\":{\"442\":1}}],[\"虚空爆发\",{\"1\":{\"442\":1}}],[\"虚空代言人艾里克\",{\"0\":{\"441\":1}}],[\"虚空奔袭\",{\"1\":{\"435\":1}}],[\"虚拟节点的个数就是绑定时指定的权重\",{\"1\":{\"716\":1}}],[\"虚拟节点\",{\"1\":{\"396\":1}}],[\"虚拟方法读取输入流的下一个字节\",{\"1\":{\"53\":1}}],[\"女王之眼\",{\"1\":{\"435\":1}}],[\"女王之牙\",{\"0\":{\"432\":1}}],[\"隐秘网士\",{\"1\":{\"435\":1}}],[\"隐藏行号\",{\"1\":{\"143\":1}}],[\"扭曲思绪\",{\"1\":{\"435\":1}}],[\"研究了打法以后会变得好奶很多\",{\"1\":{\"433\":1}}],[\"粘稠黑暗会击退你\",{\"1\":{\"433\":1}}],[\"粘贴代码会缩进错乱\",{\"1\":{\"156\":1}}],[\"粘贴\",{\"1\":{\"144\":1,\"156\":1}}],[\"凝结聚合体\",{\"0\":{\"433\":1}}],[\"飞刀投掷和寒冰镰刀\",{\"1\":{\"432\":1}}],[\"帮忙打断通灵箭雨\",{\"1\":{\"455\":1}}],[\"帮忙用纠缠根须控制狐狸\",{\"1\":{\"452\":1}}],[\"帮\",{\"1\":{\"432\":1}}],[\"受到\",{\"1\":{\"847\":1}}],[\"受到疑之影点名并且没有被秒驱散的人必须开减伤\",{\"1\":{\"431\":1}}],[\"受\",{\"1\":{\"805\":1}}],[\"受cluster\",{\"1\":{\"659\":1}}],[\"受限于sleep方法的精度无法更加提高\",{\"1\":{\"379\":1}}],[\"喧神教化\",{\"1\":{\"431\":1}}],[\"演进过程\",{\"0\":{\"1380\":1}}],[\"演示一致性哈希交换器的使用\",{\"1\":{\"712\":1}}],[\"演说者基克斯威兹克\",{\"0\":{\"431\":1}}],[\"演练结束后\",{\"1\":{\"280\":2}}],[\"演练过程中\",{\"1\":{\"280\":1}}],[\"超前的条目\",{\"1\":{\"1520\":1}}],[\"超出会触发流控\",{\"1\":{\"1519\":1}}],[\"超出范围的索引不会报错\",{\"1\":{\"297\":1}}],[\"超时\",{\"1\":{\"1403\":1,\"1427\":1}}],[\"超时时间\",{\"1\":{\"698\":1}}],[\"超过半数大于它\",{\"1\":{\"1521\":1}}],[\"超过半数\",{\"1\":{\"1491\":1,\"1497\":2,\"1499\":1}}],[\"超过半数成功则继续\",{\"1\":{\"1488\":1,\"1499\":1}}],[\"超过这个次数则丢弃\",{\"1\":{\"1468\":1}}],[\"超过这个时间间隔的事务消息才会被回查\",{\"1\":{\"1468\":1}}],[\"超过该时间后\",{\"1\":{\"870\":1}}],[\"超过\",{\"1\":{\"611\":1,\"864\":1,\"1488\":1,\"1495\":1,\"1499\":1,\"1517\":1}}],[\"超高额\",{\"1\":{\"428\":1}}],[\"巢穴的召唤\",{\"1\":{\"428\":1}}],[\"野蛮猛击\",{\"1\":{\"428\":1}}],[\"野性冲锋\",{\"1\":{\"490\":3}}],[\"野性\",{\"1\":{\"419\":1,\"446\":2}}],[\"野性成长就可以奶住\",{\"1\":{\"431\":1}}],[\"野性成长增强那两点也还是可以换成双叶伴身和铁皮减\",{\"1\":{\"403\":1}}],[\"野性成长\",{\"1\":{\"401\":1,\"409\":1,\"489\":4}}],[\"蛛魔搬运者\",{\"1\":{\"428\":1}}],[\"哨兵鹿壳虫\",{\"1\":{\"428\":1}}],[\"毒液箭雨\",{\"1\":{\"428\":1}}],[\"鲜血监督者\",{\"1\":{\"428\":1}}],[\"沾血的网法师\",{\"1\":{\"428\":1}}],[\"惊惧尖鸣\",{\"1\":{\"428\":1}}],[\"老文件用来读取\",{\"1\":{\"1417\":1}}],[\"老化时间限制\",{\"1\":{\"1347\":1}}],[\"老消费者的消费任务可能还没有结束\",{\"1\":{\"1208\":1}}],[\"老消息都不会被复制\",{\"1\":{\"678\":1}}],[\"老的进度不需要\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"老的消息不进行同步\",{\"1\":{\"693\":1}}],[\"老版本的延迟消息流程和源码解析可以看这篇文章\",{\"1\":{\"850\":1}}],[\"老版本中\",{\"1\":{\"850\":1}}],[\"老一前第二个小\",{\"1\":{\"428\":1}}],[\"老一前第一个小\",{\"1\":{\"428\":1}}],[\"老三前大甲虫\",{\"1\":{\"428\":1}}],[\"老二前的几个小\",{\"1\":{\"448\":1}}],[\"老二前过道\",{\"1\":{\"428\":1}}],[\"老二和他之前几个小\",{\"1\":{\"422\":1}}],[\"伊克辛\",{\"1\":{\"428\":1}}],[\"伊森利恩\",{\"1\":{\"398\":1}}],[\"颤声侍从\",{\"1\":{\"428\":1}}],[\"驱动状态机\",{\"1\":{\"1497\":1}}],[\"驱动层最为底层\",{\"1\":{\"1387\":1}}],[\"驱动层\",{\"1\":{\"1387\":1}}],[\"驱散\",{\"1\":{\"491\":1}}],[\"驱散毒药的时候一般先驱自己\",{\"1\":{\"427\":1}}],[\"驱之前走到不会波及队友的地方驱\",{\"1\":{\"427\":1}}],[\"近战位放绿水本来就很挤了\",{\"1\":{\"427\":1}}],[\"扇形地板\",{\"1\":{\"426\":1}}],[\"阿里云\",{\"1\":{\"922\":1}}],[\"阿加法力之油\",{\"1\":{\"485\":1}}],[\"阿加法力药水\",{\"1\":{\"485\":1}}],[\"阿加治疗药水\",{\"1\":{\"485\":1}}],[\"阿玛厄斯\",{\"0\":{\"458\":1}}],[\"阿努布伊卡基\",{\"0\":{\"446\":1}}],[\"阿奴布泽克特\",{\"0\":{\"426\":1}}],[\"阿瓦诺克斯\",{\"0\":{\"425\":1}}],[\"放在\",{\"1\":{\"1321\":1}}],[\"放在参数列表的第一位\",{\"1\":{\"580\":1}}],[\"放弃本次拉取\",{\"1\":{\"1170\":2}}],[\"放弃了几乎所有防御性职业天赋点换成输出\",{\"1\":{\"455\":1}}],[\"放弃了几乎所有防御性的职业天赋点\",{\"1\":{\"449\":1}}],[\"放入处理队列\",{\"1\":{\"1520\":2}}],[\"放入等待响应的日志追加\",{\"1\":{\"1509\":1}}],[\"放入缓存\",{\"1\":{\"1431\":1}}],[\"放入返回结果中返回\",{\"1\":{\"1408\":1}}],[\"放入请求栈\",{\"1\":{\"1372\":1}}],[\"放入有界阻塞队列\",{\"1\":{\"1355\":1}}],[\"放入时间轮\",{\"1\":{\"1354\":1}}],[\"放入到\",{\"1\":{\"1332\":1}}],[\"放入消息属性\",{\"1\":{\"1296\":1}}],[\"放入消费队列\",{\"1\":{\"1149\":1}}],[\"放入\",{\"1\":{\"1275\":1,\"1278\":1,\"1319\":1,\"1332\":1,\"1348\":1,\"1359\":2,\"1370\":2,\"1372\":3,\"1417\":1,\"1518\":1,\"1520\":1}}],[\"放入内存匹配失败\",{\"1\":{\"1271\":1}}],[\"放入内存\",{\"1\":{\"1262\":1,\"1271\":1,\"1275\":2}}],[\"放入内存和磁盘\",{\"1\":{\"1258\":1,\"1271\":1}}],[\"放入磁盘存储\",{\"1\":{\"1262\":1}}],[\"放入拉取请求队列\",{\"1\":{\"1228\":1}}],[\"放入拉取队列\",{\"1\":{\"1119\":1}}],[\"放入待执行的拉取请求队列\",{\"1\":{\"1119\":1}}],[\"放入重试\",{\"1\":{\"1100\":1}}],[\"放入指定队列\",{\"1\":{\"1065\":1}}],[\"放到一个\",{\"1\":{\"1253\":1,\"1507\":1}}],[\"放到\",{\"1\":{\"1044\":1,\"1294\":1,\"1359\":1}}],[\"放到消息属性中\",{\"1\":{\"843\":1}}],[\"放到消息的\",{\"1\":{\"834\":1}}],[\"放到锁外\",{\"1\":{\"736\":1}}],[\"放到了锁外\",{\"1\":{\"736\":1}}],[\"放蛛网圈\",{\"1\":{\"447\":1}}],[\"放圈的时候进行移动可以完全规避圈的伤害\",{\"1\":{\"445\":1}}],[\"放圈只会点远程放\",{\"1\":{\"445\":1}}],[\"放熵能清算\",{\"1\":{\"441\":1}}],[\"放排放口技能的同时会有\",{\"1\":{\"440\":1}}],[\"放虚空释能时交你的治疗手牌\",{\"1\":{\"439\":1}}],[\"放地板的方式是全体和\",{\"1\":{\"425\":1}}],[\"放的好不仅能提高你的\",{\"1\":{\"416\":1}}],[\"及时将变更加载到内存\",{\"1\":{\"990\":1,\"996\":1}}],[\"及时奶上\",{\"1\":{\"425\":1}}],[\"及不可用的恢复时间\",{\"1\":{\"283\":1}}],[\"警示尖鸣\",{\"1\":{\"425\":1}}],[\"地址白名单\",{\"1\":{\"978\":1}}],[\"地址表\",{\"1\":{\"971\":1}}],[\"地址列表\",{\"1\":{\"953\":1,\"971\":1}}],[\"地址\",{\"1\":{\"944\":1,\"949\":1,\"952\":1,\"965\":1,\"970\":1,\"971\":1,\"997\":1,\"1029\":1,\"1039\":2,\"1042\":1,\"1053\":1,\"1077\":2,\"1078\":1,\"1120\":1,\"1160\":1,\"1163\":1,\"1188\":1,\"1197\":2,\"1200\":1,\"1226\":1,\"1472\":1}}],[\"地址生产或消费消息\",{\"1\":{\"941\":1}}],[\"地板触手\",{\"1\":{\"475\":1}}],[\"地板很难看清的扇形伤害\",{\"1\":{\"468\":1}}],[\"地板放水\",{\"1\":{\"441\":1}}],[\"地板放蛛网\",{\"1\":{\"425\":1}}],[\"地毯\",{\"1\":{\"411\":1}}],[\"卡拉\",{\"0\":{\"423\":1},\"1\":{\"480\":1}}],[\"四星\",{\"1\":{\"422\":1}}],[\"矶石宝库\",{\"0\":{\"436\":1},\"1\":{\"480\":3}}],[\"矶石\",{\"1\":{\"422\":1}}],[\"围攻伯拉勒斯\",{\"0\":{\"462\":1},\"1\":{\"480\":1}}],[\"围攻\",{\"1\":{\"422\":1}}],[\"压测的过滤条件为\",{\"1\":{\"1325\":1}}],[\"压缩后的索引文件\",{\"1\":{\"1435\":1}}],[\"压缩后的新文件\",{\"1\":{\"1435\":1}}],[\"压缩后索引文件\",{\"1\":{\"1435\":1}}],[\"压缩后索引文件引用\",{\"1\":{\"1412\":1}}],[\"压缩文件于压缩前文件相比\",{\"1\":{\"1435\":1}}],[\"压缩索引文件到新文件\",{\"1\":{\"1435\":1}}],[\"压缩索引文件并上传到二级存储\",{\"1\":{\"1435\":1}}],[\"压缩成新索引文件\",{\"1\":{\"1435\":1}}],[\"压缩并上传\",{\"1\":{\"1435\":1}}],[\"压缩并上传到二级存储\",{\"1\":{\"1394\":1}}],[\"压缩的过程会在\",{\"1\":{\"1394\":1}}],[\"压缩之后转储到更廉价的存储系统中\",{\"1\":{\"1385\":1}}],[\"压缩\",{\"1\":{\"1042\":1,\"1053\":1}}],[\"压力\",{\"1\":{\"735\":1,\"1402\":1}}],[\"压力都不大\",{\"1\":{\"443\":1}}],[\"压力在治疗\",{\"1\":{\"422\":1}}],[\"压榨\",{\"1\":{\"116\":1}}],[\"破晨老二\",{\"1\":{\"491\":1}}],[\"破晨可以把强化驱散去掉换成强化回春术\",{\"1\":{\"443\":1}}],[\"破晨号\",{\"0\":{\"443\":1},\"1\":{\"480\":1}}],[\"破晨\",{\"1\":{\"422\":1}}],[\"三种消息发送方式\",{\"0\":{\"1027\":1}}],[\"三种多文件操作概念\",{\"1\":{\"151\":1}}],[\"三星\",{\"1\":{\"422\":1}}],[\"三级属性\",{\"0\":{\"477\":1},\"1\":{\"421\":1}}],[\"吸血尖牙之诵\",{\"1\":{\"486\":1}}],[\"吸血对治疗来说可以提供可观的治疗量\",{\"1\":{\"477\":1}}],[\"吸血\",{\"1\":{\"421\":2,\"477\":1}}],[\"闪避和吸血都不错\",{\"1\":{\"477\":1}}],[\"闪避\",{\"1\":{\"421\":2,\"477\":1}}],[\"闪亮登场\",{\"1\":{\"2\":1}}],[\"争霸艾泽拉斯版本引入了次要属性衰减的机制\",{\"1\":{\"421\":1}}],[\"毫秒\",{\"1\":{\"420\":1}}],[\"施法排队窗口\",{\"0\":{\"420\":1}}],[\"恢复事务半消息的真实\",{\"1\":{\"1464\":1}}],[\"恢复之前获取信号量避免并发度过高\",{\"1\":{\"1421\":1}}],[\"恢复的入口是\",{\"1\":{\"1421\":1}}],[\"恢复重试消息的主题名\",{\"1\":{\"1195\":1}}],[\"恢复药水炸弹感觉比较鸡肋\",{\"1\":{\"485\":1}}],[\"恢复药水炸弹\",{\"1\":{\"485\":1}}],[\"恢复造成伤害和治疗的\",{\"1\":{\"421\":1}}],[\"恢复\",{\"0\":{\"753\":1,\"759\":1,\"770\":1},\"1\":{\"419\":1,\"834\":1,\"836\":1}}],[\"割裂\",{\"1\":{\"419\":1}}],[\"割裂保持不了一半以上的时间不如撕咬\",{\"1\":{\"412\":1}}],[\"阳炎术\",{\"1\":{\"419\":1,\"489\":3}}],[\"月底\",{\"1\":{\"886\":1}}],[\"月火\",{\"1\":{\"489\":1}}],[\"月火术\",{\"1\":{\"419\":1,\"489\":2}}],[\"月照树人\",{\"1\":{\"401\":1}}],[\"星火术\",{\"1\":{\"489\":3}}],[\"星终结技来避免原始之怒\",{\"1\":{\"417\":1}}],[\"星以上的凶猛撕咬\",{\"1\":{\"412\":1}}],[\"限制每个投递任务投递的消息量即可\",{\"1\":{\"932\":1}}],[\"限制\",{\"1\":{\"413\":1,\"503\":1}}],[\"塞纳里奥结界\",{\"1\":{\"413\":1,\"489\":2}}],[\"塞纳留斯的指引\",{\"1\":{\"405\":1}}],[\"手工删除文件\",{\"1\":{\"870\":1}}],[\"手动删除是否被触发\",{\"1\":{\"870\":1}}],[\"手动删除\",{\"1\":{\"866\":1}}],[\"手动发送消息\",{\"1\":{\"711\":1}}],[\"手动指定脚本模块的路径\",{\"1\":{\"601\":1}}],[\"手套\",{\"1\":{\"479\":1,\"480\":1}}],[\"手牌没啥需要规划的\",{\"1\":{\"445\":1}}],[\"手牌转不过来可以用减伤\",{\"1\":{\"426\":1}}],[\"手牌\",{\"0\":{\"413\":1}}],[\"手法\",{\"1\":{\"399\":1}}],[\"血缚恐魔\",{\"1\":{\"479\":1}}],[\"血钩\",{\"0\":{\"464\":1}}],[\"血肉工匠\",{\"1\":{\"461\":1}}],[\"血的时候触发\",{\"1\":{\"454\":1}}],[\"血就撕咬\",{\"1\":{\"412\":1}}],[\"血量更低的目标\",{\"1\":{\"405\":1}}],[\"斜掠\",{\"1\":{\"412\":1,\"419\":1}}],[\"搓星火术\",{\"1\":{\"412\":2}}],[\"搓愤怒\",{\"1\":{\"412\":1}}],[\"吃三层精通继续愈合\",{\"1\":{\"411\":1}}],[\"树\",{\"1\":{\"1321\":1}}],[\"树液饕餮腰带\",{\"1\":{\"479\":1,\"480\":1}}],[\"树皮\",{\"1\":{\"446\":2,\"492\":1}}],[\"树人小迅捷\",{\"1\":{\"446\":2}}],[\"树人小迅捷+\",{\"1\":{\"446\":2}}],[\"树人\",{\"1\":{\"411\":1}}],[\"树奶除了上述效果以外还有几个关键的天赋\",{\"1\":{\"401\":1}}],[\"树奶更稳定\",{\"1\":{\"401\":1}}],[\"树奶\",{\"1\":{\"401\":1}}],[\"树奶偏向于群奶和可以减少主要技能的\",{\"1\":{\"401\":1}}],[\"俩脆皮\",{\"1\":{\"411\":1}}],[\"治疗压力不大\",{\"1\":{\"445\":1}}],[\"治疗压力反而不大\",{\"1\":{\"422\":1}}],[\"治疗检测本\",{\"1\":{\"422\":1}}],[\"治疗自己不会触发吸血\",{\"1\":{\"415\":1}}],[\"治疗\",{\"0\":{\"411\":1}}],[\"治疗量上限大于树奶\",{\"1\":{\"401\":1}}],[\"件套\",{\"1\":{\"409\":2}}],[\"套装\",{\"1\":{\"479\":5}}],[\"套装加成\",{\"1\":{\"411\":1}}],[\"套装效果\",{\"0\":{\"409\":1}}],[\"套接字编程\",{\"0\":{\"245\":1}}],[\"套接字来编写运行在不可信环境中的分布式应用程序\",{\"1\":{\"237\":1}}],[\"孪生双芽\",{\"1\":{\"407\":1}}],[\"万物皆消息\",{\"1\":{\"935\":1}}],[\"万能翡翠\",{\"1\":{\"485\":1}}],[\"万灵\",{\"1\":{\"461\":1}}],[\"万灵可以全部变猫输出\",{\"1\":{\"457\":1}}],[\"万灵可以全部变猫打伤害\",{\"1\":{\"445\":1}}],[\"万灵可以都用来打\",{\"1\":{\"452\":1}}],[\"万灵看团血\",{\"1\":{\"451\":1}}],[\"万灵也可以奶过\",{\"1\":{\"443\":1}}],[\"万灵和树皮留给黑暗脉动\",{\"1\":{\"433\":1}}],[\"万灵来应对\",{\"1\":{\"428\":1}}],[\"万灵之召使用特殊法术或技能的几率提高\",{\"1\":{\"405\":1}}],[\"万灵之召的冷却时间缩短50\",{\"1\":{\"405\":1}}],[\"万华疾行\",{\"1\":{\"407\":1}}],[\"橡木树皮\",{\"1\":{\"406\":1}}],[\"职业天赋\",{\"0\":{\"406\":1}}],[\"职业选手写的奶德大秘境完全指南\",{\"0\":{\"398\":1},\"1\":{\"608\":1}}],[\"几小时或者更多时间去同步消息\",{\"1\":{\"693\":1}}],[\"几分钟以上\",{\"1\":{\"613\":1}}],[\"几乎所有的\",{\"1\":{\"564\":1}}],[\"几乎没有很大的治疗缺口\",{\"1\":{\"449\":1}}],[\"几乎没有点生存向的\",{\"1\":{\"403\":1}}],[\"几乎没有深度进行过开荒\",{\"1\":{\"399\":1}}],[\"几率使附近一个有效目标身上的同类型植物立即生长\",{\"1\":{\"407\":1}}],[\"几率使其绽放\",{\"1\":{\"405\":1}}],[\"光合作用\",{\"1\":{\"405\":1}}],[\"光用这个来打伤害全程都能打\",{\"1\":{\"401\":1}}],[\"蔓生绽放\",{\"1\":{\"405\":1}}],[\"精度\",{\"1\":{\"922\":1,\"924\":1}}],[\"精确度\",{\"1\":{\"1360\":1,\"1374\":1}}],[\"精确度为1ms\",{\"1\":{\"379\":1}}],[\"精确到秒\",{\"1\":{\"787\":1}}],[\"精湛翡翠\",{\"1\":{\"485\":1}}],[\"精通\",{\"1\":{\"405\":1,\"421\":3,\"476\":1}}],[\"森林之风\",{\"1\":{\"405\":1}}],[\"翡翠灌注\",{\"1\":{\"405\":1}}],[\"翡翠灌注的话则是给一个人灌注之后就不用管他了\",{\"1\":{\"403\":1}}],[\"专门用于\",{\"1\":{\"1395\":1}}],[\"专门用来保存还没有到投递时间的定时消息\",{\"1\":{\"836\":1}}],[\"专门的重试\",{\"1\":{\"1251\":1}}],[\"专门存放延迟消息\",{\"1\":{\"834\":1}}],[\"专精天赋\",{\"0\":{\"405\":1}}],[\"专业\",{\"1\":{\"2\":1}}],[\"丰饶结界可以随意\",{\"1\":{\"403\":1}}],[\"丰富指南的内容\",{\"1\":{\"399\":1}}],[\"右边\",{\"1\":{\"1156\":1}}],[\"右边是投递过程状态更新线程\",{\"1\":{\"856\":1}}],[\"右边是针对消息生产的指令\",{\"1\":{\"742\":1}}],[\"右边是follower\",{\"1\":{\"674\":1}}],[\"右边方法将切分后的字符串直接存到\",{\"1\":{\"741\":1}}],[\"右边新增的的\",{\"1\":{\"737\":1}}],[\"右边绿色新增的代码是原先在锁中的操作\",{\"1\":{\"737\":1}}],[\"右边主要把萌芽之叶换成了赛梦\",{\"1\":{\"403\":1}}],[\"右移窗口\",{\"1\":{\"153\":1}}],[\"痛击\",{\"1\":{\"412\":1}}],[\"痛击其实伤害占比很小\",{\"1\":{\"403\":1}}],[\"痛定思痛我尝试找到科学的提升方法\",{\"1\":{\"399\":1}}],[\"粉色可以按习惯自行抉择\",{\"1\":{\"403\":1}}],[\"换来的是消费性能大幅提升\",{\"1\":{\"916\":1}}],[\"换成了赛梦\",{\"1\":{\"455\":1}}],[\"换成输出\",{\"1\":{\"449\":1}}],[\"换成蓝色的\",{\"1\":{\"403\":1}}],[\"换句话说\",{\"1\":{\"85\":1,\"657\":1}}],[\"千丝之城\",{\"0\":{\"429\":1},\"1\":{\"479\":1,\"480\":3}}],[\"千丝\",{\"1\":{\"422\":1}}],[\"千丝的\",{\"1\":{\"403\":1}}],[\"千丝老三\",{\"1\":{\"401\":1,\"492\":1}}],[\"欣欣向荣也不失为一个好选择\",{\"1\":{\"403\":1}}],[\"欣欣向荣的好处是一可以多一个救急手段\",{\"1\":{\"403\":1}}],[\"二级存储\",{\"1\":{\"1390\":1}}],[\"二级属性\",{\"1\":{\"421\":1}}],[\"二层过滤\",{\"1\":{\"1333\":1}}],[\"二进制数组会存到扩展存储中\",{\"1\":{\"1308\":1,\"1315\":1,\"1323\":1}}],[\"二进制型与位语法\",{\"0\":{\"198\":1}}],[\"二\",{\"1\":{\"829\":1}}],[\"二星\",{\"1\":{\"422\":1}}],[\"二可以多触发一次丛林之魂\",{\"1\":{\"403\":1}}],[\"双主\",{\"0\":{\"1068\":1},\"1\":{\"1538\":1}}],[\"双向宏就是目标为敌人的时候用伤害技能\",{\"1\":{\"488\":1}}],[\"双手武器\",{\"1\":{\"480\":1}}],[\"双绽放\",{\"1\":{\"411\":1,\"446\":1}}],[\"双小迅捷\",{\"1\":{\"403\":1}}],[\"双方通过receive\",{\"1\":{\"73\":1}}],[\"什么都不做\",{\"1\":{\"1373\":1}}],[\"什么是零拷贝\",{\"1\":{\"1527\":1}}],[\"什么是\",{\"0\":{\"1245\":1}}],[\"什么是一致性哈希\",{\"1\":{\"397\":1}}],[\"什么是一致性哈希算法\",{\"0\":{\"385\":1}}],[\"什么时候用这套天赋\",{\"0\":{\"403\":1}}],[\"奶的住后二基本就能过\",{\"1\":{\"422\":1}}],[\"奶德的精通很强\",{\"1\":{\"476\":1}}],[\"奶德\",{\"1\":{\"403\":1}}],[\"奶别人\",{\"1\":{\"401\":1,\"492\":2}}],[\"奶量是够的\",{\"1\":{\"461\":1}}],[\"奶量很足\",{\"1\":{\"403\":1}}],[\"奶量更足\",{\"1\":{\"403\":1}}],[\"奶量\",{\"1\":{\"400\":1}}],[\"愈合奶\",{\"1\":{\"439\":1}}],[\"愈合之网\",{\"1\":{\"435\":1}}],[\"愈合之涌\",{\"1\":{\"405\":1}}],[\"愈合没有绽放的人\",{\"1\":{\"411\":1}}],[\"愈合\",{\"1\":{\"409\":1,\"419\":1,\"446\":6,\"489\":4,\"490\":1}}],[\"愈合的持续治疗效果提高50\",{\"1\":{\"405\":1}}],[\"愈合对自己治疗效果提高\",{\"1\":{\"401\":1}}],[\"愈合和百花齐放造成的治疗有机会在目标身上产生共生绽华\",{\"1\":{\"401\":1}}],[\"祥和体制\",{\"1\":{\"401\":1}}],[\"盛放注能\",{\"1\":{\"401\":1}}],[\"觅血缠藤\",{\"1\":{\"401\":1}}],[\"少了一次拷贝\",{\"1\":{\"894\":1}}],[\"少一次内存拷贝\",{\"1\":{\"894\":1}}],[\"少量目标下伤害可观\",{\"1\":{\"401\":1}}],[\"少的话变量会被赋值为\",{\"1\":{\"307\":1}}],[\"免疫回查时长\",{\"1\":{\"1468\":1}}],[\"免疫回查期时长\",{\"1\":{\"1468\":1}}],[\"免去了排序的步骤\",{\"1\":{\"927\":1}}],[\"免去了存到\",{\"1\":{\"741\":1}}],[\"免费星火\",{\"1\":{\"401\":1}}],[\"免运维\",{\"1\":{\"276\":1}}],[\"减\",{\"1\":{\"1519\":1}}],[\"减伤\",{\"1\":{\"401\":2,\"406\":1,\"421\":1}}],[\"减少加锁次数\",{\"1\":{\"1495\":1}}],[\"减少对分级存储的访问\",{\"1\":{\"1404\":1}}],[\"减少资源利用率\",{\"1\":{\"1380\":1}}],[\"减少磁盘占用\",{\"1\":{\"930\":1}}],[\"减少通知开销以提升性能\",{\"1\":{\"916\":1}}],[\"减少通知次数\",{\"1\":{\"916\":1}}],[\"减少锁的占用\",{\"1\":{\"883\":1}}],[\"减少了复制\",{\"1\":{\"741\":1}}],[\"减少字节数组拷贝\",{\"0\":{\"730\":1}}],[\"减少消息消费的时延\",{\"1\":{\"631\":1}}],[\"减少信用\",{\"0\":{\"624\":1}}],[\"减少受到的aoe伤害\",{\"1\":{\"477\":1}}],[\"减少\",{\"1\":{\"421\":1,\"1385\":1}}],[\"减少命名冲突的方法是把自己的所有变量和函数全部绑定到一个全局变量中\",{\"1\":{\"313\":1}}],[\"减少上下文切换\",{\"1\":{\"117\":1}}],[\"根开减伤吃的\",{\"1\":{\"438\":1}}],[\"根\",{\"1\":{\"438\":3}}],[\"根消完是吃不住的\",{\"1\":{\"438\":1}}],[\"根本奶不住\",{\"1\":{\"433\":1}}],[\"根须网道\",{\"1\":{\"401\":1}}],[\"根据仲裁成功的日志\",{\"1\":{\"1521\":1}}],[\"根据序号获取\",{\"1\":{\"1520\":1}}],[\"根据日志转发器状态向\",{\"1\":{\"1519\":1}}],[\"根据日志序号查询内容\",{\"1\":{\"1519\":1}}],[\"根据日志序号查询日志内容\",{\"1\":{\"1519\":1}}],[\"根据待比较日志序号查询\",{\"1\":{\"1519\":1}}],[\"根据需要截断的\",{\"1\":{\"1510\":1}}],[\"根据比较的结果\",{\"1\":{\"1510\":1}}],[\"根据投票结果进行仲裁\",{\"1\":{\"1497\":1}}],[\"根据投票结果进行仲裁的逻辑如下\",{\"1\":{\"1491\":1}}],[\"根据节点角色的不同\",{\"1\":{\"1482\":1}}],[\"根据结果处理事务半消息\",{\"1\":{\"1472\":1}}],[\"根据结果更新状态\",{\"1\":{\"861\":1}}],[\"根据生产组\",{\"1\":{\"1453\":1}}],[\"根据生命周期计算是否需要执行\",{\"1\":{\"374\":1}}],[\"根据回查的本地事务执行结果\",{\"1\":{\"1446\":1}}],[\"根据本地事务执行装填\",{\"1\":{\"1472\":1}}],[\"根据本地事务执行状态通知\",{\"1\":{\"1460\":1}}],[\"根据本地事务执行状态设置事务结束请求类型\",{\"1\":{\"1460\":1}}],[\"根据本地事务执行状态\",{\"1\":{\"1460\":1,\"1472\":1}}],[\"根据本地事务执行结果来复原或丢弃事务半消息\",{\"1\":{\"1446\":1}}],[\"根据本地事务随机模拟的\",{\"1\":{\"1442\":1}}],[\"根据队列查找分级存储文件\",{\"1\":{\"1430\":1}}],[\"根据队列找到对应的消费队列\",{\"1\":{\"1153\":1}}],[\"根据索引项起始位置和索引项总长度读取索引项\",{\"1\":{\"1436\":1}}],[\"根据索引项起始位置和索引项总长度从\",{\"1\":{\"1415\":1}}],[\"根据索引项的时间戳范围和\",{\"1\":{\"1415\":1,\"1436\":1}}],[\"根据索引文件状态判断从哪里读取\",{\"1\":{\"1415\":1}}],[\"根据索引在\",{\"1\":{\"1359\":1}}],[\"根据创建时间排序的跳表\",{\"1\":{\"1412\":1}}],[\"根据要读取消息的偏移量和最大读取消息数量获取分级存储\",{\"1\":{\"1408\":1}}],[\"根据判断结果来调用读取消息的方法\",{\"1\":{\"1407\":1}}],[\"根据用户配置的分级存储读取策略\",{\"1\":{\"1405\":1}}],[\"根据偏移量获取本地存储中的\",{\"1\":{\"1403\":1}}],[\"根据偏移量获取\",{\"1\":{\"1368\":1}}],[\"根据偏移量从\",{\"1\":{\"1198\":1}}],[\"根据时间戳获取槽位\",{\"1\":{\"1367\":1}}],[\"根据时间戳获取槽位下标\",{\"1\":{\"1367\":1}}],[\"根据时间轴间歇性有高额伤害的时候\",{\"1\":{\"413\":1}}],[\"根据当前节点的\",{\"1\":{\"1503\":1}}],[\"根据当前时间轮扫描的时间戳\",{\"1\":{\"1372\":1}}],[\"根据当前扫描时间轮的时间戳\",{\"1\":{\"1358\":1}}],[\"根据当前目录的位置确定classpath\",{\"1\":{\"21\":1}}],[\"根据定时消息偏移量\",{\"1\":{\"1348\":1,\"1357\":1}}],[\"根据拉取结果\",{\"1\":{\"1329\":1}}],[\"根据拉取消息的消费者信息\",{\"1\":{\"1324\":1}}],[\"根据拉取的状态进行判断\",{\"1\":{\"1165\":1}}],[\"根据完整消息来判断消息是否匹配过滤规则\",{\"1\":{\"1318\":1}}],[\"根据重平衡策略名称获取策略\",{\"1\":{\"1266\":1}}],[\"根据集群的负载来选择\",{\"1\":{\"1234\":1}}],[\"根据名称查询主节点地址\",{\"1\":{\"1197\":1}}],[\"根据服务端下一次校对的偏移量尝试更新消息消费进度\",{\"1\":{\"1175\":1}}],[\"根据属性进行过滤\",{\"1\":{\"1174\":1}}],[\"根据getmessageresult状态码推算response状态码\",{\"1\":{\"1173\":1}}],[\"根据主从同步延迟计算下一次从主或从节点拉取\",{\"1\":{\"1173\":1}}],[\"根据主题名称\",{\"1\":{\"1171\":1}}],[\"根据brokername\",{\"1\":{\"1171\":1}}],[\"根据过滤类型构建拉取时的系统标记\",{\"1\":{\"1170\":1}}],[\"根据从存储查询消息的结果\",{\"1\":{\"1163\":1}}],[\"根据请求中需要比对的\",{\"1\":{\"1511\":1}}],[\"根据请求类型不同\",{\"1\":{\"1511\":1}}],[\"根据请求头中的事务半消息物理偏移量\",{\"1\":{\"1451\":1}}],[\"根据请求发送的交互模式\",{\"1\":{\"1161\":1}}],[\"根据请求的队列\",{\"1\":{\"1257\":1}}],[\"根据请求的\",{\"1\":{\"1061\":2}}],[\"根据请求的主题获取该主题的路由信息\",{\"1\":{\"973\":1}}],[\"根据配置文件中的\",{\"1\":{\"1424\":1}}],[\"根据配置的分级存储消息读取策略进行判断\",{\"1\":{\"1401\":1}}],[\"根据配置\",{\"1\":{\"1138\":1}}],[\"根据配置同步或者异步投递\",{\"1\":{\"857\":1}}],[\"根据推和拉模式的不同\",{\"1\":{\"1129\":1}}],[\"根据注册的\",{\"1\":{\"1104\":1}}],[\"根据不同种类的请求做不同类型的处理\",{\"1\":{\"944\":1}}],[\"根据文件过期时间来删除文件\",{\"1\":{\"870\":1}}],[\"根据是否启用\",{\"1\":{\"1052\":1}}],[\"根据是否配置自动重试来执行重试或者直接跳过\",{\"1\":{\"858\":1}}],[\"根据是否是strict模式\",{\"1\":{\"317\":1}}],[\"根据任务的执行状态来更新\",{\"1\":{\"855\":1}}],[\"根据consumequeue的有效延迟消息逻辑offset\",{\"1\":{\"845\":1,\"860\":1}}],[\"根据classpath读取资源时\",{\"1\":{\"56\":1}}],[\"根据delaylevel查找对应的延迟消息consumequeue\",{\"1\":{\"845\":1,\"860\":1}}],[\"根据store中获取的最大偏移量\",{\"1\":{\"823\":1}}],[\"根据topic和queueid从容器中取出挂起的拉取请求列表\",{\"1\":{\"825\":1}}],[\"根据topic和queueid构造map的key\",{\"1\":{\"822\":1}}],[\"根据topic和message\",{\"1\":{\"789\":1,\"794\":2}}],[\"根据上面的活动图来看一下\",{\"1\":{\"806\":1}}],[\"根据上面分而治之的优化思想\",{\"1\":{\"127\":1}}],[\"根据轮询设定的超时阈值大小的不同\",{\"1\":{\"804\":1}}],[\"根据key的hash值计算hash槽的绝对位置\",{\"1\":{\"797\":1}}],[\"根据逻辑偏移量从\",{\"1\":{\"767\":2,\"1174\":1}}],[\"根据期望的偏移量找到对应的内存映射文件\",{\"1\":{\"765\":1}}],[\"根据消费队列判断消息是否匹配过滤规则\",{\"1\":{\"1318\":1}}],[\"根据消费队列过滤时\",{\"1\":{\"1314\":1}}],[\"根据消费队列索引从\",{\"1\":{\"1164\":1}}],[\"根据消费结果设置返回状态\",{\"1\":{\"1218\":1}}],[\"根据消费状态判定返回结果\",{\"1\":{\"1188\":1}}],[\"根据消费组\",{\"1\":{\"1173\":1}}],[\"根据消费者类型不同有着不同的实现\",{\"1\":{\"1134\":1}}],[\"根据消费的\",{\"1\":{\"751\":1}}],[\"根据消息\",{\"0\":{\"1436\":1}}],[\"根据消息逻辑偏移量一条一条从缓存中查询消息\",{\"1\":{\"1409\":1}}],[\"根据消息属性精确匹配的性能消耗比较大\",{\"1\":{\"1313\":1}}],[\"根据消息的属性和\",{\"1\":{\"1315\":1}}],[\"根据消息的\",{\"1\":{\"1303\":1}}],[\"根据消息的偏移量和消息的大小从\",{\"1\":{\"767\":1,\"1174\":1}}],[\"根据消息发回请求中带的物理偏移量\",{\"1\":{\"1188\":1}}],[\"根据消息发送方式进行网络传输\",{\"1\":{\"1053\":1}}],[\"根据消息发送方式\",{\"1\":{\"1053\":1}}],[\"根据消息发送方式调用\",{\"1\":{\"1042\":1}}],[\"根据消息发送的\",{\"1\":{\"668\":1}}],[\"根据消息队列从本地缓存查询对应的\",{\"1\":{\"1160\":1}}],[\"根据消息分发请求构建索引\",{\"1\":{\"789\":1,\"794\":1}}],[\"根据消息在\",{\"1\":{\"747\":1}}],[\"根据哈希结果将生产者发送的消息路由到哪个队列中\",{\"1\":{\"708\":1}}],[\"根据镜像队列的机制\",{\"1\":{\"669\":1}}],[\"根据习惯的手法来选择\",{\"1\":{\"403\":1}}],[\"根据我打\",{\"1\":{\"401\":1}}],[\"根据副本和层数进行调整\",{\"1\":{\"401\":1}}],[\"根据虚拟节点的数量和名称\",{\"1\":{\"394\":1}}],[\"根据提供服务的对象可以划分为对外和对内两层\",{\"1\":{\"372\":1}}],[\"根据响应码判断失败原因\",{\"1\":{\"348\":1}}],[\"根据openchaos内置的算法来计算出要弹到的目标规模\",{\"1\":{\"285\":1}}],[\"根据设置的并发数建立相应个数的客户端\",{\"1\":{\"280\":1}}],[\"根据国内外科技媒体调研统计\",{\"1\":{\"276\":1}}],[\"根据\",{\"1\":{\"123\":1,\"764\":1,\"767\":1,\"794\":1,\"797\":2,\"825\":1,\"942\":1,\"954\":1,\"972\":1,\"1021\":1,\"1037\":1,\"1053\":2,\"1138\":1,\"1143\":1,\"1263\":1,\"1276\":1,\"1280\":1,\"1299\":1,\"1328\":1,\"1333\":2,\"1364\":1,\"1403\":1,\"1408\":1,\"1415\":1,\"1425\":1,\"1430\":1,\"1432\":1,\"1436\":3,\"1519\":1}}],[\"根据异常回滚更加复杂\",{\"1\":{\"87\":1}}],[\"根据字段名获取当前类的某个field\",{\"1\":{\"38\":1}}],[\"根据字段名获取某个public的field\",{\"1\":{\"38\":1}}],[\"茁壮植被\",{\"1\":{\"401\":1}}],[\"共用一个类\",{\"1\":{\"869\":1}}],[\"共用了一个通用的解析方法\",{\"1\":{\"742\":1}}],[\"共享\",{\"1\":{\"700\":1,\"701\":1}}],[\"共识协议\",{\"1\":{\"695\":1}}],[\"共识协议逐渐成为了工业上大量使用的分布式共识协议\",{\"1\":{\"694\":1}}],[\"共识算法的一个变种\",{\"1\":{\"694\":1}}],[\"共振弹幕\",{\"1\":{\"428\":1}}],[\"共生绽华有\",{\"1\":{\"401\":1}}],[\"共生绽华\",{\"1\":{\"401\":1}}],[\"共生绽华会使你的目标收到的治疗效果提升\",{\"1\":{\"401\":1}}],[\"共生绽华可以被以下英雄天赋增强\",{\"1\":{\"401\":1}}],[\"共注入十次主节点网络分区故障\",{\"1\":{\"284\":1}}],[\"点定时了\",{\"1\":{\"1344\":1}}],[\"点删一次\",{\"1\":{\"870\":1}}],[\"点这个小时都是删除文件的时间窗\",{\"1\":{\"870\":1}}],[\"点这一小时中每\",{\"1\":{\"866\":1}}],[\"点开始\",{\"1\":{\"866\":1}}],[\"点指的是\",{\"1\":{\"866\":1}}],[\"点\",{\"1\":{\"864\":1,\"866\":2,\"870\":1}}],[\"点击队列名称可以进入查看队列详细信息\",{\"1\":{\"655\":1}}],[\"点名高额\",{\"1\":{\"442\":1}}],[\"点名前记得散开\",{\"1\":{\"431\":1}}],[\"点名\",{\"1\":{\"426\":1}}],[\"点名的人开减伤\",{\"1\":{\"472\":1}}],[\"点名的人\",{\"1\":{\"411\":1,\"448\":1}}],[\"点名则给点名的人\",{\"1\":{\"411\":1}}],[\"点别的\",{\"1\":{\"403\":1}}],[\"点出夺魂咆哮是为了多一个群控\",{\"1\":{\"403\":1}}],[\"点生命值\",{\"1\":{\"401\":1,\"405\":2,\"407\":1}}],[\"点语法\",{\"1\":{\"191\":1}}],[\"法强\",{\"1\":{\"401\":2,\"405\":2,\"407\":1}}],[\"片梦境之瓣\",{\"1\":{\"401\":1}}],[\"林莽卫士\",{\"1\":{\"413\":1,\"489\":1}}],[\"林莽卫士使你的下一个指定目标的治疗效果会在附近产生\",{\"1\":{\"401\":1}}],[\"林中和谐\",{\"1\":{\"401\":1}}],[\"梦境涌现释放的治疗法术额外产生一篇梦境之瓣\",{\"1\":{\"401\":1}}],[\"梦境涌现\",{\"1\":{\"401\":1}}],[\"百花齐放鼠标指向\",{\"1\":{\"489\":1}}],[\"百花齐放\",{\"1\":{\"401\":1,\"489\":2}}],[\"天内的秒数\",{\"1\":{\"1367\":1}}],[\"天内要投递\",{\"1\":{\"1347\":1,\"1371\":1}}],[\"天之后无需新建时间轮文件\",{\"1\":{\"1346\":1}}],[\"天的消息可能会被老化清除\",{\"1\":{\"1343\":1}}],[\"天过期清除\",{\"1\":{\"924\":1}}],[\"天\",{\"1\":{\"922\":1,\"1343\":1,\"1346\":1}}],[\"天降绿水\",{\"1\":{\"453\":1}}],[\"天赋代码\",{\"1\":{\"402\":1}}],[\"天赋\",{\"0\":{\"402\":1}}],[\"天赋解析\",{\"1\":{\"401\":1}}],[\"天池中间件大赛百万队列存储设计总结\",{\"1\":{\"137\":1}}],[\"猫奶的治疗量加成确实大\",{\"1\":{\"401\":1}}],[\"猫奶除了上述效果以外还有的关键天赋\",{\"1\":{\"401\":1}}],[\"猫奶\",{\"1\":{\"401\":2}}],[\"猫奶比树奶在大多数场景下的表现更好\",{\"1\":{\"401\":1}}],[\"猫奶更偏向于单奶和猫形态下的伤害\",{\"1\":{\"401\":1}}],[\"毕业装备\",{\"0\":{\"479\":1}}],[\"毕业配装\",{\"1\":{\"400\":1}}],[\"毕达哥拉斯三元数组\",{\"1\":{\"184\":1}}],[\"机器的时间\",{\"1\":{\"866\":1}}],[\"机器时间的\",{\"1\":{\"866\":1}}],[\"机动性\",{\"1\":{\"400\":1}}],[\"机制\",{\"1\":{\"230\":1,\"441\":1,\"883\":1,\"990\":1,\"996\":1}}],[\"伤害统计\",{\"1\":{\"491\":1}}],[\"伤害的时候\",{\"1\":{\"460\":1}}],[\"伤害不多\",{\"1\":{\"455\":1}}],[\"伤害不错\",{\"1\":{\"401\":1}}],[\"伤害比较高之外这个本其实\",{\"1\":{\"455\":1}}],[\"伤害提升和\",{\"1\":{\"421\":1}}],[\"伤害还凑合\",{\"1\":{\"403\":1}}],[\"伤害很足\",{\"1\":{\"403\":1}}],[\"伤害很高的本\",{\"1\":{\"403\":1}}],[\"伤害压力小就换结界\",{\"1\":{\"403\":1}}],[\"伤害\",{\"1\":{\"400\":1,\"411\":1,\"415\":1,\"421\":1,\"428\":1,\"432\":1,\"440\":2,\"457\":2,\"459\":1}}],[\"伤害把我吓傻了\",{\"1\":{\"399\":1}}],[\"概念和应用场景\",{\"0\":{\"1337\":1}}],[\"概念和消费流程\",{\"0\":{\"1085\":1},\"1\":{\"1538\":1}}],[\"概念简述\",{\"0\":{\"1087\":1}}],[\"概要流程\",{\"0\":{\"617\":1,\"806\":1,\"834\":1}}],[\"概要设计中讲到\",{\"1\":{\"1411\":1}}],[\"概要设计\",{\"0\":{\"386\":1,\"748\":1,\"779\":1,\"943\":1,\"1010\":1,\"1060\":1,\"1108\":1,\"1127\":1,\"1148\":1,\"1178\":1,\"1204\":1,\"1250\":1,\"1289\":1,\"1311\":1,\"1340\":1,\"1384\":1,\"1446\":1,\"1476\":1,\"1507\":1}}],[\"概述\",{\"0\":{\"400\":1,\"610\":1,\"630\":1,\"682\":1,\"720\":1,\"745\":1,\"776\":1,\"800\":1,\"831\":1,\"850\":1,\"864\":1,\"886\":1,\"940\":1,\"977\":1,\"1025\":1,\"1530\":1}}],[\"希望能将这些页面都锁定在物理内存中\",{\"1\":{\"882\":1}}],[\"希望能够推动这一领域的标准诞生\",{\"1\":{\"276\":1}}],[\"希望看到的小树苗都能在大米的路上少走弯路快速提升\",{\"1\":{\"399\":1}}],[\"翻译自\",{\"1\":{\"692\":1}}],[\"翻译的过程中也会去查看每个技能描述\",{\"1\":{\"399\":1}}],[\"翻译者\",{\"1\":{\"398\":1}}],[\"申请集合石的时候慢慢写的\",{\"1\":{\"399\":1}}],[\"申请一个线程进行发送\",{\"1\":{\"116\":1}}],[\"申请一个线程处理读取\",{\"1\":{\"116\":1}}],[\"冲垮\",{\"1\":{\"1344\":1}}],[\"冲刷到\",{\"1\":{\"1300\":1}}],[\"冲突时\",{\"1\":{\"1386\":1}}],[\"冲突时变成链表结构\",{\"1\":{\"786\":1}}],[\"冲突的可能\",{\"1\":{\"786\":1}}],[\"冲\",{\"1\":{\"399\":1}}],[\"弱势职业的劣势也体现出来\",{\"1\":{\"399\":1}}],[\"完最后一条消息\",{\"1\":{\"1519\":1}}],[\"完整消息内容\",{\"1\":{\"1318\":1}}],[\"完整类型声明\",{\"1\":{\"547\":1}}],[\"完后解锁\",{\"1\":{\"1270\":1}}],[\"完全关闭之前\",{\"1\":{\"960\":1}}],[\"完全是顺序写\",{\"1\":{\"877\":1}}],[\"完全不一样了\",{\"1\":{\"399\":1}}],[\"完成的\",{\"1\":{\"1521\":1}}],[\"完成请求体解析和一些参数和权限的校验\",{\"1\":{\"1257\":1}}],[\"完成消息轨迹的保存\",{\"1\":{\"1011\":1}}],[\"完成消息的存储和持久化工作\",{\"1\":{\"689\":1}}],[\"完成消息的存储以及可能的持久化工作等\",{\"1\":{\"671\":1}}],[\"完成了大量预操作\",{\"1\":{\"737\":1}}],[\"完成后它会交换这两个\",{\"1\":{\"724\":1}}],[\"完成\",{\"1\":{\"379\":1,\"1131\":1,\"1257\":1,\"1262\":1,\"1263\":1,\"1510\":1}}],[\"渐渐的能限\",{\"1\":{\"399\":1}}],[\"渐渐从打\",{\"1\":{\"399\":1}}],[\"左边是老的索引文件格式\",{\"1\":{\"1418\":1}}],[\"左边是定时消息到期投递线程\",{\"1\":{\"856\":1}}],[\"左边\",{\"1\":{\"1156\":1}}],[\"左边其实是一个通用的解码方法\",{\"1\":{\"742\":1}}],[\"左边可以根据需要来调整\",{\"1\":{\"403\":1}}],[\"左右两个从节点\",{\"1\":{\"1481\":1}}],[\"左右的总耗时\",{\"1\":{\"896\":1}}],[\"左右\",{\"1\":{\"399\":1,\"401\":1,\"403\":2,\"917\":1,\"927\":1}}],[\"左移窗口\",{\"1\":{\"153\":1}}],[\"抄前排大佬的天赋\",{\"1\":{\"399\":1}}],[\"于是决定分多篇来写\",{\"1\":{\"1086\":1}}],[\"于是决定降低一个数量级\",{\"1\":{\"927\":1}}],[\"于是将\",{\"1\":{\"1080\":1}}],[\"于是想办法修改\",{\"1\":{\"1079\":1}}],[\"于是需要获取\",{\"1\":{\"1039\":1}}],[\"于是轨迹数据的采集可以放在钩子函数中进行\",{\"1\":{\"1010\":1}}],[\"于是最终决定采用发送一条\",{\"1\":{\"935\":1}}],[\"于是投递的逻辑变成这样\",{\"1\":{\"932\":1}}],[\"于是毅然选择自研存储\",{\"1\":{\"928\":1}}],[\"于是在\",{\"1\":{\"915\":1}}],[\"于是这里改成也使用\",{\"1\":{\"912\":1}}],[\"于是优化成没有反向\",{\"1\":{\"888\":1}}],[\"于是写\",{\"1\":{\"877\":1}}],[\"于是接下来的第二阶段它又可以批量处理\",{\"1\":{\"724\":1}}],[\"于是手动安装\",{\"1\":{\"645\":1}}],[\"于是我就把\",{\"1\":{\"399\":1}}],[\"于是就去\",{\"1\":{\"399\":1}}],[\"于是带着不断变强的想法踏上大米之路\",{\"1\":{\"399\":1}}],[\"拿起自己\",{\"1\":{\"399\":1}}],[\"拿到一个索引项后从中获取定时消息存储位置\",{\"1\":{\"930\":1}}],[\"拿到resp\",{\"1\":{\"354\":1}}],[\"拿到就绪通道的选择键\",{\"1\":{\"122\":1}}],[\"适用于消息丢失也没有太大影响的场景\",{\"1\":{\"1027\":1}}],[\"适用于小规模的性能分析\",{\"1\":{\"255\":1}}],[\"适合各个消费者都需要通知的场景\",{\"1\":{\"1090\":1}}],[\"适合开始就拉一波大的本\",{\"1\":{\"485\":1}}],[\"适合集合石的\",{\"1\":{\"429\":1,\"443\":1,\"455\":1}}],[\"适合\",{\"1\":{\"403\":1}}],[\"适合我这种加班的打工人体制\",{\"1\":{\"399\":1}}],[\"适应词缀和对应的副本\",{\"1\":{\"403\":1}}],[\"练级也快了\",{\"1\":{\"399\":1}}],[\"国服的卡\",{\"1\":{\"473\":1}}],[\"国服回归因为好多朋友都回来玩所以突然有个念头想回来和朋友一起吹逼\",{\"1\":{\"399\":1}}],[\"国内由信通院牵头的混沌工程实验室也在如火如荼地推动该领域的飞速发展\",{\"1\":{\"276\":1}}],[\"没法打断的圆形范围伤害\",{\"1\":{\"461\":1}}],[\"没什么压力\",{\"1\":{\"422\":1}}],[\"没车队真的难\",{\"1\":{\"399\":1}}],[\"没办法这时候重新去研究\",{\"1\":{\"399\":1}}],[\"没怎么玩就\",{\"1\":{\"399\":1}}],[\"没有推送新日志\",{\"1\":{\"1520\":1}}],[\"没有积压的\",{\"1\":{\"1520\":1}}],[\"没有存储任何数据\",{\"1\":{\"1519\":1}}],[\"没有新的日志条目需要推送\",{\"1\":{\"1519\":1}}],[\"没有新消息\",{\"1\":{\"1175\":1}}],[\"没有数据\",{\"1\":{\"1510\":1}}],[\"没有数据要提交\",{\"1\":{\"1428\":1}}],[\"没有半数心跳响应成功\",{\"1\":{\"1499\":1}}],[\"没有主从切换能力\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"没有主动解锁\",{\"1\":{\"1212\":1}}],[\"没有请求成功则下次继续回查\",{\"1\":{\"1468\":1}}],[\"没有操作消息\",{\"1\":{\"1468\":1}}],[\"没有强制刷盘\",{\"1\":{\"1427\":1}}],[\"没有它的情况下也能正常消费消息\",{\"1\":{\"1414\":1}}],[\"没有读写操作\",{\"1\":{\"1382\":1}}],[\"没有更新slave的消费队列时间戳到checkpoint中的逻辑\",{\"1\":{\"1297\":1}}],[\"没有消费到新的消息\",{\"1\":{\"1278\":1}}],[\"没有消费到新消息\",{\"1\":{\"1278\":1}}],[\"没有查询到消息的次数\",{\"1\":{\"1278\":1}}],[\"没有拉取到消息\",{\"1\":{\"1269\":1,\"1270\":1}}],[\"没有满\",{\"1\":{\"1269\":1}}],[\"没有匹配的消息\",{\"1\":{\"1175\":1}}],[\"没有上报心跳\",{\"1\":{\"954\":1}}],[\"没有收到心跳\",{\"1\":{\"945\":1}}],[\"没有加锁而是采用\",{\"1\":{\"915\":1}}],[\"没有拷贝和新对象的创建\",{\"1\":{\"894\":1}}],[\"没有决定性优势\",{\"1\":{\"893\":1}}],[\"没有别的线程跟它竞争\",{\"1\":{\"724\":1}}],[\"没有了同步问题\",{\"1\":{\"696\":1}}],[\"没有返回值\",{\"1\":{\"606\":1}}],[\"没有指定定位方法时\",{\"1\":{\"597\":1}}],[\"没有任何限制\",{\"1\":{\"502\":1}}],[\"没有的话我们最好把一个法师设焦点来补断箭雨\",{\"1\":{\"458\":1}}],[\"没有的话用森林再生的大树\",{\"1\":{\"433\":1}}],[\"没有裁缝的话会有第二波\",{\"1\":{\"428\":1}}],[\"没有他很不习惯\",{\"1\":{\"403\":1}}],[\"没有余力去打输出\",{\"1\":{\"403\":1}}],[\"没有预铺就是直接死\",{\"1\":{\"399\":1}}],[\"没有垃圾收集机制\",{\"1\":{\"247\":1}}],[\"没有\",{\"1\":{\"182\":1,\"406\":1,\"457\":1,\"1446\":1}}],[\"没有客户端连接则直接返回\",{\"1\":{\"123\":1}}],[\"没有被抛出的异常称为\",{\"1\":{\"34\":1}}],[\"金融级稳定的高性能消息队列\",{\"1\":{\"874\":1}}],[\"金团是我唯一的乐趣\",{\"1\":{\"399\":1}}],[\"金甲虫\",{\"1\":{\"398\":1}}],[\"游戏时间不多\",{\"1\":{\"399\":1}}],[\"末期就入坑\",{\"1\":{\"399\":1}}],[\"年久失修\",{\"1\":{\"1073\":1}}],[\"年的消息\",{\"1\":{\"928\":1}}],[\"年的延迟消息\",{\"1\":{\"922\":1}}],[\"年的\",{\"1\":{\"886\":1}}],[\"年没打\",{\"1\":{\"399\":1}}],[\"年星际\",{\"1\":{\"399\":1}}],[\"年\",{\"1\":{\"399\":1,\"922\":1,\"937\":1}}],[\"另外如果消费消息用时超过了\",{\"1\":{\"1251\":1}}],[\"另外一个触发\",{\"1\":{\"952\":1}}],[\"另外有一个\",{\"1\":{\"724\":1}}],[\"另外写法\",{\"1\":{\"524\":1}}],[\"另外\",{\"1\":{\"506\":1}}],[\"另外老一消柱子也要分配好\",{\"1\":{\"438\":1}}],[\"另外图中键位也可以参考\",{\"1\":{\"399\":1}}],[\"另\",{\"1\":{\"399\":1}}],[\"另一类是保存所有分级存储文件句柄\",{\"1\":{\"1395\":1}}],[\"另一方面\",{\"1\":{\"874\":1}}],[\"另一个触发路由删除逻辑的是\",{\"1\":{\"954\":1}}],[\"另一个与apply\",{\"1\":{\"319\":1}}],[\"另一个优化思路是基于事件启动\",{\"1\":{\"117\":1}}],[\"另一种实现方案\",{\"0\":{\"1364\":1}}],[\"另一种称为\",{\"1\":{\"597\":1}}],[\"另一种写法\",{\"1\":{\"522\":1,\"554\":1}}],[\"另一种是给映射组添加一个全新的k\",{\"1\":{\"192\":1}}],[\"另一种方式是将调用包裹在`catch`表达式中\",{\"1\":{\"193\":1,\"195\":1}}],[\"另一种方式\",{\"1\":{\"10\":1}}],[\"先校验日志追加请求的合法性\",{\"1\":{\"1509\":1}}],[\"先给自己投票\",{\"1\":{\"1480\":1}}],[\"先恢复分级存储\",{\"1\":{\"1421\":1}}],[\"先读取消费队列数据\",{\"1\":{\"1391\":1}}],[\"先批量上传消息数据\",{\"1\":{\"1388\":1}}],[\"先批量将取消请求入队\",{\"1\":{\"1358\":1}}],[\"先存到一个延迟\",{\"1\":{\"1342\":1}}],[\"先判断拉取消息请求是否带有过滤信息\",{\"1\":{\"1321\":1}}],[\"先判断文件是否存在\",{\"1\":{\"793\":1}}],[\"先计算消息的\",{\"1\":{\"1314\":1}}],[\"先调用\",{\"1\":{\"1294\":1,\"1324\":1}}],[\"先尝试从缓存中读消息\",{\"1\":{\"1409\":1}}],[\"先尝试从消息拉取请求中获取过滤信息\",{\"1\":{\"1318\":1}}],[\"先尝试放入内存匹配\",{\"1\":{\"1273\":1}}],[\"先尝试将\",{\"1\":{\"1260\":1}}],[\"先尝试使用读锁\",{\"1\":{\"793\":1}}],[\"先运行\",{\"1\":{\"1248\":1}}],[\"先试着获取\",{\"1\":{\"1215\":1}}],[\"先获取锁容器的改动锁\",{\"1\":{\"1214\":1}}],[\"先获取或创建死信队列\",{\"1\":{\"1188\":1}}],[\"先获延迟等级取对应的\",{\"1\":{\"845\":1}}],[\"先找到\",{\"1\":{\"1188\":1}}],[\"先检查处理队列是否被丢弃\",{\"1\":{\"1188\":1}}],[\"先根据较少的信息\",{\"1\":{\"1318\":1}}],[\"先根据\",{\"1\":{\"1174\":1,\"1318\":1,\"1446\":1,\"1492\":1}}],[\"先根据上一步选择的队列\",{\"1\":{\"1042\":1}}],[\"先从内存查找\",{\"1\":{\"1171\":1}}],[\"先向\",{\"1\":{\"1136\":1}}],[\"先看一下\",{\"1\":{\"1109\":1}}],[\"先看一下代码上的改动\",{\"1\":{\"737\":1}}],[\"先更新到内存\",{\"1\":{\"1104\":1}}],[\"先了解一下\",{\"1\":{\"1086\":1}}],[\"先加载\",{\"1\":{\"947\":1,\"961\":1}}],[\"先发送的不一定先投递\",{\"1\":{\"926\":1}}],[\"先来了解一下\",{\"1\":{\"978\":1}}],[\"先来先投递\",{\"1\":{\"925\":1}}],[\"先来看直接走分级存储读取的场景\",{\"1\":{\"1408\":1}}],[\"先来看一下类图\",{\"1\":{\"1117\":1}}],[\"先来看一下本次性能优化的所有优化项\",{\"1\":{\"886\":1}}],[\"先来看一下删除\",{\"1\":{\"870\":1}}],[\"先来看看\",{\"1\":{\"800\":1}}],[\"先查本地缓存\",{\"1\":{\"1042\":1}}],[\"先查询对应\",{\"1\":{\"878\":1}}],[\"先查出当前\",{\"1\":{\"871\":1}}],[\"先导入\",{\"1\":{\"712\":1}}],[\"先声明一个空对象\",{\"1\":{\"556\":1}}],[\"先把嗜血开了\",{\"1\":{\"443\":1}}],[\"先站到靠近黑洞的地方\",{\"1\":{\"441\":1}}],[\"先贴个自己的大米分数\",{\"1\":{\"399\":1}}],[\"先将原始消息以事务半消息的形式发送到服务端\",{\"1\":{\"1446\":1}}],[\"先将消息放入缓冲区\",{\"1\":{\"1427\":1}}],[\"先将消息存至默认的本地存储中\",{\"1\":{\"1400\":1}}],[\"先将等待上传的这部分消息放入刷盘缓冲区\",{\"1\":{\"1388\":1}}],[\"先将\",{\"1\":{\"125\":1,\"1403\":1}}],[\"译者注\",{\"1\":{\"400\":1,\"401\":1,\"403\":1,\"406\":1,\"407\":1,\"411\":1,\"412\":2,\"417\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"429\":1,\"431\":1,\"432\":1,\"433\":1,\"434\":1,\"436\":1,\"438\":1,\"439\":1,\"440\":1,\"441\":1,\"443\":1,\"445\":1,\"446\":1,\"447\":1,\"448\":1,\"449\":1,\"451\":1,\"452\":1,\"453\":1,\"455\":1,\"457\":1,\"458\":1,\"459\":1,\"460\":1,\"461\":2,\"462\":1,\"464\":1,\"465\":1,\"466\":1,\"468\":1,\"469\":1,\"471\":1,\"473\":1,\"476\":1,\"480\":1,\"482\":1,\"485\":3,\"488\":1,\"491\":1,\"492\":1}}],[\"译者序\",{\"0\":{\"399\":1}}],[\"译文\",{\"1\":{\"136\":1}}],[\"首条位置\",{\"1\":{\"1351\":1}}],[\"首选需要修改一下\",{\"1\":{\"1075\":1}}],[\"首次注册\",{\"1\":{\"971\":1}}],[\"首字母大写的number\",{\"1\":{\"506\":1}}],[\"首杀团成员\",{\"1\":{\"398\":1}}],[\"首先检查内存队列是否已满\",{\"1\":{\"1516\":1}}],[\"首先根据读取策略\",{\"1\":{\"1391\":1}}],[\"首先先来根据下面这张图来观察\",{\"1\":{\"1300\":1}}],[\"首先是如何采集数据\",{\"1\":{\"1010\":1}}],[\"首先操作起来太复杂\",{\"1\":{\"942\":1}}],[\"首先分析了任意时间定时消息实现的难点\",{\"1\":{\"936\":1}}],[\"首先想到的方法是将\",{\"1\":{\"915\":1}}],[\"首先这里面有使用\",{\"1\":{\"909\":1}}],[\"首先回顾一下同步投递的逻辑\",{\"1\":{\"855\":1}}],[\"首先看一下\",{\"1\":{\"785\":1}}],[\"首先看生产者消费者直接与主节点连接的情况\",{\"1\":{\"668\":1}}],[\"首先查询出这些偏移量信息\",{\"1\":{\"782\":1}}],[\"首先保存到\",{\"1\":{\"755\":1}}],[\"首先需要明确延迟消息与定时消息虽然意思不同\",{\"1\":{\"1338\":1}}],[\"首先需要用版本号来创建一个\",{\"1\":{\"1074\":1}}],[\"首先需要在\",{\"1\":{\"983\":1,\"1061\":1}}],[\"首先需要找到\",{\"1\":{\"887\":1}}],[\"首先需要补充一点消费相关的前置知识\",{\"1\":{\"800\":1}}],[\"首先需要安装\",{\"1\":{\"642\":1}}],[\"首先需要确定节点的虚拟节点数量\",{\"1\":{\"392\":1}}],[\"首先需要实现一个哈希算法\",{\"1\":{\"390\":1}}],[\"首先判断了delayms的时长\",{\"1\":{\"379\":1}}],[\"首先判断当前可用的worker节点数是否达到了maxworkercount\",{\"1\":{\"378\":1}}],[\"首先执行\",{\"1\":{\"194\":1}}],[\"首先\",{\"1\":{\"21\":1,\"368\":1,\"995\":1,\"1300\":1}}],[\"尼鲁巴尔王宫\",{\"1\":{\"398\":1}}],[\"卖豆腐啦\",{\"1\":{\"398\":1}}],[\"名加入集群信息表\",{\"1\":{\"971\":1}}],[\"名\",{\"1\":{\"964\":1}}],[\"名称前缀必须是\",{\"1\":{\"1287\":1}}],[\"名称为\",{\"1\":{\"1188\":1}}],[\"名称\",{\"1\":{\"952\":1,\"1052\":1,\"1065\":1,\"1197\":1,\"1288\":1,\"1352\":1}}],[\"名称列表\",{\"1\":{\"944\":1}}],[\"名称和读写队列数量\",{\"1\":{\"944\":1}}],[\"名称过长\",{\"1\":{\"906\":1}}],[\"名称的正则匹配检查\",{\"0\":{\"904\":1}}],[\"名称可以为\",{\"1\":{\"393\":1}}],[\"名字更重要\",{\"1\":{\"582\":1}}],[\"名字空间\",{\"0\":{\"313\":1}}],[\"算该本最简单的\",{\"1\":{\"426\":1}}],[\"算法的\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"算法实现\",{\"1\":{\"668\":1}}],[\"算法\",{\"1\":{\"390\":1}}],[\"算数表达式\",{\"0\":{\"201\":1}}],[\"经常看到有人捏着减伤不用\",{\"1\":{\"492\":1}}],[\"经常死\",{\"1\":{\"492\":1}}],[\"经常中地板暴毙\",{\"1\":{\"399\":1}}],[\"经常用到\",{\"1\":{\"44\":1}}],[\"经过重排后的格式\",{\"1\":{\"1412\":1}}],[\"经过几次重构\",{\"1\":{\"1380\":1}}],[\"经过上面的分析\",{\"1\":{\"929\":1}}],[\"经过这个改动\",{\"1\":{\"915\":1}}],[\"经过哈希得到的整数\",{\"1\":{\"787\":1}}],[\"经过哈希函数计算得出哈希环上的位置\",{\"1\":{\"395\":1}}],[\"经过hash\",{\"1\":{\"786\":1}}],[\"经过一些实践测试\",{\"1\":{\"733\":1}}],[\"经过削弱已经没那么难了\",{\"1\":{\"459\":1}}],[\"经过\",{\"1\":{\"387\":1,\"780\":1,\"913\":1,\"1393\":1}}],[\"马洛克\",{\"0\":{\"451\":1}}],[\"马上进行下次拉取\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"马上拉取该消息\",{\"1\":{\"803\":1}}],[\"马上吃掉一个获取不稳定的能量来增加治疗效果\",{\"1\":{\"439\":1}}],[\"马上就可以由其它可用server去接管\",{\"1\":{\"380\":1}}],[\"马海\",{\"1\":{\"286\":1}}],[\"试想下\",{\"1\":{\"379\":1}}],[\"看该消息是否到期\",{\"1\":{\"1188\":1}}],[\"看完本文能够对消息消费涉及到的相关类和消费流程有大体的了解\",{\"1\":{\"1107\":1}}],[\"看一看它究竟是怎么实现的\",{\"1\":{\"922\":1}}],[\"看一下它支持的版本号列表\",{\"1\":{\"1073\":1}}],[\"看一下\",{\"1\":{\"723\":1,\"990\":1}}],[\"看一下源码中如何处理信用的流动和消息的阻塞\",{\"1\":{\"623\":1}}],[\"看作是索引项组成的数组\",{\"1\":{\"749\":1}}],[\"看箭头躲开\",{\"1\":{\"442\":1}}],[\"看似没什么灭点\",{\"1\":{\"422\":1}}],[\"看到这里可能有疑问\",{\"1\":{\"374\":1}}],[\"看是否小于某个阈值\",{\"1\":{\"295\":1}}],[\"派发的执行任务并完成计算\",{\"1\":{\"372\":1}}],[\"派生类\",{\"1\":{\"53\":1,\"54\":1}}],[\"得到当前集群中的大多数节点已经写入的日志序号\",{\"1\":{\"1507\":1}}],[\"得到一个二进制数组\",{\"1\":{\"1315\":1}}],[\"得到一个固定长度的输出摘要\",{\"1\":{\"385\":1}}],[\"得到重平衡后的该消费者分到的消息队列\",{\"1\":{\"1143\":1}}],[\"得到分配给当前消费者实例的队列列表\",{\"1\":{\"1143\":1}}],[\"得到的位数组\",{\"1\":{\"1323\":1}}],[\"得到的整数\",{\"1\":{\"786\":1}}],[\"得到的一个\",{\"1\":{\"780\":1}}],[\"得到\",{\"1\":{\"786\":1,\"904\":1,\"906\":1}}],[\"得分最高的节点将作为本次任务的\",{\"1\":{\"372\":1}}],[\"得出测试结果并输出可视化图表\",{\"1\":{\"280\":2}}],[\"角色\",{\"1\":{\"372\":1,\"976\":1,\"978\":2,\"1491\":2}}],[\"种执行结果\",{\"1\":{\"1442\":1}}],[\"种本地事务的执行结果\",{\"1\":{\"1442\":1,\"1445\":1}}],[\"种方式\",{\"1\":{\"1246\":1}}],[\"种消费方式\",{\"1\":{\"1203\":1}}],[\"种消费者实现\",{\"1\":{\"1136\":1}}],[\"种消息发送方式\",{\"1\":{\"1027\":1}}],[\"种发送方式\",{\"1\":{\"1025\":1}}],[\"种作用域\",{\"1\":{\"978\":1}}],[\"种\",{\"1\":{\"978\":1}}],[\"种概念\",{\"1\":{\"978\":1}}],[\"种类\",{\"0\":{\"632\":1}}],[\"种类型的事件中的一种或几种\",{\"1\":{\"118\":1}}],[\"种类型的事件\",{\"1\":{\"118\":1}}],[\"种族\",{\"0\":{\"487\":1}}],[\"种不同颜色的宝石是为了触发顶峰渎神玉的特效\",{\"1\":{\"400\":1}}],[\"种角色\",{\"1\":{\"372\":1}}],[\"策略使用正则表达式来配置需要应用镜像策略的队列名称\",{\"1\":{\"652\":1}}],[\"策略\",{\"1\":{\"372\":1}}],[\"架构设计\",{\"1\":{\"974\":1}}],[\"架构设计与实现原理\",{\"1\":{\"884\":1}}],[\"架构解析\",{\"0\":{\"372\":1}}],[\"架构与案例分析\",{\"0\":{\"279\":1}}],[\"极限冲层推荐暗夜精灵\",{\"1\":{\"487\":1}}],[\"极容易造成减员\",{\"1\":{\"461\":1}}],[\"极大加强自己的生存能力\",{\"1\":{\"482\":1}}],[\"极大提高目标收到的治疗效果\",{\"1\":{\"401\":1}}],[\"极大地提高开发效率\",{\"1\":{\"371\":1}}],[\"极致弹性\",{\"1\":{\"276\":1}}],[\"运算\",{\"1\":{\"1322\":2}}],[\"运算符可以取出\",{\"1\":{\"586\":1}}],[\"运算符可以获得类的自身类型\",{\"1\":{\"574\":1}}],[\"运算符\",{\"0\":{\"518\":1,\"586\":1},\"1\":{\"503\":1}}],[\"运算符==\",{\"1\":{\"503\":1}}],[\"运用顺序读写\",{\"1\":{\"874\":1}}],[\"运维\",{\"1\":{\"1385\":1}}],[\"运维人员\",{\"1\":{\"978\":1}}],[\"运维人员必须做出选择\",{\"1\":{\"693\":1}}],[\"运维便捷\",{\"1\":{\"371\":1}}],[\"运行结果\",{\"0\":{\"1445\":1}}],[\"运行一次\",{\"1\":{\"1403\":1}}],[\"运行的时候不断尝试从队列中取出拉取请求执行消息拉取动作\",{\"1\":{\"1152\":1}}],[\"运行的脚本下面添加\",{\"1\":{\"1081\":1}}],[\"运行脚本\",{\"1\":{\"1081\":1}}],[\"运行脚本之后\",{\"1\":{\"1072\":1}}],[\"运行之后会启动两个\",{\"1\":{\"1075\":1}}],[\"运行如下命令\",{\"1\":{\"1074\":1}}],[\"运行如下代码使用\",{\"1\":{\"7\":1}}],[\"运行机制复杂\",{\"1\":{\"942\":1}}],[\"运行所有消息\",{\"1\":{\"756\":1}}],[\"运行中\",{\"1\":{\"379\":1}}],[\"运行时诊断\",{\"0\":{\"256\":1}}],[\"运行字符串的命令并捕捉结果\",{\"1\":{\"243\":1}}],[\"运行\",{\"1\":{\"224\":1,\"645\":1}}],[\"运行程序的不同方式\",{\"0\":{\"224\":1}}],[\"运行在同一线程中\",{\"1\":{\"120\":2}}],[\"运行mvn\",{\"1\":{\"62\":1}}],[\"运行期\",{\"1\":{\"43\":1,\"85\":1}}],[\"运行测试\",{\"0\":{\"10\":1}}],[\"广播模式的消费者本地存储进度比较简单\",{\"1\":{\"1182\":1}}],[\"广播模式消费进度管理\",{\"0\":{\"1182\":1}}],[\"广播模式\",{\"1\":{\"1103\":1,\"1120\":1,\"1122\":1,\"1195\":1,\"1218\":1,\"1266\":1}}],[\"广播模式不支持顺序消费\",{\"1\":{\"1102\":1}}],[\"广播模式下服务端不维护消费进度\",{\"1\":{\"1090\":1}}],[\"广播模式下\",{\"1\":{\"1090\":3,\"1181\":1}}],[\"广播模式使用较少\",{\"1\":{\"1090\":1}}],[\"广播消费模式下不支持\",{\"1\":{\"1090\":2}}],[\"广播消费模式即全部的消息会广播分发到所有的消费者实例\",{\"1\":{\"1090\":1}}],[\"广播消费模式\",{\"0\":{\"1090\":1},\"1\":{\"1090\":1,\"1091\":1}}],[\"广播消息发送给节点b\",{\"1\":{\"674\":1}}],[\"广播一条内容为\",{\"1\":{\"674\":1}}],[\"广播\",{\"1\":{\"371\":1,\"1266\":1}}],[\"删掉不可用的部分\",{\"1\":{\"771\":1}}],[\"删\",{\"1\":{\"371\":1}}],[\"删除多余的数据\",{\"1\":{\"1510\":1}}],[\"删除多余的文件\",{\"1\":{\"759\":1}}],[\"删除事务半消息\",{\"1\":{\"1451\":2,\"1464\":2}}],[\"删除本地\",{\"1\":{\"1435\":1}}],[\"删除本地的新老格式的索引文件\",{\"1\":{\"1417\":1}}],[\"删除过期的日志时\",{\"1\":{\"1519\":1}}],[\"删除过期的文件\",{\"1\":{\"866\":1}}],[\"删除过期索引文件\",{\"1\":{\"1435\":1}}],[\"删除时\",{\"1\":{\"1419\":1}}],[\"删除它的路由信息\",{\"1\":{\"972\":1}}],[\"删除所有最大\",{\"1\":{\"872\":1}}],[\"删除逻辑队列文件\",{\"1\":{\"871\":1}}],[\"删除小于该\",{\"1\":{\"871\":1}}],[\"删除文件数量\",{\"1\":{\"870\":1}}],[\"删除文本对象并进入插入模式\",{\"1\":{\"148\":1}}],[\"删除两个文件的间隔\",{\"1\":{\"870\":1}}],[\"删除两个文件的间隔时间\",{\"1\":{\"870\":1}}],[\"删除成功的文件数量\",{\"1\":{\"870\":1}}],[\"删除物理文件的时间间隔\",{\"1\":{\"870\":1}}],[\"删除该\",{\"1\":{\"867\":1,\"972\":1}}],[\"删除该文件\",{\"1\":{\"52\":1}}],[\"删除消息请求\",{\"1\":{\"1373\":1}}],[\"删除消息commitlog偏移量offset之前的所有indexfile文件\",{\"1\":{\"795\":1,\"872\":1}}],[\"删除消息时并不会直接删除消息所在的文件\",{\"1\":{\"688\":1}}],[\"删除等\",{\"1\":{\"789\":1}}],[\"删除了无用的代码\",{\"1\":{\"736\":1}}],[\"删除了大量重复代码\",{\"1\":{\"731\":1}}],[\"删除节点上\",{\"1\":{\"1520\":2}}],[\"删除节点\",{\"0\":{\"394\":1}}],[\"删除key\",{\"1\":{\"301\":1}}],[\"删除一个不存在的school属性也不会报错\",{\"1\":{\"299\":1}}],[\"删除一个字符\",{\"1\":{\"147\":1}}],[\"删除name属性\",{\"1\":{\"299\":1}}],[\"删除num行\",{\"1\":{\"147\":1}}],[\"删除num个字符并入插入模式\",{\"1\":{\"148\":1}}],[\"删除num个字符\",{\"1\":{\"147\":1}}],[\"删除双引号里面的内容并进入插入模式\",{\"1\":{\"155\":1}}],[\"删除整行并进入插入操作\",{\"1\":{\"148\":1}}],[\"删除整行并进入插入模式\",{\"1\":{\"148\":1}}],[\"删除到``并进入插入模式\",{\"1\":{\"148\":1}}],[\"删除当前字符并进入插入模式\",{\"1\":{\"148\":1}}],[\"删除当前行\",{\"1\":{\"142\":1}}],[\"删除行\",{\"1\":{\"147\":1}}],[\"删除\",{\"1\":{\"144\":1,\"868\":1,\"872\":1,\"954\":1}}],[\"删除上一单词\",{\"1\":{\"142\":1}}],[\"删除上一字符\",{\"1\":{\"142\":1}}],[\"摘下网上的一幅图\",{\"1\":{\"371\":1}}],[\"固定大小\",{\"1\":{\"787\":1}}],[\"固定延迟和api四种定时调度策略\",{\"1\":{\"371\":1}}],[\"固定延迟等调度策略\",{\"1\":{\"370\":1}}],[\"固定频率\",{\"1\":{\"370\":1,\"371\":1}}],[\"支持二阶段的提交能力\",{\"1\":{\"1439\":1}}],[\"支持以插件的方式引入自定义的存储实现\",{\"1\":{\"1397\":1}}],[\"支持的过滤方式\",{\"0\":{\"1303\":1}}],[\"支持在配置文件中进行修改\",{\"1\":{\"1299\":1}}],[\"支持在线日志功能\",{\"1\":{\"371\":1}}],[\"支持在线配置任务依赖关系\",{\"1\":{\"371\":1}}],[\"支持对重试主题的属性进行过滤\",{\"1\":{\"1173\":1}}],[\"支持将重平衡流程在服务端实现\",{\"1\":{\"1131\":1}}],[\"支持将统一主题的一批消息打包发送\",{\"1\":{\"1044\":1}}],[\"支持两种消息模式\",{\"1\":{\"1088\":1}}],[\"支持多种消息发送的方式和特殊消息的发送\",{\"1\":{\"1025\":1}}],[\"支持多种消费方式\",{\"1\":{\"801\":1}}],[\"支持消息轨迹的查询\",{\"1\":{\"1009\":1}}],[\"支持\",{\"1\":{\"941\":1,\"1027\":1,\"1203\":1}}],[\"支持取消已经发送的定时消息\",{\"1\":{\"937\":1}}],[\"支持定时也要支持取消\",{\"1\":{\"935\":1}}],[\"支持更大的延迟时间意味着延迟消息更长的保存时间\",{\"1\":{\"924\":1}}],[\"支持任意时间的定时\",{\"1\":{\"923\":1}}],[\"支持最长\",{\"1\":{\"922\":1}}],[\"支持比较灵活的延迟消息\",{\"1\":{\"922\":1}}],[\"支持跨度很大的延迟消息\",{\"1\":{\"922\":1}}],[\"支持发送\",{\"0\":{\"905\":1}}],[\"支持延迟消息异步投递\",{\"0\":{\"853\":1}}],[\"支持延迟消息的异步投递\",{\"1\":{\"850\":1}}],[\"支持了\",{\"1\":{\"773\":1}}],[\"支持无限的水平扩展\",{\"1\":{\"371\":1}}],[\"支持spring\",{\"1\":{\"371\":1}}],[\"支持单机\",{\"1\":{\"371\":1}}],[\"支持cron表达式\",{\"1\":{\"371\":1}}],[\"支持cron\",{\"1\":{\"370\":1}}],[\"支持正则表达式\",{\"1\":{\"150\":1}}],[\"源码\",{\"1\":{\"1439\":1,\"1537\":1}}],[\"源码中内置了两种分级存储\",{\"1\":{\"1382\":1}}],[\"源码分析事务消息系列\",{\"1\":{\"1473\":1}}],[\"源码分析之\",{\"1\":{\"1001\":1}}],[\"源码分析rocketmq消息过滤机制下篇\",{\"1\":{\"1334\":1}}],[\"源码分析rocketmq消息轨迹\",{\"1\":{\"1022\":1}}],[\"源码分析rocketmq消息pull\",{\"1\":{\"829\":1}}],[\"源码分析rocketmq\",{\"1\":{\"1001\":1}}],[\"源码不在此处展示\",{\"1\":{\"765\":1}}],[\"源码比较熟悉\",{\"1\":{\"720\":1}}],[\"源码剖析\",{\"0\":{\"719\":1,\"862\":1,\"885\":1,\"939\":1,\"958\":1,\"975\":1,\"1023\":1,\"1528\":1},\"1\":{\"1538\":6}}],[\"源码见mapprocessor接口的map方法\",{\"1\":{\"378\":1}}],[\"源码解析\",{\"0\":{\"370\":1,\"377\":1,\"609\":1,\"623\":1,\"760\":1,\"791\":1,\"817\":1,\"830\":1,\"842\":1,\"859\":1,\"869\":1,\"992\":1,\"1016\":1,\"1045\":1,\"1106\":1,\"1121\":1,\"1124\":1,\"1139\":1,\"1146\":1,\"1166\":1,\"1176\":1,\"1192\":1,\"1202\":1,\"1220\":1,\"1243\":1,\"1264\":1,\"1282\":1,\"1295\":1,\"1301\":1,\"1326\":1,\"1335\":1,\"1365\":1,\"1376\":1,\"1422\":1,\"1438\":1,\"1455\":1,\"1474\":1,\"1493\":1,\"1505\":1,\"1513\":1,\"1524\":1},\"1\":{\"608\":1,\"718\":1,\"1338\":1,\"1538\":14}}],[\"源自官网\",{\"1\":{\"375\":1}}],[\"源代码中\",{\"1\":{\"191\":2}}],[\"响应计算\",{\"1\":{\"1519\":1}}],[\"响应处理\",{\"0\":{\"1488\":1,\"1491\":1}}],[\"响应\",{\"1\":{\"819\":1,\"1173\":1,\"1510\":1,\"1519\":3}}],[\"响应收到的消息\",{\"1\":{\"369\":1}}],[\"响应message事件\",{\"1\":{\"369\":1}}],[\"响应整个流程\",{\"1\":{\"120\":1}}],[\"咱们通信就不使用http协议了\",{\"1\":{\"368\":1}}],[\"准备\",{\"1\":{\"1519\":1}}],[\"准备推送下一条日志\",{\"1\":{\"1510\":1}}],[\"准备发起新一轮投票\",{\"1\":{\"1497\":1}}],[\"准备事务半消息\",{\"1\":{\"1463\":1}}],[\"准备提交\",{\"1\":{\"1427\":1}}],[\"准备重排和上传\",{\"1\":{\"1417\":1}}],[\"准备投递到\",{\"1\":{\"1356\":1,\"1359\":1,\"1371\":1,\"1373\":1}}],[\"准备构造拉取请求\",{\"1\":{\"1159\":1}}],[\"准备module对象\",{\"1\":{\"364\":1}}],[\"准备工作\",{\"0\":{\"272\":1}}],[\"堆外暴露变量\",{\"1\":{\"361\":1}}],[\"优点是降低冷数据的长期存储成本\",{\"1\":{\"1385\":1}}],[\"优点是池化存储\",{\"1\":{\"1385\":1}}],[\"优点\",{\"1\":{\"883\":1,\"928\":1}}],[\"优化过后构建\",{\"1\":{\"912\":1}}],[\"优化性能\",{\"1\":{\"904\":1}}],[\"优化之后完全没有新对象产生\",{\"1\":{\"900\":1}}],[\"优化方法\",{\"0\":{\"894\":1,\"900\":1,\"903\":1,\"909\":1,\"912\":1}}],[\"优化方案\",{\"0\":{\"891\":1,\"915\":1,\"916\":1}}],[\"优化的步骤是根据\",{\"1\":{\"917\":1}}],[\"优化的方法主要通过字符数组运算替代字符串操作\",{\"1\":{\"900\":1}}],[\"优化的方案是尽量减少反射的使用\",{\"1\":{\"891\":1}}],[\"优化的解码方法\",{\"1\":{\"742\":1}}],[\"优化此方法其实对性能没有什么提升\",{\"1\":{\"888\":1}}],[\"优化占用时间高且可以优化的地方\",{\"1\":{\"887\":1}}],[\"优化点主要是预先计算了需要解析成字符串的长度\",{\"1\":{\"741\":1}}],[\"优化前后效果\",{\"1\":{\"741\":1}}],[\"优化掉了字符串末尾的\",{\"1\":{\"740\":1}}],[\"优化字符串格式的属性存储\",{\"1\":{\"740\":1}}],[\"优化\",{\"0\":{\"730\":1,\"736\":1,\"737\":1,\"739\":1,\"741\":1,\"742\":1,\"889\":1},\"1\":{\"741\":2,\"904\":1}}],[\"优化2\",{\"0\":{\"726\":1}}],[\"优化1\",{\"0\":{\"725\":1}}],[\"优化分析\",{\"0\":{\"721\":1}}],[\"优化思路\",{\"0\":{\"115\":1}}],[\"优先处理\",{\"1\":{\"1520\":1}}],[\"优先从\",{\"1\":{\"1511\":1}}],[\"优先从预读缓存读取消息\",{\"1\":{\"1391\":1}}],[\"优先使用消息属性中的值\",{\"1\":{\"1468\":1}}],[\"优先保留最近一段时间最常使用的那些\",{\"1\":{\"879\":1}}],[\"优先级\",{\"1\":{\"698\":1}}],[\"优先去放黑洞\",{\"1\":{\"441\":1}}],[\"优先堆急速\",{\"1\":{\"421\":1}}],[\"优先选择具有你的持续治疗效果的目标\",{\"1\":{\"405\":1}}],[\"优势\",{\"1\":{\"360\":1}}],[\"才对该消息执行事务状态回查\",{\"1\":{\"1467\":1}}],[\"才可以应用改动\",{\"1\":{\"1005\":1}}],[\"才会实现\",{\"1\":{\"1341\":1}}],[\"才会将\",{\"1\":{\"1300\":1}}],[\"才会启动删除过期文件\",{\"1\":{\"864\":1}}],[\"才会向主节点返回写入成功\",{\"1\":{\"853\":1}}],[\"才会执行\",{\"1\":{\"738\":1}}],[\"才会被提升为主节点\",{\"1\":{\"659\":1}}],[\"才会被执行\",{\"1\":{\"359\":1}}],[\"才允许发送新的消息\",{\"1\":{\"664\":1}}],[\"才将上游进程的信用值加200\",{\"1\":{\"619\":1}}],[\"才恢复\",{\"1\":{\"613\":1}}],[\"才属于交叉类型a\",{\"1\":{\"516\":1}}],[\"才能将拉转换为推\",{\"1\":{\"1119\":1}}],[\"才能进行下一次查询\",{\"1\":{\"806\":1}}],[\"才能使用\",{\"1\":{\"503\":1}}],[\"才能吃住震地猛击不死\",{\"1\":{\"438\":1}}],[\"才打过的\",{\"1\":{\"433\":1}}],[\"才加载\",{\"1\":{\"37\":1}}],[\"抛出错误的函数\",{\"0\":{\"543\":1}}],[\"抛出错误\",{\"0\":{\"357\":1}}],[\"抛出异常\",{\"0\":{\"34\":1},\"1\":{\"1050\":1}}],[\"获得更高的吞吐量\",{\"1\":{\"707\":1}}],[\"获得丛林之魂和急速\",{\"1\":{\"411\":1}}],[\"获得\",{\"1\":{\"405\":1}}],[\"获得一个array\",{\"1\":{\"352\":1}}],[\"获取日志表中间的日志序号\",{\"1\":{\"1521\":1}}],[\"获取新投票轮次\",{\"1\":{\"1497\":1}}],[\"获取其他节点的投票响应\",{\"1\":{\"1480\":1}}],[\"获取其最近一次修改的时间\",{\"1\":{\"999\":1}}],[\"获取本地事务执行状态\",{\"1\":{\"1472\":1}}],[\"获取本地事务执行结果\",{\"1\":{\"1449\":1}}],[\"获取空消息的次数\",{\"1\":{\"1468\":1}}],[\"获取半消息队列对应的\",{\"1\":{\"1453\":1}}],[\"获取事务半消息\",{\"1\":{\"1453\":1,\"1468\":1}}],[\"获取时间范围内的所有索引文件\",{\"1\":{\"1436\":1}}],[\"获取时间轮当前槽\",{\"1\":{\"1372\":1}}],[\"获取时间轮一个槽位中对应的\",{\"1\":{\"1372\":1}}],[\"获取分级存储文件锁\",{\"1\":{\"1427\":1}}],[\"获取锁失败时直接返回\",{\"1\":{\"1427\":1}}],[\"获取查询时间范围内的所有索引文件\",{\"1\":{\"1415\":1}}],[\"获取整体要读的消息长度\",{\"1\":{\"1408\":1,\"1432\":1}}],[\"获取定时消息对应的时间轮槽\",{\"1\":{\"1371\":1}}],[\"获取定时消息主题的消费队列\",{\"1\":{\"1370\":1}}],[\"获取排序后的\",{\"1\":{\"1279\":1}}],[\"获取发起请求的消费组信息\",{\"1\":{\"1266\":1}}],[\"获取一批消息\",{\"1\":{\"1252\":1}}],[\"获取的这批消息为空\",{\"1\":{\"1230\":1}}],[\"获取成功\",{\"1\":{\"1225\":1}}],[\"获取延迟等级\",{\"1\":{\"1197\":1}}],[\"获取订阅关系\",{\"1\":{\"1188\":1}}],[\"获取订阅数据\",{\"1\":{\"1170\":1}}],[\"获取返回结果中第一条消息的消费队列offset\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"获取返回体\",{\"1\":{\"820\":1}}],[\"获取待拉取的消费队列\",{\"1\":{\"1170\":1,\"1228\":1}}],[\"获取消费组中所有消费者的\",{\"1\":{\"1331\":1}}],[\"获取消费组的订阅配置\",{\"1\":{\"1198\":1}}],[\"获取消费锁失败\",{\"1\":{\"1225\":1}}],[\"获取消费队列锁\",{\"1\":{\"1218\":1}}],[\"获取消费队列最大和最小的逻辑偏移量\",{\"1\":{\"1164\":1}}],[\"获取消息数据\",{\"1\":{\"1403\":1}}],[\"获取消息的消费索引\",{\"1\":{\"1318\":1}}],[\"获取消息的所有\",{\"1\":{\"794\":1}}],[\"获取消息时调用\",{\"1\":{\"1318\":1}}],[\"获取消息属性中需要分发的\",{\"1\":{\"1294\":1}}],[\"获取消息消费偏移量\",{\"1\":{\"1117\":1}}],[\"获取消息\",{\"1\":{\"767\":1,\"1174\":1,\"1401\":1}}],[\"获取队列的订阅信息\",{\"1\":{\"1159\":1}}],[\"获取全部的订阅信息\",{\"1\":{\"1142\":1}}],[\"获取自己分配到的消息队列\",{\"1\":{\"1137\":1}}],[\"获取该消费组下所有的消费者\",{\"1\":{\"1137\":1}}],[\"获取该等级的\",{\"1\":{\"857\":1}}],[\"获取它们的重平衡实现并且调用\",{\"1\":{\"1137\":1}}],[\"获取它们要生产\",{\"1\":{\"945\":1}}],[\"获取读队列的方法\",{\"1\":{\"1116\":1}}],[\"获取主题的路由信息\",{\"1\":{\"1050\":1}}],[\"获取对应的操作队列\",{\"1\":{\"1468\":1}}],[\"获取对应的\",{\"1\":{\"1042\":1}}],[\"获取到\",{\"1\":{\"1041\":1}}],[\"获取到broker地址后缓存到本地\",{\"1\":{\"942\":1}}],[\"获取或创建重试\",{\"1\":{\"1188\":1}}],[\"获取或创建\",{\"1\":{\"1037\":1}}],[\"获取acl配置文件数量并和\",{\"1\":{\"999\":1}}],[\"获取请求用户的访问控制权限\",{\"1\":{\"991\":1,\"1000\":1}}],[\"获取账号信息进行权限判断\",{\"1\":{\"987\":1}}],[\"获取consumequeue索引的三个关键属性\",{\"1\":{\"845\":1,\"860\":1}}],[\"获取挂起的拉取请求列表\",{\"1\":{\"825\":2}}],[\"获取索引数据\",{\"1\":{\"797\":1}}],[\"获取hash槽的值\",{\"1\":{\"797\":2}}],[\"获取hash槽位置\",{\"1\":{\"797\":1}}],[\"获取最后一个索引文件\",{\"1\":{\"789\":1,\"793\":2}}],[\"获取最新的路由信息\",{\"1\":{\"941\":1}}],[\"获取最新的索引文件\",{\"1\":{\"789\":1}}],[\"获取最新的偏移量\",{\"1\":{\"765\":1}}],[\"获取地\",{\"1\":{\"479\":1,\"480\":1}}],[\"获取物理节点在哈希环中已经存在的虚拟节点数量\",{\"1\":{\"396\":1}}],[\"获取字符\",{\"1\":{\"297\":1}}],[\"获取长度\",{\"1\":{\"297\":1}}],[\"获取当前消费组内所有消费者的客户端\",{\"1\":{\"1143\":1}}],[\"获取当前\",{\"1\":{\"797\":1,\"1512\":1,\"1521\":1}}],[\"获取当前载入路径值\",{\"1\":{\"223\":1}}],[\"获取当前类实现的所有接口\",{\"1\":{\"40\":1}}],[\"获取当前类的所有method\",{\"1\":{\"39\":1}}],[\"获取当前类的所有field\",{\"1\":{\"38\":1}}],[\"获取当前类的某个method\",{\"1\":{\"39\":1}}],[\"获取就绪的\",{\"1\":{\"118\":1}}],[\"获取\",{\"1\":{\"44\":1,\"122\":1,\"794\":1,\"845\":1,\"1053\":2,\"1061\":2,\"1200\":1,\"1266\":1,\"1270\":1,\"1372\":1,\"1410\":1,\"1436\":1,\"1519\":2}}],[\"获取父类类型\",{\"1\":{\"40\":1}}],[\"获取继承关系\",{\"0\":{\"40\":1}}],[\"获取某个public的method\",{\"1\":{\"39\":1}}],[\"获取所有订阅该\",{\"1\":{\"1315\":1}}],[\"获取所有消费者\",{\"1\":{\"1130\":1}}],[\"获取所有\",{\"1\":{\"998\":1,\"1270\":1}}],[\"获取所有有效的消息\",{\"1\":{\"845\":1,\"860\":1}}],[\"获取所有public的method\",{\"1\":{\"39\":1}}],[\"获取所有public的field\",{\"1\":{\"38\":1}}],[\"获取所有添加的被屏蔽异常\",{\"1\":{\"34\":1}}],[\"获取常量定义的字符串\",{\"1\":{\"31\":1}}],[\"成为\",{\"1\":{\"1497\":1}}],[\"成为了微服务架构中不可或缺的一部分\",{\"1\":{\"1439\":1}}],[\"成本\",{\"1\":{\"1385\":1}}],[\"成多个虚拟节点\",{\"1\":{\"716\":1}}],[\"成员值默认为数值\",{\"1\":{\"585\":1}}],[\"成员的值可以是任意数值\",{\"1\":{\"583\":1}}],[\"成员的值\",{\"0\":{\"583\":1}}],[\"成员的值不重要\",{\"1\":{\"582\":1}}],[\"成员数量是确定的\",{\"1\":{\"529\":1}}],[\"成长\",{\"1\":{\"446\":2}}],[\"成\",{\"1\":{\"388\":2}}],[\"成功后更新\",{\"1\":{\"1519\":1}}],[\"成功回调\",{\"1\":{\"1519\":1}}],[\"成功的响应后会唤醒\",{\"1\":{\"1512\":1}}],[\"成功响应的\",{\"1\":{\"1499\":1}}],[\"成功响应\",{\"1\":{\"1499\":1}}],[\"成功查询出事务半消息\",{\"1\":{\"1464\":2}}],[\"成功则直接返回\",{\"1\":{\"1273\":1}}],[\"成功则更新统计数据\",{\"1\":{\"1195\":1}}],[\"成功数量\",{\"1\":{\"1195\":1}}],[\"成功或失败\",{\"1\":{\"1195\":1}}],[\"成功\",{\"1\":{\"348\":1,\"351\":2,\"1278\":1,\"1371\":1,\"1488\":1,\"1499\":1,\"1519\":2}}],[\"成功完成\",{\"1\":{\"348\":1}}],[\"成熟的specific度量指标\",{\"1\":{\"277\":1}}],[\"状态为\",{\"1\":{\"1510\":2}}],[\"状态为响应\",{\"1\":{\"125\":1}}],[\"状态维护\",{\"0\":{\"1494\":1}}],[\"状态会发起新的投票轮次\",{\"1\":{\"1480\":1}}],[\"状态转移\",{\"1\":{\"1478\":1,\"1479\":1,\"1480\":1}}],[\"状态等\",{\"1\":{\"1420\":1}}],[\"状态下的索引文件\",{\"1\":{\"1412\":2}}],[\"状态下索引文件引用\",{\"1\":{\"1412\":1}}],[\"状态的消息会被丢弃\",{\"1\":{\"1445\":1}}],[\"状态的消息会继续进行回查\",{\"1\":{\"1445\":1}}],[\"状态的索引文件仍然会保留未压缩前的索引文件\",{\"1\":{\"1436\":2}}],[\"状态的索引文件压缩到新文件\",{\"1\":{\"1435\":1}}],[\"状态的索引文件才允许被写入\",{\"1\":{\"1434\":1}}],[\"状态的索引文件\",{\"1\":{\"1394\":1,\"1414\":1,\"1417\":1}}],[\"状态的文件\",{\"1\":{\"1394\":1}}],[\"状态信息\",{\"1\":{\"944\":1,\"949\":1,\"967\":1}}],[\"状态\",{\"1\":{\"638\":2,\"1394\":1,\"1415\":1,\"1417\":1,\"1445\":3,\"1497\":4,\"1500\":1,\"1503\":1}}],[\"状态检查线程负责定时查询任务运行后一定时间内还处于运行中\",{\"1\":{\"374\":1}}],[\"状态检查\",{\"1\":{\"374\":1}}],[\"状态监控和集群中各执行节点的健康检查\",{\"1\":{\"372\":1}}],[\"状态发生变化时\",{\"1\":{\"348\":1}}],[\"浏览器用wss\",{\"1\":{\"368\":1}}],[\"浏览器和服务器就可以随时主动发送消息给对方\",{\"1\":{\"368\":1}}],[\"浏览器事件都必须异步执行\",{\"1\":{\"351\":1}}],[\"浏览器还提供了原生支持的fetch\",{\"1\":{\"349\":1}}],[\"浏览器\",{\"0\":{\"346\":1}}],[\"记得提前预铺和减伤\",{\"1\":{\"428\":1}}],[\"记得打开小队框架上共生绽华的图标\",{\"1\":{\"401\":1}}],[\"记得在哪看到一句话\",{\"1\":{\"399\":1}}],[\"记得用super调用父类的构造方法\",{\"1\":{\"345\":1}}],[\"记录其日志序号\",{\"1\":{\"1520\":1}}],[\"记录其实就是元组的另一种形式\",{\"1\":{\"190\":1}}],[\"记录最新一次检查的时间戳\",{\"1\":{\"1519\":1}}],[\"记录本次发送心跳时间戳\",{\"1\":{\"1496\":1}}],[\"记录该事务半消息的最终处理结果\",{\"1\":{\"1446\":1}}],[\"记录的位置重新开始向后遍历\",{\"1\":{\"1362\":1}}],[\"记录的消息\",{\"1\":{\"1362\":1}}],[\"记录消费失败的消息\",{\"1\":{\"1198\":1}}],[\"记录消费时的轨迹\",{\"1\":{\"1021\":1}}],[\"记录客户端拉取的消息记录\",{\"1\":{\"1173\":1}}],[\"记录保存的消息总大小\",{\"1\":{\"1065\":1}}],[\"记录这个队列扫描的偏移量\",{\"1\":{\"845\":1}}],[\"记录定义\",{\"1\":{\"253\":1}}],[\"记录\",{\"0\":{\"190\":1},\"1\":{\"253\":1}}],[\"简明概述\",{\"1\":{\"1527\":1}}],[\"简介\",{\"0\":{\"494\":1,\"522\":1,\"527\":1,\"531\":1,\"533\":1,\"550\":1,\"558\":1,\"566\":1,\"582\":1,\"589\":1,\"591\":1,\"605\":1},\"1\":{\"398\":1}}],[\"简单高效\",{\"1\":{\"921\":1,\"1337\":1}}],[\"简单地说是在\",{\"1\":{\"716\":1}}],[\"简单说\",{\"1\":{\"633\":1}}],[\"简单来说\",{\"1\":{\"619\":1,\"622\":1}}],[\"简单的哈希算法无法保证节点数量发生之后\",{\"1\":{\"385\":1}}],[\"简单理解就是\",{\"1\":{\"118\":1}}],[\"简而言之\",{\"1\":{\"343\":1}}],[\"继承了\",{\"1\":{\"506\":1,\"944\":1}}],[\"继承\",{\"0\":{\"343\":1,\"345\":1,\"560\":1,\"561\":1,\"562\":1},\"1\":{\"342\":1}}],[\"继续检查下一条待追加日志\",{\"1\":{\"1520\":1}}],[\"继续比较\",{\"1\":{\"1519\":1}}],[\"继续发起\",{\"1\":{\"1519\":1}}],[\"继续本轮选举\",{\"1\":{\"1497\":1}}],[\"继续本轮拉票\",{\"1\":{\"1491\":1}}],[\"继续判断\",{\"1\":{\"1492\":1}}],[\"继续消费下一条\",{\"1\":{\"1453\":1}}],[\"继续攒批\",{\"1\":{\"1427\":1}}],[\"继续下面的逻辑\",{\"1\":{\"1503\":1}}],[\"继续下面逻辑\",{\"1\":{\"1492\":1}}],[\"继续下一个事务半消息的回查判断\",{\"1\":{\"1468\":1}}],[\"继续下一次扫描\",{\"1\":{\"861\":1}}],[\"继续下次扫描\",{\"1\":{\"841\":1}}],[\"继续提供服务\",{\"1\":{\"695\":1}}],[\"继续在新的构造函数的原型上定义新方法\",{\"1\":{\"342\":1}}],[\"继续搜索该行下一个\",{\"1\":{\"145\":1}}],[\"继续读取\",{\"1\":{\"125\":2}}],[\"继续创建一个定时任务\",{\"1\":{\"845\":2,\"860\":1}}],[\"继续创建\",{\"1\":{\"121\":1}}],[\"节省空间\",{\"1\":{\"1352\":1}}],[\"节省存储空间\",{\"1\":{\"1296\":1}}],[\"节省消息传输大小\",{\"0\":{\"740\":1}}],[\"节省场地\",{\"1\":{\"472\":1}}],[\"节省内存空间`\",{\"1\":{\"690\":1}}],[\"节省内存\",{\"1\":{\"341\":1}}],[\"节点已经保存的日志表\",{\"1\":{\"1521\":1}}],[\"节点已经有新的\",{\"1\":{\"1499\":1}}],[\"节点激活\",{\"1\":{\"1521\":1}}],[\"节点水位\",{\"1\":{\"1519\":1}}],[\"节点当前投票轮次\",{\"1\":{\"1519\":1}}],[\"节点更新自身水位线\",{\"1\":{\"1518\":1}}],[\"节点收到的每一条数据在服务端维护一个递增的日志序号\",{\"1\":{\"1517\":1}}],[\"节点收到自己发送的消息后\",{\"1\":{\"674\":1}}],[\"节点追加日志条目\",{\"1\":{\"1517\":1}}],[\"节点日志存储\",{\"1\":{\"1516\":1}}],[\"节点创建一个\",{\"1\":{\"1514\":1}}],[\"节点会为每一个\",{\"1\":{\"1514\":1}}],[\"节点编号\",{\"1\":{\"1514\":1,\"1521\":1}}],[\"节点推送的下一\",{\"1\":{\"1508\":1}}],[\"节点轮次小于\",{\"1\":{\"1500\":1}}],[\"节点切换成\",{\"1\":{\"1499\":1}}],[\"节点成功响应\",{\"1\":{\"1499\":1}}],[\"节点超过半数\",{\"1\":{\"1499\":1}}],[\"节点投票轮次小于\",{\"1\":{\"1499\":1}}],[\"节点不一致\",{\"1\":{\"1499\":1,\"1500\":1}}],[\"节点向\",{\"1\":{\"1499\":1}}],[\"节点间通信类\",{\"1\":{\"1482\":1}}],[\"节点间进行队列数据的复制\",{\"1\":{\"692\":1}}],[\"节点状态机\",{\"1\":{\"1482\":1,\"1514\":1}}],[\"节点状态流转\",{\"0\":{\"1477\":1}}],[\"节点需要实现的所有请求方法\",{\"1\":{\"1482\":1}}],[\"节点需要实现的协议处理方法\",{\"1\":{\"1482\":1}}],[\"节点组成的集群\",{\"1\":{\"1481\":1}}],[\"节点组成的一个特殊的\",{\"1\":{\"672\":1}}],[\"节点发送心跳包\",{\"1\":{\"1499\":1}}],[\"节点发送心跳请求给其他节点的间隔时间\",{\"1\":{\"1477\":1}}],[\"节点发送请求和处理请求的入口\",{\"1\":{\"1482\":1}}],[\"节点发出\",{\"1\":{\"674\":1}}],[\"节点在选举超时后\",{\"1\":{\"1477\":1}}],[\"节点定期发送心跳请求给其他节点\",{\"1\":{\"1477\":1}}],[\"节点也会收到该重试消息\",{\"1\":{\"1188\":1}}],[\"节点的轮次和已提交指针\",{\"1\":{\"1520\":1}}],[\"节点的已提交指针\",{\"1\":{\"1520\":2}}],[\"节点的已提交指针更新\",{\"1\":{\"1520\":2}}],[\"节点的开始日志序号\",{\"1\":{\"1519\":1}}],[\"节点的最大日志序号\",{\"1\":{\"1519\":1}}],[\"节点的起始日志序号\",{\"1\":{\"1519\":1}}],[\"节点的水位线\",{\"1\":{\"1519\":1}}],[\"节点的条目推送给\",{\"1\":{\"1519\":1}}],[\"节点的重启会丢失所有数据\",{\"1\":{\"693\":1}}],[\"节点的内存占用\",{\"1\":{\"372\":1}}],[\"节点记录的状态信息\",{\"1\":{\"674\":1}}],[\"节点为\",{\"1\":{\"674\":1,\"1520\":1}}],[\"节点时对应广播消息的生命周期结束\",{\"1\":{\"674\":1}}],[\"节点可以清除缓存的消息\",{\"1\":{\"674\":1}}],[\"节点都会对消息进行缓存\",{\"1\":{\"674\":1}}],[\"节点都由一组进程组成\",{\"1\":{\"672\":1}}],[\"节点中\",{\"1\":{\"672\":1}}],[\"节点中测试程序\",{\"1\":{\"238\":1}}],[\"节点上将条目推送给\",{\"1\":{\"1514\":1}}],[\"节点上保持写一个事务日志\",{\"1\":{\"942\":1}}],[\"节点上\",{\"1\":{\"695\":1}}],[\"节点上则是\",{\"1\":{\"672\":1}}],[\"节点上回调处理是\",{\"1\":{\"672\":1}}],[\"节点和\",{\"1\":{\"672\":2}}],[\"节点名是在rabbitmqctl\",{\"1\":{\"657\":1}}],[\"节点名称\",{\"1\":{\"657\":1}}],[\"节点数量多了之后分布也相对均匀\",{\"1\":{\"388\":1}}],[\"节点分布不均衡\",{\"1\":{\"388\":1}}],[\"节点列表的所有节点上都初始化一个新的\",{\"1\":{\"252\":1}}],[\"节点里测试程序\",{\"1\":{\"238\":1}}],[\"节点是一个独立的\",{\"1\":{\"237\":1}}],[\"节点\",{\"0\":{\"1518\":1},\"1\":{\"237\":1,\"252\":1,\"372\":1,\"674\":2,\"912\":1,\"1188\":1,\"1248\":1,\"1482\":1,\"1497\":2,\"1499\":1,\"1500\":1,\"1503\":3,\"1507\":1,\"1509\":1,\"1516\":1,\"1518\":1,\"1519\":2,\"1520\":1}}],[\"依然是通过查看火焰图的方法\",{\"1\":{\"914\":1}}],[\"依次扫描所有的队列\",{\"1\":{\"1388\":1}}],[\"依次扫描消息是否到期\",{\"1\":{\"857\":1}}],[\"依次加载每个索引文件\",{\"1\":{\"793\":1}}],[\"依次输出0\",{\"1\":{\"332\":1}}],[\"依赖\",{\"1\":{\"712\":1}}],[\"依赖精简\",{\"1\":{\"371\":1}}],[\"依赖于一个父\",{\"1\":{\"1293\":1}}],[\"依赖于\",{\"1\":{\"230\":1}}],[\"依赖注入可以通过多种方式实现\",{\"1\":{\"81\":1}}],[\"依赖管理\",{\"0\":{\"60\":1}}],[\"号\",{\"1\":{\"332\":1}}],[\"括号括起来\",{\"1\":{\"331\":1}}],[\"括号内的东西就是返回值\",{\"1\":{\"181\":1}}],[\"两种类型的数据\",{\"1\":{\"816\":1}}],[\"两种方法\",{\"1\":{\"567\":1}}],[\"两种分布式模型\",{\"0\":{\"237\":1}}],[\"两个场景会发触发\",{\"1\":{\"1464\":1}}],[\"两个实现\",{\"1\":{\"1425\":1}}],[\"两个索引文件类实现了这个接口\",{\"1\":{\"1412\":1}}],[\"两个消费服务都实现了\",{\"1\":{\"1187\":1}}],[\"两个消费服务实现中都包含了\",{\"1\":{\"1187\":1}}],[\"两个\",{\"1\":{\"635\":1,\"786\":1}}],[\"两个远程尽量站在一起可以节省场地\",{\"1\":{\"445\":1}}],[\"两个参数来设置线程池中的线程个数\",{\"1\":{\"1238\":1}}],[\"两个参数来记录当前投递状态\",{\"1\":{\"932\":1}}],[\"两个参数分别控制正常关闭\",{\"1\":{\"659\":1}}],[\"两个参数让用户决策是保证队列的可用性\",{\"1\":{\"659\":1}}],[\"两个参数都是函数\",{\"1\":{\"351\":1}}],[\"两个参数\",{\"1\":{\"331\":1}}],[\"已提交指针\",{\"1\":{\"1521\":2}}],[\"已提交的日志序号\",{\"1\":{\"1521\":1}}],[\"已投票仲裁的日志序号\",{\"1\":{\"1521\":1}}],[\"已投递位移\",{\"1\":{\"932\":1}}],[\"已投递时间\",{\"1\":{\"932\":1}}],[\"已存储的最大日志序号\",{\"1\":{\"1520\":1}}],[\"已写入日志序号\",{\"1\":{\"1519\":1}}],[\"已复制序号\",{\"1\":{\"1519\":1}}],[\"已复制日志序号\",{\"1\":{\"1519\":1}}],[\"已向\",{\"1\":{\"1519\":1}}],[\"已完成\",{\"1\":{\"1519\":1}}],[\"已满\",{\"1\":{\"1516\":1}}],[\"已被集群中超过半数节点确认的\",{\"1\":{\"1508\":1}}],[\"已知的最大投票轮次\",{\"1\":{\"1497\":1}}],[\"已知的最大队列数量\",{\"1\":{\"1173\":1}}],[\"已有\",{\"1\":{\"1491\":1,\"1497\":1}}],[\"已刷盘\",{\"1\":{\"1427\":1}}],[\"已上传二级存储\",{\"1\":{\"1412\":1}}],[\"已经完成比较的日志序号\",{\"1\":{\"1520\":1}}],[\"已经完成比较的日志序号与\",{\"1\":{\"1519\":1}}],[\"已经有\",{\"1\":{\"1497\":1}}],[\"已经有一个队列复制的实现\",{\"1\":{\"692\":1}}],[\"已经存在\",{\"1\":{\"1497\":1}}],[\"已经投给其他节点\",{\"1\":{\"1497\":1}}],[\"已经投递的定时消息文件可以被删除\",{\"1\":{\"928\":1}}],[\"已经投递过的那些文件\",{\"1\":{\"867\":1}}],[\"已经收到操作消息的事务半消息偏移量\",{\"1\":{\"1468\":1}}],[\"已经处理完的操作消息的偏移量列表\",{\"1\":{\"1468\":1}}],[\"已经刷盘的\",{\"1\":{\"1427\":1}}],[\"已经提交到缓冲区的\",{\"1\":{\"1427\":1}}],[\"已经初始化过\",{\"1\":{\"1403\":1}}],[\"已经上传到二级存储\",{\"1\":{\"1394\":1,\"1412\":1}}],[\"已经或正在被压缩成新格式的索引文件\",{\"1\":{\"1394\":1,\"1412\":1}}],[\"已经在磁盘中\",{\"1\":{\"1277\":1}}],[\"已经被\",{\"1\":{\"1276\":1}}],[\"已经被标记为\",{\"1\":{\"1136\":1}}],[\"已经拉取到足够的消息\",{\"1\":{\"1270\":1}}],[\"已经获取且未过期\",{\"1\":{\"1218\":1}}],[\"已经\",{\"1\":{\"954\":1}}],[\"已经支持了异步投递\",{\"1\":{\"925\":1}}],[\"已经放入\",{\"1\":{\"883\":1}}],[\"已废弃\",{\"1\":{\"797\":1}}],[\"已绑定到函数参数的值不变\",{\"1\":{\"330\":1}}],[\"已导出函数相当于公共方法\",{\"1\":{\"180\":1}}],[\"闭包可以封装一个私有变量\",{\"1\":{\"330\":1}}],[\"闭包\",{\"0\":{\"328\":1,\"330\":1},\"1\":{\"329\":1}}],[\"忽略前两个元素\",{\"1\":{\"316\":1}}],[\"唯一要注意的是不要撞到火人\",{\"1\":{\"473\":1}}],[\"唯一的创建\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"唯一的触发点是一个重平衡线程\",{\"1\":{\"1128\":1}}],[\"唯一的影响是网络使用率\",{\"1\":{\"696\":1}}],[\"唯一的区别就是在客户端定义队列的时候需要定义成仲裁队列\",{\"1\":{\"696\":1}}],[\"唯一的伤害技能\",{\"1\":{\"466\":1}}],[\"唯一的灭点在尾王\",{\"1\":{\"449\":1}}],[\"唯一的全局变量myapp\",{\"1\":{\"313\":1}}],[\"唯一区别是\",{\"1\":{\"319\":1}}],[\"唯一能判断nan的方法是通过isnan\",{\"1\":{\"295\":1}}],[\"外都应该穿\",{\"1\":{\"484\":1}}],[\"外科医生缝肉\",{\"0\":{\"459\":1}}],[\"外置java类\",{\"1\":{\"371\":1}}],[\"外\",{\"1\":{\"310\":1}}],[\"便于对消息进行高性能查询\",{\"1\":{\"1006\":1}}],[\"便于在发送命令的前后拦截\",{\"1\":{\"994\":1}}],[\"便于扩充类型或自动合并\",{\"1\":{\"564\":1}}],[\"便于指定给其他变量\",{\"1\":{\"533\":1}}],[\"便于理解后面的代码\",{\"1\":{\"118\":1}}],[\"便正式启动并提供服务\",{\"1\":{\"372\":1}}],[\"便利对象的属性名称\",{\"1\":{\"303\":1}}],[\"遍历已挂起的请求\",{\"1\":{\"1521\":1}}],[\"遍历它们\",{\"1\":{\"1512\":1}}],[\"遍历集群内所有节点\",{\"1\":{\"1502\":1}}],[\"遍历集群中所有节点\",{\"1\":{\"1499\":1}}],[\"遍历索引项\",{\"1\":{\"1436\":1}}],[\"遍历索引项链表\",{\"1\":{\"1436\":1}}],[\"遍历索引链表中的每个索引\",{\"1\":{\"797\":1}}],[\"遍历该\",{\"1\":{\"1421\":1}}],[\"遍历该队列的所有拉取请求\",{\"1\":{\"825\":1}}],[\"遍历老文件的\",{\"1\":{\"1417\":1}}],[\"遍历查询到的消息\",{\"1\":{\"1278\":1}}],[\"遍历消费队列中的索引\",{\"1\":{\"1370\":1}}],[\"遍历消费队列索引\",{\"1\":{\"1164\":1}}],[\"遍历消费到的\",{\"1\":{\"1263\":1}}],[\"遍历新分配的\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"遍历新分配的消息队列\",{\"1\":{\"1137\":1}}],[\"遍历每个\",{\"1\":{\"1142\":1,\"1434\":1}}],[\"遍历每个consumequeue执行恢复recover\",{\"1\":{\"759\":1}}],[\"遍历本地缓存的消费者分到的消息队列\",{\"1\":{\"1137\":1,\"1144\":1,\"1224\":1}}],[\"遍历需要的权限与拥有的权限进行对比\",{\"1\":{\"1000\":1}}],[\"遍历所有挂起的\",{\"1\":{\"1520\":2}}],[\"遍历所有注册的带有\",{\"1\":{\"1332\":1}}],[\"遍历所有消费者\",{\"1\":{\"1323\":1}}],[\"遍历所有内存中的\",{\"1\":{\"1277\":1}}],[\"遍历所有缓存的消息队列\",{\"1\":{\"1200\":1}}],[\"遍历所有\",{\"1\":{\"970\":1,\"1435\":1}}],[\"遍历所有文件\",{\"1\":{\"872\":1}}],[\"遍历所有consumequeue目录下的文件\",{\"1\":{\"753\":1,\"759\":1}}],[\"遍历consumequeue中的所有有效消息\",{\"1\":{\"845\":1,\"860\":1}}],[\"遍历consumequeue刷盘\",{\"1\":{\"769\":1}}],[\"遍历拉取请求容器中的每个队列\",{\"1\":{\"823\":1}}],[\"遍历\",{\"1\":{\"769\":1,\"998\":1,\"1277\":1,\"1280\":1,\"1373\":1,\"1421\":2,\"1435\":1}}],[\"遍历文件的每个索引项进行校验\",{\"1\":{\"753\":1,\"759\":1,\"771\":1}}],[\"遍历map\",{\"1\":{\"303\":1}}],[\"遍历map和set就无法使用下标\",{\"1\":{\"303\":1}}],[\"遍历set\",{\"1\":{\"303\":1}}],[\"遍历array\",{\"1\":{\"303\":1}}],[\"遍历array可以采用下标循环\",{\"1\":{\"303\":1}}],[\"遍历就绪通道的\",{\"1\":{\"122\":1}}],[\"空间\",{\"1\":{\"882\":1}}],[\"空对象\",{\"0\":{\"556\":1}}],[\"空\",{\"1\":{\"506\":1}}],[\"空类型\",{\"1\":{\"504\":1}}],[\"空转\",{\"1\":{\"411\":1,\"413\":1,\"1521\":1}}],[\"空set\",{\"1\":{\"302\":1}}],[\"空map\",{\"1\":{\"301\":1}}],[\"空数组继续shift不会报错\",{\"1\":{\"298\":1}}],[\"空数组继续pop不会报错\",{\"1\":{\"298\":1}}],[\"串联字符串\",{\"1\":{\"298\":1}}],[\"往consumequeue中写入索引项\",{\"1\":{\"765\":1}}],[\"往往需要进行\",{\"1\":{\"515\":1}}],[\"往往将多个值结合\",{\"1\":{\"514\":1}}],[\"往array的头部添加若干元素\",{\"1\":{\"298\":1}}],[\"往stringbuilder中新增字符时\",{\"1\":{\"28\":1}}],[\"截断\",{\"1\":{\"1510\":1,\"1519\":1}}],[\"截掉老索引项的下一个索引项位置\",{\"1\":{\"1435\":1}}],[\"截至目前版本\",{\"1\":{\"833\":1}}],[\"截取部分元素\",{\"1\":{\"298\":1}}],[\"截屏2021\",{\"1\":{\"272\":1}}],[\"岁了\",{\"1\":{\"297\":2}}],[\"且没有新消息写入\",{\"1\":{\"1520\":1}}],[\"且等待表不为空\",{\"1\":{\"1511\":1}}],[\"且对顺序读出和随机读出做了优化\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"且对性能和延迟的要求\",{\"1\":{\"925\":1}}],[\"且本批次操作消息中最后一个在免疫期外\",{\"1\":{\"1468\":1}}],[\"且当前半消息在回查免疫期外\",{\"1\":{\"1468\":1}}],[\"且超过最大获取不到消息的次数\",{\"1\":{\"1468\":1}}],[\"且会通过调用业务\",{\"1\":{\"1300\":1}}],[\"且它的位置在堆外内存\",{\"1\":{\"1300\":1}}],[\"且之前没有拉取过重试消息\",{\"1\":{\"1257\":1}}],[\"且消费时长大于\",{\"1\":{\"1225\":1}}],[\"且消费者\",{\"1\":{\"1095\":1}}],[\"且消费逻辑一致\",{\"1\":{\"1089\":1}}],[\"且用户是管理员\",{\"1\":{\"1000\":1}}],[\"且具备很高的可靠程度\",{\"1\":{\"942\":1}}],[\"且实现了流控和投递失败的重投\",{\"1\":{\"932\":1}}],[\"且延迟精度能够达到\",{\"1\":{\"922\":1}}],[\"且删除分\",{\"1\":{\"870\":1}}],[\"且方便扩展\",{\"1\":{\"773\":1}}],[\"且位置必须在字符串成员之前\",{\"1\":{\"585\":1}}],[\"且属性值也是字符串\",{\"1\":{\"553\":1}}],[\"且其持续治疗效果也会作用于你的生命绽放的目标\",{\"1\":{\"405\":1}}],[\"且不能用数字开头\",{\"1\":{\"294\":1}}],[\"且持续跟踪服务的逻辑状态\",{\"1\":{\"117\":1}}],[\"键的方法可以定义主队列选择策略\",{\"1\":{\"660\":1}}],[\"键都是字符串类型\",{\"1\":{\"294\":1}}],[\"键值对\",{\"1\":{\"190\":1}}],[\"负载\",{\"1\":{\"1143\":1,\"1267\":1}}],[\"负载的消息队列发生变化时调用\",{\"1\":{\"1134\":1}}],[\"负载方式\",{\"1\":{\"1091\":1,\"1097\":1}}],[\"负载过高而引起的此种情形\",{\"1\":{\"622\":2}}],[\"负载过高\",{\"1\":{\"622\":1,\"1234\":1}}],[\"负数\",{\"1\":{\"294\":1}}],[\"负责在\",{\"1\":{\"1514\":1}}],[\"负责触发节点的状态维护方法\",{\"1\":{\"1483\":1}}],[\"负责节点的状态维护\",{\"1\":{\"1483\":1}}],[\"负责实现逻辑文件到具体的分级存储系统的映射\",{\"1\":{\"1387\":1}}],[\"负责定时或者立即触发重平衡\",{\"1\":{\"1129\":1}}],[\"负责消费消息\",{\"1\":{\"1089\":1}}],[\"负责消息消费\",{\"1\":{\"1120\":1}}],[\"负责消息轨迹消息的转发\",{\"1\":{\"1021\":1}}],[\"负责消息的持久化\",{\"1\":{\"621\":1}}],[\"负责调用\",{\"1\":{\"1042\":1}}],[\"负责执行核心的消息发送方法\",{\"1\":{\"1038\":1}}],[\"负责更新和提供路由信息\",{\"1\":{\"1030\":1}}],[\"负责异步发送轨迹数据\",{\"1\":{\"1021\":1}}],[\"负责周期性扫描该\",{\"1\":{\"841\":1}}],[\"负责维护队列中落盘消息的信息\",{\"1\":{\"687\":1}}],[\"负责协议相关的消息处理\",{\"1\":{\"671\":1}}],[\"负责将\",{\"1\":{\"1021\":1,\"1519\":1}}],[\"负责将消息存入内存\",{\"1\":{\"621\":1}}],[\"负责将客户端连接分发给\",{\"1\":{\"120\":1}}],[\"负责接收消费者的消费进度更新请求\",{\"1\":{\"1190\":1}}],[\"负责接收\",{\"1\":{\"621\":1}}],[\"负责所有worker的调度\",{\"1\":{\"380\":1}}],[\"负责华为云分布式中间件设计与研发\",{\"1\":{\"286\":1}}],[\"负责使集群节点组成一个待测试的分布式集群\",{\"1\":{\"280\":1}}],[\"负责处理分级存储读取请求\",{\"1\":{\"1402\":1}}],[\"负责处理消息发送请求\",{\"1\":{\"1030\":1}}],[\"负责处理\",{\"1\":{\"124\":1,\"621\":1}}],[\"负责响应客户端请求事件\",{\"1\":{\"120\":1}}],[\"科学计数法表示1\",{\"1\":{\"294\":1}}],[\"十六制为0x0a\",{\"1\":{\"288\":1}}],[\"十六进制代码为0x0d\",{\"1\":{\"288\":1}}],[\"十进制ascii代码是10\",{\"1\":{\"288\":1}}],[\"十进制ascii代码是13\",{\"1\":{\"288\":1}}],[\"擅长混沌工程\",{\"1\":{\"286\":1}}],[\"擅长中间件性能优化\",{\"1\":{\"286\":1}}],[\"喜欢大道至简的设计理念\",{\"1\":{\"286\":1}}],[\"嘉浩\",{\"1\":{\"286\":1}}],[\"资深中间件研发工程师\",{\"1\":{\"286\":1}}],[\"资深研发工程师\",{\"1\":{\"286\":1}}],[\"资源密集\",{\"1\":{\"1284\":1}}],[\"资源的概念\",{\"1\":{\"976\":1}}],[\"资源上可能是昂贵的\",{\"1\":{\"379\":1}}],[\"资源管理问题\",{\"1\":{\"81\":1}}],[\"资源\",{\"0\":{\"56\":1},\"1\":{\"722\":1,\"978\":2,\"1364\":1}}],[\"推进时间轮并返回\",{\"1\":{\"1372\":1}}],[\"推进时间轮扫描时间到下一槽位\",{\"1\":{\"1358\":1}}],[\"推进时间轮\",{\"1\":{\"1358\":1,\"1372\":1}}],[\"推\",{\"1\":{\"1245\":1}}],[\"推送过程可能会停止\",{\"1\":{\"1520\":1}}],[\"推送过来\",{\"1\":{\"1520\":1}}],[\"推送条目并记录已推送的索引\",{\"1\":{\"1520\":1}}],[\"推送条目的序号可能超前于当前\",{\"1\":{\"1520\":1}}],[\"推送请求中的不一样\",{\"1\":{\"1520\":1}}],[\"推送写入的日志到\",{\"0\":{\"1518\":1}}],[\"推送的请求\",{\"0\":{\"1520\":1}}],[\"推送的条目就超前于当前\",{\"1\":{\"1511\":1}}],[\"推送的日志内容相同\",{\"1\":{\"1520\":1}}],[\"推送的日志\",{\"1\":{\"1508\":1,\"1510\":1}}],[\"推送完成\",{\"1\":{\"1510\":1}}],[\"推送\",{\"1\":{\"1245\":1}}],[\"推送到客户端\",{\"1\":{\"1147\":1}}],[\"推模式并发消费流程\",{\"0\":{\"1188\":1}}],[\"推模式并发消费\",{\"0\":{\"1186\":1,\"1193\":1}}],[\"推模式并发消费主要的步骤为\",{\"1\":{\"1179\":1}}],[\"推模式并发消费交互流程\",{\"0\":{\"1179\":1}}],[\"推模式下有并发消费和顺序消费两种消费模式\",{\"1\":{\"1179\":1}}],[\"推模式消费逻辑从消息拉取开始\",{\"1\":{\"1188\":1}}],[\"推模式消费也是通过拉取消息请求来拉取消息\",{\"1\":{\"1152\":1}}],[\"推模式消费者在处理消费结果的逻辑中\",{\"1\":{\"1184\":1}}],[\"推模式消费者的拉取为异步调用\",{\"1\":{\"1161\":1}}],[\"推模式消费者拉取\",{\"0\":{\"1152\":1}}],[\"推模式消费者启动或恢复时\",{\"1\":{\"1128\":1}}],[\"推模式消费者实际内部也是通过拉取消息的方式进行消息拉取\",{\"1\":{\"1119\":1}}],[\"推模式消费者实现相关的类图如下所示\",{\"1\":{\"1119\":1}}],[\"推模式消费者实现\",{\"0\":{\"1119\":1}}],[\"推模式消费者自动监听推送过来的消息并进行消费\",{\"1\":{\"1119\":1}}],[\"推模式消费者消费步骤更简单\",{\"1\":{\"1117\":1}}],[\"推模式消费者接口就定义了这些方法\",{\"1\":{\"1117\":1}}],[\"推模式消费者接口\",{\"0\":{\"1117\":1},\"1\":{\"1117\":1}}],[\"推消费者实现\",{\"1\":{\"1170\":1}}],[\"推消费者还支持并发消费和顺序消费\",{\"1\":{\"1119\":1}}],[\"推出了\",{\"1\":{\"648\":1}}],[\"推断类型为\",{\"1\":{\"523\":2}}],[\"推断为\",{\"1\":{\"523\":1}}],[\"推入时间轮等待运行\",{\"1\":{\"374\":1}}],[\"推动云原生架构不断演进\",{\"1\":{\"286\":1}}],[\"推荐使用\",{\"1\":{\"1138\":2}}],[\"推荐使用异步方式\",{\"1\":{\"1027\":1}}],[\"推荐使用同步方式\",{\"1\":{\"1027\":1}}],[\"推荐使用可靠的磁盘\",{\"1\":{\"703\":1}}],[\"推荐适合集合石的\",{\"1\":{\"469\":1}}],[\"推荐组个盗贼来跳怪\",{\"1\":{\"462\":1}}],[\"推荐天赋\",{\"1\":{\"443\":1,\"455\":1}}],[\"推荐用标准天赋\",{\"1\":{\"423\":1,\"429\":1,\"436\":1,\"449\":1,\"462\":1,\"469\":1}}],[\"推荐插件\",{\"1\":{\"165\":1}}],[\"推荐\",{\"1\":{\"23\":1,\"589\":1}}],[\"努力将它打造成分布式系统韧性架构的压舱石\",{\"1\":{\"286\":1}}],[\"助力信通院颁发了国内首个\",{\"1\":{\"286\":1}}],[\"未超过则返回\",{\"1\":{\"1519\":2}}],[\"未提交的\",{\"1\":{\"1510\":1}}],[\"未到下一次拉票时间\",{\"1\":{\"1497\":1}}],[\"未准备\",{\"1\":{\"1499\":1}}],[\"未准备好投票\",{\"1\":{\"1497\":2}}],[\"未准备好\",{\"1\":{\"1491\":1,\"1499\":1}}],[\"未准备的响应超过半数\",{\"1\":{\"1488\":1}}],[\"未压缩的和压缩后的\",{\"1\":{\"1435\":1}}],[\"未重排文件\",{\"1\":{\"1417\":1}}],[\"未锁定\",{\"1\":{\"1228\":1}}],[\"未缓存该\",{\"1\":{\"1053\":1}}],[\"未开启布隆过滤器\",{\"1\":{\"1325\":1}}],[\"未开启长轮询\",{\"1\":{\"824\":1}}],[\"未开启发送方确认时\",{\"1\":{\"615\":1}}],[\"未找到消息直接返回消息未找到\",{\"1\":{\"819\":1,\"1173\":1}}],[\"未定义\",{\"1\":{\"506\":1}}],[\"未来\",{\"1\":{\"286\":1}}],[\"未来规划\",{\"0\":{\"286\":1}}],[\"未导出函数相当于私有方法\",{\"1\":{\"180\":1}}],[\"总结\",{\"1\":{\"1325\":1}}],[\"总结一下\",{\"1\":{\"1179\":1}}],[\"总结一下用到的优化方法主要有\",{\"1\":{\"917\":1}}],[\"总结起来\",{\"1\":{\"696\":1}}],[\"总是驱散一个培植毒药\",{\"1\":{\"427\":1}}],[\"总是使用try\",{\"1\":{\"57\":1}}],[\"总体利用率达到\",{\"1\":{\"285\":1}}],[\"展示了消息消费整个流程的调用关系\",{\"1\":{\"1119\":1}}],[\"展示了在不同规模下\",{\"1\":{\"285\":1}}],[\"展开后\",{\"1\":{\"213\":1}}],[\"扩大到\",{\"1\":{\"1418\":1,\"1435\":1}}],[\"扩容和\",{\"0\":{\"907\":1}}],[\"扩容可能会发生多次\",{\"1\":{\"906\":1}}],[\"扩容\",{\"0\":{\"906\":1}}],[\"扩容的损耗\",{\"1\":{\"741\":1}}],[\"扩展它之后只需要实现\",{\"1\":{\"1420\":1}}],[\"扩展\",{\"1\":{\"1116\":1,\"1382\":1}}],[\"扩展了最大定时时长\",{\"1\":{\"1338\":1}}],[\"扩展了客户端配置类\",{\"1\":{\"1109\":1}}],[\"扩展了\",{\"1\":{\"841\":1}}],[\"扩展运算符\",{\"0\":{\"529\":1},\"1\":{\"527\":1,\"529\":1}}],[\"扩展列表\",{\"1\":{\"177\":1}}],[\"扩到\",{\"1\":{\"285\":1}}],[\"扩缩代价\",{\"1\":{\"285\":2}}],[\"除此之外\",{\"1\":{\"921\":1,\"1337\":1}}],[\"除非系统内存不够用\",{\"1\":{\"879\":1}}],[\"除非你不停按键按的飞快\",{\"1\":{\"420\":1}}],[\"除了原本的信息外\",{\"1\":{\"1446\":1}}],[\"除了以上两个瓶颈之外\",{\"1\":{\"1379\":1}}],[\"除了public修饰符\",{\"1\":{\"576\":1}}],[\"除了undefined和null这两个值不能转为对象\",{\"1\":{\"511\":1}}],[\"除了any类型和unknown类型\",{\"1\":{\"503\":1}}],[\"除了你磕了合剂的\",{\"1\":{\"485\":1}}],[\"除了猜谜游戏的时候都可以输出\",{\"1\":{\"452\":1}}],[\"除了黑暗之拥的时候都可以输出\",{\"1\":{\"451\":1}}],[\"除了上面预铺之外再把回春铺满\",{\"1\":{\"411\":1}}],[\"除了return语句\",{\"1\":{\"332\":1}}],[\"除可靠性外\",{\"1\":{\"285\":1}}],[\"除以\",{\"1\":{\"174\":2}}],[\"该过程也是异步的\",{\"1\":{\"1507\":1}}],[\"该事务半消息没有被提交或者回滚\",{\"1\":{\"1468\":1}}],[\"该主题保存事务消息提交或者回滚的请求\",{\"1\":{\"1468\":1}}],[\"该值\",{\"1\":{\"1467\":1}}],[\"该值默认为\",{\"1\":{\"687\":1}}],[\"该接口有两个方法\",{\"1\":{\"1442\":1}}],[\"该列表最多只允许有一个\",{\"1\":{\"1413\":1}}],[\"该列表在消息生产时永远只有\",{\"1\":{\"1017\":1}}],[\"该定时时间的消息数量\",{\"1\":{\"1367\":1}}],[\"该定时时间的最后\",{\"1\":{\"1367\":1}}],[\"该定时时间的第一条消息在\",{\"1\":{\"1367\":1}}],[\"该方案的读性能同样令人满意\",{\"1\":{\"1363\":1}}],[\"该方法会把需要截断\",{\"1\":{\"1511\":1}}],[\"该方法会从半消息\",{\"1\":{\"1453\":1}}],[\"该方法会检查消息的\",{\"1\":{\"1450\":1}}],[\"该方法会调用\",{\"1\":{\"1449\":1}}],[\"该方法逻辑为\",{\"1\":{\"1257\":1}}],[\"该方法逻辑如下\",{\"1\":{\"374\":1,\"957\":1,\"973\":1,\"1137\":1,\"1408\":1}}],[\"该方法将消费消息的请求提交到消费线程池\",{\"1\":{\"1119\":1}}],[\"该方法将\",{\"1\":{\"1119\":1}}],[\"该方法中初始化一个\",{\"1\":{\"906\":1}}],[\"该方法的第一步是找到本次上传数据的偏移量起始和结束位置\",{\"1\":{\"1403\":1}}],[\"该方法的\",{\"1\":{\"896\":1}}],[\"该方法的调用关系如下图所示\",{\"1\":{\"767\":1}}],[\"该方法调用线程池\",{\"1\":{\"820\":1}}],[\"该方法在长轮询收到新消息时调用\",{\"1\":{\"814\":1}}],[\"该方法主要完成如下操作\",{\"1\":{\"814\":1}}],[\"该方法每隔\",{\"1\":{\"769\":1}}],[\"该槽位的定时消息都处理完成后\",{\"1\":{\"1358\":1}}],[\"该条消息topic的hash\",{\"1\":{\"1352\":1}}],[\"该条消息在commitlog中的大小\",{\"1\":{\"1352\":1}}],[\"该条消息在commitlog中的位置\",{\"1\":{\"1352\":1}}],[\"该条记录的定时时间\",{\"1\":{\"1352\":1}}],[\"该条consumequeue索引对应的消息如果未到投递时间\",{\"1\":{\"845\":1,\"860\":1}}],[\"该数据只会暂时存储到\",{\"1\":{\"1300\":1}}],[\"该数值可以通过\",{\"1\":{\"787\":2}}],[\"该配置项为\",{\"1\":{\"1234\":1}}],[\"该配置默认会自动获取主机\",{\"1\":{\"1075\":1}}],[\"该机制默认不开启\",{\"1\":{\"1234\":1}}],[\"该机制在\",{\"1\":{\"944\":1}}],[\"该队列新分配到负载的\",{\"1\":{\"1225\":1}}],[\"该消费者负载的队列列表\",{\"1\":{\"1267\":1}}],[\"该消费者负载的所有消息队列\",{\"1\":{\"1133\":1}}],[\"该消息投递之后消费者会收到并重试消费\",{\"1\":{\"1188\":1}}],[\"该消息之后会发送到延迟消息的\",{\"1\":{\"1188\":1}}],[\"该逻辑由\",{\"1\":{\"1155\":1}}],[\"该逻辑在\",{\"1\":{\"1039\":1}}],[\"该模式的消费实时性较高\",{\"1\":{\"1094\":1}}],[\"该对象创建时默认状态为\",{\"1\":{\"1047\":1}}],[\"该功能默认关闭\",{\"1\":{\"1005\":1}}],[\"该账号未设置任何访问规则\",{\"1\":{\"1000\":1}}],[\"该账号拥有的资源权限\",{\"1\":{\"1000\":1}}],[\"该参数目前设置为5秒\",{\"1\":{\"999\":1}}],[\"该服务的核心逻辑如下\",{\"1\":{\"999\":1}}],[\"该服务是一个线程\",{\"1\":{\"999\":1}}],[\"该服务线程\",{\"1\":{\"816\":1}}],[\"该服务线程会从\",{\"1\":{\"815\":1}}],[\"该改动在服务端nettyserverconfig和客户端配置nettyclientconfig中新增了如下配置项\",{\"1\":{\"1299\":1}}],[\"该改动依赖\",{\"1\":{\"905\":1}}],[\"该改动要在\",{\"1\":{\"894\":1}}],[\"该提交未合入\",{\"1\":{\"889\":1,\"892\":1,\"913\":1}}],[\"该文件最后一次写入过后\",{\"1\":{\"870\":1}}],[\"该文件可以看作\",{\"1\":{\"746\":1}}],[\"该索引主要包含消息在\",{\"1\":{\"836\":1}}],[\"该线程池默认有\",{\"1\":{\"1203\":1}}],[\"该线程中用生产\",{\"1\":{\"1158\":1}}],[\"该线程应用了生产\",{\"1\":{\"881\":1}}],[\"该线程循环扫描对应的\",{\"1\":{\"836\":1}}],[\"该线程扫描对应的延迟等级\",{\"1\":{\"834\":1}}],[\"该线程负责将存储到\",{\"1\":{\"811\":1}}],[\"该mappedfile起始物理偏移量\",{\"1\":{\"765\":1}}],[\"该mappedfile被写过的位置\",{\"1\":{\"765\":1}}],[\"该函数的大致逻辑如下\",{\"1\":{\"765\":1}}],[\"该\",{\"1\":{\"740\":1,\"834\":1,\"971\":1,\"1144\":1,\"1224\":1,\"1499\":1}}],[\"该优化主要是减少冗余代码\",{\"1\":{\"731\":1}}],[\"该协议能够保证组播消息的原子性\",{\"1\":{\"673\":1}}],[\"该情况下队列的主副本所在的节点与生产者\",{\"1\":{\"668\":1}}],[\"该情况下吞吐量达到130万\",{\"1\":{\"285\":1}}],[\"该节点称为队列主服务器\",{\"1\":{\"660\":1}}],[\"该策略为所有\",{\"1\":{\"652\":1}}],[\"该进程会被阻塞\",{\"1\":{\"621\":1}}],[\"该类是\",{\"1\":{\"809\":1}}],[\"该类型的变量可以赋予任意类型的值\",{\"1\":{\"502\":1}}],[\"该类拉起了调度\",{\"1\":{\"374\":1}}],[\"该副本难度为一星\",{\"1\":{\"443\":1,\"449\":1}}],[\"该部分负责将配置的protocol进行激活初始化\",{\"1\":{\"374\":1}}],[\"该https连接升级为websocket连接\",{\"1\":{\"368\":1}}],[\"该响应代码101表示本次连接的http协议即将被更改\",{\"1\":{\"368\":1}}],[\"该请求和普通的http请求有几点不同\",{\"1\":{\"368\":1}}],[\"该问题我们也已经report给etcd社区\",{\"1\":{\"284\":1}}],[\"该插件可以做到绝大部分的新增\",{\"1\":{\"271\":1}}],[\"输入\",{\"1\":{\"595\":1}}],[\"输入错误\",{\"1\":{\"357\":1}}],[\"输出消息内容\",{\"1\":{\"1195\":1}}],[\"输出\",{\"0\":{\"412\":1},\"1\":{\"596\":1}}],[\"输出长度\",{\"1\":{\"390\":2}}],[\"输出集群的处理语义情况\",{\"1\":{\"283\":1}}],[\"输冒号进入command模式\",{\"1\":{\"161\":1}}],[\"韧性\",{\"1\":{\"282\":1}}],[\"韧性架构\",{\"1\":{\"278\":1,\"286\":1}}],[\"韧性架构进一步发展\",{\"1\":{\"277\":1}}],[\"度量模型会计算出集群的\",{\"1\":{\"285\":1}}],[\"度量模型会根据实验中故障注入情况与系统表现\",{\"1\":{\"283\":1}}],[\"度量模型会对系统的表现进行分析\",{\"1\":{\"283\":1}}],[\"度量模型\",{\"0\":{\"283\":1},\"1\":{\"280\":1}}],[\"图\",{\"1\":{\"693\":2,\"695\":1}}],[\"图中黄色部分\",{\"1\":{\"1403\":1}}],[\"图中未画出\",{\"1\":{\"1300\":1}}],[\"图中3\",{\"1\":{\"621\":1}}],[\"图中2\",{\"1\":{\"621\":1}}],[\"图中1\",{\"1\":{\"621\":1}}],[\"图中的\",{\"1\":{\"120\":1}}],[\"图7\",{\"1\":{\"285\":1}}],[\"图7是具体的弹性评测结果部分截图\",{\"1\":{\"285\":1}}],[\"图6\",{\"1\":{\"285\":1}}],[\"图6为各指标随着实验时间的变化情况\",{\"1\":{\"285\":1}}],[\"图5\",{\"1\":{\"285\":1}}],[\"图5为三节点集群上的一个\",{\"1\":{\"285\":1}}],[\"图4\",{\"1\":{\"284\":1}}],[\"图3\",{\"1\":{\"284\":1}}],[\"图2\",{\"1\":{\"284\":1}}],[\"图1\",{\"1\":{\"279\":1}}],[\"检测配置文件的变更\",{\"1\":{\"990\":1,\"996\":1}}],[\"检测本\",{\"1\":{\"422\":1}}],[\"检测模型与度量模型\",{\"0\":{\"281\":1}}],[\"检测模型\",{\"0\":{\"282\":1},\"1\":{\"280\":1}}],[\"检索系统的查全率与查准率\",{\"1\":{\"278\":1}}],[\"检查被挂起的追加请求\",{\"1\":{\"1521\":1}}],[\"检查日志推送到\",{\"0\":{\"1521\":1}}],[\"检查日志条目是否存在\",{\"1\":{\"1520\":1}}],[\"检查日志转发器内部状态\",{\"1\":{\"1519\":1}}],[\"检查最老的日志\",{\"1\":{\"1519\":2}}],[\"检查节点状态\",{\"1\":{\"1519\":2}}],[\"检查节点是否为\",{\"1\":{\"1519\":1}}],[\"检查主从同步差异\",{\"1\":{\"1519\":1}}],[\"检查挂起的日志追加请求是否泄漏\",{\"1\":{\"1521\":1}}],[\"检查挂起的\",{\"1\":{\"1519\":2}}],[\"检查请求是否丢失\",{\"1\":{\"1511\":1,\"1520\":1}}],[\"检查和刷新节点状态\",{\"1\":{\"1510\":1}}],[\"检查和等待\",{\"1\":{\"1371\":1}}],[\"检查该事务半消息的偏移量\",{\"1\":{\"1468\":1}}],[\"检查一次\",{\"1\":{\"1467\":1}}],[\"检查对应消息的本地事务执行的最终结果\",{\"1\":{\"1446\":1}}],[\"检查本地事务执行状态\",{\"1\":{\"1471\":1,\"1472\":1}}],[\"检查本地事务\",{\"1\":{\"1442\":1}}],[\"检查给定的\",{\"1\":{\"1323\":1}}],[\"检查处理队列是否丢弃\",{\"1\":{\"1218\":1}}],[\"检查处理队列中还未被消费的消息\",{\"1\":{\"1159\":1}}],[\"检查队列是否被丢弃和消费者是否挂起\",{\"1\":{\"1159\":1}}],[\"检查队列数量\",{\"1\":{\"1098\":1}}],[\"检查是否超出配额\",{\"1\":{\"1519\":2}}],[\"检查是否需要流控\",{\"1\":{\"1510\":1}}],[\"检查是否需要从分级存储中读取消息\",{\"1\":{\"1405\":1}}],[\"检查是否已经\",{\"1\":{\"1277\":1}}],[\"检查是否是刚创建状态\",{\"1\":{\"1120\":1}}],[\"检查是否有消息到达\",{\"1\":{\"824\":1}}],[\"检查生产者处于运行状态\",{\"1\":{\"1050\":1}}],[\"检查配置\",{\"1\":{\"1037\":1}}],[\"检查的字符串的每一个字符是否在位图中\",{\"1\":{\"904\":1}}],[\"检查通过正则表达式匹配来进行\",{\"1\":{\"904\":1}}],[\"检查重试次数\",{\"1\":{\"861\":1}}],[\"检查所有已经挂起的长轮询请求\",{\"1\":{\"823\":1}}],[\"检查所有挂起的拉取请求\",{\"1\":{\"815\":1}}],[\"检查轮询条件\",{\"1\":{\"815\":1}}],[\"检查消费结果\",{\"1\":{\"1218\":1}}],[\"检查消费成功与否\",{\"1\":{\"1188\":1}}],[\"检查消费者配置是否合法\",{\"1\":{\"1122\":1}}],[\"检查消费者配置信息是否合法\",{\"1\":{\"1120\":1}}],[\"检查消费者状态\",{\"1\":{\"1122\":1}}],[\"检查消费队列中是否有新消息到达\",{\"1\":{\"806\":1}}],[\"检查消息是否含有重试\",{\"1\":{\"1188\":1}}],[\"检查消息合法性检查\",{\"1\":{\"1056\":1}}],[\"检查消息合理性\",{\"1\":{\"1043\":1}}],[\"检查消息\",{\"1\":{\"762\":1}}],[\"检查索引文件列表最后一个文件是否存在以及是否满\",{\"1\":{\"789\":1}}],[\"检查周期flushintervalconsumequeue可配置\",{\"1\":{\"758\":1}}],[\"检查\",{\"1\":{\"234\":1,\"638\":2,\"941\":1,\"954\":1,\"1047\":1,\"1195\":1,\"1198\":2}}],[\"检查连接是否处理完毕\",{\"1\":{\"125\":1}}],[\"弹性的含义不仅包括实例节点的伸缩能力\",{\"1\":{\"285\":1}}],[\"弹性检测模型会根据指定的预期值与当前系统表现\",{\"1\":{\"285\":1}}],[\"弹性也是分布式系统需要重点关注的能力\",{\"1\":{\"285\":1}}],[\"弹性案例分析\",{\"0\":{\"285\":1}}],[\"弹性伸缩与冷启效率\",{\"1\":{\"278\":1}}],[\"弹性\",{\"1\":{\"278\":1}}],[\"弹性等一系列韧性架构的挑战\",{\"1\":{\"276\":1}}],[\"很难支持百万级别甚至更多数量\",{\"1\":{\"1284\":1}}],[\"很难形成统一的评测标准\",{\"1\":{\"277\":1}}],[\"很明显\",{\"1\":{\"928\":1}}],[\"很大机会会被虚拟机分配至物理机器的高速寄存器中存储\",{\"1\":{\"904\":1}}],[\"很大程度上能减少被秒的概率\",{\"1\":{\"492\":1}}],[\"很高的场景下\",{\"1\":{\"741\":1}}],[\"很常见\",{\"1\":{\"556\":1}}],[\"很考验打断和控制\",{\"1\":{\"455\":1}}],[\"很吃打断和控制链\",{\"1\":{\"422\":1}}],[\"很吃打断和道具的使用\",{\"1\":{\"422\":1}}],[\"很有治疗压力\",{\"1\":{\"422\":1}}],[\"很容易减员\",{\"1\":{\"422\":1}}],[\"很容易进本就黑散\",{\"1\":{\"399\":1}}],[\"很多操作最终都是调用它来做的\",{\"1\":{\"1118\":1}}],[\"很多网站\",{\"1\":{\"976\":1}}],[\"很多次都不想打了\",{\"1\":{\"399\":1}}],[\"很多时候\",{\"1\":{\"188\":1,\"295\":1}}],[\"面向有更多复杂特性的分布式系统\",{\"1\":{\"277\":1}}],[\"面向对象基础\",{\"0\":{\"18\":1}}],[\"面向对象编程\",{\"0\":{\"17\":1,\"339\":1}}],[\"硬件\",{\"1\":{\"277\":1}}],[\"倾向于构造以黑盒随机为主的故障类型\",{\"1\":{\"277\":1}}],[\"良药虽好\",{\"0\":{\"277\":1}}],[\"混沌工程的最基本流程是在生产环境小规模定期自动化执行试验\",{\"1\":{\"277\":1}}],[\"混沌工程思想给我们带来了一定程度的启发\",{\"1\":{\"276\":1}}],[\"混沌故障\",{\"1\":{\"276\":1}}],[\"混沌故障引入到催生未来架构变革的多云多活参考架构的制定\",{\"1\":{\"276\":1}}],[\"企业的数字化升级不断加快\",{\"1\":{\"276\":1}}],[\"安抚\",{\"1\":{\"490\":1}}],[\"安苏雷克的传令官\",{\"1\":{\"435\":1}}],[\"安全性是仲裁队列的主要目标\",{\"1\":{\"704\":1}}],[\"安全性等特性的检测模型\",{\"1\":{\"282\":1}}],[\"安全的websocket连接机制和https类似\",{\"1\":{\"368\":1}}],[\"安全限制\",{\"0\":{\"350\":1}}],[\"安全\",{\"1\":{\"276\":1,\"278\":1}}],[\"安装包到本地\",{\"1\":{\"1072\":1}}],[\"安装包\",{\"1\":{\"645\":1}}],[\"安装包下载\",{\"1\":{\"643\":1}}],[\"安装包安装\",{\"0\":{\"643\":1}}],[\"安装方法是用\",{\"1\":{\"642\":1}}],[\"安装使用方式可以在网上搜索\",{\"1\":{\"271\":1}}],[\"安装\",{\"0\":{\"641\":1,\"642\":1,\"644\":1,\"645\":1},\"1\":{\"165\":1,\"272\":1,\"643\":1,\"644\":1,\"718\":1}}],[\"安装插件管理器\",{\"0\":{\"165\":1}}],[\"安装插件的情况下可以直接运行测试\",{\"1\":{\"10\":1}}],[\"安装插件\",{\"0\":{\"6\":1}}],[\"融合架构是这几年被提的最多的一个词\",{\"1\":{\"276\":1}}],[\"催生新架构的不断演进\",{\"1\":{\"276\":1}}],[\"含义\",{\"1\":{\"978\":1,\"983\":1,\"1508\":1}}],[\"含义相同\",{\"1\":{\"503\":1}}],[\"含义为\",{\"1\":{\"167\":1}}],[\"含1\",{\"1\":{\"302\":1}}],[\"含服务网格\",{\"1\":{\"276\":1}}],[\"微服务架构兴起\",{\"1\":{\"1439\":1}}],[\"微服务\",{\"1\":{\"276\":1}}],[\"微基准测试工具\",{\"1\":{\"15\":1}}],[\"观察火焰图中时间占比较高的方法进行针对性优化\",{\"1\":{\"917\":1}}],[\"观察消息在队列中的分布\",{\"1\":{\"711\":1}}],[\"观察\",{\"1\":{\"273\":1}}],[\"控制包\",{\"1\":{\"1300\":1}}],[\"控制\",{\"1\":{\"575\":1,\"805\":1,\"866\":1,\"1300\":2}}],[\"控制少以外没啥缺点\",{\"1\":{\"403\":1}}],[\"控制器\",{\"1\":{\"960\":1}}],[\"控制器在模型中载入需要测试的分布式系统的驱动\",{\"1\":{\"280\":1}}],[\"控制器负责调度引擎层的组件进行工作\",{\"1\":{\"280\":1}}],[\"控制节点根据\",{\"1\":{\"280\":1}}],[\"控制面对整个流程进行控制\",{\"1\":{\"280\":1}}],[\"控制台上可以控制\",{\"1\":{\"372\":1}}],[\"控制台执行\",{\"1\":{\"273\":1}}],[\"控制台不用关\",{\"1\":{\"273\":1}}],[\"控制台粘贴即可\",{\"1\":{\"273\":1}}],[\"控制台\",{\"1\":{\"273\":1}}],[\"控制权从应用程序转移到了\",{\"1\":{\"81\":1}}],[\"担心安全问题的话可以只在本地开启\",{\"1\":{\"272\":1}}],[\"探索\",{\"0\":{\"271\":1}}],[\"谁拖垮了效率\",{\"0\":{\"270\":1}}],[\"谁负责根据依赖关系组装组件\",{\"1\":{\"81\":1}}],[\"谁负责创建组件\",{\"1\":{\"81\":1}}],[\"避免内存泄漏\",{\"1\":{\"1521\":1}}],[\"避免定时消息被老化删除\",{\"0\":{\"1347\":1}}],[\"避免\",{\"0\":{\"1240\":1}}],[\"避免订阅关系不一致导致消息丢失\",{\"0\":{\"1239\":1}}],[\"避免同一个服务器上的多个生产者实例名相同\",{\"1\":{\"1047\":1}}],[\"避免了对延迟消息重新排序\",{\"1\":{\"925\":1}}],[\"避免动态扩容\",{\"1\":{\"917\":1}}],[\"避免扩容\",{\"1\":{\"909\":1}}],[\"避免无谓的\",{\"0\":{\"906\":1,\"907\":1}}],[\"避免其被多次调用\",{\"0\":{\"901\":1}}],[\"避免每次调用都重新计算和创建字符串对象\",{\"1\":{\"900\":1}}],[\"避免多余对象产生\",{\"1\":{\"900\":1}}],[\"避免多余的字符串对象产生\",{\"1\":{\"900\":1}}],[\"避免多次调用\",{\"1\":{\"896\":1}}],[\"避免多线程下的竞争条件和同步问题\",{\"1\":{\"124\":1}}],[\"避免一些坑\",{\"1\":{\"863\":1}}],[\"避免消息丢失\",{\"1\":{\"693\":1}}],[\"避免编译器报错\",{\"1\":{\"589\":1}}],[\"避免伤害叠加\",{\"1\":{\"447\":1}}],[\"避免空转嗜血\",{\"1\":{\"443\":1}}],[\"避免驱一个撞到球\",{\"1\":{\"431\":1}}],[\"避免变量自动被声明为全局变量\",{\"1\":{\"296\":1}}],[\"避免重启应用\",{\"0\":{\"268\":1}}],[\"找不到\",{\"1\":{\"1276\":1}}],[\"找不到则从\",{\"1\":{\"1171\":1}}],[\"找到索引文件表中下一个\",{\"1\":{\"1417\":1}}],[\"找到索引链表绝对位置\",{\"1\":{\"797\":1}}],[\"找到包含\",{\"1\":{\"1410\":1}}],[\"找到创建时间最早的处于\",{\"1\":{\"1394\":1}}],[\"找到数据在磁盘上的物理位置\",{\"1\":{\"876\":1}}],[\"找到安全的排气口\",{\"1\":{\"440\":1}}],[\"找到对应消息\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"找到对应的挂起请求\",{\"1\":{\"1521\":1}}],[\"找到对应的消费队列索引\",{\"1\":{\"1164\":1}}],[\"找到对应的\",{\"1\":{\"954\":1,\"972\":1}}],[\"找到对应\",{\"1\":{\"396\":1,\"954\":1,\"972\":1}}],[\"找到\",{\"1\":{\"266\":2,\"1053\":1}}],[\"找出应该执行哪一段表达式序列\",{\"1\":{\"194\":1}}],[\"容量为\",{\"1\":{\"927\":1}}],[\"容量和时间跨度\",{\"1\":{\"927\":1}}],[\"容易想到使用一个单独的线程来处理投递逻辑\",{\"1\":{\"930\":1}}],[\"容易出现繁忙\",{\"1\":{\"883\":1}}],[\"容易造成混淆\",{\"1\":{\"592\":1}}],[\"容错性\",{\"1\":{\"372\":1}}],[\"容错性高的系统\",{\"1\":{\"372\":1}}],[\"容错和分布式的应用程序\",{\"1\":{\"262\":1}}],[\"容器层为上面提到的存储模型除了\",{\"1\":{\"1387\":1}}],[\"容器层\",{\"1\":{\"1387\":1}}],[\"容器负责\",{\"1\":{\"81\":1}}],[\"容器\",{\"0\":{\"80\":1},\"1\":{\"81\":1,\"1075\":1}}],[\"介绍消息拉取的流程\",{\"1\":{\"1147\":1}}],[\"介绍消费者重平衡\",{\"1\":{\"1125\":1}}],[\"介绍消费者相关类与调用关系\",{\"1\":{\"1107\":1}}],[\"介绍了openchaos的架构\",{\"1\":{\"275\":1}}],[\"介绍\",{\"0\":{\"262\":1},\"1\":{\"990\":1}}],[\"做了判断\",{\"1\":{\"916\":1}}],[\"做了更进一步的性能优化\",{\"1\":{\"886\":1}}],[\"做了一系列性能优化\",{\"1\":{\"886\":1}}],[\"做了一些性能优化\",{\"1\":{\"720\":1}}],[\"做什么\",{\"1\":{\"261\":1}}],[\"做模式匹配\",{\"1\":{\"233\":1}}],[\"错误示例\",{\"1\":{\"1308\":1}}],[\"错误\",{\"1\":{\"556\":1}}],[\"错误就会被抛到外层调用函数\",{\"1\":{\"358\":1}}],[\"错误传播\",{\"0\":{\"358\":1}}],[\"错误类型\",{\"0\":{\"356\":1}}],[\"错误处理\",{\"0\":{\"355\":1}}],[\"错误发生在\",{\"1\":{\"256\":1}}],[\"错误消息之后是栈跟踪信息\",{\"1\":{\"256\":1}}],[\"测量\",{\"1\":{\"255\":1}}],[\"测试时也可以不依赖\",{\"1\":{\"273\":1}}],[\"测试仅仅需要模式匹配和=\",{\"1\":{\"180\":1}}],[\"测试的时候并不依赖spring容器\",{\"1\":{\"81\":1}}],[\"测试结果\",{\"1\":{\"11\":1}}],[\"测试模式\",{\"1\":{\"11\":1}}],[\"测试模式为计算测试方法的吞吐量\",{\"1\":{\"9\":1}}],[\"测试\",{\"0\":{\"639\":1},\"1\":{\"11\":1}}],[\"测试执行\",{\"1\":{\"9\":1}}],[\"测试方法\",{\"1\":{\"4\":1,\"9\":1}}],[\"～\",{\"1\":{\"255\":1}}],[\"调整消息发送几个参数的默认值\",{\"0\":{\"732\":1}}],[\"调动整个集群加速计算\",{\"1\":{\"371\":1}}],[\"调度中心可以多实例部署来做到调度中心高可用\",{\"1\":{\"372\":1}}],[\"调度中心和执行器之间通过\",{\"1\":{\"372\":1}}],[\"调度中心是一个基于\",{\"1\":{\"372\":1}}],[\"调度服务器经过精心设计\",{\"1\":{\"371\":1}}],[\"调度编排系统的精准调度\",{\"1\":{\"278\":1}}],[\"调试器\",{\"0\":{\"260\":1}}],[\"调试并行程序时\",{\"1\":{\"258\":1}}],[\"调试\",{\"0\":{\"258\":1}}],[\"调试方法\",{\"0\":{\"257\":1}}],[\"调试与跟踪\",{\"0\":{\"254\":1}}],[\"调用事务生产者的\",{\"1\":{\"1449\":1}}],[\"调用时才会返回为\",{\"1\":{\"1300\":1}}],[\"调用时用\",{\"1\":{\"812\":1}}],[\"调用消费者\",{\"1\":{\"1188\":1}}],[\"调用注册的监听器执行消费逻辑\",{\"1\":{\"1179\":1}}],[\"调用客户端\",{\"1\":{\"1160\":1}}],[\"调用重平衡策略\",{\"1\":{\"1129\":1}}],[\"调用并代理到\",{\"1\":{\"1112\":1}}],[\"调用存储模块将消息存储\",{\"1\":{\"1043\":1}}],[\"调用它的\",{\"1\":{\"1414\":1,\"1415\":1}}],[\"调用它的进程就会在跟踪事件发生时收到跟踪消息\",{\"1\":{\"261\":1}}],[\"调用它内部的\",{\"1\":{\"1036\":1}}],[\"调用这个方法\",{\"1\":{\"825\":1}}],[\"调用该类的\",{\"1\":{\"809\":1}}],[\"调用该索引文件的\",{\"1\":{\"789\":1,\"794\":1}}],[\"调用符合条件的索引文件\",{\"1\":{\"789\":1}}],[\"调用defaultmessagestore\",{\"1\":{\"759\":1}}],[\"调用credit\",{\"1\":{\"624\":1,\"627\":1}}],[\"调用了serverdiscoveryservice的start方法\",{\"1\":{\"380\":1}}],[\"调用map方法时\",{\"1\":{\"378\":1}}],[\"调用希望\",{\"1\":{\"342\":1}}],[\"调用原函数\",{\"1\":{\"320\":1}}],[\"调用的总是最新版模块里的最新版函数\",{\"1\":{\"207\":1}}],[\"调用函数\",{\"0\":{\"307\":1},\"1\":{\"180\":1}}],[\"调用\",{\"1\":{\"122\":1,\"132\":1,\"135\":1,\"380\":1,\"671\":1,\"726\":1,\"764\":1,\"789\":1,\"812\":3,\"815\":1,\"837\":1,\"841\":1,\"894\":1,\"947\":1,\"952\":1,\"956\":1,\"957\":2,\"960\":1,\"973\":2,\"994\":1,\"999\":1,\"1119\":2,\"1140\":1,\"1159\":1,\"1188\":2,\"1191\":2,\"1213\":1,\"1214\":1,\"1226\":1,\"1300\":1,\"1319\":1,\"1398\":1,\"1409\":1,\"1417\":1,\"1421\":2,\"1428\":1,\"1449\":1,\"1453\":2,\"1509\":2,\"1511\":2,\"1520\":1}}],[\"调用方法\",{\"0\":{\"39\":1}}],[\"调用方可通过throwable\",{\"1\":{\"34\":1}}],[\"^\",{\"1\":{\"904\":1}}],[\"^表示所有队列都是镜像队列\",{\"1\":{\"652\":1}}],[\"^mirror\",{\"1\":{\"653\":1,\"654\":1}}],[\"^m\",{\"1\":{\"289\":1}}],[\"^g\",{\"1\":{\"248\":1}}],[\"^移动到第一个非空白字符\",{\"1\":{\"145\":1}}],[\"λ\",{\"1\":{\"248\":1}}],[\"同一队列的消息数据可能会横跨更多的文件\",{\"1\":{\"1402\":1}}],[\"同一队列积累的拉取请求\",{\"1\":{\"815\":1}}],[\"同一进程中多个生产者发送消息到多个集群\",{\"0\":{\"1235\":1}}],[\"同一消费组中的每个消费者应保持一致\",{\"1\":{\"1133\":1}}],[\"同一\",{\"1\":{\"1091\":1,\"1240\":1}}],[\"同步一次\",{\"1\":{\"1519\":1}}],[\"同步当前节点的已提交日志序号\",{\"1\":{\"1510\":2}}],[\"同步存储消息\",{\"1\":{\"1462\":1}}],[\"同步消息的基准是\",{\"1\":{\"1188\":1}}],[\"同步发送共重试timestotal次\",{\"1\":{\"1050\":1}}],[\"同步发送的重试逻辑即在\",{\"1\":{\"1040\":1}}],[\"同步发送和异步发送的重试次数分别由\",{\"1\":{\"1040\":1}}],[\"同步等待所有节点响应\",{\"1\":{\"1497\":1}}],[\"同步等待\",{\"1\":{\"1027\":1}}],[\"同步标记\",{\"1\":{\"964\":1}}],[\"同步投递\",{\"1\":{\"860\":1,\"861\":1}}],[\"同步复制\",{\"1\":{\"853\":1}}],[\"同步和异步的消息存储函数\",{\"1\":{\"839\":1}}],[\"同步保存消息的方法即是异步方法调用get\",{\"1\":{\"843\":1}}],[\"同步保存批量消息\",{\"1\":{\"731\":1}}],[\"同步保存单条消息\",{\"1\":{\"731\":1}}],[\"同步的问题被解决\",{\"1\":{\"696\":1}}],[\"同步的影响就会抱很大\",{\"1\":{\"693\":1}}],[\"同步还会消耗内存\",{\"1\":{\"693\":1}}],[\"同步很快结束\",{\"1\":{\"693\":1}}],[\"同步是阻塞的\",{\"1\":{\"693\":1}}],[\"同步会导致集群中与内存相关的问题\",{\"1\":{\"678\":1}}],[\"同步将会需要很长时间\",{\"1\":{\"678\":1}}],[\"同步阻塞\",{\"0\":{\"678\":1}}],[\"同步\",{\"1\":{\"633\":1,\"677\":1,\"1021\":1,\"1025\":1,\"1027\":2,\"1053\":1,\"1161\":1,\"1171\":1,\"1519\":1}}],[\"同名\",{\"0\":{\"584\":1}}],[\"同名type则会报错\",{\"1\":{\"564\":1}}],[\"同名interface会自动合并\",{\"1\":{\"564\":1}}],[\"同学\",{\"1\":{\"338\":1}}],[\"同样用生产\",{\"1\":{\"916\":1}}],[\"同样一次最多删\",{\"1\":{\"866\":1}}],[\"同样地\",{\"1\":{\"695\":1}}],[\"同样\",{\"1\":{\"674\":2,\"858\":1}}],[\"同样也是缓存\",{\"1\":{\"1190\":1}}],[\"同样也会将消息对外发送两次\",{\"1\":{\"668\":1}}],[\"同样也包含具体业务\",{\"1\":{\"285\":1}}],[\"同样的\",{\"1\":{\"663\":1,\"708\":1}}],[\"同样会引起array大小的变化\",{\"1\":{\"298\":1}}],[\"同时提供了索引文件操作的接口\",{\"1\":{\"1402\":1}}],[\"同时水位线还分为高水位线和低水位线\",{\"1\":{\"1300\":1}}],[\"同时删除messagequeue\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"同时包含消费者启动流程\",{\"1\":{\"1107\":1}}],[\"同时消费者端缓存\",{\"1\":{\"1103\":1}}],[\"同时启动\",{\"0\":{\"1081\":1}}],[\"同时更新路由信息表\",{\"1\":{\"954\":1}}],[\"同时缓存了路由信息\",{\"1\":{\"950\":1}}],[\"同时触发\",{\"1\":{\"945\":1}}],[\"同时再加上定期的将内存数据镜像\",{\"1\":{\"942\":1}}],[\"同时最多只能满足两个点\",{\"1\":{\"942\":1}}],[\"同时生产和消费\",{\"1\":{\"887\":1}}],[\"同时在第一次试图删除该文件时记录当前时间戳\",{\"1\":{\"870\":1}}],[\"同时向4个延迟等级发送延迟消息\",{\"1\":{\"852\":2}}],[\"同时向\",{\"1\":{\"852\":1}}],[\"同时从本地缓存变量\",{\"1\":{\"816\":1}}],[\"同时将参数\",{\"1\":{\"733\":1}}],[\"同时这个\",{\"1\":{\"622\":1}}],[\"同时还具备基本等同于普通消息的性能表现\",{\"1\":{\"922\":1}}],[\"同时还会发送一次对消息的\",{\"1\":{\"668\":1}}],[\"同时还会设置x的值为构造方法的参数值\",{\"1\":{\"576\":1}}],[\"同时还支持上下游任务间的数据传递\",{\"1\":{\"371\":1}}],[\"同时定义一个对象类型\",{\"1\":{\"564\":1}}],[\"同时能提供少量的伤害\",{\"1\":{\"483\":1}}],[\"同时维护着一组后台线程定期上报自身的健康状态\",{\"1\":{\"372\":1}}],[\"同时维护注册到本注册中心所有执行器集群的状态\",{\"1\":{\"372\":1}}],[\"同时支持所有spring\",{\"1\":{\"371\":1}}],[\"同时执行p1和p2\",{\"1\":{\"352\":1}}],[\"同时发出新的http请求\",{\"1\":{\"347\":1}}],[\"同时对一组变量进行赋值\",{\"1\":{\"316\":1}}],[\"同时\",{\"1\":{\"277\":1,\"372\":1,\"380\":1,\"627\":1,\"696\":1,\"751\":1,\"990\":1,\"996\":1,\"1262\":1,\"1300\":1}}],[\"同时开启一个新的事务\",{\"1\":{\"87\":1}}],[\"同键表\",{\"1\":{\"248\":1}}],[\"损坏会尝试修复\",{\"1\":{\"247\":1}}],[\"速度就比较慢了\",{\"1\":{\"1453\":1}}],[\"速度就比较鸡肋\",{\"1\":{\"477\":1}}],[\"速度才更快\",{\"1\":{\"917\":1}}],[\"速度更快且更稳定\",{\"1\":{\"917\":1}}],[\"速度相较于写文件对应的\",{\"1\":{\"883\":1}}],[\"速度\",{\"1\":{\"421\":2,\"477\":1}}],[\"速度慢于\",{\"1\":{\"247\":1}}],[\"速率\",{\"1\":{\"130\":1}}],[\"脚本\",{\"0\":{\"243\":1}}],[\"系统当前时间\",{\"1\":{\"1467\":1}}],[\"系统生成的路径是\",{\"1\":{\"1074\":1}}],[\"系统级别的\",{\"1\":{\"836\":1}}],[\"系统会自动安装依赖包\",{\"1\":{\"643\":1}}],[\"系统管理的轻量级进程\",{\"1\":{\"623\":1}}],[\"系统中存在着多台\",{\"1\":{\"380\":1}}],[\"系统表现出的性能以及弹性变更的花销与效率\",{\"1\":{\"285\":1}}],[\"系统在整个实验过程中的响应时间等\",{\"1\":{\"283\":1}}],[\"系统的可观测性\",{\"1\":{\"277\":1}}],[\"系统边界\",{\"1\":{\"277\":1}}],[\"系统\",{\"1\":{\"237\":1,\"836\":1}}],[\"系统剪贴板\",{\"1\":{\"158\":1}}],[\"尾递归\",{\"1\":{\"235\":1}}],[\"尾递归的说明\",{\"0\":{\"235\":1}}],[\"尾是t\",{\"1\":{\"177\":1}}],[\"带有\",{\"1\":{\"1353\":2}}],[\"带有可选的关卡\",{\"1\":{\"187\":1}}],[\"带着这个疑问我做了一些压测\",{\"1\":{\"1325\":1}}],[\"带超时的接收\",{\"0\":{\"232\":1}}],[\"收集将要消费消息的轨迹信息\",{\"1\":{\"1020\":1}}],[\"收割精魄\",{\"1\":{\"454\":1}}],[\"收割者卡吉尔\",{\"0\":{\"427\":1}}],[\"收到对端未准备好的响应的节点个数\",{\"1\":{\"1499\":1}}],[\"收到成功响应的节点个数\",{\"1\":{\"1499\":1}}],[\"收到过半赞成\",{\"1\":{\"1497\":1}}],[\"收到日志追加请求后把日志保存\",{\"1\":{\"1481\":1}}],[\"收到后会返回响应并重新启动计时器\",{\"1\":{\"1478\":1}}],[\"收到了\",{\"1\":{\"1300\":1}}],[\"收到客户端发来的持久化消费进度请求\",{\"1\":{\"1201\":1}}],[\"收到客户端获取路由信息请求后\",{\"1\":{\"957\":1,\"973\":1}}],[\"收到请求后用延迟消息机制\",{\"1\":{\"1180\":1}}],[\"收到请求后发送请求让其他消费者重平衡\",{\"1\":{\"1128\":1}}],[\"收到请求后交给请求处理模块处理\",{\"1\":{\"806\":1}}],[\"收到拉去请求\",{\"1\":{\"1119\":1}}],[\"收到消费进度先缓存到内存\",{\"1\":{\"1103\":1}}],[\"收到消息就会主动推送到消费者端\",{\"1\":{\"1094\":1}}],[\"收到消息后关闭订单\",{\"1\":{\"921\":1,\"1337\":1}}],[\"收到消息后存储消息时调用\",{\"1\":{\"839\":1}}],[\"收到消息后\",{\"1\":{\"834\":1}}],[\"收到消息之后也要立即打印\",{\"1\":{\"258\":1}}],[\"收到消息进行处理之后立即再次调用\",{\"1\":{\"235\":1}}],[\"收到延迟消息后\",{\"1\":{\"925\":1}}],[\"收到\",{\"1\":{\"809\":1,\"814\":1,\"1480\":1,\"1500\":1,\"1511\":1,\"1520\":1}}],[\"收到的广播消息进行回调处理\",{\"1\":{\"672\":1}}],[\"收到的\",{\"1\":{\"421\":1}}],[\"收到的消息会被放入该进程的邮箱\",{\"1\":{\"229\":1}}],[\"收取到的数据存储在buffer中\",{\"1\":{\"72\":1}}],[\"收取一个udp数据包\",{\"1\":{\"72\":1}}],[\"现成\",{\"1\":{\"1483\":1}}],[\"现代浏览器上写ajax主要依靠xmlhttprequest对象\",{\"1\":{\"348\":1}}],[\"现实世界中的并发\",{\"0\":{\"227\":1}}],[\"现在的延迟消息机制基于\",{\"1\":{\"847\":1}}],[\"现在的打法都是把\",{\"1\":{\"425\":1}}],[\"现在都移动到了锁外面\",{\"1\":{\"737\":1}}],[\"现在都研究了一下都不用回春来奶了\",{\"1\":{\"399\":1}}],[\"现在改成以函数形式传入addinitializer\",{\"1\":{\"606\":1}}],[\"现在小迅捷数值加强了\",{\"1\":{\"403\":1}}],[\"现在奶德专精天赋和英雄天赋点法还是比较固定的\",{\"1\":{\"403\":1}}],[\"现在\",{\"1\":{\"21\":1,\"677\":1}}],[\"改成\",{\"1\":{\"1079\":1,\"1354\":1}}],[\"改成最新的官方镜像地址\",{\"1\":{\"1075\":1}}],[\"改成宿主机\",{\"1\":{\"1075\":1}}],[\"改成异步投递后\",{\"1\":{\"850\":1}}],[\"改变日志转发器的状态\",{\"1\":{\"1519\":1}}],[\"改变日志转发器的状态为\",{\"1\":{\"1519\":1}}],[\"改变\",{\"1\":{\"1198\":1}}],[\"改变生产者的\",{\"1\":{\"1047\":1}}],[\"改变开发环境\",{\"0\":{\"223\":1}}],[\"改动\",{\"1\":{\"945\":1}}],[\"改动背景\",{\"0\":{\"893\":1}}],[\"改动后\",{\"1\":{\"852\":2}}],[\"改动后的性能变化\",{\"1\":{\"852\":1}}],[\"改动前\",{\"1\":{\"852\":1}}],[\"改动解析\",{\"0\":{\"851\":1}}],[\"改动主要移除了事务消息中的日志打印\",{\"1\":{\"722\":1}}],[\"改\",{\"1\":{\"371\":1}}],[\"改为宿主机的\",{\"1\":{\"1075\":2}}],[\"改为使用\",{\"1\":{\"850\":1}}],[\"改为了\",{\"1\":{\"733\":1}}],[\"改为\",{\"1\":{\"125\":2,\"241\":1,\"726\":2,\"852\":2}}],[\"比当前节点大\",{\"1\":{\"1488\":1}}],[\"比例\",{\"1\":{\"1382\":1}}],[\"比较多时\",{\"1\":{\"910\":1}}],[\"比较少时\",{\"1\":{\"910\":1}}],[\"比较第一个\",{\"1\":{\"872\":1}}],[\"比较它的最大\",{\"1\":{\"868\":1}}],[\"比较时间信息\",{\"1\":{\"797\":1}}],[\"比较上次刷盘时间与当前时间差距\",{\"1\":{\"769\":1}}],[\"比较好\",{\"1\":{\"733\":1}}],[\"比较运算符\",{\"0\":{\"295\":1}}],[\"比较数据类型\",{\"0\":{\"220\":1}}],[\"比如在\",{\"1\":{\"1344\":1,\"1379\":1}}],[\"比如通过修改消息拉取线程\",{\"1\":{\"1207\":1}}],[\"比如保存路由和客户端信息\",{\"1\":{\"1109\":1}}],[\"比如当消费者数量变化\",{\"1\":{\"1098\":1}}],[\"比如当前最新版本为\",{\"1\":{\"1072\":1}}],[\"比如消息生产的请求由\",{\"1\":{\"1043\":1}}],[\"比如用户先发了一条延迟\",{\"1\":{\"925\":1}}],[\"比如用户余额变更\",{\"1\":{\"87\":1}}],[\"比如每\",{\"1\":{\"924\":1}}],[\"比如使用了内存映射文件的方案进行读写\",{\"1\":{\"874\":1}}],[\"比如投递时页缓存繁忙或者其他原因导致一次投递失败\",{\"1\":{\"854\":1}}],[\"比如basic\",{\"1\":{\"624\":1}}],[\"比如处理路由逻辑\",{\"1\":{\"622\":1}}],[\"比如类名\",{\"1\":{\"606\":1}}],[\"比如交叉类型和联合类型\",{\"1\":{\"564\":1}}],[\"比如破晨老二\",{\"1\":{\"492\":1}}],[\"比如围攻的\",{\"1\":{\"492\":1}}],[\"比如我们在场地左边\",{\"1\":{\"425\":1}}],[\"比如一个分布式\",{\"1\":{\"384\":1}}],[\"比如需要更新一大批数据\",{\"1\":{\"371\":1}}],[\"比如说\",{\"1\":{\"368\":1}}],[\"比如引入故障或者系统的扩缩容\",{\"1\":{\"280\":1}}],[\"比如\",{\"1\":{\"117\":1,\"261\":1,\"385\":1,\"392\":1,\"582\":1,\"1027\":1,\"1284\":1,\"1420\":1}}],[\"比如缺乏预热的步骤\",{\"1\":{\"3\":1}}],[\"他本身的启动方法并没有什么逻辑\",{\"1\":{\"1120\":1}}],[\"他们都是实验性的\",{\"1\":{\"1382\":1}}],[\"他们的大小关系通常是\",{\"1\":{\"1508\":1}}],[\"他们的监听\",{\"1\":{\"1075\":1}}],[\"他们的关系如下图所示\",{\"1\":{\"118\":1}}],[\"他们之中的消息顺序就是固定的\",{\"1\":{\"925\":1}}],[\"他们可以使用参数\",{\"1\":{\"665\":1}}],[\"他们可以定义一个类型\",{\"1\":{\"564\":1}}],[\"他在那时就提供了现在看来的标准天赋\",{\"1\":{\"403\":1}}],[\"他提出并带领团队创造了openchaos这一新兴项目\",{\"1\":{\"277\":1}}],[\"他是一个\",{\"1\":{\"217\":1}}],[\"碰到\",{\"1\":{\"213\":1}}],[\"宏伟宝库旁边用\",{\"1\":{\"485\":1}}],[\"宏控制流\",{\"0\":{\"214\":1}}],[\"宏语法模板\",{\"1\":{\"213\":1}}],[\"宏\",{\"0\":{\"213\":1,\"488\":1}}],[\"移出\",{\"1\":{\"1262\":1,\"1277\":1}}],[\"移出同步代码块\",{\"1\":{\"726\":1}}],[\"移到\",{\"1\":{\"341\":1}}],[\"移除对应的挂起请求\",{\"1\":{\"1521\":1}}],[\"移除消息的\",{\"1\":{\"1296\":1}}],[\"移除消费队列\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"移除前持久化消费的消费进度\",{\"1\":{\"1225\":1}}],[\"移除前持久化\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"移除不再属于当前实例的messagequeue和processqueue\",{\"1\":{\"1142\":1}}],[\"移除不再属于当前实例的消息队列和处理队列\",{\"1\":{\"1137\":1}}],[\"移除未激活状态的\",{\"1\":{\"961\":1}}],[\"移除掉线的\",{\"1\":{\"947\":1,\"961\":1}}],[\"移除\",{\"0\":{\"723\":1,\"731\":1,\"888\":1},\"1\":{\"406\":1,\"954\":2,\"972\":4,\"1262\":1,\"1507\":1,\"1519\":1}}],[\"移除与\",{\"1\":{\"234\":1}}],[\"移除的意思是b中所有元素都会从a里面去除\",{\"1\":{\"212\":1}}],[\"移动消费队列下标\",{\"1\":{\"1370\":1}}],[\"移动速度提高\",{\"1\":{\"421\":1}}],[\"移动窗口\",{\"1\":{\"153\":1}}],[\"移动到文件开头\",{\"1\":{\"145\":1}}],[\"移动到行尾非空白字符\",{\"1\":{\"145\":1}}],[\"移动到行尾\",{\"1\":{\"145\":1}}],[\"移动到行首\",{\"1\":{\"145\":1}}],[\"移动到char的前一个字符\",{\"1\":{\"145\":1}}],[\"移动到char字符\",{\"1\":{\"145\":1}}],[\"移动\",{\"1\":{\"141\":1,\"145\":1}}],[\"再构建索引\",{\"1\":{\"1388\":1}}],[\"再放入时间轮槽位\",{\"1\":{\"1356\":1}}],[\"再进行精确判断\",{\"1\":{\"1319\":1}}],[\"再根据完整的消息信息做精确过滤\",{\"1\":{\"1318\":1}}],[\"再将定时消息请求入队\",{\"1\":{\"1358\":1}}],[\"再将处理结果写入到\",{\"1\":{\"1300\":1}}],[\"再将它重新放入队列\",{\"1\":{\"1152\":1}}],[\"再看\",{\"1\":{\"1299\":1}}],[\"再看一下这个方法\",{\"1\":{\"624\":1}}],[\"再判断是否可以释放\",{\"1\":{\"1215\":1}}],[\"再提交\",{\"1\":{\"1194\":1}}],[\"再提交到消费者消费线程池进行消费\",{\"1\":{\"1169\":1}}],[\"再定时持久化\",{\"1\":{\"1190\":1}}],[\"再次校验节点状态是否为\",{\"1\":{\"1517\":1}}],[\"再次判断锁定情况尝试拉取\",{\"1\":{\"1228\":1}}],[\"再次查询\",{\"1\":{\"1039\":1}}],[\"再次拉取消息\",{\"1\":{\"814\":1,\"820\":1}}],[\"再\",{\"1\":{\"976\":1}}],[\"再执行下一次状态维护方法\",{\"1\":{\"1483\":1}}],[\"再执行\",{\"1\":{\"931\":1,\"1318\":1,\"1427\":2}}],[\"再加上一个分隔符\",{\"1\":{\"906\":1}}],[\"再关闭内存映射\",{\"1\":{\"870\":1}}],[\"再往前遍历时间更不符合\",{\"1\":{\"794\":1}}],[\"再结合图中的情况\",{\"1\":{\"668\":1}}],[\"再讲一下驱散是要在\",{\"1\":{\"438\":1}}],[\"再用javascript更新页面\",{\"1\":{\"347\":1}}],[\"再创建一个函数\",{\"1\":{\"330\":1}}],[\"再比较\",{\"1\":{\"295\":1}}],[\"再比如写着写着突然对某个资源的响应内容不确定\",{\"1\":{\"271\":1}}],[\"再到后来\",{\"1\":{\"276\":1}}],[\"再由所有需要这些定义的模块包含此文件\",{\"1\":{\"211\":1}}],[\"再恢复执行\",{\"1\":{\"87\":2}}],[\"引到怪之后用隐遁可以脱战\",{\"1\":{\"487\":1}}],[\"引用server类\",{\"1\":{\"369\":1}}],[\"引用的用途是创建独一无二的标签\",{\"1\":{\"218\":1}}],[\"引用\",{\"0\":{\"218\":1},\"1\":{\"210\":1,\"218\":1,\"725\":1}}],[\"引用当前模块的本地函数\",{\"1\":{\"210\":1}}],[\"引用在当前或外部模块里定义的某个函数\",{\"1\":{\"210\":1}}],[\"引入原因\",{\"0\":{\"1284\":1}}],[\"引入分布式锁是最好的选择\",{\"1\":{\"1209\":1}}],[\"引入的新消费形式\",{\"1\":{\"1095\":1}}],[\"引入第三方组件\",{\"1\":{\"928\":1}}],[\"引入hello模块\",{\"1\":{\"361\":1}}],[\"引入事件总线如apache\",{\"1\":{\"276\":1}}],[\"引入了预读缓存的设计\",{\"1\":{\"1391\":1}}],[\"引入了轻量级队列\",{\"1\":{\"1284\":1}}],[\"引入了延迟故障规避机制\",{\"1\":{\"1234\":1}}],[\"引入了新的订阅表达式写法\",{\"1\":{\"1307\":1}}],[\"引入了新的\",{\"1\":{\"773\":1}}],[\"引入了一套基于信用证的流控实现\",{\"1\":{\"614\":1,\"617\":1}}],[\"引入了一个更强大\",{\"1\":{\"495\":1}}],[\"引入了两个解决方法\",{\"1\":{\"592\":1}}],[\"引入了调度中心来统一解决任务的配置和调度\",{\"1\":{\"372\":1}}],[\"引入了\",{\"1\":{\"131\":1,\"300\":1,\"883\":1,\"1475\":1,\"1506\":1}}],[\"引入\",{\"0\":{\"131\":1,\"1249\":1},\"1\":{\"186\":1,\"747\":1,\"1249\":2}}],[\"引入依赖\",{\"0\":{\"8\":1}}],[\"转写模式下\",{\"1\":{\"1385\":1}}],[\"转写\",{\"1\":{\"1385\":1}}],[\"转入磁盘等待匹配\",{\"1\":{\"1253\":1}}],[\"转发到\",{\"0\":{\"1519\":1}}],[\"转发日志到\",{\"0\":{\"1510\":1},\"1\":{\"1508\":1}}],[\"转发后会将等待转发完成的日志序号存在一个\",{\"1\":{\"1507\":1}}],[\"转发\",{\"1\":{\"756\":1}}],[\"转\",{\"1\":{\"741\":2}}],[\"转不过来的时候用变熊来生存\",{\"1\":{\"425\":1}}],[\"转储至文件\",{\"0\":{\"259\":1}}],[\"转义序列\",{\"0\":{\"209\":1}}],[\"转换成一个逗号分隔的序列\",{\"1\":{\"529\":1}}],[\"转换成长整型\",{\"1\":{\"396\":1}}],[\"转换成\",{\"1\":{\"390\":1,\"1478\":1,\"1479\":3,\"1480\":2}}],[\"转换成标准的绝对路径后的路径\",{\"1\":{\"52\":1}}],[\"转换为整数\",{\"1\":{\"385\":1}}],[\"转换解析出的属性\",{\"1\":{\"338\":1}}],[\"转换时需要指定编码\",{\"1\":{\"58\":1}}],[\"任意的定时时间\",{\"0\":{\"1342\":1}}],[\"任意时间定时\",{\"0\":{\"1346\":1}}],[\"任意时间定时消息\",{\"0\":{\"1335\":1},\"1\":{\"1538\":1}}],[\"任意时间定时消息特性提供领先业界的定时消息体验\",{\"1\":{\"937\":1}}],[\"任意时间定时消息的主要难点有以下几个\",{\"1\":{\"1341\":1}}],[\"任意时间定时消息的实现存在一定的难点\",{\"1\":{\"1341\":1}}],[\"任意时间定时消息的难点\",{\"0\":{\"1341\":1}}],[\"任意时间定时消息的使用\",{\"0\":{\"1339\":1}}],[\"任意时间定时消息的设计和实现\",{\"1\":{\"936\":1}}],[\"任意时间定时消息的面纱\",{\"1\":{\"922\":1}}],[\"任意时间定时消息实现\",{\"0\":{\"848\":1}}],[\"任意时间延时消息原理讲解\",{\"1\":{\"938\":1}}],[\"任意时间的定时消息或延迟消息\",{\"1\":{\"937\":1}}],[\"任意时间的定时消息\",{\"1\":{\"919\":1}}],[\"任何功能都可以用消息来触发\",{\"1\":{\"935\":1}}],[\"任何包含\",{\"1\":{\"591\":1}}],[\"任何一个类型必须同时属于a和b\",{\"1\":{\"516\":1}}],[\"任何一个类型只要属于a或b\",{\"1\":{\"515\":1}}],[\"任何其他类型的变量都可以赋值为undefined或null\",{\"1\":{\"513\":1}}],[\"任何运行旧版代码的进程都会被终止\",{\"1\":{\"207\":1}}],[\"任凭风浪起\",{\"1\":{\"286\":1}}],[\"任务的新增和取消都是\",{\"1\":{\"931\":1}}],[\"任务扔到一个队列中\",{\"1\":{\"915\":1}}],[\"任务不断从阻塞队列头部获取异步投递过程对象\",{\"1\":{\"858\":1}}],[\"任务\",{\"1\":{\"857\":1,\"858\":2}}],[\"任务有点重\",{\"1\":{\"733\":1}}],[\"任务配置重试策略的判断是否发起重试\",{\"1\":{\"374\":1}}],[\"任务就能顺利完成\",{\"1\":{\"371\":1}}],[\"任务运行状态监控和运行日志查看等功能\",{\"1\":{\"371\":1}}],[\"任务执行状态\",{\"1\":{\"372\":1}}],[\"任务执行失败后\",{\"1\":{\"371\":1}}],[\"任务执行\",{\"1\":{\"273\":1}}],[\"任务分发可能会更慢\",{\"1\":{\"117\":1}}],[\"哪些失败了\",{\"1\":{\"1195\":1}}],[\"哪些消息被发送到哪个消费者的信息就丢失了\",{\"1\":{\"665\":1}}],[\"哪怕当代码在模块里运行时重新编译了该模块也是如此\",{\"1\":{\"207\":1}}],[\"哪个更快\",{\"1\":{\"2\":1}}],[\"块级类型声明\",{\"0\":{\"519\":1}}],[\"块表达式\",{\"0\":{\"205\":1}}],[\"块状选择\",{\"1\":{\"144\":1}}],[\"预读缓存是使用\",{\"1\":{\"1406\":1}}],[\"预读缓存设计\",{\"0\":{\"1406\":1}}],[\"预读缓存过期时间\",{\"1\":{\"1382\":1}}],[\"预先根据这些消费组的过滤表达式进行一次精确匹配\",{\"1\":{\"1315\":1}}],[\"预先定义需要继续挂起的拉取请求列表\",{\"1\":{\"825\":1}}],[\"预设了多种负载算法供不同场景下的消费\",{\"1\":{\"1097\":1}}],[\"预加载到时间轮\",{\"0\":{\"931\":1}}],[\"预测行为\",{\"1\":{\"904\":1}}],[\"预分配文件\",{\"0\":{\"881\":1}}],[\"预铺\",{\"1\":{\"465\":1}}],[\"预铺来应对\",{\"1\":{\"448\":1}}],[\"预警尖鸣\",{\"1\":{\"428\":1}}],[\"预制宏\",{\"1\":{\"213\":1}}],[\"预处理器会展开源文件里所有的宏\",{\"1\":{\"208\":1}}],[\"预处理器\",{\"0\":{\"208\":1}}],[\"预定义模块属性\",{\"0\":{\"203\":1}}],[\"预热\",{\"1\":{\"11\":1}}],[\"预热执行\",{\"1\":{\"9\":1}}],[\"语法标准文件\",{\"1\":{\"1321\":1}}],[\"语法\",{\"1\":{\"1308\":1,\"1321\":1}}],[\"语法二\",{\"1\":{\"589\":2}}],[\"语法一\",{\"1\":{\"589\":2}}],[\"语法高亮\",{\"1\":{\"143\":1}}],[\"语言的类型增强\",{\"1\":{\"582\":1}}],[\"语言中都是内置对象\",{\"1\":{\"506\":1}}],[\"语言\",{\"1\":{\"506\":1}}],[\"语句编译成\",{\"1\":{\"1321\":1}}],[\"语句解析为\",{\"1\":{\"1321\":1}}],[\"语句加载的模块\",{\"1\":{\"598\":2}}],[\"语句和\",{\"1\":{\"597\":1}}],[\"语句输入的类型前面加上type关键字\",{\"1\":{\"592\":1}}],[\"语句\",{\"0\":{\"592\":1,\"595\":1,\"596\":1,\"1321\":1},\"1\":{\"591\":1,\"592\":1,\"593\":4}}],[\"语句的文件\",{\"1\":{\"591\":1}}],[\"语句来打印出感兴趣的变量值\",{\"1\":{\"258\":1}}],[\"语句里面的模块文件位置\",{\"1\":{\"597\":1}}],[\"语句里\",{\"1\":{\"195\":1}}],[\"里是\",{\"1\":{\"1477\":2}}],[\"里面是该\",{\"1\":{\"931\":1}}],[\"里面消息的延迟等级相同\",{\"1\":{\"925\":1}}],[\"里面采用生产\",{\"1\":{\"915\":1}}],[\"里面都会执行一个新的定时任务\",{\"1\":{\"841\":1}}],[\"里面一写\",{\"1\":{\"733\":1}}],[\"里面包含三个成员red\",{\"1\":{\"582\":1}}],[\"里面的消息将会重试\",{\"1\":{\"1261\":1}}],[\"里面的消息是否到达投递时间\",{\"1\":{\"925\":1}}],[\"里面的函数重载\",{\"1\":{\"558\":1}}],[\"里面的狭义对象\",{\"1\":{\"512\":1}}],[\"里面分成两种类型\",{\"1\":{\"521\":1}}],[\"里面\",{\"1\":{\"518\":1,\"519\":1,\"729\":1}}],[\"里可以排前三的\",{\"1\":{\"446\":1}}],[\"里\",{\"1\":{\"256\":1,\"1468\":1}}],[\"里表示这些表\",{\"1\":{\"253\":1}}],[\"里调用\",{\"0\":{\"243\":1}}],[\"里的逻辑偏移量怎么已经被计算出来了\",{\"1\":{\"765\":1}}],[\"里的数据拷贝进去\",{\"1\":{\"729\":1}}],[\"里的表是一个包含若干行的\",{\"1\":{\"253\":1}}],[\"里的\",{\"1\":{\"195\":1}}],[\"里没有字符串\",{\"1\":{\"178\":1}}],[\"捕捉一切可能的异常错误\",{\"1\":{\"196\":1}}],[\"捕捉异常错误\",{\"0\":{\"195\":1}}],[\"捕获异常\",{\"0\":{\"194\":1}}],[\"像一个函数\",{\"1\":{\"332\":1}}],[\"像一个反应堆一样\",{\"1\":{\"119\":1}}],[\"像是它的强化版\",{\"1\":{\"194\":1}}],[\"显然延迟\",{\"1\":{\"925\":1}}],[\"显式调用包括\",{\"1\":{\"193\":1}}],[\"显示的\",{\"1\":{\"655\":1}}],[\"显示换行符\",{\"0\":{\"289\":1}}],[\"显示\",{\"0\":{\"287\":1},\"1\":{\"608\":1}}],[\"显示所有配色\",{\"1\":{\"163\":1}}],[\"显示当前主题颜色\",{\"1\":{\"163\":1}}],[\"显示行号\",{\"1\":{\"143\":1}}],[\"忘掉\",{\"1\":{\"191\":1}}],[\"归集器\",{\"0\":{\"189\":1},\"1\":{\"189\":1}}],[\"`pwd`\",{\"1\":{\"1080\":9}}],[\"`hi\",{\"1\":{\"605\":1}}],[\"`你好\",{\"1\":{\"297\":1}}],[\"`这是一个\",{\"1\":{\"297\":1}}],[\"`caculatearea`\",{\"1\":{\"230\":1}}],[\"`case`\",{\"1\":{\"187\":1}}],[\"`receive`\",{\"1\":{\"230\":1}}],[\"`spawn`\",{\"1\":{\"230\":1}}],[\"`echo\",{\"1\":{\"369\":1}}],[\"`erlang\",{\"1\":{\"193\":1}}],[\"`exit\",{\"1\":{\"193\":1}}],[\"`\",{\"1\":{\"193\":3,\"230\":2,\"297\":1,\"369\":11,\"605\":1,\"1383\":20}}],[\"`throw\",{\"1\":{\"193\":1}}],[\"`if`\",{\"1\":{\"188\":1}}],[\"`为真的元素`x`组成的列表\",{\"1\":{\"187\":1}}],[\"`filter`\",{\"1\":{\"187\":1}}],[\"`g1\",{\"1\":{\"186\":1}}],[\"`guardexpr1\",{\"1\":{\"186\":1}}],[\"```ts\",{\"1\":{\"504\":1}}],[\"``\",{\"1\":{\"155\":1}}],[\"表\",{\"1\":{\"1144\":1,\"1224\":1,\"1412\":1}}],[\"表中\",{\"1\":{\"1317\":1}}],[\"表中该\",{\"1\":{\"972\":1}}],[\"表中移除该\",{\"1\":{\"945\":1}}],[\"表中最后一项可能是损坏的会丢失\",{\"1\":{\"247\":1}}],[\"表offsettable\",{\"1\":{\"857\":1}}],[\"表达了镜像队列的镜像策略和异常后的晋升策略\",{\"1\":{\"656\":1}}],[\"表达式去过滤消息属性\",{\"1\":{\"1333\":1}}],[\"表达式模式过滤服务\",{\"1\":{\"1333\":1}}],[\"表达式类似\",{\"1\":{\"1321\":1}}],[\"表达式解析成一个抽象语法树\",{\"1\":{\"1321\":1}}],[\"表达式对象\",{\"1\":{\"1321\":2}}],[\"表达式计算来精确匹配\",{\"1\":{\"1315\":1}}],[\"表达式匹配\",{\"1\":{\"1315\":1}}],[\"表达式表示或的意思\",{\"1\":{\"1307\":1}}],[\"表达式来灵活地过滤消息的\",{\"1\":{\"1303\":1}}],[\"表达式过滤的逻辑在\",{\"1\":{\"1313\":1}}],[\"表达式过滤\",{\"0\":{\"1313\":1},\"1\":{\"1303\":1,\"1318\":1,\"1328\":1,\"1333\":1}}],[\"表达式最小间隔\",{\"1\":{\"374\":1}}],[\"表达式加上最后的\",{\"1\":{\"194\":1}}],[\"表达式和case表达式之间的相似性\",{\"1\":{\"194\":1}}],[\"表达式里\",{\"1\":{\"193\":1}}],[\"表达式k\",{\"1\":{\"192\":2}}],[\"表达式的消费者\",{\"1\":{\"1332\":1}}],[\"表达式的时机与\",{\"1\":{\"1321\":1}}],[\"表达式的值\",{\"1\":{\"187\":1}}],[\"表达式的最后一个关卡是原子\",{\"1\":{\"188\":1}}],[\"表达式的最后\",{\"1\":{\"186\":1}}],[\"表达式\",{\"0\":{\"187\":1,\"188\":1},\"1\":{\"187\":1,\"188\":1,\"1305\":1}}],[\"表达式为真\",{\"1\":{\"186\":1}}],[\"表达式均为真\",{\"1\":{\"186\":1}}],[\"表达式组成\",{\"1\":{\"186\":1}}],[\"表还可以在不同机器之间进行复制\",{\"1\":{\"251\":1}}],[\"表在内部是用散列表表示的\",{\"1\":{\"249\":1}}],[\"表效率的因素\",{\"0\":{\"249\":1}}],[\"表里所有的键都是唯一的\",{\"1\":{\"248\":1}}],[\"表保存的是元组\",{\"1\":{\"248\":1}}],[\"表的类型\",{\"0\":{\"248\":1}}],[\"表示从该日志序号开始\",{\"1\":{\"1520\":1}}],[\"表示从节点\",{\"1\":{\"952\":1}}],[\"表示有相交\",{\"1\":{\"1519\":1}}],[\"表示时新的集群\",{\"1\":{\"1519\":1}}],[\"表示时刻表上的每一秒\",{\"1\":{\"1351\":1}}],[\"表示本次仲裁向客户端返回响应结果的数量\",{\"1\":{\"1521\":1}}],[\"表示本次追加请求失败\",{\"1\":{\"1516\":1}}],[\"表示本地事务暂时没有执行完\",{\"1\":{\"1442\":1}}],[\"表示本地事务的状态\",{\"1\":{\"1442\":2}}],[\"表示整个集群已经确认的\",{\"1\":{\"1511\":1}}],[\"表示主从日志不一致\",{\"1\":{\"1510\":1}}],[\"表示主节点\",{\"1\":{\"952\":1}}],[\"表示已达到多数节点复制确认的最大\",{\"1\":{\"1508\":1}}],[\"表示已提交\",{\"1\":{\"1508\":1}}],[\"表示单个索引文件\",{\"1\":{\"1412\":1}}],[\"表示单个队列的存储实现\",{\"1\":{\"1402\":1}}],[\"表示单个队列的消息文件\",{\"1\":{\"1386\":1}}],[\"表示一个\",{\"1\":{\"1482\":1}}],[\"表示一个事务半消息\",{\"1\":{\"1446\":1}}],[\"表示一个变量的值有若干种可能\",{\"1\":{\"515\":1}}],[\"表示一段时间\",{\"1\":{\"1351\":1}}],[\"表示投递时间\",{\"1\":{\"1346\":1}}],[\"表示可能需要消费该消息\",{\"1\":{\"1333\":1}}],[\"表示可以消费所有队列\",{\"1\":{\"1255\":1}}],[\"表示可以同时投递的消息数\",{\"1\":{\"855\":1}}],[\"表示属性的值在某个集合内\",{\"1\":{\"1308\":1}}],[\"表示属性值在两个值的区间之外\",{\"1\":{\"1308\":1}}],[\"表示属性值在两个数字之间\",{\"1\":{\"1308\":1}}],[\"表示无限\",{\"1\":{\"1267\":1}}],[\"表示这组消息\",{\"1\":{\"1351\":1}}],[\"表示这个时间要投递的所有定时消息\",{\"1\":{\"1346\":1}}],[\"表示这个单词\",{\"1\":{\"155\":1}}],[\"表示这条消息被\",{\"1\":{\"1262\":1}}],[\"表示允许消费者进行额外的负载获取队列的次数\",{\"1\":{\"1255\":1}}],[\"表示对应到一个\",{\"1\":{\"1235\":1}}],[\"表示对任何\",{\"1\":{\"124\":1}}],[\"表示由客户端控制重试次数\",{\"1\":{\"1198\":1}}],[\"表示由\",{\"1\":{\"1197\":1,\"1198\":1}}],[\"表示拉取的一批消息都消费成功\",{\"1\":{\"1195\":1}}],[\"表示最多同时消费\",{\"1\":{\"1187\":1}}],[\"表示新增队列\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"表示新消息到达\",{\"1\":{\"815\":1}}],[\"表示下一次从下一个\",{\"1\":{\"857\":1}}],[\"表示下一行\",{\"1\":{\"288\":3}}],[\"表示此时出现流控或者阻塞\",{\"1\":{\"857\":1}}],[\"表示每个延迟等级当前投递的消息在\",{\"1\":{\"857\":1}}],[\"表示每次至少刷2个操作系统page\",{\"1\":{\"769\":1}}],[\"表示每次测试都会执行\",{\"1\":{\"9\":1}}],[\"表示需要创建新的索引文件\",{\"1\":{\"797\":1}}],[\"表示消息在该\",{\"1\":{\"765\":1}}],[\"表示消息为广播的第一条消息\",{\"1\":{\"674\":1}}],[\"表示实时刷盘\",{\"1\":{\"735\":1}}],[\"表示同步副本数为\",{\"1\":{\"655\":1}}],[\"表示手动向master同步数据\",{\"1\":{\"652\":1}}],[\"表示自动向master同步数据\",{\"1\":{\"652\":1}}],[\"表示镜像队列中消息的同步方式\",{\"1\":{\"652\":1}}],[\"表示在指定的代理上进行镜像\",{\"1\":{\"652\":1}}],[\"表示在指定个数的代理上进行镜像\",{\"1\":{\"652\":1}}],[\"表示在集群所有的代理上进行镜像\",{\"1\":{\"652\":1}}],[\"表示所装饰的对象是否为类的静态成员\",{\"1\":{\"606\":1}}],[\"表示所装饰的对象是否为类的私有成员\",{\"1\":{\"606\":1}}],[\"表示所装饰对象的类型\",{\"1\":{\"606\":1}}],[\"表示所有属性名类型为字符串的属性\",{\"1\":{\"568\":1}}],[\"表示模块定位时\",{\"1\":{\"603\":1}}],[\"表示模式为\",{\"1\":{\"11\":1}}],[\"表示该消息已经被处理\",{\"1\":{\"1451\":1,\"1464\":2}}],[\"表示该消息是一个事务半消息\",{\"1\":{\"1449\":1}}],[\"表示该事务半消息需要提交或回滚\",{\"1\":{\"1446\":1}}],[\"表示该队列有消息正被消费\",{\"1\":{\"1225\":1}}],[\"表示该队列没有消息正被消费\",{\"1\":{\"1225\":1}}],[\"表示该类不能被实例化\",{\"1\":{\"579\":1}}],[\"表示该方法运行的时机\",{\"1\":{\"9\":1}}],[\"表示当前类满足这些外部类型条件的限制\",{\"1\":{\"570\":1}}],[\"表示当前对象\",{\"1\":{\"317\":1}}],[\"表示类型不确定\",{\"1\":{\"503\":1}}],[\"表示哈希环上的位置\",{\"1\":{\"391\":1}}],[\"表示函数没有返回值\",{\"1\":{\"541\":1}}],[\"表示函数剩余的所有参数\",{\"1\":{\"539\":1}}],[\"表示函数本身的参数\",{\"1\":{\"318\":1}}],[\"表示函数可以被用作参数\",{\"1\":{\"181\":1}}],[\"表示除了已定义参数之外的参数\",{\"1\":{\"309\":1}}],[\"表示常量值\",{\"1\":{\"175\":1}}],[\"表示全部\",{\"1\":{\"150\":1}}],[\"表示范围\",{\"1\":{\"150\":1}}],[\"表示连接可以关闭了\",{\"1\":{\"125\":1}}],[\"表示\",{\"1\":{\"118\":1,\"965\":2,\"1247\":1,\"1267\":1,\"1497\":1,\"1509\":1,\"1511\":2,\"1519\":1,\"1520\":1}}],[\"表示通道准备好进行写入的事件\",{\"1\":{\"118\":1}}],[\"表示通道准备好进行读取的事件\",{\"1\":{\"118\":1}}],[\"表示通道完成连接的事件\",{\"1\":{\"118\":1}}],[\"表示通道接受连接的事件\",{\"1\":{\"118\":1}}],[\"表示与客户端的连接\",{\"1\":{\"112\":1}}],[\"表示如果当前有事务\",{\"1\":{\"87\":1}}],[\"表示如果有事务\",{\"1\":{\"87\":1}}],[\"表示不限成员数量的元组\",{\"1\":{\"527\":1}}],[\"表示不支持事务\",{\"1\":{\"87\":1}}],[\"表示不管当前有没有事务\",{\"1\":{\"87\":1}}],[\"表示必须要存在当前事务并加入执行\",{\"1\":{\"87\":1}}],[\"表示误差\",{\"1\":{\"11\":1}}],[\"表示平均耗时\",{\"1\":{\"11\":1}}],[\"表示测试模式\",{\"1\":{\"11\":1}}],[\"递归\",{\"1\":{\"184\":1}}],[\"小林coding\",{\"1\":{\"1527\":1}}],[\"小结\",{\"0\":{\"917\":1,\"936\":1}}],[\"小时的索引文件大小就会达到\",{\"1\":{\"927\":1}}],[\"小时内\",{\"1\":{\"922\":1}}],[\"小时就过期\",{\"1\":{\"866\":1}}],[\"小时\",{\"1\":{\"866\":1,\"927\":1,\"1180\":1,\"1338\":1}}],[\"小消息实时生产的\",{\"1\":{\"720\":1}}],[\"小写的object类型代表\",{\"1\":{\"512\":1}}],[\"小队\",{\"1\":{\"491\":1}}],[\"小队分散站位\",{\"1\":{\"467\":1}}],[\"小怪的读条技\",{\"1\":{\"464\":1}}],[\"小怪\",{\"0\":{\"428\":1,\"435\":1,\"442\":1,\"448\":1,\"454\":1,\"461\":1,\"468\":1,\"475\":1}}],[\"小蜘蛛\",{\"1\":{\"425\":1}}],[\"小于对端\",{\"1\":{\"1497\":2}}],[\"小于当前\",{\"1\":{\"1503\":1}}],[\"小于当前的\",{\"1\":{\"1492\":1}}],[\"小于当前节点的\",{\"1\":{\"1489\":1,\"1492\":3,\"1503\":3}}],[\"小于最小\",{\"1\":{\"1427\":1}}],[\"小于最大偏移量时才能正常拉取\",{\"1\":{\"1164\":1}}],[\"小于提交到缓冲区的\",{\"1\":{\"1427\":1}}],[\"小于阈值\",{\"1\":{\"916\":1}}],[\"小于consumequeue中保存的最大commitlog物理偏移量\",{\"1\":{\"765\":1}}],[\"小于\",{\"1\":{\"412\":1,\"872\":1,\"1511\":1,\"1519\":2,\"1520\":1}}],[\"小于1024的端口属于特权端口\",{\"1\":{\"68\":1}}],[\"小迅捷树人\",{\"1\":{\"446\":1}}],[\"小迅捷\",{\"1\":{\"411\":1}}],[\"小迅捷稳定产生共生绽华\",{\"1\":{\"407\":1}}],[\"小明同学\",{\"1\":{\"338\":1}}],[\"小明\",{\"1\":{\"297\":1,\"299\":2,\"316\":4,\"338\":3,\"339\":3,\"341\":1}}],[\"小的数组成的列表\",{\"1\":{\"184\":1}}],[\"请谨慎选择\",{\"1\":{\"1090\":1}}],[\"请点击使用\",{\"1\":{\"937\":1}}],[\"请等待响应\",{\"1\":{\"348\":1}}],[\"请注意\",{\"1\":{\"184\":1,\"212\":1}}],[\"请求是否超时\",{\"1\":{\"1521\":1}}],[\"请求是否已经超时\",{\"1\":{\"1519\":1}}],[\"请求返回客户端\",{\"1\":{\"1521\":1}}],[\"请求队列不为空\",{\"1\":{\"1520\":1}}],[\"请求修正数据\",{\"1\":{\"1520\":1}}],[\"请求类型不是\",{\"1\":{\"1519\":1}}],[\"请求重推\",{\"1\":{\"1519\":1}}],[\"请求状态不一致\",{\"1\":{\"1519\":1}}],[\"请求等待列表中的日志条目\",{\"1\":{\"1519\":1}}],[\"请求数量大于阈值\",{\"1\":{\"1519\":1}}],[\"请求数量是否超过阈值\",{\"1\":{\"1519\":1}}],[\"请求数是否超过阈值\",{\"1\":{\"1519\":1}}],[\"请求数\",{\"1\":{\"1519\":1}}],[\"请求数据和本地数据是否相等\",{\"1\":{\"1511\":1}}],[\"请求列表\",{\"1\":{\"1519\":1}}],[\"请求已超时\",{\"1\":{\"1519\":1}}],[\"请求已超时则返回\",{\"1\":{\"1511\":1,\"1520\":1}}],[\"请求已发送\",{\"1\":{\"348\":1}}],[\"请求进行检查\",{\"1\":{\"1511\":1,\"1520\":1}}],[\"请求来更新集群的\",{\"1\":{\"1510\":1}}],[\"请求来同步\",{\"1\":{\"1510\":1}}],[\"请求去更新到\",{\"1\":{\"1510\":1}}],[\"请求不那么频繁\",{\"1\":{\"1510\":1}}],[\"请求不为空\",{\"1\":{\"1427\":1}}],[\"请求不到则等到下次重平衡再次请求\",{\"1\":{\"1209\":1}}],[\"请求触发\",{\"1\":{\"1415\":1}}],[\"请求都将由分级存储处理\",{\"1\":{\"1390\":1,\"1405\":1}}],[\"请求都将由本地消息存储处理\",{\"1\":{\"1390\":1,\"1405\":1}}],[\"请求才会由分级存储处理\",{\"1\":{\"1390\":2,\"1405\":2}}],[\"请求要求的数量\",{\"1\":{\"1257\":1}}],[\"请求指定了队列\",{\"1\":{\"1257\":1}}],[\"请求处理队列\",{\"1\":{\"1520\":3}}],[\"请求处理器收到\",{\"1\":{\"1507\":1}}],[\"请求处理入口\",{\"0\":{\"1257\":1},\"1\":{\"1520\":1}}],[\"请求处理机制会按照业务逻辑进行处理器的拆分\",{\"1\":{\"1043\":1}}],[\"请求后\",{\"1\":{\"1253\":1,\"1519\":1}}],[\"请求后触发\",{\"1\":{\"1136\":1}}],[\"请求给\",{\"1\":{\"1252\":2}}],[\"请求中带有重平衡策略\",{\"1\":{\"1252\":1}}],[\"请求中包含了消息的全部信息\",{\"1\":{\"1024\":1}}],[\"请求和更新自己负载的消费队列的\",{\"1\":{\"1209\":1}}],[\"请求到\",{\"1\":{\"1200\":1}}],[\"请求的日志序号\",{\"1\":{\"1519\":1}}],[\"请求的时间戳\",{\"1\":{\"1519\":1}}],[\"请求的等待表\",{\"1\":{\"1511\":2}}],[\"请求的队列id是否合法\",{\"1\":{\"1173\":1}}],[\"请求的操作就会执行\",{\"1\":{\"261\":1}}],[\"请求码\",{\"1\":{\"1043\":1}}],[\"请求码为requestcode\",{\"1\":{\"757\":1,\"766\":1}}],[\"请求体中包含\",{\"1\":{\"952\":1}}],[\"请求消息头解码性能\",{\"0\":{\"742\":1}}],[\"请求头upgrade\",{\"1\":{\"368\":1}}],[\"请求分发\",{\"0\":{\"123\":1}}],[\"请求\",{\"0\":{\"1464\":1,\"1516\":1},\"1\":{\"78\":1,\"945\":1,\"952\":1,\"1209\":1,\"1250\":1,\"1464\":1,\"1510\":4,\"1511\":2,\"1512\":1,\"1514\":1,\"1516\":2,\"1519\":18,\"1520\":14,\"1521\":1}}],[\"过了免疫期\",{\"1\":{\"1467\":1}}],[\"过一段时间将会再次收到这些消息进行消费\",{\"1\":{\"1179\":1}}],[\"过一\",{\"1\":{\"931\":1}}],[\"过期后保留的时间\",{\"1\":{\"870\":1}}],[\"过期\",{\"1\":{\"870\":1}}],[\"过期文件删除机制\",{\"0\":{\"862\":1},\"1\":{\"1538\":1}}],[\"过期删除\",{\"0\":{\"795\":1}}],[\"过高时\",{\"1\":{\"854\":1}}],[\"过滤索引项\",{\"1\":{\"1415\":1,\"1436\":1}}],[\"过滤模式\",{\"1\":{\"1329\":1}}],[\"过滤可以选择在消息生产的构建索引阶段预先计算布隆过滤器的位数组\",{\"1\":{\"1325\":1}}],[\"过滤一样\",{\"1\":{\"1324\":1}}],[\"过滤如果开启如下配置\",{\"1\":{\"1323\":1}}],[\"过滤逻辑\",{\"1\":{\"1321\":1}}],[\"过滤进行初筛\",{\"1\":{\"1319\":1}}],[\"过滤的主方法\",{\"1\":{\"1318\":1}}],[\"过滤的逻辑都在\",{\"1\":{\"1318\":1}}],[\"过滤主要用到\",{\"1\":{\"1318\":1}}],[\"过滤只用到\",{\"1\":{\"1318\":1}}],[\"过滤专用\",{\"1\":{\"1318\":1}}],[\"过滤信息管理器\",{\"1\":{\"1331\":1}}],[\"过滤信息由消费者发送心跳时有\",{\"1\":{\"1317\":1}}],[\"过滤信息的保存位置不同\",{\"1\":{\"1317\":1}}],[\"过滤信息的注册也是由消费这发送心跳触发\",{\"1\":{\"1317\":1}}],[\"过滤信息的注册\",{\"0\":{\"1312\":1}}],[\"过滤信息和\",{\"1\":{\"1317\":1}}],[\"过滤信息注册\",{\"0\":{\"1317\":1}}],[\"过滤不会进行进一步的匹配\",{\"1\":{\"1314\":1}}],[\"过滤更灵活\",{\"1\":{\"1308\":1}}],[\"过滤比\",{\"1\":{\"1308\":1}}],[\"过滤是最简单的一种过滤方法\",{\"1\":{\"1305\":1}}],[\"过滤类型\",{\"1\":{\"1171\":1}}],[\"过滤表达式\",{\"1\":{\"1171\":1,\"1317\":1}}],[\"过滤\",{\"0\":{\"1305\":1,\"1314\":1,\"1315\":1,\"1319\":1,\"1320\":1,\"1327\":1,\"1330\":1},\"1\":{\"1165\":1,\"1173\":1,\"1308\":1,\"1314\":1,\"1315\":1,\"1318\":1,\"1328\":1,\"1333\":1}}],[\"过滤消息\",{\"1\":{\"1025\":1}}],[\"过滤tag的hashcode\",{\"1\":{\"765\":1}}],[\"过滤器接口\",{\"0\":{\"1318\":1}}],[\"过滤器\",{\"1\":{\"184\":2}}],[\"过度生长\",{\"1\":{\"454\":1}}],[\"过程很长\",{\"1\":{\"271\":1}}],[\"过程\",{\"1\":{\"120\":1}}],[\"位点管理\",{\"1\":{\"1249\":1}}],[\"位数\",{\"1\":{\"906\":1}}],[\"位的\",{\"1\":{\"894\":1}}],[\"位置之前的消息都是消费成功的\",{\"1\":{\"1195\":1}}],[\"位置\",{\"1\":{\"459\":1,\"839\":1}}],[\"位\",{\"1\":{\"390\":2,\"396\":2,\"894\":1}}],[\"位串\",{\"1\":{\"184\":1}}],[\"位串生成器或过滤器\",{\"1\":{\"184\":1}}],[\"位表示字节的部分\",{\"1\":{\"54\":1}}],[\"循环将队列中的所有\",{\"1\":{\"1371\":1}}],[\"循环执行发送\",{\"1\":{\"1050\":1}}],[\"循环扫描这个\",{\"1\":{\"925\":1}}],[\"循环等待\",{\"1\":{\"915\":1}}],[\"循环获取队列中第一个投递任务\",{\"1\":{\"861\":1}}],[\"循环或者是周期性定时任务来周期执行\",{\"1\":{\"841\":1}}],[\"循环中局部作用域的变量\",{\"1\":{\"314\":1}}],[\"循环\",{\"1\":{\"182\":1}}],[\"情况分析函数\",{\"1\":{\"180\":1}}],[\"导入websocket模块\",{\"1\":{\"369\":1}}],[\"导出声明\",{\"1\":{\"180\":1}}],[\"导致队列一直上锁\",{\"1\":{\"1212\":1}}],[\"导致服务之间是不连通的\",{\"1\":{\"942\":1}}],[\"导致删除时间并不是现实时间\",{\"1\":{\"866\":1}}],[\"导致数据无法正常的投递到正确的消费队列\",{\"1\":{\"845\":1}}],[\"导致内存相关的问题\",{\"1\":{\"693\":1}}],[\"导致其他变量出错\",{\"1\":{\"502\":1}}],[\"导致你的输出损失\",{\"1\":{\"420\":1}}],[\"导致的连击点溢出\",{\"1\":{\"417\":1}}],[\"导致大量的哈希结果落在同一个节点上\",{\"1\":{\"388\":1}}],[\"导致在客户端优先连接的节点为主节点\",{\"1\":{\"284\":1}}],[\"导致\",{\"1\":{\"130\":1,\"931\":1}}],[\"句号\",{\"1\":{\"180\":1}}],[\"逗号\",{\"1\":{\"180\":1}}],[\"模板\",{\"1\":{\"1069\":1}}],[\"模板字符串\",{\"1\":{\"297\":1}}],[\"模拟本地事务未执行完\",{\"1\":{\"1442\":1}}],[\"模拟\",{\"1\":{\"1442\":1}}],[\"模拟抗性\",{\"1\":{\"454\":1}}],[\"模拟指针转动\",{\"1\":{\"379\":1}}],[\"模拟的业务流量速率为1000\",{\"1\":{\"284\":1}}],[\"模型的并发和分布式计算工具包\",{\"1\":{\"372\":1}}],[\"模型\",{\"1\":{\"280\":1,\"372\":1}}],[\"模块使用\",{\"1\":{\"1035\":1}}],[\"模块实现了一套简单访问控制功能\",{\"1\":{\"976\":1}}],[\"模块实现的是一种可靠的组播通信协议\",{\"1\":{\"673\":1}}],[\"模块格式为\",{\"1\":{\"597\":1}}],[\"模块格式不兼容\",{\"1\":{\"594\":1}}],[\"模块定位有两种方法\",{\"1\":{\"597\":1}}],[\"模块定位\",{\"0\":{\"597\":1},\"1\":{\"597\":1}}],[\"模块文件\",{\"1\":{\"595\":1}}],[\"模块内部的变量\",{\"1\":{\"591\":1}}],[\"模块本身是一个作用域\",{\"1\":{\"591\":1}}],[\"模块的使用和实现原理\",{\"1\":{\"976\":1}}],[\"模块的对象\",{\"1\":{\"596\":1}}],[\"模块的实现原理\",{\"0\":{\"364\":1},\"1\":{\"986\":1}}],[\"模块的外部函数\",{\"1\":{\"210\":1}}],[\"模块路径搜索\",{\"0\":{\"363\":1}}],[\"模块会在实验中监测被测集群的表现\",{\"1\":{\"280\":2}}],[\"模块名和行号\",{\"1\":{\"256\":1}}],[\"模块名必须与存放该模块的主文件名相同\",{\"1\":{\"180\":1}}],[\"模块属性的语法是\",{\"1\":{\"202\":1}}],[\"模块声明\",{\"1\":{\"180\":1,\"203\":1}}],[\"模块保存在扩展名为\",{\"1\":{\"180\":1}}],[\"模块是erlang的基本代码单元\",{\"1\":{\"180\":1}}],[\"模块\",{\"0\":{\"180\":1,\"361\":1,\"500\":1,\"590\":1,\"594\":1,\"944\":1},\"1\":{\"500\":1,\"595\":2,\"944\":1,\"976\":1,\"990\":1,\"996\":1}}],[\"模块与函数\",{\"0\":{\"179\":1}}],[\"模式开启的情况下\",{\"1\":{\"1507\":1}}],[\"模式重平衡\",{\"1\":{\"1266\":1,\"1267\":1}}],[\"模式时引入了\",{\"1\":{\"1255\":1}}],[\"模式不同\",{\"1\":{\"1255\":1}}],[\"模式拉取消息\",{\"1\":{\"1246\":1}}],[\"模式指的是\",{\"1\":{\"1245\":1}}],[\"模式消费\",{\"1\":{\"1245\":1}}],[\"模式消费和\",{\"1\":{\"1245\":1}}],[\"模式消费的以下痛点\",{\"1\":{\"1095\":1}}],[\"模式并发消费流程\",{\"1\":{\"1104\":1}}],[\"模式共同使用\",{\"1\":{\"1095\":1}}],[\"模式默认配置下\",{\"1\":{\"1080\":1}}],[\"模式前保证有足够的可用内存\",{\"1\":{\"1079\":1}}],[\"模式实现\",{\"1\":{\"829\":1}}],[\"模式实现的\",{\"1\":{\"135\":1}}],[\"模式如何进行消息的查询\",{\"1\":{\"804\":1}}],[\"模式或\",{\"1\":{\"804\":1}}],[\"模式内部也用了\",{\"1\":{\"803\":1}}],[\"模式原理\",{\"0\":{\"803\":1}}],[\"模式和\",{\"1\":{\"657\":1,\"801\":1}}],[\"模式识别有深刻的理解与研究\",{\"1\":{\"286\":1}}],[\"模式中\",{\"1\":{\"118\":1}}],[\"模式之前先来简单回顾一下\",{\"1\":{\"118\":1}}],[\"模式必不可少的依赖\",{\"1\":{\"118\":1}}],[\"模式是如何做到能够立即消费新的消息\",{\"1\":{\"802\":1}}],[\"模式是对用户空间的\",{\"1\":{\"109\":1}}],[\"模式是什么\",{\"0\":{\"109\":1}}],[\"模式的性能比主备模式差\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"模式的重平衡与\",{\"1\":{\"1255\":1}}],[\"模式的过滤选择功能\",{\"1\":{\"1117\":1}}],[\"模式的\",{\"0\":{\"107\":1,\"1079\":1},\"1\":{\"138\":1,\"1509\":1}}],[\"模式下可允许被共享的队列数\",{\"1\":{\"1267\":1}}],[\"模式下使用\",{\"1\":{\"1095\":1}}],[\"模式下性能提升了\",{\"1\":{\"853\":1}}],[\"模式下性能很差\",{\"1\":{\"850\":1}}],[\"模式下存在性能瓶颈\",{\"1\":{\"853\":1}}],[\"模式下的投递性能\",{\"0\":{\"853\":1}}],[\"模式下\",{\"1\":{\"81\":1,\"853\":1,\"1095\":1}}],[\"模式\",{\"0\":{\"55\":1,\"135\":1,\"296\":1},\"1\":{\"119\":1,\"801\":3,\"802\":1,\"1246\":1,\"1248\":1,\"1252\":2,\"1333\":1,\"1424\":1}}],[\"~32767\",{\"1\":{\"894\":2}}],[\"~~info~~\",{\"1\":{\"722\":1}}],[\"~n\",{\"1\":{\"259\":1}}],[\"~p\",{\"1\":{\"259\":1}}],[\"~p~n\",{\"1\":{\"235\":1,\"248\":1}}],[\"~s~n\",{\"1\":{\"259\":1}}],[\"~\",{\"1\":{\"248\":1,\"642\":1,\"703\":1,\"866\":1,\"870\":1,\"1079\":3}}],[\"~ts~n\",{\"1\":{\"178\":1}}],[\"~w~n\",{\"1\":{\"178\":1}}],[\"竖线\",{\"1\":{\"177\":1}}],[\"符合任意一种都会执行删除逻辑\",{\"1\":{\"866\":1}}],[\"符合以下两种条件之一的拉取请求会被处理并返回\",{\"1\":{\"825\":1}}],[\"符合时间的\",{\"1\":{\"789\":1}}],[\"符合方法签名的构造方法\",{\"1\":{\"76\":1}}],[\"符合方法签名的实例方法\",{\"1\":{\"76\":1}}],[\"符合方法签名的静态方法\",{\"1\":{\"76\":1}}],[\"符烙护腕\",{\"1\":{\"479\":1}}],[\"符号\",{\"1\":{\"175\":1}}],[\"给其他节点发拉票请求\",{\"1\":{\"1480\":1}}],[\"给自己投票\",{\"1\":{\"1480\":1}}],[\"给自己贴绽放然后站在地毯里面刷更快\",{\"1\":{\"433\":1}}],[\"给消费者\",{\"1\":{\"1094\":1,\"1245\":1}}],[\"给操作系统建议\",{\"1\":{\"882\":1}}],[\"给出参数的类型和返回值的类型\",{\"1\":{\"533\":1}}],[\"给出了各个开源调度中间件的对比\",{\"1\":{\"371\":1}}],[\"给治疗的压力也是拉满\",{\"1\":{\"434\":1}}],[\"给他留一个减伤\",{\"1\":{\"428\":1}}],[\"给尽可能多的目标上斜掠\",{\"1\":{\"412\":1}}],[\"给尽可能多的目标上割裂\",{\"1\":{\"412\":1}}],[\"给生命绽放的目标上回春术\",{\"1\":{\"411\":1}}],[\"给程序添加打印语句是最常见的调试形式\",{\"1\":{\"258\":1}}],[\"给两个整数做除法时\",{\"1\":{\"174\":1}}],[\"给invocationhandler\",{\"1\":{\"41\":1}}],[\"浮点数在运算过程中会产生误差\",{\"1\":{\"295\":1}}],[\"浮点数0\",{\"1\":{\"294\":1}}],[\"浮点数的程序会存在和c等语言一样的浮点数取整与精度问题\",{\"1\":{\"174\":1}}],[\"浮点数\",{\"0\":{\"174\":1},\"1\":{\"215\":1}}],[\"变为\",{\"1\":{\"1418\":1,\"1435\":1}}],[\"变化\",{\"1\":{\"1145\":1}}],[\"变化事件\",{\"1\":{\"1143\":1}}],[\"变化考虑两种情况\",{\"1\":{\"999\":1}}],[\"变异幼崽\",{\"1\":{\"475\":1}}],[\"变成一次\",{\"1\":{\"1393\":1}}],[\"变成送的\",{\"1\":{\"473\":1}}],[\"变成能勉强打\",{\"1\":{\"399\":1}}],[\"变熊来吃放水的尖刺伤害\",{\"1\":{\"441\":1}}],[\"变猫省一个\",{\"1\":{\"403\":1}}],[\"变量含义\",{\"1\":{\"769\":1}}],[\"变量保存着每个\",{\"1\":{\"765\":1}}],[\"变量的类型声明需要带有类型参数的值\",{\"1\":{\"578\":1}}],[\"变量的类型可以写成类car\",{\"1\":{\"573\":1}}],[\"变量的作用域是函数维度的\",{\"1\":{\"314\":1}}],[\"变量的作用域是它定义时所处的语汇单元\",{\"1\":{\"173\":1}}],[\"变量类型范围\",{\"1\":{\"503\":1}}],[\"变量类型和属性都是静态的\",{\"1\":{\"495\":1}}],[\"变量就变成了函数内部的局部变量\",{\"1\":{\"364\":1}}],[\"变量提升\",{\"0\":{\"311\":1}}],[\"变量作用域与解构赋值\",{\"0\":{\"310\":1}}],[\"变量名是大小写英文\",{\"1\":{\"294\":1}}],[\"变量\",{\"0\":{\"173\":1},\"1\":{\"294\":1}}],[\"变慢\",{\"1\":{\"127\":1}}],[\"整除\",{\"1\":{\"1257\":1}}],[\"整除结果仍是浮点数\",{\"1\":{\"174\":1}}],[\"整个日志复制流程如上图所示\",{\"1\":{\"1507\":1}}],[\"整个分发逻辑为\",{\"1\":{\"1403\":1}}],[\"整个系统弱依赖二级存储\",{\"1\":{\"1385\":1}}],[\"整个系统由调度中心\",{\"1\":{\"372\":1}}],[\"整个流程分\",{\"1\":{\"1156\":1}}],[\"整个流程如下图所示\",{\"1\":{\"930\":1,\"1446\":1}}],[\"整个逻辑比较简单\",{\"1\":{\"1147\":1}}],[\"整个集群不可用\",{\"1\":{\"942\":1}}],[\"整个选举的时间太长\",{\"1\":{\"942\":1}}],[\"整个开发过程中\",{\"1\":{\"273\":1}}],[\"整体类图\",{\"0\":{\"1115\":1}}],[\"整体流程顺序图\",{\"0\":{\"1063\":1}}],[\"整体流程\",{\"0\":{\"1061\":1,\"1156\":1}}],[\"整体集群恢复为可用\",{\"1\":{\"284\":1}}],[\"整体架构\",{\"0\":{\"280\":1}}],[\"整\",{\"1\":{\"273\":1}}],[\"整数123\",{\"1\":{\"294\":1}}],[\"整数的运算时精确的\",{\"1\":{\"215\":1}}],[\"整数运算是精确的\",{\"1\":{\"172\":1}}],[\"整数运算\",{\"0\":{\"172\":1}}],[\"整行补全\",{\"1\":{\"162\":1}}],[\"甚至作为\",{\"1\":{\"923\":1}}],[\"甚至节点内存会被打爆\",{\"1\":{\"854\":1}}],[\"甚至不得不放弃使用仲裁队列\",{\"1\":{\"701\":1}}],[\"甚至不使用任何镜像\",{\"1\":{\"662\":1}}],[\"甚至可以和\",{\"1\":{\"1095\":1}}],[\"甚至可以相同\",{\"1\":{\"583\":1}}],[\"甚至可能造成节点需要重启\",{\"1\":{\"693\":1}}],[\"甚至规划了减伤\",{\"1\":{\"491\":1}}],[\"甚至对于侦测目标\",{\"1\":{\"487\":1}}],[\"甚至还更高\",{\"1\":{\"401\":1}}],[\"甚至还可以生成一个安全shell\",{\"1\":{\"171\":1}}],[\"甚至智能预测\",{\"1\":{\"277\":1}}],[\"甚至每次调用方法前后都可以用\",{\"1\":{\"4\":1}}],[\"停止消费\",{\"1\":{\"1195\":1}}],[\"停止接收信息\",{\"0\":{\"625\":1}}],[\"停止\",{\"1\":{\"171\":1}}],[\"学习笔记\",{\"0\":{\"168\":1},\"1\":{\"608\":1}}],[\"启用消费队列扩展存储\",{\"1\":{\"1308\":1,\"1315\":1,\"1323\":1}}],[\"启用\",{\"1\":{\"1052\":2}}],[\"启用智能大小写匹配\",{\"1\":{\"167\":1}}],[\"启动计时器\",{\"1\":{\"1478\":1,\"1480\":1}}],[\"启动选主流程\",{\"1\":{\"1477\":1}}],[\"启动配置\",{\"0\":{\"1286\":1}}],[\"启动拉取\",{\"1\":{\"1137\":1,\"1144\":1,\"1224\":1}}],[\"启动拉取消息服务\",{\"1\":{\"1120\":1,\"1123\":1}}],[\"启动默认生产者\",{\"1\":{\"1120\":1,\"1123\":1}}],[\"启动通信模块\",{\"1\":{\"1120\":1,\"1123\":1}}],[\"启动客户端实例\",{\"1\":{\"1122\":1}}],[\"启动客户端实例对象\",{\"1\":{\"1120\":1}}],[\"启动客户端代理\",{\"1\":{\"1048\":1,\"1123\":1}}],[\"启动重平衡线程\",{\"1\":{\"1120\":1,\"1123\":1}}],[\"启动重平衡\",{\"1\":{\"1118\":1}}],[\"启动命令也是在\",{\"1\":{\"1112\":1}}],[\"启动带\",{\"0\":{\"1084\":1}}],[\"启动单节点\",{\"0\":{\"1083\":1}}],[\"启动参数的环境变量\",{\"1\":{\"1080\":1}}],[\"启动流程的示意图\",{\"1\":{\"947\":1}}],[\"启动了一个新的工作线程\",{\"1\":{\"915\":1}}],[\"启动定时任务\",{\"1\":{\"1037\":1,\"1048\":1,\"1120\":1,\"1123\":1}}],[\"启动定时任务执行的\",{\"1\":{\"852\":1}}],[\"启动定时清理过期文件线程\",{\"1\":{\"869\":1}}],[\"启动时启动定时任务\",{\"1\":{\"1191\":1}}],[\"启动时也会启动定时任务\",{\"1\":{\"1183\":1}}],[\"启动时创建\",{\"1\":{\"1039\":1,\"1191\":1}}],[\"启动时会由\",{\"1\":{\"990\":1,\"996\":1}}],[\"启动时会自动创建\",{\"1\":{\"836\":1}}],[\"启动时的一些默认\",{\"1\":{\"970\":1}}],[\"启动时调用\",{\"1\":{\"869\":1}}],[\"启动时运行\",{\"1\":{\"840\":1}}],[\"启动时\",{\"1\":{\"834\":1,\"1191\":1}}],[\"启动一个\",{\"1\":{\"1078\":1}}],[\"启动一个定时任务线程\",{\"1\":{\"945\":1}}],[\"启动一个新的定时任务\",{\"1\":{\"932\":1}}],[\"启动一个新的进程使用`spawn`函数\",{\"1\":{\"230\":1}}],[\"启动一个线程将前一个写满的文件异步刷盘\",{\"1\":{\"793\":1}}],[\"启动后马上向\",{\"1\":{\"1047\":1}}],[\"启动后台线程indicator\",{\"1\":{\"379\":1}}],[\"启动后浏览器打开\",{\"1\":{\"273\":1}}],[\"启动类\",{\"0\":{\"133\":1}}],[\"启动\",{\"0\":{\"126\":1,\"129\":1,\"134\":1,\"947\":1,\"959\":1,\"961\":1,\"1074\":1,\"1076\":1,\"1078\":1,\"1079\":1,\"1122\":1,\"1123\":1},\"1\":{\"122\":1,\"126\":1,\"133\":1,\"171\":1,\"252\":1,\"947\":1,\"960\":2,\"1037\":4,\"1047\":1,\"1069\":1,\"1076\":1,\"1080\":1,\"1510\":1}}],[\"启动这个服务端程序\",{\"1\":{\"113\":1}}],[\"补全\",{\"1\":{\"162\":1}}],[\"补全类型\",{\"1\":{\"162\":1}}],[\"√\",{\"1\":{\"162\":3,\"922\":1,\"1508\":2}}],[\"普通定时消息请求\",{\"1\":{\"1372\":1}}],[\"普通定时消息请求栈\",{\"1\":{\"1372\":1}}],[\"普通重平衡\",{\"1\":{\"1266\":1}}],[\"普通消息存储\",{\"1\":{\"1462\":2}}],[\"普通消息无法满足\",{\"1\":{\"1439\":1}}],[\"普通消息请求\",{\"1\":{\"1373\":1}}],[\"普通消息默认重试\",{\"1\":{\"1241\":1}}],[\"普通消息可以由客户端并发发送\",{\"1\":{\"1028\":1}}],[\"普通消息\",{\"1\":{\"1028\":1,\"1273\":1}}],[\"普通消息性能\",{\"1\":{\"922\":3}}],[\"普通模式即集群中每个\",{\"1\":{\"1012\":1}}],[\"普通模式和物理\",{\"1\":{\"1012\":1}}],[\"普通模式命令\",{\"1\":{\"154\":1}}],[\"普通用户\",{\"1\":{\"978\":1}}],[\"普通的哈希算法无法保证在增加或者减少队列绑定时\",{\"1\":{\"708\":1}}],[\"普通队列使用\",{\"1\":{\"700\":1}}],[\"普通队列\",{\"0\":{\"700\":1}}],[\"普通队列结构\",{\"0\":{\"671\":1}}],[\"普通函数的一种简化写法\",{\"1\":{\"535\":1}}],[\"普通预铺\",{\"1\":{\"431\":1,\"446\":1}}],[\"普通关键字\",{\"1\":{\"162\":1}}],[\"常被用于分散压力和集群消息转移\",{\"1\":{\"634\":1}}],[\"常见问题\",{\"0\":{\"492\":1}}],[\"常见的哈希算法有\",{\"1\":{\"390\":1}}],[\"常见寄存器\",{\"0\":{\"158\":1}}],[\"常量\",{\"0\":{\"315\":1}}],[\"常驻内存\",{\"1\":{\"247\":1}}],[\"常用于判断传入参数的个数\",{\"1\":{\"308\":1}}],[\"常用做法是将元组第一个元素设为一个原子\",{\"1\":{\"176\":1}}],[\"常用\",{\"1\":{\"162\":1}}],[\"结束遍历\",{\"1\":{\"1521\":1}}],[\"结束等待\",{\"1\":{\"1497\":2}}],[\"结束本次回查\",{\"1\":{\"1468\":1}}],[\"结束本次消费请求的消费\",{\"1\":{\"1230\":1}}],[\"结束本次消费任务\",{\"1\":{\"1230\":1}}],[\"结束事务\",{\"1\":{\"1459\":1}}],[\"结束录制\",{\"1\":{\"160\":1}}],[\"结构上也类似\",{\"1\":{\"1386\":1}}],[\"结构的所有成员名\",{\"1\":{\"586\":1}}],[\"结构比较适合的场景是\",{\"1\":{\"582\":1}}],[\"结构\",{\"1\":{\"582\":1}}],[\"结构本身也是一种类型\",{\"1\":{\"582\":1}}],[\"结构color\",{\"1\":{\"582\":1}}],[\"结界\",{\"1\":{\"489\":1}}],[\"结界默认给\",{\"1\":{\"411\":1}}],[\"结界换成了丰饶\",{\"1\":{\"403\":1}}],[\"结果进行仲裁\",{\"1\":{\"1519\":1}}],[\"结果仲裁线程根据节点水位表\",{\"1\":{\"1507\":1}}],[\"结果未知\",{\"1\":{\"1442\":1}}],[\"结果的位数组\",{\"1\":{\"1323\":1}}],[\"结果\",{\"1\":{\"309\":2,\"657\":1,\"1507\":2,\"1519\":1}}],[\"结果会输出到一个文件\",{\"1\":{\"255\":1}}],[\"结果会自动转换成浮点数\",{\"1\":{\"174\":1}}],[\"结尾lower\",{\"1\":{\"145\":1}}],[\"结尾\",{\"1\":{\"29\":1,\"145\":1}}],[\"qps\",{\"1\":{\"913\":2}}],[\"qid=3\",{\"1\":{\"1445\":1}}],[\"qid=1\",{\"1\":{\"1445\":1}}],[\"qid=0\",{\"1\":{\"1445\":1}}],[\"qid\",{\"1\":{\"765\":2,\"845\":1}}],[\"qos\",{\"1\":{\"698\":1}}],[\"q1和q4队列中只有alpha状态的消息\",{\"1\":{\"690\":1}}],[\"q1\",{\"1\":{\"690\":2}}],[\"q4\",{\"1\":{\"690\":2}}],[\"q4五个子队列构成\",{\"1\":{\"690\":1}}],[\"q46awd9tkf4zmfvrmleqqv8vbe\",{\"1\":{\"429\":1}}],[\"q3\",{\"1\":{\"690\":5}}],[\"q2和q3包含beta和gamma状态的消息\",{\"1\":{\"690\":1}}],[\"q2\",{\"1\":{\"690\":5}}],[\"qs1ujncbxc0cmms2wdlm4wst8\",{\"1\":{\"443\":1}}],[\"qsort\",{\"1\":{\"184\":4}}],[\"qbifcuek8lb6wga\",{\"1\":{\"429\":1}}],[\"qq\",{\"1\":{\"398\":1}}],[\"qlc\",{\"1\":{\"253\":7}}],[\"q\",{\"1\":{\"160\":2,\"171\":2,\"253\":7,\"1247\":2}}],[\"quota\",{\"1\":{\"1519\":7}}],[\"quorumindex\",{\"1\":{\"1521\":12}}],[\"quorumackchecker\",{\"0\":{\"1521\":1},\"1\":{\"1508\":2,\"1510\":1,\"1512\":2,\"1514\":2,\"1519\":2,\"1521\":5}}],[\"quorumvoteresponses\",{\"1\":{\"1497\":2}}],[\"quorum\",{\"0\":{\"692\":1},\"1\":{\"628\":1,\"648\":1,\"675\":1,\"692\":3,\"718\":1,\"1516\":1,\"1521\":2}}],[\"queried\",{\"1\":{\"1436\":1}}],[\"querymessage\",{\"1\":{\"1415\":1}}],[\"querymsgtracebyid\",{\"1\":{\"1008\":1}}],[\"querymsg\",{\"1\":{\"794\":1}}],[\"queryasyncfromsegmentfile\",{\"1\":{\"1436\":2}}],[\"queryasyncfromunsealedfile\",{\"1\":{\"1436\":2}}],[\"queryasync\",{\"0\":{\"1436\":1},\"1\":{\"1412\":1,\"1415\":2,\"1436\":3}}],[\"queryassignmentprocessor\",{\"0\":{\"1266\":1,\"1267\":1},\"1\":{\"1255\":1}}],[\"queryload\",{\"1\":{\"1266\":5}}],[\"queryoffsetresult\",{\"1\":{\"794\":2}}],[\"queryoffset\",{\"1\":{\"789\":1,\"794\":2,\"1278\":1}}],[\"query\",{\"1\":{\"92\":1,\"171\":2,\"767\":4,\"1174\":4,\"1430\":4,\"1436\":10}}],[\"questions\",{\"1\":{\"646\":1}}],[\"queuewithnamespace\",{\"1\":{\"1460\":1}}],[\"queuemetadatatable\",{\"1\":{\"1402\":1,\"1420\":1}}],[\"queuemaxspanflowcontroltimes\",{\"1\":{\"1170\":1}}],[\"queuemaxspanflowcontroltimes++\",{\"1\":{\"1170\":1}}],[\"queuekey\",{\"1\":{\"1296\":1}}],[\"queuelockmanager\",{\"1\":{\"1270\":2}}],[\"queueflowcontroltimes\",{\"1\":{\"1170\":2}}],[\"queueflowcontroltimes++\",{\"1\":{\"1170\":2}}],[\"queuedatalist\",{\"1\":{\"972\":3}}],[\"queuedata\",{\"1\":{\"964\":1,\"972\":4}}],[\"queuedata>>\",{\"1\":{\"964\":1}}],[\"queuedatas\",{\"1\":{\"950\":1,\"968\":3}}],[\"queuedeclare\",{\"1\":{\"712\":1}}],[\"queue<putresultprocess>\",{\"1\":{\"860\":1}}],[\"queueoffset=9\",{\"1\":{\"1445\":1}}],[\"queueoffset=8\",{\"1\":{\"1445\":1}}],[\"queueoffset=7\",{\"1\":{\"1445\":1}}],[\"queueoffset=6\",{\"1\":{\"1445\":1}}],[\"queueoffset=5\",{\"1\":{\"1445\":1}}],[\"queueoffset=4\",{\"1\":{\"1445\":1}}],[\"queueoffset=3\",{\"1\":{\"1445\":1}}],[\"queueoffset=2\",{\"1\":{\"1445\":1}}],[\"queueoffset=1\",{\"1\":{\"1445\":1}}],[\"queueoffset=0\",{\"1\":{\"1445\":4}}],[\"queueoffsets\",{\"1\":{\"1296\":3,\"1297\":3}}],[\"queueoffsetassigner\",{\"1\":{\"1296\":5}}],[\"queueoffset\",{\"1\":{\"737\":3,\"738\":1,\"1296\":2,\"1297\":5,\"1430\":10,\"1431\":10,\"1432\":17}}],[\"queueidint\",{\"1\":{\"1056\":5,\"1198\":3,\"1462\":2}}],[\"queueid=3\",{\"1\":{\"1445\":3}}],[\"queueid=2\",{\"1\":{\"1445\":2}}],[\"queueid=1\",{\"1\":{\"1445\":4}}],[\"queueid=0\",{\"1\":{\"1445\":4}}],[\"queueid=\",{\"1\":{\"823\":1,\"845\":1,\"860\":2,\"1201\":1,\"1332\":1,\"1427\":4,\"1431\":2,\"1432\":3}}],[\"queueid\",{\"1\":{\"737\":2,\"742\":1,\"751\":1,\"757\":1,\"764\":1,\"765\":2,\"767\":4,\"815\":2,\"819\":2,\"822\":3,\"823\":5,\"825\":5,\"828\":2,\"834\":4,\"836\":3,\"839\":3,\"843\":8,\"857\":1,\"906\":2,\"1173\":5,\"1174\":6,\"1201\":8,\"1269\":8,\"1270\":21,\"1271\":2,\"1278\":6,\"1279\":4,\"1280\":6,\"1288\":1,\"1297\":12,\"1360\":1,\"1370\":3,\"1374\":1,\"1407\":1,\"1420\":1,\"1427\":15,\"1430\":3,\"1434\":8,\"1436\":1,\"1463\":2,\"1469\":1}}],[\"queue=\",{\"1\":{\"722\":1,\"1431\":1,\"1468\":3}}],[\"queuebind\",{\"1\":{\"712\":1}}],[\"queuename\",{\"1\":{\"712\":6,\"1297\":7}}],[\"queue3\",{\"1\":{\"712\":1}}],[\"queue2\",{\"1\":{\"712\":1}}],[\"queue1\",{\"1\":{\"712\":1}}],[\"queue结构来看\",{\"1\":{\"690\":1}}],[\"queue模块实现\",{\"1\":{\"690\":1}}],[\"queue的匹配模式\",{\"1\":{\"652\":1}}],[\"queuesize\",{\"1\":{\"1021\":1}}],[\"queues\",{\"0\":{\"692\":1},\"1\":{\"621\":2,\"628\":1,\"648\":1,\"653\":1,\"675\":1,\"679\":1,\"692\":4,\"718\":1,\"1296\":4,\"1297\":5}}],[\"queue\",{\"0\":{\"634\":1,\"773\":1,\"905\":1,\"1282\":1},\"1\":{\"420\":1,\"614\":3,\"619\":1,\"621\":2,\"622\":6,\"630\":2,\"632\":1,\"634\":1,\"636\":1,\"637\":4,\"647\":1,\"648\":1,\"653\":2,\"655\":2,\"660\":4,\"665\":1,\"668\":1,\"671\":1,\"672\":7,\"679\":1,\"687\":2,\"690\":1,\"712\":4,\"746\":1,\"747\":1,\"749\":1,\"751\":1,\"755\":4,\"756\":1,\"765\":3,\"767\":1,\"771\":6,\"819\":1,\"834\":3,\"836\":6,\"841\":2,\"843\":1,\"845\":1,\"860\":1,\"867\":1,\"877\":1,\"878\":1,\"886\":2,\"905\":1,\"910\":7,\"925\":5,\"949\":1,\"972\":1,\"1021\":1,\"1052\":1,\"1091\":1,\"1094\":2,\"1095\":1,\"1126\":3,\"1130\":1,\"1170\":1,\"1173\":3,\"1174\":6,\"1175\":2,\"1195\":1,\"1226\":1,\"1230\":9,\"1247\":1,\"1253\":1,\"1257\":1,\"1266\":1,\"1269\":5,\"1270\":4,\"1273\":1,\"1278\":1,\"1282\":1,\"1284\":1,\"1288\":1,\"1290\":2,\"1296\":4,\"1297\":9,\"1298\":1,\"1300\":2,\"1328\":1,\"1333\":1,\"1383\":4,\"1395\":5,\"1402\":2,\"1403\":2,\"1419\":1,\"1420\":2,\"1421\":1,\"1427\":1,\"1430\":5,\"1431\":1,\"1432\":5,\"1463\":1,\"1468\":2,\"1469\":1,\"1538\":1}}],[\"quartz可以认为是第一代调度框架\",{\"1\":{\"371\":1}}],[\"quantity=n1\",{\"1\":{\"253\":1}}],[\"quantity=quantity\",{\"1\":{\"253\":1}}],[\"quantity\",{\"1\":{\"253\":11,\"626\":3}}],[\"quanlifier\",{\"1\":{\"82\":2}}],[\"qualifier2\",{\"1\":{\"184\":1}}],[\"qualifier1\",{\"1\":{\"184\":1}}],[\"quit\",{\"1\":{\"171\":1}}],[\"录制和回放宏\",{\"0\":{\"160\":1}}],[\"zookeeper\",{\"0\":{\"942\":1},\"1\":{\"941\":1,\"942\":11}}],[\"z0\",{\"1\":{\"904\":1}}],[\"zab\",{\"1\":{\"942\":1}}],[\"za\",{\"1\":{\"904\":1}}],[\"zero\",{\"1\":{\"886\":1,\"892\":1,\"894\":1,\"1524\":1,\"1527\":1}}],[\"zh\",{\"1\":{\"601\":1}}],[\"z2vegvgua3a4bdrxik5h5gp11oyg500n5c0dqx3lqvqt3ikrkjt5jako2skp\",{\"1\":{\"469\":1}}],[\"zmxoyqalsttr7o76tfxdkxvsxxrs\",{\"1\":{\"443\":1}}],[\"zmidleen3cyulo1erumvsdczlm942mdkx4wnhcmoxxi3smuqhim0rlkmsg6ig\",{\"1\":{\"436\":1}}],[\"zmt\",{\"1\":{\"370\":1}}],[\"zf\",{\"1\":{\"433\":1}}],[\"zip\",{\"1\":{\"316\":2,\"1042\":1,\"1053\":1}}],[\"zipcode\",{\"1\":{\"294\":2,\"316\":1}}],[\"z和i为undefined\",{\"1\":{\"311\":1}}],[\"z>\",{\"1\":{\"171\":1}}],[\"z\",{\"1\":{\"157\":1,\"171\":3,\"303\":1,\"311\":1,\"316\":3,\"423\":1,\"555\":2,\"562\":1}}],[\"zz\",{\"1\":{\"145\":1}}],[\"选票未超过半数\",{\"1\":{\"1480\":1}}],[\"选票超过半数\",{\"1\":{\"1480\":1}}],[\"选出\",{\"1\":{\"1480\":1}}],[\"选主流程中还有两个重要的\",{\"1\":{\"1477\":1}}],[\"选主的过程中有一些重要的请求类型\",{\"1\":{\"1477\":1}}],[\"选主器添加角色变更监听器\",{\"1\":{\"1424\":1}}],[\"选举负责集群中选出一个主节点\",{\"1\":{\"1506\":1}}],[\"选举轮次启动时\",{\"1\":{\"1480\":1}}],[\"选举超时\",{\"1\":{\"1477\":1}}],[\"选举流程中\",{\"1\":{\"1477\":1}}],[\"选举的设计和流程\",{\"1\":{\"1475\":1}}],[\"选举和日志复制\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"选举\",{\"0\":{\"1474\":1},\"1\":{\"1538\":1}}],[\"选中要复制的地方\",{\"1\":{\"156\":1}}],[\"选择先实现转写模式\",{\"1\":{\"1385\":1}}],[\"选择最新的\",{\"1\":{\"1073\":1}}],[\"选择最大的怪割裂\",{\"1\":{\"412\":1}}],[\"选择发送的队列\",{\"1\":{\"1052\":1}}],[\"选择队列\",{\"1\":{\"1052\":1}}],[\"选择队列的逻辑由\",{\"1\":{\"1041\":1}}],[\"选择下一个队列\",{\"1\":{\"1041\":1,\"1052\":1}}],[\"选择消息队列\",{\"0\":{\"1041\":1,\"1052\":1},\"1\":{\"1038\":1,\"1050\":2}}],[\"选择自研路由中心呢\",{\"1\":{\"942\":1}}],[\"选择客户机声明队列连接到的节点\",{\"1\":{\"660\":1}}],[\"选择承载最小绑定主机数量的节点\",{\"1\":{\"660\":1}}],[\"选择\",{\"1\":{\"643\":2}}],[\"选择第二大的怪割裂\",{\"1\":{\"412\":1}}],[\"选择正确的生命绽放目标将至关重要\",{\"1\":{\"405\":1}}],[\"选择性接收\",{\"0\":{\"233\":1}}],[\"选择行\",{\"1\":{\"144\":1}}],[\"选择器\",{\"1\":{\"118\":1,\"121\":1}}],[\"剪切\",{\"1\":{\"156\":1}}],[\"命令以后\",{\"1\":{\"1321\":1}}],[\"命令设置\",{\"1\":{\"1128\":1}}],[\"命令有一个\",{\"1\":{\"602\":1}}],[\"命令来输入\",{\"1\":{\"591\":1}}],[\"命令声明\",{\"1\":{\"591\":1}}],[\"命令都可以改写为\",{\"1\":{\"564\":1}}],[\"命令不方便设置复杂的入参\",{\"1\":{\"273\":1}}],[\"命令获取帮助\",{\"1\":{\"171\":1}}],[\"命令让shell忘记现有的任何绑定\",{\"1\":{\"171\":1}}],[\"命令\",{\"0\":{\"517\":1},\"1\":{\"155\":1,\"162\":1,\"564\":1}}],[\"命令行界面直接编译和运行\",{\"1\":{\"224\":1}}],[\"命令行\",{\"0\":{\"653\":1},\"1\":{\"21\":1}}],[\"文档\",{\"0\":{\"264\":1},\"1\":{\"798\":1}}],[\"文本对象操作方式\",{\"1\":{\"155\":1}}],[\"文件大小\",{\"1\":{\"1435\":1}}],[\"文件完全没有初始化\",{\"1\":{\"1427\":1}}],[\"文件发生新建\",{\"1\":{\"1419\":1}}],[\"文件内容格式与本地存储的索引文件相同\",{\"1\":{\"1411\":1}}],[\"文件格式进行了优化\",{\"1\":{\"1411\":1}}],[\"文件对应的队列起始偏移量\",{\"1\":{\"1403\":1}}],[\"文件元数据\",{\"1\":{\"1402\":3}}],[\"文件需要增加以下的配置项\",{\"1\":{\"1286\":1}}],[\"文件做如下修改\",{\"1\":{\"1080\":1}}],[\"文件未找到\",{\"1\":{\"1079\":1}}],[\"文件映射端口改了之外\",{\"1\":{\"1075\":1}}],[\"文件是用来以不同部署方式启动\",{\"1\":{\"1074\":1}}],[\"文件夹\",{\"1\":{\"1074\":2}}],[\"文件创建后\",{\"1\":{\"882\":1}}],[\"文件预热\",{\"0\":{\"882\":1}}],[\"文件的容器\",{\"1\":{\"1412\":1}}],[\"文件的大小默认是\",{\"1\":{\"881\":1}}],[\"文件的io几乎等同于内存的io\",{\"1\":{\"879\":1}}],[\"文件的过期删除\",{\"1\":{\"871\":1}}],[\"文件异步生成\",{\"1\":{\"877\":1}}],[\"文件过期时间\",{\"1\":{\"870\":2}}],[\"文件将被强制删除\",{\"1\":{\"870\":1}}],[\"文件可以拒绝删除\",{\"1\":{\"870\":1}}],[\"文件保证使用的镜像名称正确\",{\"1\":{\"1075\":1}}],[\"文件保留时间\",{\"1\":{\"870\":2}}],[\"文件保存在\",{\"1\":{\"749\":1}}],[\"文件删除线程会检查所有的\",{\"1\":{\"868\":1}}],[\"文件删除线程就会检查所有\",{\"1\":{\"867\":1}}],[\"文件删除的条件有以下几种\",{\"1\":{\"866\":1}}],[\"文件中\",{\"1\":{\"1332\":1,\"1427\":1}}],[\"文件中的\",{\"1\":{\"789\":1,\"866\":1}}],[\"文件中的最小单元是索引项\",{\"1\":{\"749\":1}}],[\"文件中取出一条消息\",{\"1\":{\"767\":1,\"1174\":1}}],[\"文件结构\",{\"0\":{\"749\":1,\"755\":1}}],[\"文件编程\",{\"0\":{\"244\":1}}],[\"文件名补全\",{\"1\":{\"162\":1}}],[\"文件名\",{\"1\":{\"152\":1}}],[\"文件通道\",{\"1\":{\"118\":1,\"880\":1}}],[\"文件\",{\"1\":{\"43\":1,\"137\":1,\"498\":1,\"746\":1,\"765\":1,\"848\":1,\"871\":1,\"872\":1,\"990\":1,\"996\":2,\"1077\":1,\"1078\":1,\"1321\":1,\"1362\":2,\"1383\":1,\"1402\":1,\"1403\":1,\"1527\":1}}],[\"新\",{\"1\":{\"1510\":2}}],[\"新索引项中不需要\",{\"1\":{\"1435\":1}}],[\"新文件用来上传\",{\"1\":{\"1417\":1}}],[\"新引入的\",{\"1\":{\"1245\":1}}],[\"新引入的一种原始类型的值\",{\"1\":{\"531\":1}}],[\"新消费者注册\",{\"1\":{\"1331\":1}}],[\"新消费者开始消费\",{\"1\":{\"1208\":1}}],[\"新消息来了创建异步任务并唤醒线程\",{\"1\":{\"915\":1}}],[\"新创建的重试消息是定时消息\",{\"1\":{\"1188\":1}}],[\"新创建的队列按照规则成为镜像队列\",{\"1\":{\"649\":1}}],[\"新增\",{\"1\":{\"1275\":1}}],[\"新增了\",{\"1\":{\"900\":1,\"1299\":1}}],[\"新增1个分区的平均时间约20ms\",{\"1\":{\"285\":1}}],[\"新队列镜像将不接收现有消息\",{\"1\":{\"658\":1}}],[\"新镜像同步策略\",{\"0\":{\"658\":1}}],[\"新绿的联动\",{\"1\":{\"415\":1}}],[\"新绿\",{\"1\":{\"405\":1}}],[\"新建消费者时构造\",{\"1\":{\"1111\":1}}],[\"新建消费者\",{\"0\":{\"1111\":1}}],[\"新建一个日志追加的\",{\"1\":{\"1509\":1}}],[\"新建一个\",{\"1\":{\"987\":1,\"1144\":1,\"1224\":1}}],[\"新建\",{\"1\":{\"978\":1,\"984\":1,\"985\":1,\"1109\":1}}],[\"新建实例时\",{\"1\":{\"578\":1}}],[\"新建xmlhttprequest对象\",{\"1\":{\"348\":1}}],[\"新建标签页\",{\"1\":{\"154\":1}}],[\"新编译的版本则成为当前版\",{\"1\":{\"207\":1}}],[\"新的格式直接将同一\",{\"1\":{\"1418\":1}}],[\"新的索引文件将每个\",{\"1\":{\"1393\":1}}],[\"新的任务需要等待\",{\"1\":{\"1348\":1}}],[\"新的改动将延迟消息的到期投递模式改为可配置\",{\"1\":{\"850\":1}}],[\"新的消息到达\",{\"1\":{\"828\":1}}],[\"新的队列镜像将随着时间的推移成为主服务器的精确副本\",{\"1\":{\"658\":1}}],[\"新的信用值\",{\"1\":{\"622\":1}}],[\"新的事件到达则调用附加在其\",{\"1\":{\"132\":1}}],[\"新的\",{\"1\":{\"132\":1}}],[\"列举了哪些函数要导入到模块中\",{\"1\":{\"203\":1}}],[\"列举当前缓冲区\",{\"1\":{\"152\":1}}],[\"列表不为空\",{\"1\":{\"1432\":1}}],[\"列表为空\",{\"1\":{\"1432\":1}}],[\"列表的封装\",{\"1\":{\"1410\":1}}],[\"列表保存着具体消息的轨迹信息\",{\"1\":{\"1017\":1}}],[\"列表里面\",{\"1\":{\"988\":1,\"994\":1}}],[\"列表里的每个元素代表了一个unicode字符\",{\"1\":{\"178\":1}}],[\"列表中的索引文件\",{\"1\":{\"789\":1}}],[\"列表操作\",{\"0\":{\"212\":1}}],[\"列表推导里的生成器部分起着过滤器的作用\",{\"1\":{\"184\":1}}],[\"列表推导的常规形式\",{\"1\":{\"184\":1}}],[\"列表推导\",{\"0\":{\"184\":1},\"1\":{\"184\":1}}],[\"列表求和函数\",{\"1\":{\"183\":1}}],[\"列表处理\",{\"0\":{\"183\":1}}],[\"列表尾作为y\",{\"1\":{\"177\":1}}],[\"列表\",{\"0\":{\"177\":1},\"1\":{\"944\":1,\"947\":1,\"949\":1,\"952\":1,\"961\":1,\"971\":1,\"988\":1,\"994\":1,\"1020\":1,\"1279\":1}}],[\"列\",{\"1\":{\"153\":1}}],[\"行为\",{\"1\":{\"1478\":1,\"1479\":1,\"1480\":1}}],[\"行\",{\"1\":{\"153\":1}}],[\"行间搜索移动\",{\"1\":{\"145\":1}}],[\"|a\",{\"1\":{\"904\":1}}],[\"|=\",{\"1\":{\"396\":1,\"1053\":2}}],[\"||\",{\"0\":{\"184\":1},\"1\":{\"184\":5,\"194\":1,\"195\":1,\"219\":1,\"253\":4,\"330\":1,\"341\":1,\"342\":2,\"503\":1,\"627\":1,\"742\":4,\"797\":6,\"843\":1,\"870\":3,\"971\":2,\"996\":1,\"998\":2,\"1000\":1,\"1020\":5,\"1051\":2,\"1053\":1,\"1173\":2,\"1175\":2,\"1198\":1,\"1200\":1,\"1229\":1,\"1230\":4,\"1267\":1,\"1270\":5,\"1277\":2,\"1278\":2,\"1280\":2,\"1288\":1,\"1297\":3,\"1307\":2,\"1331\":3,\"1332\":1,\"1333\":9,\"1368\":1,\"1371\":2,\"1372\":1,\"1373\":1,\"1374\":1,\"1427\":2,\"1431\":1,\"1434\":2,\"1435\":2,\"1436\":3,\"1462\":1,\"1468\":8,\"1472\":1,\"1497\":3,\"1499\":1,\"1519\":6,\"1521\":1}}],[\"|things\",{\"1\":{\"177\":1}}],[\"|`\",{\"1\":{\"165\":1}}],[\"|\",{\"1\":{\"153\":2,\"177\":1,\"180\":1,\"182\":1,\"183\":3,\"184\":1,\"234\":1,\"515\":12,\"568\":1,\"586\":1,\"591\":1,\"606\":2,\"625\":1,\"626\":1,\"643\":5,\"1198\":2,\"1371\":2,\"1383\":56,\"1430\":12,\"1443\":1,\"1537\":1}}],[\"使得用户普通的消息数据与消息轨迹数据的物理io完全隔离\",{\"1\":{\"1004\":1}}],[\"使得对文件的操作不用再需要拷贝到pagecache\",{\"1\":{\"728\":1}}],[\"使程序对文件的顺序读写速度几乎接近于内存\",{\"1\":{\"879\":1}}],[\"使随机读写文件和读写内存拥有相似的速度\",{\"1\":{\"728\":1}}],[\"使你的扬升效果翻倍\",{\"1\":{\"484\":1}}],[\"使其恢复\",{\"1\":{\"405\":1}}],[\"使编写高性能web服务轻而易举\",{\"1\":{\"360\":1}}],[\"使编译自动化\",{\"0\":{\"225\":1}}],[\"使a和b相加\",{\"1\":{\"212\":1}}],[\"使预处理器能找到正确的文件\",{\"1\":{\"211\":1}}],[\"使所有窗口等宽\",{\"1\":{\"153\":1}}],[\"使用发起拉票请求的\",{\"1\":{\"1503\":1}}],[\"使用对端\",{\"1\":{\"1491\":1,\"1497\":1}}],[\"使用新的\",{\"1\":{\"1459\":1}}],[\"使用磁盘文件作为二级存储\",{\"1\":{\"1382\":1}}],[\"使用磁盘存储\",{\"1\":{\"247\":1}}],[\"使用内存作为二级存储\",{\"1\":{\"1382\":1}}],[\"使用这种方式存储定时消息\",{\"1\":{\"1364\":1}}],[\"使用命令行方式切换\",{\"0\":{\"1247\":1}}],[\"使用异步发送可以避免上游调用超时\",{\"1\":{\"1233\":1}}],[\"使用异步而非同步\",{\"1\":{\"917\":1}}],[\"使用服务器端校正的偏移量进行下一次消息的拉取\",{\"1\":{\"1175\":1}}],[\"使用批量发送可以提升发送效率\",{\"1\":{\"1044\":1}}],[\"使用示例\",{\"0\":{\"1004\":1,\"1440\":1}}],[\"使用日志等\",{\"1\":{\"1003\":1}}],[\"使用spi机制加载配置的accessvalidator实现类\",{\"1\":{\"996\":1}}],[\"使用第三方\",{\"1\":{\"928\":1}}],[\"使用索引文件解决定时消息顺序问题\",{\"0\":{\"927\":1}}],[\"使用索引项中的\",{\"1\":{\"767\":2}}],[\"使用延迟消息\",{\"1\":{\"920\":1}}],[\"使用定时消息\",{\"1\":{\"920\":1}}],[\"使用容器时在初始化时指定长度\",{\"1\":{\"917\":1}}],[\"使用更高效的容器\",{\"1\":{\"917\":1}}],[\"使用字符来匹配\",{\"1\":{\"904\":1}}],[\"使用缓存\",{\"1\":{\"900\":1}}],[\"使用火焰图可以清晰地看出当前耗时比较多的方法\",{\"1\":{\"887\":1}}],[\"使用写锁创建文件\",{\"1\":{\"793\":1}}],[\"使用函数式接口\",{\"1\":{\"738\":1}}],[\"使用消息\",{\"1\":{\"1406\":1}}],[\"使用消息属性作为路由键\",{\"0\":{\"715\":1}}],[\"使用消息的\",{\"1\":{\"714\":1}}],[\"使用和原理\",{\"0\":{\"705\":1},\"1\":{\"718\":1}}],[\"使用和原理详解\",{\"0\":{\"647\":1},\"1\":{\"718\":1}}],[\"使用仲裁队列可以在\",{\"1\":{\"692\":1}}],[\"使用信用证机制限制消息生产的速度\",{\"1\":{\"664\":1}}],[\"使用策略\",{\"1\":{\"652\":1}}],[\"使用方法\",{\"0\":{\"982\":1,\"1285\":1,\"1304\":1}}],[\"使用方法和注意事项\",{\"0\":{\"650\":1}}],[\"使用方式\",{\"1\":{\"487\":1}}],[\"使用前提\",{\"0\":{\"635\":1}}],[\"使用时会接收到value和context两个参数\",{\"1\":{\"606\":1}}],[\"使用时需要指定编码\",{\"1\":{\"57\":1}}],[\"使用export\",{\"1\":{\"596\":1}}],[\"使用import\",{\"1\":{\"595\":1}}],[\"使用了新的事务消息生产者\",{\"1\":{\"1472\":1}}],[\"使用了老的生产者\",{\"1\":{\"1472\":1}}],[\"使用了双\",{\"1\":{\"724\":1}}],[\"使用了某个模板的对象\",{\"1\":{\"558\":1}}],[\"使用了内部缓冲区来提高数据写入的效率\",{\"1\":{\"54\":1}}],[\"使用null判断运算符\",{\"1\":{\"551\":1}}],[\"使用new命令调用\",{\"1\":{\"548\":1}}],[\"使用符号|表示\",{\"1\":{\"515\":1}}],[\"使用大写类型会报错\",{\"1\":{\"509\":1}}],[\"使用有清晰预兆效果的愈合\",{\"1\":{\"411\":1}}],[\"使用的\",{\"1\":{\"1405\":1}}],[\"使用的内存映射文件\",{\"1\":{\"727\":1}}],[\"使用的方法是在创建一致性哈希交换器时用\",{\"1\":{\"715\":1}}],[\"使用的方法是\",{\"1\":{\"714\":1}}],[\"使用的法术数量降低25\",{\"1\":{\"405\":1}}],[\"使用的资源更少\",{\"1\":{\"117\":1}}],[\"使用场景最广泛的消息类型\",{\"1\":{\"1028\":1}}],[\"使用场景\",{\"0\":{\"384\":1,\"631\":1,\"707\":1},\"1\":{\"504\":1}}],[\"使用率和磁盘使用率进行健康度计算\",{\"1\":{\"372\":1}}],[\"使用简单\",{\"1\":{\"371\":1}}],[\"使用结构化和关联日志\",{\"1\":{\"276\":1}}],[\"使用姿势\",{\"0\":{\"274\":1}}],[\"使用arthas显式执行代码\",{\"0\":{\"268\":1}}],[\"使用注册进程的方法\",{\"1\":{\"234\":1}}],[\"使用y复制文本同时会被拷贝到复制寄存器0\",{\"1\":{\"158\":1}}],[\"使用线程池\",{\"0\":{\"128\":1}}],[\"使用开发者工具\",{\"0\":{\"95\":1}}],[\"使用高级查询\",{\"0\":{\"92\":1}}],[\"使用声明式事务\",{\"0\":{\"87\":1}}],[\"使用关键字aspect来实现织入\",{\"1\":{\"85\":1}}],[\"使用条件装配\",{\"0\":{\"84\":1}}],[\"使用户能够编写自己的\",{\"1\":{\"78\":1}}],[\"使用下面的安装命令指定版本\",{\"1\":{\"65\":1}}],[\"使用maven\",{\"1\":{\"64\":1,\"65\":1}}],[\"使用自定义插件的时候\",{\"1\":{\"64\":1}}],[\"使用插件\",{\"0\":{\"64\":1}}],[\"使用try\",{\"1\":{\"54\":1,\"58\":1}}],[\"使用<\",{\"1\":{\"49\":1}}],[\"使用两个字节表示一个汉字\",{\"1\":{\"27\":1}}],[\"使用一个消费线程池进行消费\",{\"1\":{\"1203\":1}}],[\"使用一个无限循环来处理客户端的连接\",{\"1\":{\"69\":1}}],[\"使用一个进程来运行测试\",{\"1\":{\"9\":1}}],[\"使用一些工具可以对该结果进行可视化\",{\"1\":{\"3\":1}}],[\"使用锁还是\",{\"1\":{\"2\":1}}],[\"使用\",{\"0\":{\"7\":1,\"83\":1,\"85\":1,\"369\":1,\"636\":1,\"709\":1,\"712\":1,\"714\":1,\"910\":1,\"1008\":1,\"1009\":1,\"1068\":1,\"1076\":1,\"1381\":1},\"1\":{\"2\":3,\"3\":1,\"6\":1,\"9\":1,\"53\":1,\"62\":1,\"119\":1,\"121\":1,\"122\":1,\"132\":1,\"165\":1,\"190\":2,\"230\":1,\"273\":1,\"412\":1,\"592\":1,\"633\":1,\"657\":1,\"840\":1,\"850\":1,\"880\":1,\"894\":1,\"960\":2,\"1080\":1,\"1398\":1,\"1459\":1,\"1520\":2,\"1538\":1}}],[\"knownmaxtermingroup\",{\"1\":{\"1497\":7}}],[\"know\",{\"1\":{\"1472\":1}}],[\"kitchen\",{\"1\":{\"1290\":1}}],[\"kind\",{\"1\":{\"605\":1,\"606\":2}}],[\"kong\",{\"1\":{\"1105\":1}}],[\"ko2tbnrwnbezborm1u7ogm\",{\"1\":{\"469\":1}}],[\"kubernetes\",{\"1\":{\"1074\":2}}],[\"karray\",{\"1\":{\"823\":4}}],[\"kafka和rocketmq底层存储之那些你不知道的事\",{\"1\":{\"1527\":1}}],[\"kafka如何实现高性能io\",{\"1\":{\"884\":1}}],[\"kafka\",{\"0\":{\"1524\":1},\"1\":{\"285\":1,\"286\":1,\"681\":1,\"874\":3,\"884\":1,\"922\":1,\"941\":1,\"942\":1,\"1136\":1,\"1524\":1,\"1537\":1}}],[\"kb\",{\"1\":{\"643\":2}}],[\"ksl\",{\"1\":{\"480\":1}}],[\"kxg2nbnuxvvpm\",{\"1\":{\"469\":1}}],[\"k7wlojbb2jwbuk4qqb9flfg1\",{\"1\":{\"469\":1}}],[\"kc0i4jmxis0dkf6lspmfl2nkdx2hzia8rjv3fkgbkpbqib84ebpctmzzjzxfclququekcxqhidbf7ck2mcsiodyqou8lljsqishrhqmssikdmi6ij4bqs3pswedcyt2iyvy\",{\"1\":{\"436\":1}}],[\"kcebwhwmdnxkf2lj7p\",{\"1\":{\"423\":1}}],[\"kvconfig\",{\"1\":{\"944\":1,\"947\":1,\"950\":1,\"957\":1,\"960\":1,\"961\":1,\"968\":1,\"973\":2}}],[\"kvconfigmanager\",{\"1\":{\"944\":2,\"961\":2}}],[\"kv\",{\"1\":{\"384\":1,\"944\":2,\"947\":1,\"961\":3,\"1364\":2}}],[\"k=fybx5c\",{\"1\":{\"381\":1}}],[\"kernel\",{\"1\":{\"211\":1}}],[\"keyidx\",{\"1\":{\"1273\":1,\"1427\":1,\"1459\":1,\"1463\":1,\"1468\":1,\"1469\":1,\"1471\":1,\"1472\":1}}],[\"keybuilder\",{\"1\":{\"1269\":3,\"1270\":1,\"1273\":1,\"1279\":1,\"1280\":2}}],[\"key=c0a80109803418b4aac25d18020f0007\",{\"1\":{\"1445\":1}}],[\"key=c0a80109803418b4aac25d1801be0001\",{\"1\":{\"1445\":1}}],[\"key=c0a80109803418b4aac25d1801e70004\",{\"1\":{\"1445\":1}}],[\"key=\",{\"1\":{\"1201\":1}}],[\"key为acl配置文件的绝对路径\",{\"1\":{\"999\":1}}],[\"keychanged\",{\"1\":{\"961\":4}}],[\"key已经存在\",{\"1\":{\"797\":1}}],[\"keyhashread\",{\"1\":{\"797\":2}}],[\"keyhashcode\",{\"1\":{\"797\":1}}],[\"keyhash\",{\"1\":{\"797\":7}}],[\"key1\",{\"1\":{\"740\":1}}],[\"keyof\",{\"0\":{\"586\":1},\"1\":{\"586\":2}}],[\"key是用于标识这个连接\",{\"1\":{\"368\":1}}],[\"keys=key7\",{\"1\":{\"1445\":1}}],[\"keys=key1\",{\"1\":{\"1445\":1}}],[\"keys=key4\",{\"1\":{\"1445\":1}}],[\"keysize\",{\"1\":{\"1434\":1}}],[\"keystoneloot\",{\"1\":{\"480\":1}}],[\"keyset\",{\"1\":{\"396\":1,\"794\":3,\"823\":1,\"1434\":12,\"1499\":1,\"1502\":1,\"1519\":1,\"1521\":2}}],[\"keys\",{\"1\":{\"217\":1,\"794\":4,\"1017\":1,\"1427\":1}}],[\"key\",{\"0\":{\"1436\":1},\"1\":{\"192\":1,\"217\":6,\"275\":1,\"300\":1,\"302\":1,\"338\":2,\"368\":1,\"384\":5,\"385\":5,\"386\":1,\"387\":2,\"391\":3,\"395\":2,\"396\":9,\"624\":5,\"626\":2,\"668\":1,\"711\":3,\"720\":1,\"736\":2,\"778\":2,\"780\":6,\"782\":1,\"786\":5,\"787\":3,\"789\":3,\"790\":3,\"794\":12,\"797\":13,\"815\":1,\"822\":3,\"823\":2,\"825\":2,\"868\":1,\"890\":1,\"897\":5,\"908\":1,\"927\":6,\"960\":1,\"961\":1,\"965\":1,\"983\":2,\"984\":4,\"985\":4,\"995\":2,\"997\":1,\"1006\":2,\"1021\":12,\"1039\":1,\"1065\":1,\"1155\":1,\"1201\":7,\"1263\":1,\"1275\":1,\"1278\":2,\"1296\":3,\"1346\":1,\"1359\":1,\"1364\":4,\"1386\":1,\"1393\":4,\"1402\":1,\"1407\":1,\"1412\":1,\"1414\":1,\"1415\":1,\"1418\":1,\"1434\":8,\"1436\":26,\"1443\":1,\"1459\":2,\"1468\":1,\"1519\":1}}],[\"keep\",{\"1\":{\"171\":2}}],[\"k\",{\"0\":{\"913\":1},\"1\":{\"153\":2,\"162\":1,\"215\":1,\"742\":3,\"886\":1,\"890\":1,\"894\":3,\"928\":1,\"1322\":2,\"1323\":3}}],[\"窗口间循环切换\",{\"1\":{\"153\":1}}],[\"窗口切换\",{\"1\":{\"153\":1}}],[\"垂直扩容指的是提高\",{\"1\":{\"648\":1}}],[\"垂直分割\",{\"1\":{\"153\":1}}],[\"垂直移动\",{\"1\":{\"145\":1}}],[\"加一\",{\"1\":{\"1510\":1}}],[\"加快处理性能\",{\"1\":{\"1319\":1}}],[\"加快生态建设\",{\"1\":{\"286\":1}}],[\"加锁\",{\"0\":{\"1223\":1}}],[\"加锁的过程是向\",{\"1\":{\"1214\":1}}],[\"加\",{\"1\":{\"1218\":1}}],[\"加解锁流程\",{\"0\":{\"1214\":1}}],[\"加解锁时机\",{\"0\":{\"1213\":1}}],[\"加入推送等待表\",{\"1\":{\"1510\":1}}],[\"加入锁定状态表\",{\"1\":{\"1222\":1}}],[\"加入失败列表\",{\"1\":{\"1195\":1}}],[\"加入消息拉取线程\",{\"1\":{\"1137\":1,\"1144\":1,\"1224\":1}}],[\"加入\",{\"1\":{\"1047\":1,\"1371\":1}}],[\"加入到\",{\"1\":{\"988\":1,\"994\":1,\"1358\":1}}],[\"加入到credit\",{\"1\":{\"625\":1}}],[\"加写锁\",{\"1\":{\"953\":1,\"954\":1,\"971\":1,\"972\":2}}],[\"加载对应的消息存储插件\",{\"1\":{\"1424\":1}}],[\"加载单个文件的配置\",{\"1\":{\"999\":1}}],[\"加载到缓存中\",{\"1\":{\"998\":1}}],[\"加载到timer时间轮中等待调度\",{\"1\":{\"379\":1}}],[\"加载所有的验证器\",{\"1\":{\"990\":1,\"996\":1}}],[\"加载配置到内存\",{\"1\":{\"980\":1}}],[\"加载访问验证器\",{\"1\":{\"980\":1}}],[\"加载\",{\"1\":{\"960\":1,\"961\":1,\"990\":1,\"996\":1}}],[\"加载命令行中指定的属性\",{\"1\":{\"960\":1}}],[\"加载至内存\",{\"1\":{\"882\":1}}],[\"加载是否成功\",{\"1\":{\"793\":1}}],[\"加载这些文件\",{\"1\":{\"753\":1,\"759\":1}}],[\"加上单次提交的消息数阈值\",{\"1\":{\"1427\":1}}],[\"加上关键字abstract\",{\"1\":{\"579\":1}}],[\"加上牛头人的踩地板有两个群控\",{\"1\":{\"403\":1}}],[\"加上函数式编程\",{\"1\":{\"360\":1}}],[\"加上tab补全来跳转\",{\"1\":{\"152\":1}}],[\"加速比效率\",{\"1\":{\"285\":2}}],[\"加了一个构造器\",{\"1\":{\"132\":1}}],[\"正在上传中的不算在内\",{\"1\":{\"1430\":1,\"1432\":1}}],[\"正在写入的索引文件\",{\"1\":{\"1412\":1}}],[\"正在被写入\",{\"1\":{\"1394\":1,\"1412\":1}}],[\"正在投递\",{\"1\":{\"861\":1}}],[\"正如俗话说的\",{\"1\":{\"1363\":1}}],[\"正如其名字\",{\"1\":{\"943\":1}}],[\"正常\",{\"1\":{\"1511\":1,\"1520\":1}}],[\"正常消费\",{\"1\":{\"1100\":1}}],[\"正常关闭\",{\"1\":{\"954\":1}}],[\"正确\",{\"1\":{\"503\":2,\"509\":3,\"514\":1,\"515\":2,\"555\":1,\"556\":1,\"582\":2,\"592\":1}}],[\"正确关闭\",{\"1\":{\"53\":1}}],[\"正则表达式\",{\"1\":{\"150\":1,\"652\":1}}],[\"正则搜索替换\",{\"0\":{\"150\":1}}],[\"搜索光标所在的当前单词\",{\"1\":{\"149\":1}}],[\"搜索高亮\",{\"1\":{\"143\":1}}],[\"替换内容中的版本号\",{\"1\":{\"1074\":1}}],[\"替换原来的\",{\"1\":{\"894\":1,\"900\":1}}],[\"替换\",{\"1\":{\"894\":1}}],[\"替换消息的topic和queueid为定时消息topic和延迟等级对应的queueid\",{\"1\":{\"843\":1}}],[\"替换成定时消息对应的\",{\"1\":{\"836\":1,\"839\":1,\"843\":1}}],[\"替换前需要确认\",{\"1\":{\"150\":1}}],[\"替换标志\",{\"1\":{\"150\":1}}],[\"替换后文本\",{\"1\":{\"150\":1}}],[\"替换num个字符为char\",{\"1\":{\"148\":1}}],[\"替换一个字符为\",{\"1\":{\"148\":1}}],[\"连续\",{\"1\":{\"1278\":1}}],[\"连续shift\",{\"1\":{\"298\":1}}],[\"连续pop\",{\"1\":{\"298\":1}}],[\"连续替换字符\",{\"1\":{\"148\":1}}],[\"连接的数据发送一方中的\",{\"1\":{\"1300\":1}}],[\"连接的状态保存在\",{\"1\":{\"897\":1}}],[\"连接的接收和发送\",{\"1\":{\"118\":1}}],[\"连接地址\",{\"1\":{\"712\":1}}],[\"连接\",{\"1\":{\"298\":1,\"729\":1,\"896\":1}}],[\"连接仍打开\",{\"1\":{\"125\":1}}],[\"连接已经关闭\",{\"1\":{\"125\":1}}],[\"连接通道\",{\"1\":{\"118\":1}}],[\"连接指定服务器和端口\",{\"1\":{\"70\":1,\"73\":1}}],[\"配置不同的\",{\"1\":{\"1385\":1}}],[\"配置开启时才创建位数组\",{\"1\":{\"1332\":1}}],[\"配置为\",{\"1\":{\"1322\":1}}],[\"配置建议\",{\"1\":{\"1233\":1,\"1234\":1,\"1235\":1,\"1240\":1}}],[\"配置中的\",{\"1\":{\"1080\":1}}],[\"配置而变\",{\"1\":{\"1028\":1}}],[\"配置规则加载到内存\",{\"1\":{\"998\":1}}],[\"配置用户名和密码\",{\"1\":{\"984\":1,\"985\":1}}],[\"配置文件路径\",{\"1\":{\"1079\":1}}],[\"配置文件版本号表\",{\"1\":{\"997\":1}}],[\"配置文件和全局白名单的映射关系\",{\"1\":{\"997\":1}}],[\"配置文件的数量发生变化\",{\"1\":{\"999\":1}}],[\"配置文件的全局白名单\",{\"1\":{\"997\":1}}],[\"配置文件的映射关系\",{\"1\":{\"997\":1}}],[\"配置文件\",{\"1\":{\"980\":1,\"997\":1,\"998\":3}}],[\"配置信息发生变化或第一次注册才会更新\",{\"1\":{\"971\":1}}],[\"配置的机房名\",{\"1\":{\"1138\":1}}],[\"配置的\",{\"1\":{\"1075\":1,\"1425\":1}}],[\"配置的版本号\",{\"1\":{\"952\":1}}],[\"配置的操作是修改\",{\"1\":{\"952\":1}}],[\"配置的注解生命周期\",{\"1\":{\"44\":1}}],[\"配置项\",{\"1\":{\"787\":2,\"789\":1}}],[\"配置参数\",{\"0\":{\"656\":1},\"1\":{\"960\":2}}],[\"配置完\",{\"1\":{\"655\":1}}],[\"配置方法\",{\"0\":{\"651\":1}}],[\"配置镜像队列规则后\",{\"1\":{\"649\":1}}],[\"配置\",{\"0\":{\"990\":1,\"996\":1,\"1382\":1},\"1\":{\"630\":1,\"638\":2,\"947\":2,\"952\":1,\"960\":1,\"961\":3,\"970\":1,\"986\":1,\"998\":1,\"1075\":1,\"1382\":1,\"1420\":1}}],[\"配合\",{\"1\":{\"1352\":1,\"1385\":1}}],[\"配合一些重试和补偿机制\",{\"1\":{\"1027\":1}}],[\"配合吸血\",{\"1\":{\"415\":1}}],[\"配合async写法\",{\"1\":{\"349\":1}}],[\"配合文本对象删除一个单词\",{\"1\":{\"147\":1}}],[\"配色名\",{\"1\":{\"163\":1}}],[\"向客户端返回\",{\"1\":{\"1521\":1}}],[\"向客户端返回响应结果\",{\"1\":{\"1521\":1}}],[\"向客户端返回写入成功\",{\"1\":{\"1521\":1}}],[\"向客户端返回错误码\",{\"1\":{\"1516\":1,\"1521\":1}}],[\"向某一\",{\"1\":{\"1508\":1}}],[\"向其他节点发起投票请求\",{\"1\":{\"1502\":1}}],[\"向其他节点发起拉票请求\",{\"1\":{\"1497\":1}}],[\"向其他节点发拉票请求\",{\"1\":{\"1486\":1}}],[\"向其他节点发送心跳请求\",{\"1\":{\"1479\":1}}],[\"向其他节点请求投票\",{\"1\":{\"1477\":1}}],[\"向生产者返回\",{\"1\":{\"1446\":1}}],[\"向消费者客户端发送单向的消息回查请求\",{\"1\":{\"1468\":1}}],[\"向消费者投递消息\",{\"1\":{\"671\":1}}],[\"向消息属性中添加了事务消息标识\",{\"1\":{\"1446\":1}}],[\"向压缩后的文件写入\",{\"1\":{\"1435\":1}}],[\"向当前写入的索引文件中写入索引项\",{\"1\":{\"1434\":1}}],[\"向最新的索引文件中写入索引项\",{\"1\":{\"1434\":1}}],[\"向consumer返回应答\",{\"1\":{\"1173\":1}}],[\"向broker处理服务启注册钩子函数\",{\"1\":{\"996\":1}}],[\"向所有从节点发送心跳\",{\"1\":{\"1496\":1}}],[\"向所有其他节点发送心跳请求\",{\"1\":{\"1479\":1}}],[\"向所有消费者发送重平衡请求\",{\"1\":{\"1331\":1}}],[\"向所有\",{\"1\":{\"970\":1}}],[\"向每个\",{\"1\":{\"952\":1}}],[\"向索引文件插入新的索引项\",{\"1\":{\"797\":2}}],[\"向master上报slave当前的offset\",{\"1\":{\"729\":1}}],[\"向array的末尾添加若干元素\",{\"1\":{\"298\":1}}],[\"向端口发送data\",{\"1\":{\"241\":1}}],[\"向\",{\"1\":{\"229\":1,\"310\":1,\"945\":5,\"955\":1,\"1037\":1,\"1047\":1,\"1109\":1,\"1118\":1,\"1120\":1,\"1123\":1,\"1128\":1,\"1130\":1,\"1136\":1,\"1171\":1,\"1200\":1,\"1209\":1,\"1214\":2,\"1226\":2,\"1252\":1,\"1297\":1,\"1460\":2,\"1472\":1,\"1510\":5,\"1519\":4,\"1520\":1}}],[\"向载入路径的末端添加一个新目录\",{\"1\":{\"223\":1}}],[\"向载入路径的开头添加一个新目录\",{\"1\":{\"223\":1}}],[\"向下翻页\",{\"1\":{\"145\":1}}],[\"向上翻页\",{\"1\":{\"145\":1}}],[\"回填成功结果\",{\"1\":{\"1512\":1}}],[\"回填之前日志追加请求的\",{\"1\":{\"1507\":1}}],[\"回填等待转发完成的\",{\"1\":{\"1507\":1}}],[\"回查的请求头\",{\"1\":{\"1472\":1}}],[\"回查其执行状态\",{\"1\":{\"1469\":1}}],[\"回查次数\",{\"1\":{\"1468\":1}}],[\"回查该队列中需要回查的事务半消息的执行状态\",{\"1\":{\"1468\":1}}],[\"回查事务消息执行状态\",{\"1\":{\"1467\":1,\"1468\":1,\"1469\":1}}],[\"回查事务状态\",{\"0\":{\"1453\":1,\"1466\":1}}],[\"回查请求的主要方法是\",{\"1\":{\"1454\":1}}],[\"回查时会复原半消息的原始\",{\"1\":{\"1453\":1}}],[\"回想\",{\"1\":{\"927\":1}}],[\"回调\",{\"1\":{\"1143\":1}}],[\"回调关闭订单的方法\",{\"1\":{\"921\":1,\"1337\":1}}],[\"回调函数并未执行\",{\"1\":{\"359\":1}}],[\"回春\",{\"1\":{\"489\":1}}],[\"回春铺满\",{\"1\":{\"446\":3}}],[\"回春术\",{\"1\":{\"419\":1,\"489\":3}}],[\"回响之城\",{\"0\":{\"423\":1},\"1\":{\"480\":1}}],[\"回响\",{\"1\":{\"422\":1}}],[\"回放某寄存器中的宏\",{\"1\":{\"160\":1}}],[\"回到上一个word\",{\"1\":{\"145\":1}}],[\"回退到normal模式\",{\"1\":{\"142\":2}}],[\"←↓↑→\",{\"1\":{\"145\":1}}],[\"复原事务半消息的原始\",{\"1\":{\"1451\":1}}],[\"复原或丢弃\",{\"1\":{\"1450\":1}}],[\"复用一个拉取请求\",{\"1\":{\"1168\":1}}],[\"复生\",{\"1\":{\"489\":2,\"490\":2}}],[\"复生畸体腕带\",{\"1\":{\"480\":1}}],[\"复制组中每个节点当前存储的最大日志序列号\",{\"1\":{\"1521\":1}}],[\"复制组中每个节点当前已存储的最大日志序号\",{\"1\":{\"1514\":1}}],[\"复制组中所有节点已保存的日志水位\",{\"1\":{\"1521\":1}}],[\"复制完数据后\",{\"1\":{\"1518\":1}}],[\"复制完数据\",{\"1\":{\"1518\":1}}],[\"复制到镜像\",{\"1\":{\"677\":1}}],[\"复制到另一个\",{\"1\":{\"630\":1}}],[\"复制的过程是非阻塞的\",{\"1\":{\"696\":1}}],[\"复制的目的端被称为\",{\"1\":{\"630\":1}}],[\"复制的源端被称为\",{\"1\":{\"630\":1}}],[\"复制命令\",{\"1\":{\"273\":1}}],[\"复制专用寄存器\",{\"1\":{\"158\":1}}],[\"复制与粘贴\",{\"1\":{\"157\":1}}],[\"复制一行\",{\"1\":{\"156\":1}}],[\"复制一个单词到寄存器a中\",{\"1\":{\"157\":1}}],[\"复制一个单词\",{\"1\":{\"156\":1}}],[\"复制\",{\"1\":{\"144\":1,\"156\":1}}],[\"复赛\",{\"1\":{\"137\":1}}],[\"yml\",{\"1\":{\"979\":1,\"983\":1,\"990\":1,\"996\":1,\"1075\":5,\"1078\":2}}],[\"yield\",{\"1\":{\"332\":1}}],[\"yiw\",{\"1\":{\"156\":1}}],[\"yes的练级攻略\",{\"1\":{\"1527\":1}}],[\"year\",{\"1\":{\"316\":3}}],[\"yecc\",{\"1\":{\"171\":1}}],[\"y=2\",{\"1\":{\"316\":1}}],[\"y初始化为2\",{\"1\":{\"311\":1}}],[\"yaml\",{\"1\":{\"996\":1}}],[\"yang\",{\"1\":{\"850\":1}}],[\"yank\",{\"1\":{\"144\":1}}],[\"yahoo\",{\"1\":{\"298\":2}}],[\"yunque\",{\"1\":{\"264\":1}}],[\"yuque\",{\"1\":{\"264\":1,\"381\":1}}],[\"yy\",{\"1\":{\"156\":1}}],[\"y\",{\"1\":{\"144\":1,\"155\":1,\"156\":1,\"171\":5,\"176\":1,\"186\":4,\"188\":4,\"213\":2,\"217\":5,\"253\":3,\"298\":1,\"303\":1,\"311\":1,\"316\":4,\"324\":2,\"329\":2,\"331\":5,\"502\":4,\"514\":2,\"531\":2,\"537\":2,\"550\":4,\"551\":1,\"552\":2,\"555\":4,\"556\":2,\"558\":8,\"562\":1,\"566\":5,\"643\":3}}],[\"yourself\",{\"1\":{\"1333\":1}}],[\"your\",{\"1\":{\"97\":1,\"165\":1,\"960\":1,\"1173\":1,\"1444\":1}}],[\"you\",{\"1\":{\"97\":4,\"98\":2,\"165\":1,\"289\":1,\"643\":1}}],[\"增量信息到\",{\"1\":{\"945\":1}}],[\"增量搜索\",{\"1\":{\"143\":1}}],[\"增加了<\",{\"1\":{\"1435\":1}}],[\"增加了处理逻辑的复杂性\",{\"1\":{\"1347\":1}}],[\"增加解锁尝试次数\",{\"1\":{\"1225\":1}}],[\"增加定时任务\",{\"1\":{\"961\":2}}],[\"增加集群的抗压能力\",{\"1\":{\"942\":1}}],[\"增加维护成本\",{\"1\":{\"928\":1}}],[\"增加信用值\",{\"0\":{\"626\":1}}],[\"增加或删除节点\",{\"1\":{\"385\":1}}],[\"增益\",{\"1\":{\"405\":1}}],[\"增\",{\"1\":{\"371\":1}}],[\"增强系统的可观测性\",{\"1\":{\"276\":1}}],[\"增强\",{\"1\":{\"85\":1}}],[\"插拔网线模拟网络异常的两个测试场景\",{\"1\":{\"659\":1}}],[\"插入索引项\",{\"1\":{\"1434\":1}}],[\"插入时间不是连续的\",{\"1\":{\"1393\":1}}],[\"插入\",{\"1\":{\"1393\":1}}],[\"插入和查询\",{\"0\":{\"794\":1}}],[\"插入文件名全路径\",{\"1\":{\"143\":1}}],[\"插入文件名\",{\"1\":{\"143\":1}}],[\"插入模式快捷键\",{\"1\":{\"142\":1}}],[\"插件可以将消息从一个\",{\"1\":{\"630\":1}}],[\"插件使用\",{\"0\":{\"629\":1},\"1\":{\"718\":1}}],[\"插件来查看每个副本的掉落\",{\"1\":{\"480\":1}}],[\"插件网站\",{\"0\":{\"166\":1}}],[\"插件名称\",{\"1\":{\"64\":1}}],[\"插件\",{\"0\":{\"164\":1,\"491\":1},\"1\":{\"6\":1,\"271\":1,\"272\":1,\"630\":2,\"635\":1}}],[\"退出到normal模式\",{\"1\":{\"142\":1}}],[\"退出\",{\"1\":{\"142\":1}}],[\"进而产生不同的\",{\"1\":{\"1235\":1}}],[\"进而调用\",{\"1\":{\"812\":1,\"827\":1}}],[\"进而从\",{\"1\":{\"778\":1,\"868\":1}}],[\"进而到\",{\"1\":{\"751\":1}}],[\"进本也难\",{\"1\":{\"399\":1}}],[\"进组也变得困难\",{\"1\":{\"399\":1}}],[\"进一步的\",{\"1\":{\"276\":1}}],[\"进程进行广播同步将消息发送给\",{\"1\":{\"668\":1}}],[\"进程将消息发送给队列的\",{\"1\":{\"668\":1}}],[\"进程发送的\",{\"1\":{\"668\":1}}],[\"进程发送消息\",{\"1\":{\"229\":1}}],[\"进程所在节点会收到两次\",{\"1\":{\"668\":1}}],[\"进程收到消息后\",{\"1\":{\"668\":1}}],[\"进程都在远端节点上\",{\"1\":{\"668\":1}}],[\"进程外\",{\"1\":{\"668\":1}}],[\"进程除了将消息发送给队列的\",{\"1\":{\"668\":1}}],[\"进程中\",{\"1\":{\"668\":1}}],[\"进程从\",{\"1\":{\"668\":1}}],[\"进程解除阻塞\",{\"0\":{\"627\":1}}],[\"进程阻塞\",{\"0\":{\"625\":1}}],[\"进程成为性能瓶颈\",{\"1\":{\"622\":1}}],[\"进程会持续追踪它从\",{\"1\":{\"621\":1}}],[\"进程接收\",{\"1\":{\"621\":1}}],[\"进程开始处理一条消息\",{\"1\":{\"621\":1}}],[\"进程与操作系统的进程不同\",{\"1\":{\"619\":1}}],[\"进程的运作\",{\"1\":{\"622\":1}}],[\"进程的处理顺序如下\",{\"1\":{\"614\":1}}],[\"进程的流控\",{\"1\":{\"614\":1}}],[\"进程间只通过消息来通信\",{\"1\":{\"611\":1}}],[\"进程内流控可能在1秒钟内触发多次\",{\"1\":{\"622\":1}}],[\"进程内流控是阻塞在\",{\"1\":{\"614\":1}}],[\"进程内流控是针对\",{\"1\":{\"614\":1}}],[\"进程内流控的阻塞时间通常很短\",{\"1\":{\"614\":1}}],[\"进程内流控不会影响到消费端\",{\"1\":{\"614\":1}}],[\"进程内流控指的是这4种进程之间的流控\",{\"1\":{\"614\":1}}],[\"进程内流控\",{\"0\":{\"609\":1,\"614\":1},\"1\":{\"718\":1}}],[\"进程\",{\"1\":{\"241\":1,\"621\":3,\"623\":1,\"668\":6,\"899\":1}}],[\"进程很轻巧\",{\"0\":{\"231\":1}}],[\"进程标识符\",{\"1\":{\"230\":1}}],[\"进程字典\",{\"0\":{\"217\":1}}],[\"进制\",{\"1\":{\"215\":1}}],[\"进入到\",{\"1\":{\"1074\":1}}],[\"进入死信队列\",{\"1\":{\"1056\":1}}],[\"进入上述网页\",{\"1\":{\"643\":1}}],[\"进入\",{\"1\":{\"142\":1,\"711\":1,\"1491\":1,\"1497\":1,\"1500\":1,\"1503\":1,\"1510\":2}}],[\"进行数据比对\",{\"1\":{\"1520\":1}}],[\"进行截断\",{\"1\":{\"1511\":1}}],[\"进行日志比对和截断操作\",{\"1\":{\"1511\":1}}],[\"进行日志对比\",{\"1\":{\"1510\":1}}],[\"进行不同的逻辑\",{\"1\":{\"1511\":1}}],[\"进行结果检查\",{\"1\":{\"1510\":1,\"1512\":1}}],[\"进行流控\",{\"1\":{\"1510\":1}}],[\"进行仲裁\",{\"1\":{\"1492\":2,\"1503\":1}}],[\"进行事务消息发送\",{\"1\":{\"1459\":2}}],[\"进行二次确认\",{\"1\":{\"1446\":1}}],[\"进行回查\",{\"1\":{\"1446\":1}}],[\"进行分级存储文件恢复\",{\"1\":{\"1421\":1}}],[\"进行重排\",{\"1\":{\"1417\":1}}],[\"进行重平衡的检查\",{\"1\":{\"1136\":1}}],[\"进行重平衡的方法\",{\"1\":{\"1134\":1}}],[\"进行重平衡后需要判断并更新消费者的负载\",{\"1\":{\"1134\":1}}],[\"进行重平衡\",{\"0\":{\"1143\":1},\"1\":{\"1133\":1,\"1136\":1,\"1137\":2}}],[\"进行存储实现\",{\"1\":{\"1398\":1}}],[\"进行压测\",{\"1\":{\"1383\":1}}],[\"进行轮转\",{\"1\":{\"1347\":1}}],[\"进行更新\",{\"1\":{\"1317\":1}}],[\"进行精确匹配过滤\",{\"1\":{\"1315\":1}}],[\"进行过滤逻辑判断\",{\"1\":{\"1324\":1}}],[\"进行过滤\",{\"1\":{\"1303\":1}}],[\"进行消费\",{\"1\":{\"1291\":1}}],[\"进行消息拉取\",{\"1\":{\"1219\":1}}],[\"进行消息的存储\",{\"1\":{\"672\":1}}],[\"进行标记\",{\"1\":{\"1278\":1}}],[\"进行设置\",{\"1\":{\"1198\":1}}],[\"进行拉取\",{\"1\":{\"1155\":1}}],[\"进行下一次拉取\",{\"1\":{\"1137\":1}}],[\"进行检查或者是收到\",{\"1\":{\"1136\":1}}],[\"进行均匀的订阅\",{\"1\":{\"1094\":1}}],[\"进行开发和验证\",{\"1\":{\"1069\":1}}],[\"进行心跳检测等\",{\"1\":{\"1047\":1}}],[\"进行网络传输\",{\"1\":{\"1042\":1,\"1053\":1}}],[\"进行发送\",{\"1\":{\"1039\":1}}],[\"进行比较是否相等\",{\"1\":{\"999\":1}}],[\"进行权限控制的流程\",{\"1\":{\"979\":1}}],[\"进行权限判断\",{\"1\":{\"979\":1}}],[\"进行采样\",{\"1\":{\"911\":1}}],[\"进行拼接\",{\"1\":{\"906\":1}}],[\"进行操作\",{\"1\":{\"894\":1}}],[\"进行序列化反序列化\",{\"1\":{\"893\":1}}],[\"进行一次扫描和压缩\",{\"1\":{\"1435\":1}}],[\"进行一次扫描\",{\"1\":{\"1388\":1,\"1417\":1}}],[\"进行一次粗粒度的过滤\",{\"1\":{\"1318\":1}}],[\"进行一次重平衡\",{\"1\":{\"1136\":1}}],[\"进行一次检查\",{\"1\":{\"864\":1}}],[\"进行一次判断\",{\"1\":{\"752\":1}}],[\"进行扫描\",{\"1\":{\"756\":1}}],[\"进行哈希\",{\"1\":{\"708\":1}}],[\"进行调用\",{\"1\":{\"672\":1}}],[\"进行安全和协调的处理等\",{\"1\":{\"621\":1}}],[\"进行路由解析\",{\"1\":{\"621\":1}}],[\"进行通信\",{\"1\":{\"621\":1}}],[\"进行通讯\",{\"1\":{\"372\":1}}],[\"进行自愈风险分析与优化建议\",{\"1\":{\"277\":1}}],[\"进行浏览\",{\"0\":{\"246\":1}}],[\"进行\",{\"1\":{\"135\":1,\"1364\":1,\"1393\":1}}],[\"进行业务处理的过程会导致\",{\"1\":{\"127\":1}}],[\"进行业务处理\",{\"1\":{\"125\":1,\"128\":1}}],[\"进行处理\",{\"1\":{\"125\":1}}],[\"进行请求处理\",{\"1\":{\"121\":1}}],[\"进行运算时\",{\"1\":{\"2\":1}}],[\"论最强io\",{\"1\":{\"137\":1}}],[\"孰强孰弱\",{\"1\":{\"137\":1}}],[\"典型的双主双从部署方式如下图所示\",{\"1\":{\"941\":1}}],[\"典型的\",{\"1\":{\"136\":1}}],[\"核心原理与最佳实践\",{\"1\":{\"1057\":1}}],[\"核心入口\",{\"0\":{\"1053\":1},\"1\":{\"1053\":1}}],[\"核心引擎\",{\"1\":{\"136\":1}}],[\"核心知识总结\",{\"1\":{\"136\":1}}],[\"核心类\",{\"0\":{\"26\":1}}],[\"随机读\",{\"0\":{\"1363\":1}}],[\"随机地址被映射到了内存\",{\"1\":{\"728\":1}}],[\"随机选择一个节点\",{\"1\":{\"660\":1}}],[\"随便一个读条\",{\"1\":{\"468\":1}}],[\"随即向后找离他最近的虚拟节点\",{\"1\":{\"395\":1}}],[\"随时调试任务\",{\"1\":{\"273\":1}}],[\"随时想测某个方法时\",{\"1\":{\"273\":1}}],[\"随后等待服务线程扫描这个定时\",{\"1\":{\"1354\":1}}],[\"随后服务端会在存储中查询一批消息\",{\"1\":{\"1253\":1}}],[\"随后生产者会启动定时任务\",{\"1\":{\"1039\":1}}],[\"随后选择一个\",{\"1\":{\"1039\":1}}],[\"随后保存消息\",{\"1\":{\"1030\":1}}],[\"随后将这些匹配的消费组的名称通过布隆过滤器进行计算\",{\"1\":{\"1315\":1}}],[\"随后将消息发送给\",{\"1\":{\"1030\":1}}],[\"随后将轨迹信息交给一个异步线程池处理\",{\"1\":{\"1011\":1}}],[\"随后会将签名和用户名加入到请求扩展属性中\",{\"1\":{\"989\":1}}],[\"随后马上发一条延迟\",{\"1\":{\"925\":1}}],[\"随后构建出\",{\"1\":{\"816\":1}}],[\"随后进行恢复操作recoverconsumequeue\",{\"1\":{\"759\":1}}],[\"随后进程可以继续发送消息\",{\"1\":{\"627\":1}}],[\"随后使用查出来的phyoffset和size到commitlog中查询消息并返回\",{\"1\":{\"757\":1}}],[\"随后由一个独立线程defaultmessagestore\",{\"1\":{\"756\":1}}],[\"随后为这个\",{\"1\":{\"749\":1}}],[\"随后再次执行\",{\"1\":{\"645\":1}}],[\"随后再执行\",{\"1\":{\"643\":1}}],[\"随后更新\",{\"1\":{\"644\":1}}],[\"随后执行\",{\"1\":{\"643\":1}}],[\"随后执行异步任务\",{\"1\":{\"135\":1}}],[\"随后\",{\"1\":{\"368\":1}}],[\"随后到\",{\"1\":{\"273\":1}}],[\"随意调用方法\",{\"1\":{\"272\":1}}],[\"随着时间的推移\",{\"1\":{\"1390\":1}}],[\"随着时间轮跳动就不断地触发投递任务\",{\"1\":{\"931\":1}}],[\"随着消息存储量的增加\",{\"1\":{\"1364\":1}}],[\"随着消息队列的使用场景越来越广泛\",{\"1\":{\"976\":1}}],[\"随着发送失败次数的增多\",{\"1\":{\"1041\":1}}],[\"随着开源之夏2022活动的召开\",{\"1\":{\"286\":1}}],[\"随着codeless组合式应用快速发展\",{\"1\":{\"276\":1}}],[\"随着serverless\",{\"1\":{\"276\":1}}],[\"随着硬件资源的增加\",{\"1\":{\"115\":1}}],[\"随着客户端数量的增加而优雅降级\",{\"1\":{\"115\":1}}],[\"随着互联网的发展\",{\"1\":{\"115\":1}}],[\"业务量也达到了惊人的量级\",{\"1\":{\"1439\":1}}],[\"业务团队无法直接创建和修改\",{\"1\":{\"978\":1}}],[\"业务仍处于未恢复状态\",{\"1\":{\"284\":1}}],[\"业务创新更加专注\",{\"1\":{\"276\":1}}],[\"业务逻辑处理完毕后\",{\"1\":{\"135\":1}}],[\"业务处理完成\",{\"1\":{\"128\":1}}],[\"业务处理逻辑\",{\"1\":{\"128\":2}}],[\"业务处理如协议的编解码都分配给线程池处理\",{\"1\":{\"127\":1}}],[\"业务处理\",{\"1\":{\"116\":1,\"120\":1}}],[\"业务处理和发送\",{\"1\":{\"116\":1}}],[\"去掉了指针\",{\"1\":{\"1435\":1}}],[\"去掉了链表指针\",{\"1\":{\"1418\":1}}],[\"去掉链表指针也可以节省每个索引项占用的大小\",{\"1\":{\"1418\":1}}],[\"去处理\",{\"1\":{\"1372\":2}}],[\"去处理业务逻辑\",{\"1\":{\"132\":1}}],[\"去\",{\"1\":{\"645\":1}}],[\"去奶别人\",{\"1\":{\"482\":1}}],[\"去除字符串末尾占位符\",{\"0\":{\"740\":1}}],[\"去除\",{\"0\":{\"290\":1,\"904\":1}}],[\"去除换行符\",{\"0\":{\"287\":1},\"1\":{\"608\":1}}],[\"去分发连接给\",{\"1\":{\"121\":1,\"132\":1}}],[\"计时器到期\",{\"1\":{\"1478\":1}}],[\"计数器\",{\"1\":{\"131\":1}}],[\"计算消息写入的起始物理偏移量\",{\"1\":{\"1517\":1}}],[\"计算免疫回查时长\",{\"1\":{\"1468\":1}}],[\"计算事务半消息是否处在免疫回查期\",{\"1\":{\"1453\":1,\"1468\":1}}],[\"计算所有索引项总长度\",{\"1\":{\"1435\":1}}],[\"计算目标\",{\"1\":{\"1427\":1}}],[\"计算量较大\",{\"1\":{\"1364\":1}}],[\"计算队列还剩下的消息数量\",{\"1\":{\"1270\":1}}],[\"计算队列剩余的消息数量\",{\"1\":{\"1258\":1}}],[\"计算要提交数据的大小\",{\"1\":{\"1428\":1}}],[\"计算要\",{\"1\":{\"1270\":1}}],[\"计算本次消费请求任务执行时长\",{\"1\":{\"1230\":1}}],[\"计算本次期望写入consumequeue的物理偏移量\",{\"1\":{\"765\":1}}],[\"计算异常\",{\"1\":{\"1228\":1}}],[\"计算拉取偏移量\",{\"1\":{\"1228\":1}}],[\"计算并设置本次拉取任务消息队列的拉取偏移量\",{\"1\":{\"1228\":1}}],[\"计算并从偏移量存储中读取下次拉取的偏移量\",{\"1\":{\"1137\":1,\"1144\":1,\"1224\":1}}],[\"计算和记录拉取用时\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"计算挂起时间\",{\"1\":{\"1173\":1}}],[\"计算下次拉取建议的\",{\"1\":{\"1163\":1}}],[\"计算下一次调度时间\",{\"1\":{\"374\":1}}],[\"计算当前\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"计算当前时间距离下一个时间格的时间\",{\"1\":{\"379\":1}}],[\"计算压力越大\",{\"1\":{\"924\":1}}],[\"计算文件应该被删除的时间\",{\"1\":{\"870\":1}}],[\"计算放置索引的绝对偏移量\",{\"1\":{\"797\":1}}],[\"计算key的hash值\",{\"1\":{\"797\":1}}],[\"计算的逻辑在\",{\"1\":{\"765\":1}}],[\"计算的逻辑放到\",{\"1\":{\"738\":1}}],[\"计算应该写入\",{\"1\":{\"765\":1}}],[\"计算相对模块的位置\",{\"1\":{\"599\":1}}],[\"计算出布隆过滤器的位数组\",{\"1\":{\"1323\":1}}],[\"计算出这条消息是否匹配\",{\"1\":{\"1315\":1}}],[\"计算出其在哈希环上的位置\",{\"1\":{\"393\":1}}],[\"计算出系统的\",{\"1\":{\"283\":1}}],[\"计算在时间轮中的index下标\",{\"1\":{\"379\":1}}],[\"计算右侧\",{\"1\":{\"173\":1}}],[\"计算\",{\"1\":{\"120\":1,\"1258\":1,\"1278\":1,\"1415\":1,\"1436\":2}}],[\"下次不会回查\",{\"1\":{\"1468\":1}}],[\"下次重新消费的延迟等级根据该值来确定\",{\"1\":{\"1198\":1}}],[\"下表展示了本地存储与分级存储模型的对应关系\",{\"1\":{\"1386\":1}}],[\"下表是当前没有衰减情况下次要属性提升\",{\"1\":{\"421\":1}}],[\"下不同消费者的\",{\"1\":{\"1240\":1}}],[\"下所有队列\",{\"1\":{\"1266\":2}}],[\"下所有的队列\",{\"1\":{\"1255\":1}}],[\"下所有acl配置文件\",{\"1\":{\"998\":1}}],[\"下所有消息在\",{\"1\":{\"747\":1}}],[\"下存储的消息位置信息链表\",{\"1\":{\"927\":1}}],[\"下有\",{\"1\":{\"925\":1}}],[\"下有空余的\",{\"1\":{\"482\":1}}],[\"下个任务从该\",{\"1\":{\"855\":1}}],[\"下的并发消费无法避免\",{\"1\":{\"1203\":1}}],[\"下的一条消息只会被同一消费组中的一个消费者消费\",{\"1\":{\"1091\":1}}],[\"下的模板\",{\"1\":{\"1074\":1}}],[\"下的影响\",{\"1\":{\"935\":1}}],[\"下的消息的位置信息\",{\"1\":{\"927\":1}}],[\"下的性能提升了\",{\"1\":{\"850\":1}}],[\"下的所有队列和消费者列表进行排序\",{\"1\":{\"1143\":1}}],[\"下的所有队列\",{\"1\":{\"1133\":1,\"1143\":1}}],[\"下的所有\",{\"1\":{\"131\":1}}],[\"下标\",{\"1\":{\"797\":1}}],[\"下一条待写日志序号\",{\"1\":{\"1520\":1}}],[\"下一条期望追加的日志已经被\",{\"1\":{\"1520\":1}}],[\"下一条日志\",{\"1\":{\"1519\":1}}],[\"下一次选择队列时会避开发送失败队列所在的\",{\"1\":{\"1029\":1}}],[\"下一代高可用队列\",{\"0\":{\"694\":1}}],[\"下一个匹配\",{\"1\":{\"149\":1}}],[\"下一个word\",{\"1\":{\"145\":2}}],[\"下载后复制到服务器上安装\",{\"1\":{\"645\":1}}],[\"下游\",{\"1\":{\"702\":1}}],[\"下游集群配置\",{\"0\":{\"638\":1}}],[\"下游的集群\",{\"1\":{\"633\":1}}],[\"下游进程分别为前三个进程\",{\"1\":{\"621\":1}}],[\"下游进程处理完一条消息时\",{\"1\":{\"619\":1}}],[\"下可以看情况规划树皮铁皮一起放\",{\"1\":{\"492\":1}}],[\"下优先刷别人\",{\"1\":{\"485\":1}}],[\"下持续\",{\"1\":{\"425\":1}}],[\"下\",{\"1\":{\"411\":1,\"641\":1,\"720\":1,\"1235\":1}}],[\"下赛季如果还大米的话一定找个车队\",{\"1\":{\"399\":1}}],[\"下面详细分析每个状态维护的方法\",{\"1\":{\"1483\":1}}],[\"下面简单介绍一下几种特殊消息类型\",{\"1\":{\"1028\":1}}],[\"下面为示例配置文件\",{\"1\":{\"983\":1}}],[\"下面看一下它的逻辑\",{\"1\":{\"1258\":1}}],[\"下面看一下它们的具体结构\",{\"1\":{\"949\":1}}],[\"下面看一下\",{\"1\":{\"997\":1}}],[\"下面看下server的这个方法做了什么事情\",{\"1\":{\"380\":1}}],[\"下面看下schedule方法是怎么实现的\",{\"1\":{\"379\":1}}],[\"下面看下这个方法的逻辑\",{\"1\":{\"380\":1}}],[\"下面不会超过\",{\"1\":{\"906\":1}}],[\"下面来分别介绍\",{\"1\":{\"1402\":1}}],[\"下面来分析一下这几个方案的优缺点\",{\"1\":{\"928\":1}}],[\"下面来逐条剖析\",{\"1\":{\"886\":1}}],[\"下面来详细分析一下\",{\"1\":{\"874\":1}}],[\"下面来详细解释一下这些配置参数的意义\",{\"1\":{\"656\":1}}],[\"下面讲一下rocketmq中发送定时消息\",{\"1\":{\"834\":1}}],[\"下面分析\",{\"1\":{\"760\":1}}],[\"下面的代码第一份是修改前的\",{\"1\":{\"737\":1}}],[\"下面这张图对比了普通\",{\"1\":{\"728\":1}}],[\"下面会从源码层面来详细分析一下优化点和优化的原因\",{\"1\":{\"720\":1}}],[\"下面以单个\",{\"1\":{\"963\":1}}],[\"下面以一个延迟等级的处理为例\",{\"1\":{\"856\":1}}],[\"下面以\",{\"1\":{\"712\":1}}],[\"下面我们一一说明它们的含义和作用\",{\"1\":{\"1482\":1}}],[\"下面我们看一下每种角色的节点的行为\",{\"1\":{\"1477\":1}}],[\"下面我们看看投递的设计\",{\"1\":{\"930\":1}}],[\"下面我们将揭开华为云\",{\"1\":{\"922\":1}}],[\"下面我们以rabbit\",{\"1\":{\"623\":1}}],[\"下面我们把这个模型简化\",{\"1\":{\"621\":1}}],[\"下面可以总结出判断性能瓶颈在何处的结论\",{\"1\":{\"622\":1}}],[\"下面\",{\"1\":{\"598\":2}}],[\"下面推荐一些主动和被动的替代饰品\",{\"1\":{\"481\":1}}],[\"下面是权限验证的步骤\",{\"1\":{\"991\":1}}],[\"下面是配置的具体取值\",{\"1\":{\"983\":1}}],[\"下面是\",{\"1\":{\"979\":1,\"1318\":1,\"1510\":1}}],[\"下面是开源\",{\"1\":{\"925\":1}}],[\"下面是该策略的可选参数列表\",{\"1\":{\"660\":1}}],[\"下面是本文作者\",{\"1\":{\"491\":1}}],[\"下面是有\",{\"1\":{\"462\":1}}],[\"下面是利用\",{\"1\":{\"284\":1}}],[\"下面给出我自己的一些常用天赋\",{\"1\":{\"403\":1}}],[\"下面先来一段心路历程\",{\"1\":{\"399\":1}}],[\"下面展示增加和减少节点的场景\",{\"1\":{\"387\":1}}],[\"下面就来看看它是如何实现的\",{\"1\":{\"380\":1}}],[\"下图表示推模式消费者的消息拉取流程\",{\"1\":{\"1156\":1}}],[\"下图中\",{\"1\":{\"655\":1}}],[\"下图每个橙色组件都是一个\",{\"1\":{\"621\":1}}],[\"下图为\",{\"1\":{\"1255\":1}}],[\"下图为一个简单的示意图\",{\"1\":{\"674\":1}}],[\"下图为初始化流程\",{\"1\":{\"374\":1}}],[\"下图为更详细的实验结果\",{\"1\":{\"284\":1}}],[\"下图是权重为\",{\"1\":{\"716\":1}}],[\"下图是单\",{\"1\":{\"127\":1}}],[\"下图是\",{\"1\":{\"120\":1,\"1481\":1}}],[\"下午1\",{\"1\":{\"272\":1}}],[\"下划线\",{\"1\":{\"175\":1}}],[\"下移窗口\",{\"1\":{\"153\":1}}],[\"保留成熟的本地存储\",{\"1\":{\"1385\":1}}],[\"保留输入类型的\",{\"1\":{\"593\":2}}],[\"保障数据的高可用和安全性\",{\"1\":{\"692\":1}}],[\"保持\",{\"1\":{\"1491\":1,\"1497\":1}}],[\"保持为\",{\"1\":{\"1480\":1}}],[\"保持生命绽放\",{\"1\":{\"492\":1}}],[\"保持你想要的属性\",{\"1\":{\"483\":1}}],[\"保持靠近\",{\"1\":{\"426\":1}}],[\"保持所有目标上的月火术\",{\"1\":{\"412\":1}}],[\"保持聚好的怪上的阳炎术\",{\"1\":{\"412\":2}}],[\"保持聚好的怪上的痛击\",{\"1\":{\"412\":1}}],[\"保持阳炎术\",{\"1\":{\"412\":1}}],[\"保持月火术\",{\"1\":{\"412\":1}}],[\"保持斜掠\",{\"1\":{\"412\":1}}],[\"保持割裂\",{\"1\":{\"412\":1}}],[\"保存发送\",{\"1\":{\"1519\":1}}],[\"保存日志到本地存储\",{\"0\":{\"1517\":1}}],[\"保存日志\",{\"1\":{\"1508\":1}}],[\"保存着索引文件的跳表\",{\"1\":{\"1413\":1}}],[\"保存着消息位置\",{\"1\":{\"1402\":1}}],[\"保存着每个消息在\",{\"1\":{\"1386\":1}}],[\"保存记录的大小\",{\"1\":{\"1352\":1}}],[\"保存定时消息的索引\",{\"1\":{\"1346\":1}}],[\"保存重试消息到存储\",{\"1\":{\"1280\":1}}],[\"保存源消息的\",{\"1\":{\"1198\":1}}],[\"保存一个缓存表\",{\"1\":{\"1190\":1}}],[\"保存这些消息\",{\"1\":{\"1155\":1}}],[\"保存生产者消费者组信息\",{\"1\":{\"1118\":1}}],[\"保存路由信息\",{\"1\":{\"1118\":1}}],[\"保存元数据\",{\"1\":{\"1118\":1}}],[\"保存元组到磁盘\",{\"0\":{\"250\":1}}],[\"保存在\",{\"1\":{\"1103\":1,\"1253\":1}}],[\"保存在消费者本地\",{\"1\":{\"1103\":1}}],[\"保存在磁盘上的一种文件\",{\"1\":{\"777\":1}}],[\"保存在磁盘中\",{\"1\":{\"746\":1}}],[\"保存上报的路由信息\",{\"0\":{\"953\":1,\"971\":1}}],[\"保存时间之内任意时间的延迟消息实现\",{\"1\":{\"848\":1}}],[\"保存时间限制\",{\"1\":{\"847\":1}}],[\"保存时间的限制\",{\"1\":{\"833\":1}}],[\"保存到事务半消息的属性中\",{\"1\":{\"1463\":1}}],[\"保存到位数组中\",{\"1\":{\"1332\":1}}],[\"保存到消息属性中\",{\"1\":{\"1463\":1}}],[\"保存到消息存储\",{\"1\":{\"1056\":1}}],[\"保存到消费者过滤信息中\",{\"1\":{\"1331\":1}}],[\"保存到\",{\"1\":{\"839\":1,\"1190\":1,\"1331\":1,\"1435\":1}}],[\"保存消息时由保存的偏移量生成\",{\"1\":{\"899\":1}}],[\"保存消息时检查是否是延迟消息\",{\"1\":{\"837\":1}}],[\"保存消息\",{\"1\":{\"837\":1}}],[\"保存该次consumer拉取请求\",{\"1\":{\"822\":1}}],[\"保存\",{\"0\":{\"1259\":1,\"1370\":1,\"1371\":1},\"1\":{\"822\":1,\"944\":3,\"1273\":1,\"1348\":2}}],[\"保存的最大日志\",{\"1\":{\"1511\":1}}],[\"保存的消息数据都有一个过期时间\",{\"1\":{\"924\":1}}],[\"保存的\",{\"1\":{\"789\":1}}],[\"保存了一个链表\",{\"1\":{\"931\":1}}],[\"保存了一个\",{\"1\":{\"747\":1,\"1118\":1}}],[\"保存module\",{\"1\":{\"364\":1}}],[\"保存原函数\",{\"1\":{\"320\":1}}],[\"保存当前节点角色\",{\"1\":{\"1514\":1}}],[\"保存当前\",{\"1\":{\"131\":1}}],[\"保证主从一致性\",{\"1\":{\"1520\":1}}],[\"保证数据一致性\",{\"1\":{\"1510\":1}}],[\"保证同一时刻只有一个消费者可以拉取同一个\",{\"1\":{\"1270\":1}}],[\"保证同一时间只有一个消费者可以拉取该队列的消息\",{\"1\":{\"1253\":1}}],[\"保证同一时间只有一个消费者在消费\",{\"1\":{\"1102\":1}}],[\"保证每个消费者都有队列消费\",{\"1\":{\"1267\":1}}],[\"保证每个消费者的分配的结果幂等\",{\"1\":{\"1127\":1}}],[\"保证处理队列的\",{\"1\":{\"1218\":1}}],[\"保证消费线程池中消费这个队列的最多只有一个线程\",{\"1\":{\"1218\":1}}],[\"保证消费速度\",{\"1\":{\"1204\":1}}],[\"保证该队列消费完之前不拉取新的消息\",{\"1\":{\"1207\":1}}],[\"保证就算有多个线程同时消费一个队列\",{\"1\":{\"1207\":1}}],[\"保证一个队列同时仅被一个消费线程消费\",{\"0\":{\"1207\":1}}],[\"保证顺序性\",{\"1\":{\"1204\":1}}],[\"保证所有消费者分配的结果一致\",{\"1\":{\"1143\":1}}],[\"保证类型运算的完整性\",{\"1\":{\"504\":1}}],[\"保证高\",{\"1\":{\"441\":1}}],[\"保证任务不丢失\",{\"1\":{\"375\":1}}],[\"保证writer正确关闭\",{\"1\":{\"58\":1}}],[\"保证reader正确关闭\",{\"1\":{\"57\":1}}],[\"匹配上则认为处理完\",{\"1\":{\"1453\":1}}],[\"匹配和重试完成后\",{\"1\":{\"1279\":1}}],[\"匹配和消息重试\",{\"0\":{\"1263\":1}}],[\"匹配消费到的一批\",{\"1\":{\"1279\":1}}],[\"匹配对象\",{\"1\":{\"1278\":1}}],[\"匹配规则很简单\",{\"1\":{\"904\":1}}],[\"匹配之前创建的镜像策略\",{\"1\":{\"655\":1}}],[\"匹配\",{\"0\":{\"1261\":1,\"1274\":1},\"1\":{\"130\":1,\"1259\":1,\"1262\":1,\"1276\":1,\"1278\":3}}],[\"闲置\",{\"1\":{\"130\":1}}],[\"又对分级存储的代码进行了大量重构\",{\"1\":{\"1380\":1}}],[\"又是否成功将消息投递给消费者这些动作\",{\"1\":{\"1003\":1}}],[\"又可以称作索引文件\",{\"1\":{\"777\":1}}],[\"又可称作\",{\"1\":{\"614\":1}}],[\"又称作消费队列\",{\"1\":{\"746\":1}}],[\"又称decorator模式\",{\"1\":{\"55\":1}}],[\"又会走到\",{\"1\":{\"128\":1}}],[\"重置计时器\",{\"1\":{\"1497\":1}}],[\"重置下次拉票计时器\",{\"1\":{\"1491\":3,\"1497\":2}}],[\"重置\",{\"1\":{\"1428\":1,\"1519\":5}}],[\"重置输入流\",{\"1\":{\"1428\":1}}],[\"重置消费位点\",{\"1\":{\"1090\":1}}],[\"重排后的文件相对重排之前\",{\"1\":{\"1418\":1}}],[\"重排后文件\",{\"1\":{\"1417\":1}}],[\"重排的目标是在查询时减少对分级存储的\",{\"1\":{\"1418\":1}}],[\"重排细节\",{\"0\":{\"1418\":1}}],[\"重排前后的两个文件同时存在\",{\"1\":{\"1417\":1}}],[\"重排和上传的入口函数是\",{\"1\":{\"1417\":1}}],[\"重排流程\",{\"0\":{\"1417\":1}}],[\"重排窗口\",{\"1\":{\"153\":1}}],[\"重构后采用更简单明了的预读策略\",{\"1\":{\"1404\":1}}],[\"重发\",{\"1\":{\"1279\":1,\"1280\":1}}],[\"重发到重试\",{\"1\":{\"1279\":1}}],[\"重定向到另外一台机器\",{\"1\":{\"1173\":1}}],[\"重分配策略\",{\"1\":{\"1129\":1}}],[\"重平衡策略\",{\"1\":{\"1267\":1}}],[\"重平衡策略名\",{\"1\":{\"1266\":1}}],[\"重平衡可能会将一个队列的消费负载从一个消费者切换到另一个消费者\",{\"1\":{\"1208\":1}}],[\"重平衡完毕之后开始拉取消息\",{\"1\":{\"1252\":1}}],[\"重平衡完\",{\"1\":{\"1168\":1}}],[\"重平衡完成后\",{\"1\":{\"1133\":1}}],[\"重平衡会创建拉取请求\",{\"1\":{\"1158\":1}}],[\"重平衡将为消费者负载的队列创建拉取请求并放入队列\",{\"1\":{\"1152\":1}}],[\"重平衡后向\",{\"1\":{\"1219\":1}}],[\"重平衡后尝试释放\",{\"1\":{\"1215\":1}}],[\"重平衡后该消费者新分配到的的消息队列\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"重平衡后更新处理队列\",{\"0\":{\"1224\":1},\"1\":{\"1214\":1}}],[\"重平衡后更新\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"重平衡后更新订阅的队列和处理队列表\",{\"0\":{\"1144\":1}}],[\"重平衡后调用拉取消息方法\",{\"1\":{\"1120\":1}}],[\"重平衡入口\",{\"0\":{\"1142\":1}}],[\"重平衡队列分配策略\",{\"0\":{\"1138\":1}}],[\"重平衡触发\",{\"0\":{\"1136\":1}}],[\"重平衡方法会可以细分为对每个\",{\"1\":{\"1134\":1}}],[\"重平衡方法\",{\"1\":{\"1134\":1}}],[\"重平衡时\",{\"1\":{\"1224\":1}}],[\"重平衡时顺序消费\",{\"0\":{\"1208\":1}}],[\"重平衡时可能将队列分配给组内其他消费者会设置\",{\"1\":{\"1195\":1}}],[\"重平衡时对这些队列应用重分配策略进行分配\",{\"1\":{\"1133\":1}}],[\"重平衡时遍历这些\",{\"1\":{\"1133\":1}}],[\"重平衡流程\",{\"0\":{\"1130\":1,\"1135\":1,\"1137\":1}}],[\"重平衡线程调用客户端实例的重平衡方法\",{\"1\":{\"1137\":1}}],[\"重平衡线程\",{\"0\":{\"1140\":1},\"1\":{\"1129\":1,\"1136\":1}}],[\"重平衡线程每\",{\"1\":{\"1128\":1,\"1136\":1}}],[\"重平衡实现类中包含重平衡的一系列逻辑\",{\"1\":{\"1134\":1}}],[\"重平衡实现类\",{\"0\":{\"1132\":1}}],[\"重平衡实现\",{\"0\":{\"1141\":1},\"1\":{\"1129\":2}}],[\"重平衡主要涉及两个类\",{\"1\":{\"1129\":1}}],[\"重平衡类设计\",{\"0\":{\"1129\":1}}],[\"重平衡的主要逻辑其实与在客户端重平衡类似\",{\"1\":{\"1255\":1}}],[\"重平衡的实际逻辑在实现类中\",{\"1\":{\"1129\":1}}],[\"重平衡的触发\",{\"0\":{\"1128\":1}}],[\"重平衡的含义\",{\"0\":{\"1126\":1}}],[\"重平衡服务执行重平衡\",{\"1\":{\"1252\":1}}],[\"重平衡服务会周期性\",{\"1\":{\"1104\":1}}],[\"重平衡服务是客户端开始消费的起点\",{\"1\":{\"1104\":1}}],[\"重平衡\",{\"0\":{\"1098\":1,\"1124\":1},\"1\":{\"1086\":1,\"1112\":1,\"1125\":1,\"1143\":1,\"1147\":1,\"1155\":1,\"1177\":1,\"1203\":1,\"1208\":1,\"1538\":1}}],[\"重要的消息通知\",{\"1\":{\"1027\":1}}],[\"重投\",{\"0\":{\"934\":1}}],[\"重投递时\",{\"1\":{\"839\":1}}],[\"重投递线程会扫描是否有新消息被保存到\",{\"1\":{\"750\":1,\"781\":1}}],[\"重投递消息的过程就是为了建立消息的索引文件\",{\"1\":{\"750\":1,\"781\":1}}],[\"重试推送\",{\"1\":{\"1519\":1}}],[\"重试最多30次\",{\"1\":{\"1297\":1}}],[\"重试消息\",{\"0\":{\"1280\":1}}],[\"重试消费需要消费者将消费失败的消息发回给\",{\"1\":{\"1188\":1}}],[\"重试消费需要在消费结果处理的步骤中进行判断\",{\"1\":{\"1180\":1}}],[\"重试消费\",{\"0\":{\"1196\":1},\"1\":{\"1187\":1}}],[\"重试消费设计\",{\"0\":{\"1180\":1}}],[\"重试队列\",{\"1\":{\"1263\":1}}],[\"重试逻辑为先从\",{\"1\":{\"1263\":1}}],[\"重试等逻辑放到\",{\"1\":{\"1250\":1}}],[\"重试等逻辑\",{\"1\":{\"1249\":1}}],[\"重试时间间隔可以用\",{\"1\":{\"1241\":1}}],[\"重试实践按照延迟等级每次重试会递增\",{\"1\":{\"1241\":1}}],[\"重试次数\",{\"1\":{\"1280\":1}}],[\"重试次数设为\",{\"1\":{\"1233\":1}}],[\"重试次数为\",{\"1\":{\"1233\":1,\"1241\":1}}],[\"重试的时间从\",{\"1\":{\"1241\":1}}],[\"重试的时间间隔也会相应发生变化\",{\"1\":{\"1100\":1}}],[\"重试的时间间隔逐渐变长\",{\"1\":{\"1100\":1}}],[\"重试的\",{\"1\":{\"1100\":1}}],[\"重试发送\",{\"1\":{\"1040\":1}}],[\"重试机制\",{\"0\":{\"1040\":1},\"1\":{\"1100\":1}}],[\"重试投递时采用同步投递\",{\"1\":{\"858\":1}}],[\"重试\",{\"0\":{\"1100\":1},\"1\":{\"854\":1,\"1040\":1,\"1188\":1,\"1257\":1,\"1263\":2,\"1280\":1,\"1434\":1}}],[\"重启恢复\",{\"0\":{\"1421\":1}}],[\"重启恢复和元数据\",{\"0\":{\"1395\":1,\"1419\":1}}],[\"重启之后的恢复\",{\"1\":{\"1395\":1}}],[\"重启后\",{\"1\":{\"1395\":1}}],[\"重启后不会清空\",{\"1\":{\"687\":1}}],[\"重启后清空\",{\"1\":{\"687\":1}}],[\"重启等情况下的数据丢失\",{\"1\":{\"683\":1}}],[\"重启的时间相对较长\",{\"1\":{\"270\":1}}],[\"重盾奔袭\",{\"1\":{\"442\":1}}],[\"重合站位\",{\"1\":{\"425\":1}}],[\"重击\",{\"1\":{\"419\":2}}],[\"重新发送\",{\"1\":{\"1519\":2}}],[\"重新选举\",{\"1\":{\"1479\":1,\"1489\":1,\"1500\":1}}],[\"重新放入事务半消息队列的事务半消息数量\",{\"1\":{\"1468\":1}}],[\"重新放回hold列表中\",{\"1\":{\"825\":1}}],[\"重新提交\",{\"1\":{\"1428\":1}}],[\"重新创建文件\",{\"1\":{\"1427\":1}}],[\"重新排列\",{\"1\":{\"1393\":1}}],[\"重新将他放入\",{\"1\":{\"1347\":1}}],[\"重新进行\",{\"1\":{\"1143\":1}}],[\"重新分配之后\",{\"1\":{\"1137\":1,\"1142\":1}}],[\"重新拉取\",{\"1\":{\"1119\":1}}],[\"重新消费次数\",{\"1\":{\"1197\":1,\"1198\":2}}],[\"重新消费\",{\"1\":{\"1117\":2}}],[\"重新被放入拉取请求队列\",{\"1\":{\"1104\":1}}],[\"重新执行上述负载算法\",{\"1\":{\"1098\":1}}],[\"重新从\",{\"1\":{\"1039\":1}}],[\"重新load\",{\"1\":{\"999\":1}}],[\"重新投递消息到commitlog\",{\"1\":{\"845\":1,\"860\":1}}],[\"重新加载配置\",{\"1\":{\"996\":1}}],[\"重新加载\",{\"1\":{\"961\":1}}],[\"重新加载索引文件\",{\"1\":{\"793\":2}}],[\"重新加载该文件\",{\"1\":{\"143\":1}}],[\"重新编译某个模块时\",{\"1\":{\"207\":1}}],[\"重复推送消息时出现\",{\"1\":{\"1520\":1}}],[\"重复推送时会出现\",{\"1\":{\"1511\":1}}],[\"重复使用\",{\"1\":{\"1137\":1}}],[\"重复\",{\"1\":{\"147\":1,\"1237\":1}}],[\"重复代码\",{\"1\":{\"81\":1}}],[\"重写了\",{\"1\":{\"1401\":1}}],[\"重写\",{\"1\":{\"128\":1}}],[\"非管理员\",{\"1\":{\"978\":1}}],[\"非强制删除\",{\"1\":{\"870\":1}}],[\"非事务消息或commit类型的事务消息才执行分发\",{\"1\":{\"764\":1}}],[\"非全局的消息预取\",{\"1\":{\"698\":1}}],[\"非持久化消息\",{\"1\":{\"698\":1}}],[\"非持久化消息存储\",{\"1\":{\"687\":1}}],[\"非相对模块则是以当前脚本的路径作为起点\",{\"1\":{\"600\":1}}],[\"非相对模块指的是不带有路径信息的模块\",{\"1\":{\"598\":1}}],[\"非相对模块\",{\"0\":{\"598\":1},\"1\":{\"599\":1}}],[\"非常强大的输出伤害天赋\",{\"1\":{\"407\":1}}],[\"非易失\",{\"1\":{\"247\":1}}],[\"非\",{\"1\":{\"127\":1}}],[\"非阻塞模式下\",{\"1\":{\"123\":1}}],[\"非阻塞的读和写\",{\"1\":{\"116\":1}}],[\"非阻塞\",{\"1\":{\"109\":1}}],[\"处于不添加额外依赖的考虑\",{\"1\":{\"1010\":1}}],[\"处于flow状态时\",{\"1\":{\"622\":1}}],[\"处于flow状态\",{\"1\":{\"622\":7}}],[\"处于blocked状态\",{\"1\":{\"613\":1}}],[\"处于block状态\",{\"1\":{\"613\":1}}],[\"处于同一线程\",{\"1\":{\"127\":1}}],[\"处理待追加日志序号大于\",{\"1\":{\"1520\":1}}],[\"处理追加条目请求入口\",{\"1\":{\"1516\":1}}],[\"处理收到的拉票请求\",{\"1\":{\"1503\":1}}],[\"处理异常情况\",{\"1\":{\"1500\":1}}],[\"处理拉票请求\",{\"1\":{\"1503\":1}}],[\"处理拉票请求的方法是\",{\"1\":{\"1492\":1}}],[\"处理拉取消息请求\",{\"1\":{\"1061\":1}}],[\"处理拉取请求\",{\"1\":{\"812\":1,\"1149\":1}}],[\"处理心跳请求后响应\",{\"1\":{\"1500\":1}}],[\"处理心跳请求的方法是\",{\"1\":{\"1489\":1}}],[\"处理心跳响应\",{\"1\":{\"1479\":1}}],[\"处理日志复制\",{\"1\":{\"1479\":1}}],[\"处理所有客户端请求和日志复制\",{\"1\":{\"1479\":1}}],[\"处理回查请求\",{\"0\":{\"1470\":1}}],[\"处理本地事务执行结果请求时\",{\"1\":{\"1453\":1}}],[\"处理提交操作结果\",{\"1\":{\"1428\":1}}],[\"处理上次提交的错误\",{\"1\":{\"1428\":1}}],[\"处理写入请求\",{\"1\":{\"1413\":1}}],[\"处理下一个\",{\"1\":{\"1373\":1}}],[\"处理定时消息请求成功\",{\"1\":{\"1373\":1}}],[\"处理定时消息取消请求\",{\"1\":{\"1359\":1}}],[\"处理删除消息请求成功\",{\"1\":{\"1373\":1}}],[\"处理失败\",{\"1\":{\"1372\":1}}],[\"处理成功\",{\"1\":{\"1372\":1}}],[\"处理普通定时消息请求\",{\"1\":{\"1359\":1}}],[\"处理队列\",{\"1\":{\"1225\":1}}],[\"处理这批消息的消费结果\",{\"1\":{\"1218\":1}}],[\"处理这两种消费方式的消费服务也不同\",{\"1\":{\"1102\":1}}],[\"处理加锁请求\",{\"1\":{\"1214\":1}}],[\"处理结果\",{\"0\":{\"1195\":1}}],[\"处理重试消息请求\",{\"1\":{\"1188\":1}}],[\"处理消费者消费失败发回的消息\",{\"1\":{\"1198\":1}}],[\"处理消费失败的消息\",{\"1\":{\"1188\":1,\"1195\":2}}],[\"处理消费结果\",{\"1\":{\"1187\":1,\"1195\":2}}],[\"处理消息重新消费次数\",{\"1\":{\"1188\":1}}],[\"处理消息生产请求逻辑如下\",{\"1\":{\"1043\":1}}],[\"处理消息消费消息请求时\",{\"1\":{\"908\":1}}],[\"处理消息消费逻辑时\",{\"1\":{\"906\":1}}],[\"处理消息过滤的逻辑\",{\"1\":{\"767\":1}}],[\"处理消息的逻辑并不是往\",{\"1\":{\"733\":1}}],[\"处理消息\",{\"0\":{\"624\":1},\"1\":{\"671\":1}}],[\"处理顺序消费\",{\"1\":{\"1170\":1,\"1228\":1}}],[\"处理之后再向每个消费者发送消费者数量变化消息\",{\"1\":{\"1136\":1}}],[\"处理事务半消息\",{\"1\":{\"1469\":1}}],[\"处理事务\",{\"1\":{\"1053\":1}}],[\"处理压缩\",{\"1\":{\"1053\":1}}],[\"处理命名空间逻辑\",{\"1\":{\"1053\":1}}],[\"处理发送异常\",{\"1\":{\"1050\":1}}],[\"处理发送请求\",{\"0\":{\"1043\":1,\"1054\":1}}],[\"处理同步发送重试\",{\"1\":{\"1050\":1}}],[\"处理生产请求\",{\"1\":{\"1061\":1}}],[\"处理生产者发来的消息生产请求\",{\"1\":{\"1043\":1}}],[\"处理生产逻辑\",{\"1\":{\"1021\":1}}],[\"处理请求时\",{\"1\":{\"1482\":1}}],[\"处理请求前执行注册的钩子函数\",{\"1\":{\"981\":1}}],[\"处理请求\",{\"0\":{\"981\":1},\"1\":{\"1191\":1,\"1478\":1,\"1479\":1,\"1480\":1,\"1520\":1}}],[\"处理更高效\",{\"1\":{\"894\":1}}],[\"处理该拉取请求\",{\"1\":{\"825\":1}}],[\"处理consumer拉取请求\",{\"1\":{\"820\":1}}],[\"处理client端发送消息线程池的线程数\",{\"1\":{\"733\":1}}],[\"处理挂起的拉取消息请求并返回消费者\",{\"1\":{\"806\":1}}],[\"处理一个正常的消息\",{\"1\":{\"741\":1}}],[\"处理过程当中\",{\"1\":{\"729\":1}}],[\"处理过程如下\",{\"1\":{\"116\":1}}],[\"处理比\",{\"1\":{\"622\":1}}],[\"处理缓慢\",{\"1\":{\"622\":1}}],[\"处理取消的任务\",{\"1\":{\"379\":1}}],[\"处理秒级任务的schedulefrequentjobcore流程如下\",{\"1\":{\"374\":1}}],[\"处理的步骤从\",{\"1\":{\"130\":1}}],[\"处理完后切换成发送状态\",{\"1\":{\"128\":1}}],[\"处理完成后\",{\"1\":{\"125\":1}}],[\"处理器是\",{\"1\":{\"122\":2}}],[\"处理\",{\"0\":{\"1464\":1},\"1\":{\"120\":1,\"123\":1,\"135\":1,\"809\":1,\"814\":2,\"871\":1,\"872\":1,\"951\":1,\"971\":1,\"1014\":1,\"1041\":1,\"1042\":1,\"1043\":1,\"1269\":1,\"1273\":1,\"1294\":1,\"1359\":1,\"1471\":1,\"1472\":1,\"1508\":3,\"1520\":5,\"1521\":1}}],[\"处理客户端\",{\"0\":{\"1516\":1}}],[\"处理客户端拉取请求入口\",{\"1\":{\"1173\":1}}],[\"处理客户端拉取路由信息请求\",{\"1\":{\"973\":1}}],[\"处理客户端的发送消息请求\",{\"1\":{\"1056\":1}}],[\"处理客户端请求入口\",{\"1\":{\"819\":1}}],[\"处理客户端连接事件\",{\"1\":{\"123\":1}}],[\"处理客户端连接\",{\"1\":{\"118\":1}}],[\"处理客户端输入的内容\",{\"1\":{\"113\":1}}],[\"处理单个客户端连接的具体逻辑\",{\"1\":{\"113\":1}}],[\"处理和计算\",{\"1\":{\"111\":1,\"112\":1}}],[\"处理注解\",{\"0\":{\"44\":1}}],[\"作用\",{\"1\":{\"1382\":1}}],[\"作用域是块级作用域\",{\"1\":{\"517\":1}}],[\"作用就是要迅速的触发\",{\"1\":{\"127\":1}}],[\"作者\",{\"1\":{\"370\":1}}],[\"作者简介\",{\"1\":{\"286\":1}}],[\"作为唯一标识\",{\"1\":{\"1517\":1}}],[\"作为需要比较的\",{\"1\":{\"1510\":1}}],[\"作为参数传入\",{\"1\":{\"1425\":1}}],[\"作为参数的时候\",{\"1\":{\"75\":1}}],[\"作为重排后的文件\",{\"1\":{\"1417\":1}}],[\"作为重试消息\",{\"1\":{\"1198\":1}}],[\"作为分级存储元数据管理类\",{\"1\":{\"1420\":1}}],[\"作为分级存储索引文件读取的入口\",{\"1\":{\"1415\":1}}],[\"作为分级存储文件容器\",{\"1\":{\"1402\":1}}],[\"作为索引文件的容器和操作入口\",{\"1\":{\"1413\":1}}],[\"作为索引文件操作的入口\",{\"1\":{\"1412\":1}}],[\"作为保留字段\",{\"1\":{\"1352\":1}}],[\"作为任务的缓冲区\",{\"1\":{\"1348\":1}}],[\"作为表达式编译的入口\",{\"1\":{\"1321\":1}}],[\"作为金融级的业务消息中间件\",{\"1\":{\"1303\":1}}],[\"作为延迟消息放入消息存储\",{\"1\":{\"1180\":1}}],[\"作为消费的回调类\",{\"1\":{\"1102\":1}}],[\"作为消息的生产者和消费者\",{\"1\":{\"941\":1}}],[\"作为消息的路由键\",{\"1\":{\"714\":1}}],[\"作为\",{\"1\":{\"944\":1,\"1398\":1}}],[\"作为服务发现来说就应该是为可用性而设计\",{\"1\":{\"942\":1}}],[\"作为路由中心\",{\"1\":{\"942\":2}}],[\"作为路由键\",{\"0\":{\"714\":1},\"1\":{\"714\":1,\"715\":1}}],[\"作为一个折衷的方案\",{\"1\":{\"1341\":1}}],[\"作为一个底座\",{\"1\":{\"923\":1}}],[\"作为一个配置开关\",{\"1\":{\"883\":1}}],[\"作为联合类型返回\",{\"1\":{\"586\":1}}],[\"作为联合类型使用\",{\"1\":{\"514\":1}}],[\"作为奶很难救\",{\"1\":{\"492\":1}}],[\"作为治疗你不会被蛛网圈点名\",{\"1\":{\"447\":1}}],[\"作为哈希的结果\",{\"1\":{\"387\":1}}],[\"作为该项标准的主要贡献者\",{\"1\":{\"286\":1}}],[\"作为名称来注册进程\",{\"1\":{\"234\":1}}],[\"作为扩展名\",{\"1\":{\"180\":1}}],[\"作为占位符\",{\"1\":{\"176\":1}}],[\"作为附件关联到\",{\"1\":{\"121\":1}}],[\"判断其大于\",{\"1\":{\"1521\":1}}],[\"判断其状态\",{\"1\":{\"858\":1}}],[\"判断最新一个\",{\"1\":{\"1519\":1}}],[\"判断最后一个文件是否写满\",{\"1\":{\"793\":1}}],[\"判断请求的节点是否是当前的\",{\"1\":{\"1489\":1,\"1500\":2}}],[\"判断事务消息是否需要丢弃\",{\"1\":{\"1453\":1,\"1468\":1}}],[\"判断依据是预读缓存占用的内存是否超过阈值\",{\"1\":{\"1407\":1}}],[\"判断依据为\",{\"1\":{\"1371\":1}}],[\"判断缓冲区中等待上传的消息是否达到阈值\",{\"1\":{\"1403\":1}}],[\"判断缓冲区中的消息是否达到阈值\",{\"1\":{\"1388\":1}}],[\"判断缓存中该配置文件的全局白名单\",{\"1\":{\"998\":1}}],[\"判断定时消息是否需要轮转\",{\"1\":{\"1371\":1}}],[\"判断当前要消费的半消息的偏移量是否在\",{\"1\":{\"1453\":1}}],[\"判断当前消费者是否需要消费该消息\",{\"1\":{\"1333\":1}}],[\"判断当前索引数量是否小于最大索引数量\",{\"1\":{\"797\":1}}],[\"判断拉消息的消费者是否可能需要消费到这条消息\",{\"1\":{\"1324\":1}}],[\"判断拉取结果\",{\"1\":{\"1164\":1}}],[\"判断运算的结果是否都为\",{\"1\":{\"1322\":1}}],[\"判断元素在集合中是否大概率存在\",{\"1\":{\"1322\":1}}],[\"判断属性存在\",{\"1\":{\"1308\":1}}],[\"判断属性不存在\",{\"1\":{\"1308\":1}}],[\"判断消息是否包含这个\",{\"1\":{\"1305\":1}}],[\"判断消息是否需要执行多队列分发\",{\"1\":{\"1297\":1}}],[\"判断消息的事务属性\",{\"1\":{\"764\":1}}],[\"判断消费状态\",{\"1\":{\"1230\":1}}],[\"判断消费结果\",{\"1\":{\"1195\":1}}],[\"判断broker的订阅关系版本是否最新\",{\"1\":{\"1173\":1}}],[\"判断broker权限\",{\"1\":{\"1173\":1}}],[\"判断topic是否可读\",{\"1\":{\"1173\":1}}],[\"判断要丢弃的队列并丢弃\",{\"1\":{\"1137\":1,\"1144\":1,\"1224\":1}}],[\"判断自己分配到的队列是否变化\",{\"1\":{\"1130\":1}}],[\"判断该\",{\"1\":{\"1061\":2}}],[\"判断该用户是否有客户端请求的资源的相应操作权限\",{\"1\":{\"991\":1,\"1000\":1}}],[\"判断该用户是否配置在权限控制列表中\",{\"1\":{\"991\":1,\"1000\":1}}],[\"判断发过来的消息是否已经到达重新消费的重试最大次数\",{\"1\":{\"1056\":1}}],[\"判断客户端是否传过来了subscriptiondata\",{\"1\":{\"1173\":1}}],[\"判断客户端\",{\"1\":{\"991\":2,\"1000\":2}}],[\"判断成功则正常返回\",{\"1\":{\"981\":1}}],[\"判断\",{\"1\":{\"971\":1,\"1520\":1}}],[\"判断并挂起该拉取请求\",{\"1\":{\"819\":1}}],[\"判断文件列表是否为空\",{\"1\":{\"793\":1}}],[\"判断响应结果\",{\"1\":{\"348\":1}}],[\"判断某个全局变量是否存在用typeof\",{\"1\":{\"333\":1}}],[\"判断null请使用myvar\",{\"1\":{\"333\":1}}],[\"判断array要使用array\",{\"1\":{\"333\":1}}],[\"判断一个属性是否是xiaoming自身拥有的\",{\"1\":{\"299\":1}}],[\"判断是否存在\",{\"1\":{\"1511\":1}}],[\"判断是否已经写满\",{\"1\":{\"1414\":1}}],[\"判断是否通过过滤\",{\"1\":{\"1332\":1}}],[\"判断是否与消费队列中保存的\",{\"1\":{\"1314\":1}}],[\"判断是否需要回查\",{\"1\":{\"1468\":1}}],[\"判断是否需要立即提交\",{\"1\":{\"1427\":1}}],[\"判断是否需要分发构建\",{\"1\":{\"1294\":1}}],[\"判断是否需要提交偏移量\",{\"1\":{\"1159\":1}}],[\"判断是否\",{\"1\":{\"1257\":1}}],[\"判断是否拉磁盘数据\",{\"1\":{\"1174\":1}}],[\"判断是否是定时消息\",{\"1\":{\"843\":1}}],[\"判断是否有新消息到达\",{\"1\":{\"823\":1}}],[\"判断是否有数据要发送\",{\"1\":{\"125\":1}}],[\"判断是否启用长轮询\",{\"1\":{\"812\":1}}],[\"判断是否读取完毕\",{\"1\":{\"128\":1}}],[\"判断用户是否输入完成\",{\"1\":{\"125\":1}}],[\"此批消息到达上限\",{\"1\":{\"1174\":1}}],[\"此处不再赘述\",{\"1\":{\"660\":1}}],[\"此处如果用红色显示\",{\"1\":{\"655\":1}}],[\"此种情形最易显现\",{\"1\":{\"622\":3}}],[\"此任务的实现交给用户去定义\",{\"1\":{\"378\":1}}],[\"此外还需要实现拉消息\",{\"1\":{\"1249\":1}}],[\"此外还包含了一些抽象方法\",{\"1\":{\"1134\":1}}],[\"此外还有两个拉模式消费者\",{\"1\":{\"1136\":1}}],[\"此外还有一个重要的域即重分配策略类\",{\"1\":{\"1133\":1}}],[\"此外还有以下一些原因\",{\"1\":{\"942\":1}}],[\"此外还有必要用惰性队列作为仲裁队列的死信队列\",{\"1\":{\"702\":1}}],[\"此外有一个故障延迟机制\",{\"1\":{\"1029\":1}}],[\"此外\",{\"1\":{\"371\":1,\"660\":1,\"668\":1,\"722\":1,\"922\":1,\"978\":1,\"1010\":1,\"1075\":1,\"1103\":1,\"1119\":1,\"1249\":2,\"1251\":1,\"1291\":1}}],[\"此外它还能提供简单明了的基准测试结果输出\",{\"1\":{\"3\":1}}],[\"此实验规格下的\",{\"1\":{\"285\":1}}],[\"此方法对以下一些场景有奇效\",{\"1\":{\"273\":1}}],[\"此时每秒都向\",{\"1\":{\"1519\":1}}],[\"此时客户端的请求会被响应\",{\"1\":{\"1512\":1}}],[\"此时一般是已经推送完了全部的日志\",{\"1\":{\"1510\":1}}],[\"此时对端节点使用当前投票轮次进入\",{\"1\":{\"1497\":1}}],[\"此时其他节点已经是\",{\"1\":{\"1480\":1}}],[\"此时其他消费者会重新消费该消息\",{\"1\":{\"1195\":1}}],[\"此时进行重排\",{\"1\":{\"1417\":1}}],[\"此时已经切换为\",{\"1\":{\"1252\":1}}],[\"此时也会触发重平衡\",{\"1\":{\"1136\":1}}],[\"此时需人工介入处理\",{\"1\":{\"1100\":1}}],[\"此时就开始重平衡\",{\"1\":{\"1136\":1}}],[\"此时就需要重新进行负载均衡\",{\"1\":{\"1098\":1}}],[\"此时就可以实现批量化写入\",{\"1\":{\"883\":1}}],[\"此时调用\",{\"1\":{\"999\":1}}],[\"此时会调用\",{\"1\":{\"999\":1}}],[\"此时会略微增加消费时延\",{\"1\":{\"916\":1}}],[\"此时会拒绝写入新的消息\",{\"1\":{\"866\":1}}],[\"此时会删除过期的\",{\"1\":{\"866\":1}}],[\"此时并未刷盘\",{\"1\":{\"765\":1}}],[\"此时消息可以被消费者消费\",{\"1\":{\"1451\":1}}],[\"此时消息还没从内存刷到磁盘\",{\"1\":{\"765\":1}}],[\"此时消费者才可以消费到这条消息\",{\"1\":{\"920\":1}}],[\"此时消费者消费不到\",{\"1\":{\"765\":1}}],[\"此时从队列重新上线\",{\"1\":{\"693\":1}}],[\"此时第二个致命的设计缺陷显露了出来\",{\"1\":{\"678\":1}}],[\"此时b节点内部会重启\",{\"1\":{\"659\":1}}],[\"此时出现网络异常\",{\"1\":{\"659\":1}}],[\"此时该进程会暂时阻塞消息的生产\",{\"1\":{\"614\":1}}],[\"此时新worker会向server发送心跳\",{\"1\":{\"375\":1}}],[\"此时cpu\",{\"1\":{\"285\":1}}],[\"此时异常会被转化为一个描述错误的元组\",{\"1\":{\"193\":1,\"195\":1}}],[\"此时\",{\"1\":{\"128\":1,\"855\":1,\"933\":1,\"1112\":1,\"1520\":1}}],[\"此时通道已经准备好写入数据\",{\"1\":{\"125\":1}}],[\"此时通道已经准备好读取数据\",{\"1\":{\"125\":1}}],[\"操作队列的消息\",{\"1\":{\"1468\":1}}],[\"操作消息偏移量\",{\"1\":{\"1468\":1}}],[\"操作命令从\",{\"1\":{\"673\":1}}],[\"操作系统不会实际分配物理内存\",{\"1\":{\"882\":1}}],[\"操作系统才会清理掉一部分\",{\"1\":{\"879\":1}}],[\"操作系统并不会立刻就清除这个\",{\"1\":{\"879\":1}}],[\"操作系统把数据从文件中复制到\",{\"1\":{\"879\":1}}],[\"操作系统会先把数据写入到内存中的\",{\"1\":{\"879\":1}}],[\"操作系统\",{\"1\":{\"277\":1}}],[\"操作符发送消息\",{\"1\":{\"230\":1}}],[\"操作符优先级\",{\"0\":{\"216\":1}}],[\"操作其他函数的函数被称为高阶函数\",{\"1\":{\"181\":1}}],[\"操作成对括号中的内容\",{\"1\":{\"155\":1}}],[\"操作的开销\",{\"1\":{\"725\":1}}],[\"操作的文本对象\",{\"1\":{\"155\":1}}],[\"操作的一些最佳实践\",{\"1\":{\"137\":1}}],[\"操作仍由\",{\"1\":{\"128\":1}}],[\"操作进行分离\",{\"1\":{\"127\":1}}],[\"操作\",{\"1\":{\"125\":1,\"127\":2,\"141\":1,\"621\":1,\"756\":1,\"899\":1,\"900\":1}}],[\"操作和业务处理\",{\"0\":{\"125\":1},\"1\":{\"124\":1}}],[\"缓冲和上传\",{\"1\":{\"1403\":1}}],[\"缓冲区没有满\",{\"1\":{\"1427\":1}}],[\"缓冲区和\",{\"1\":{\"1403\":1}}],[\"缓冲区满\",{\"1\":{\"1403\":1,\"1427\":1}}],[\"缓冲区高低水位的配置\",{\"1\":{\"1299\":1}}],[\"缓冲区\",{\"1\":{\"73\":1,\"118\":1,\"1427\":3}}],[\"缓存的\",{\"1\":{\"1407\":1,\"1517\":1}}],[\"缓存项在\",{\"1\":{\"1406\":1}}],[\"缓存中的数据上传到二级存储\",{\"1\":{\"1403\":1}}],[\"缓存中的数据上传到分级存储\",{\"1\":{\"1403\":1}}],[\"缓存其结果\",{\"1\":{\"896\":1,\"917\":1}}],[\"缓存\",{\"0\":{\"895\":1},\"1\":{\"644\":1,\"997\":1,\"1190\":1}}],[\"缓存系统\",{\"1\":{\"384\":1}}],[\"缓存每次读取的内容\",{\"1\":{\"124\":1}}],[\"附\",{\"1\":{\"1235\":1}}],[\"附魔武器\",{\"1\":{\"486\":1}}],[\"附魔戒指\",{\"1\":{\"486\":1}}],[\"附魔靴子\",{\"1\":{\"486\":1}}],[\"附魔胸甲\",{\"1\":{\"486\":1}}],[\"附魔披风\",{\"1\":{\"486\":1}}],[\"附魔\",{\"0\":{\"486\":1}}],[\"附件\",{\"1\":{\"122\":1}}],[\"附加的一个对象\",{\"1\":{\"118\":1}}],[\"取而代之则是上文介绍的\",{\"1\":{\"1300\":1}}],[\"取自\",{\"1\":{\"1017\":1}}],[\"取值\",{\"1\":{\"983\":1}}],[\"取值器用来读取属性\",{\"1\":{\"567\":1}}],[\"取每个\",{\"1\":{\"954\":1}}],[\"取出最后\",{\"1\":{\"1427\":1}}],[\"取出到期的\",{\"1\":{\"1373\":1}}],[\"取出\",{\"1\":{\"1356\":1}}],[\"取出来\",{\"1\":{\"1300\":1}}],[\"取出执行一次\",{\"1\":{\"1152\":1}}],[\"取出挂起的拉起请求并执行\",{\"1\":{\"816\":1}}],[\"取出之前关联到\",{\"1\":{\"122\":1}}],[\"取决于在哪里使用它们\",{\"1\":{\"506\":1}}],[\"取反运算\",{\"1\":{\"503\":1}}],[\"取\",{\"1\":{\"396\":2,\"1517\":1}}],[\"取消定时请求\",{\"1\":{\"1372\":1}}],[\"取消投递\",{\"1\":{\"1359\":1}}],[\"取消订阅\",{\"1\":{\"1117\":1}}],[\"取消息\",{\"1\":{\"1061\":2}}],[\"取消消息\",{\"1\":{\"935\":1}}],[\"取消功能的难度没有那么大\",{\"1\":{\"935\":1}}],[\"取消这个效果之后\",{\"1\":{\"487\":1}}],[\"取消\",{\"1\":{\"379\":1}}],[\"取余高效地计算任务在时间轮的所属下标\",{\"1\":{\"379\":1}}],[\"取第一个泛型类型\",{\"1\":{\"48\":1}}],[\"主备\",{\"1\":{\"944\":1,\"949\":1}}],[\"主流程上的分支操作\",{\"1\":{\"917\":1}}],[\"主线程直接返回\",{\"1\":{\"915\":1}}],[\"主节点地址\",{\"1\":{\"952\":1,\"970\":1}}],[\"主节点和从节点都会发送心跳和路由信息\",{\"1\":{\"952\":1}}],[\"主节点的角色会变为\",{\"1\":{\"853\":1}}],[\"主节点失效和消费者取消\",{\"0\":{\"665\":1}}],[\"主题为\",{\"1\":{\"1468\":1}}],[\"主题路由信息\",{\"1\":{\"1053\":1}}],[\"主题\",{\"1\":{\"767\":1,\"822\":1,\"1144\":1,\"1174\":1,\"1224\":1}}],[\"主副本会直接从从副本中断的地方开始复制消息\",{\"1\":{\"696\":1}}],[\"主副本的选举也需要超过半数的副本同意才行\",{\"1\":{\"695\":1}}],[\"主副本再将这些命令复制到从副本\",{\"1\":{\"695\":1}}],[\"主队列和从队列分布在集群上\",{\"1\":{\"693\":1}}],[\"主队列和从队列会分布在集群的不同节点上\",{\"1\":{\"693\":1}}],[\"主队列到从队列的复制\",{\"1\":{\"693\":1}}],[\"主队列才会向生产者发送确认\",{\"1\":{\"693\":1}}],[\"主队列会将自己接收的读\",{\"1\":{\"693\":1}}],[\"主队列选择策略\",{\"0\":{\"660\":1}}],[\"主队列加上镜像\",{\"1\":{\"657\":1}}],[\"主动触发是由消费者的启动和停止触发的\",{\"1\":{\"1136\":1}}],[\"主动触发模式可以通过以下配置来关闭\",{\"1\":{\"1128\":1}}],[\"主动触发\",{\"1\":{\"1128\":1}}],[\"主动推送消息到消费者\",{\"1\":{\"1119\":1}}],[\"主动将消息推给消费者\",{\"1\":{\"1152\":1}}],[\"主动将消息\",{\"1\":{\"1094\":1}}],[\"主动权由消费者应用控制\",{\"1\":{\"1093\":1}}],[\"主动从\",{\"1\":{\"1093\":1}}],[\"主动更新后还是找不到路由信息\",{\"1\":{\"1053\":1}}],[\"主动拉取\",{\"1\":{\"1053\":1}}],[\"主动进行通知\",{\"1\":{\"806\":1}}],[\"主动饰品备选\",{\"0\":{\"482\":1}}],[\"主动召树人增加治疗效果\",{\"1\":{\"401\":1}}],[\"主动关闭\",{\"1\":{\"125\":1}}],[\"主\",{\"1\":{\"130\":1,\"133\":1,\"135\":1}}],[\"主从切换逻辑实现类\",{\"1\":{\"1482\":1}}],[\"主从切换的\",{\"1\":{\"1481\":1}}],[\"主从同步差异\",{\"1\":{\"1519\":1}}],[\"主从同步只按顺序同步\",{\"1\":{\"930\":1}}],[\"主从同步\",{\"1\":{\"924\":1}}],[\"主从复制机制会在消息写入\",{\"1\":{\"729\":1}}],[\"主从复制流程概要\",{\"0\":{\"729\":1}}],[\"主从复制线程循环传输数据\",{\"1\":{\"726\":1}}],[\"主从复制和同步刷盘中重量级锁synchronized改为自旋锁\",{\"0\":{\"725\":1}}],[\"主从复制和同步刷盘中的生产消费模式\",{\"0\":{\"724\":1}}],[\"主从复制和同步刷盘都是多线程协作处理的\",{\"1\":{\"724\":1}}],[\"主从复制和同步刷流程中锁的优化\",{\"0\":{\"723\":1}}],[\"主从\",{\"0\":{\"130\":1,\"133\":1,\"134\":1},\"1\":{\"130\":1,\"133\":1}}],[\"主循环中\",{\"1\":{\"122\":1}}],[\"主要有两个请求等待表\",{\"1\":{\"1511\":1}}],[\"主要类的类图\",{\"1\":{\"1482\":1}}],[\"主要为\",{\"1\":{\"1333\":1}}],[\"主要介绍并发消费者的消费和消费进度上报的流程\",{\"1\":{\"1177\":1}}],[\"主要提供了通过\",{\"1\":{\"1116\":1}}],[\"主要提供了三个核心组件\",{\"1\":{\"118\":1}}],[\"主要解决了原来\",{\"1\":{\"1095\":1}}],[\"主要讲述\",{\"1\":{\"1086\":1}}],[\"主要流程\",{\"0\":{\"1011\":1}}],[\"主要是上报消息轨迹\",{\"1\":{\"1472\":1}}],[\"主要是启动\",{\"1\":{\"960\":1}}],[\"主要是消息在\",{\"1\":{\"780\":1}}],[\"主要原因是\",{\"1\":{\"942\":1}}],[\"主要包含两个功能\",{\"1\":{\"941\":1}}],[\"主要优化了消息生产的速度和大量队列情况下消息消费的速度\",{\"1\":{\"917\":1}}],[\"主要的思想就是将原先的每条消息都通知一次转化为批通知\",{\"1\":{\"916\":1}}],[\"主要用于\",{\"1\":{\"1318\":1}}],[\"主要用于管理命令触发的消息消费\",{\"1\":{\"1187\":1}}],[\"主要用于构建高并发\",{\"1\":{\"372\":1}}],[\"主要用途是表示对象的合成\",{\"1\":{\"516\":1}}],[\"主要关注两个部分\",{\"1\":{\"374\":1}}],[\"主要工作还是接收\",{\"1\":{\"132\":1}}],[\"主要由两部分组成\",{\"1\":{\"689\":1}}],[\"主要由底层工具库使用\",{\"1\":{\"44\":1}}],[\"主要由编译器使用\",{\"1\":{\"44\":1}}],[\"关机恢复从倒数第3个commitlog文件开始重新转发消息生成consumequeue\",{\"1\":{\"765\":1}}],[\"关于这两个\",{\"1\":{\"899\":1}}],[\"关于消息消费的\",{\"1\":{\"746\":1}}],[\"关于第二个问题\",{\"1\":{\"492\":1}}],[\"关于第一个问题\",{\"1\":{\"492\":1}}],[\"关于奶要不要打伤害这个问题\",{\"1\":{\"412\":1}}],[\"关于翡翠灌注和欣欣向荣\",{\"1\":{\"403\":1}}],[\"关于结界和丰饶\",{\"1\":{\"403\":1}}],[\"关于文中的内容有疑问或者希望讨论的可以直接在帖子里回复\",{\"1\":{\"399\":1}}],[\"关键字\",{\"0\":{\"570\":1},\"1\":{\"570\":1}}],[\"关键字调用构造函数\",{\"1\":{\"341\":1}}],[\"关键流程解析\",{\"0\":{\"373\":1}}],[\"关键时候方能\",{\"1\":{\"286\":1}}],[\"关键注解\",{\"1\":{\"12\":1}}],[\"关联的所有注册信息\",{\"1\":{\"234\":1}}],[\"关联的处理器\",{\"1\":{\"122\":1}}],[\"关卡防止在某个\",{\"1\":{\"186\":1}}],[\"关卡序列\",{\"1\":{\"186\":1}}],[\"关卡由一系列关卡表达式组成\",{\"1\":{\"186\":1}}],[\"关卡\",{\"0\":{\"186\":1},\"1\":{\"186\":1}}],[\"关闭与\",{\"1\":{\"972\":1}}],[\"关闭定时任务线程\",{\"1\":{\"947\":1,\"960\":1}}],[\"关闭\",{\"1\":{\"883\":1,\"947\":1,\"960\":2,\"1041\":1}}],[\"关闭文件过后多久才能强制删除\",{\"1\":{\"870\":1}}],[\"关闭端口\",{\"1\":{\"241\":1}}],[\"关闭所有其他标签页\",{\"1\":{\"154\":1}}],[\"关闭当前标签页及其中的所有窗口\",{\"1\":{\"154\":1}}],[\"关闭连接\",{\"1\":{\"125\":2}}],[\"设备和\",{\"1\":{\"1284\":1}}],[\"设为\",{\"1\":{\"1195\":1}}],[\"设为刚创建状态\",{\"1\":{\"1111\":1}}],[\"设想这样一个问题\",{\"1\":{\"941\":1}}],[\"设定了\",{\"1\":{\"925\":1}}],[\"设一个布尔值\",{\"1\":{\"903\":1}}],[\"设置日志末尾\",{\"1\":{\"1517\":1}}],[\"设置当前日志条目序号和投票轮次\",{\"1\":{\"1517\":1}}],[\"设置推送成功的回调\",{\"1\":{\"1510\":1}}],[\"设置该标志位为\",{\"1\":{\"1497\":1}}],[\"设置该队列的最新拉取时间为当前时间\",{\"1\":{\"1170\":1}}],[\"设置下一次拉票时间\",{\"1\":{\"1497\":1}}],[\"设置自己投票的\",{\"1\":{\"1492\":1}}],[\"设置请求头中的\",{\"1\":{\"1472\":1}}],[\"设置事务半消息的\",{\"1\":{\"1463\":1}}],[\"设置原始消息的\",{\"1\":{\"1449\":1}}],[\"设置之前定义的本地事务执行和回查监听器实例\",{\"1\":{\"1443\":1}}],[\"设置之前已经锁定过\",{\"1\":{\"1228\":1}}],[\"设置索引文件状态为\",{\"1\":{\"1435\":1}}],[\"设置成org\",{\"1\":{\"1382\":1}}],[\"设置成集群名称\",{\"1\":{\"1235\":1}}],[\"设置在构造消费队列时\",{\"1\":{\"1308\":1,\"1315\":1,\"1323\":1}}],[\"设置要拉取的偏移量\",{\"1\":{\"1228\":1}}],[\"设置了超时时间\",{\"1\":{\"1212\":1}}],[\"设置延迟等级\",{\"1\":{\"1197\":1}}],[\"设置延迟level为5\",{\"1\":{\"835\":1}}],[\"设置id\",{\"1\":{\"1173\":1}}],[\"设置过滤表达式\",{\"1\":{\"1170\":1}}],[\"设置到返回体\",{\"1\":{\"1163\":1}}],[\"设置每个队列的拉取流控\",{\"1\":{\"1145\":1}}],[\"设置集群的\",{\"1\":{\"1077\":1}}],[\"设置一个存储阈值\",{\"1\":{\"1065\":1}}],[\"设置服务状态为\",{\"1\":{\"1037\":1,\"1047\":1}}],[\"设置服务端\",{\"1\":{\"121\":1}}],[\"设置状态为\",{\"1\":{\"1037\":1}}],[\"设置消费开始时间戳\",{\"1\":{\"1195\":1}}],[\"设置消费组名\",{\"1\":{\"1020\":1}}],[\"设置消息属性\",{\"1\":{\"1309\":1,\"1459\":1}}],[\"设置消息\",{\"1\":{\"1306\":1}}],[\"设置消息的全局唯一\",{\"1\":{\"1042\":1,\"1053\":1}}],[\"设置消息轨迹类型\",{\"1\":{\"1020\":1}}],[\"设置使用\",{\"1\":{\"894\":1}}],[\"设置\",{\"1\":{\"712\":1,\"1137\":1,\"1195\":1,\"1241\":1,\"1276\":1,\"1278\":1,\"1300\":1,\"1489\":1,\"1500\":1,\"1519\":2}}],[\"设置队列的长度限制非常重要\",{\"1\":{\"702\":1}}],[\"设置为\",{\"1\":{\"665\":1,\"1463\":1,\"1519\":2}}],[\"设置专用的检测模型\",{\"1\":{\"278\":1}}],[\"设置输出内容为json\",{\"1\":{\"266\":1}}],[\"设置进程等待接收消息的最长时间\",{\"1\":{\"232\":1}}],[\"设置非阻塞模式\",{\"1\":{\"124\":1}}],[\"设置非阻塞\",{\"1\":{\"124\":1}}],[\"设置映射关系\",{\"0\":{\"90\":1},\"1\":{\"90\":1}}],[\"设计文档\",{\"1\":{\"1473\":1}}],[\"设计思路\",{\"0\":{\"1345\":1}}],[\"设计了两层过滤机制\",{\"1\":{\"1313\":1}}],[\"设计成有多个\",{\"1\":{\"1126\":1}}],[\"设计篇\",{\"1\":{\"1022\":1}}],[\"设计与实现\",{\"1\":{\"938\":1}}],[\"设计和实现\",{\"0\":{\"923\":1}}],[\"设计上预留了手动删除的接口\",{\"1\":{\"866\":1}}],[\"设计缺陷\",{\"0\":{\"677\":1,\"678\":1}}],[\"设计到选择和管理\",{\"1\":{\"131\":1}}],[\"设计\",{\"0\":{\"120\":1,\"1212\":1},\"1\":{\"774\":1,\"785\":1,\"798\":1,\"1001\":1,\"1105\":1}}],[\"直写分布式文件系统通常需要依赖特定\",{\"1\":{\"1385\":1}}],[\"直写\",{\"1\":{\"1385\":1}}],[\"直到找到需要截断的日志序号\",{\"1\":{\"1519\":1}}],[\"直到找到足够的索引项或者达到最大查询次数\",{\"1\":{\"1436\":1}}],[\"直到找到足够的索引项\",{\"1\":{\"1415\":1,\"1436\":1}}],[\"直到当前这一秒结束\",{\"1\":{\"1519\":1}}],[\"直到没有新的半消息或处理持续时间超过\",{\"1\":{\"1453\":1}}],[\"直到缩到只有一条消息\",{\"1\":{\"1408\":1,\"1432\":1}}],[\"直到成功放入\",{\"1\":{\"1370\":1}}],[\"直到下降到低水位线\",{\"1\":{\"1300\":1}}],[\"直到i\",{\"1\":{\"1299\":1}}],[\"直到30次都失败\",{\"1\":{\"1297\":1}}],[\"直到超过请求的\",{\"1\":{\"1257\":1}}],[\"直到消费时间到期\",{\"1\":{\"1217\":1}}],[\"直到消息被消费或者从内存中删除\",{\"1\":{\"702\":1}}],[\"直到该队列的消息消费完或者超过最大消费时间\",{\"1\":{\"1206\":1}}],[\"直到该消息投递成功\",{\"1\":{\"934\":1}}],[\"直到该任务投递成功\",{\"1\":{\"860\":1}}],[\"直到新消息来唤醒线程\",{\"1\":{\"915\":1}}],[\"直到重新投递成功\",{\"1\":{\"854\":1}}],[\"直到轮询时间超过设定的阈值才会返回\",{\"1\":{\"804\":1}}],[\"直到读完或者读到查询消息数的最大值\",{\"1\":{\"767\":1,\"1174\":1}}],[\"直到所有镜像都授予它信用值\",{\"1\":{\"664\":1}}],[\"直到获得新的信用值\",{\"1\":{\"621\":1}}],[\"直到对应项恢复正常\",{\"1\":{\"613\":1}}],[\"直到被javascript引擎捕获\",{\"1\":{\"358\":1}}],[\"直到\",{\"1\":{\"340\":1,\"406\":1,\"627\":1,\"1027\":1}}],[\"直到某个关卡成功为止\",{\"1\":{\"188\":1}}],[\"直到匹配成功\",{\"1\":{\"187\":1,\"194\":1}}],[\"直到客户端输入换行符时将缓存的字符串进行处理\",{\"1\":{\"125\":1}}],[\"直到线程停止\",{\"1\":{\"122\":1}}],[\"直到至少有一个通道的\",{\"1\":{\"122\":1}}],[\"直到至少有一个\",{\"1\":{\"118\":1}}],[\"直接写本地磁盘的延迟会小于跨可用区的延迟\",{\"1\":{\"1385\":1}}],[\"直接跳过\",{\"1\":{\"1371\":1}}],[\"直接加入到\",{\"1\":{\"1356\":1,\"1371\":1}}],[\"直接可以表示下一段时间\",{\"1\":{\"1351\":1}}],[\"直接消费\",{\"1\":{\"1230\":1}}],[\"直接消费消息的方法\",{\"1\":{\"1187\":1}}],[\"直接将所有拉取的消息构造成一个消费请求并提交\",{\"1\":{\"1194\":1}}],[\"直接运行如下命令\",{\"1\":{\"1079\":1}}],[\"直接通过\",{\"1\":{\"1000\":2}}],[\"直接传入\",{\"1\":{\"894\":1}}],[\"直接从队列中移除\",{\"1\":{\"861\":1}}],[\"直接返回成功\",{\"1\":{\"1518\":1}}],[\"直接返回消息未找到\",{\"1\":{\"825\":2}}],[\"直接返回该文件\",{\"1\":{\"789\":1,\"793\":1}}],[\"直接返回\",{\"1\":{\"765\":2,\"794\":1,\"1027\":1,\"1255\":1,\"1276\":2,\"1328\":1,\"1333\":1,\"1391\":1,\"1497\":1,\"1511\":1,\"1519\":2,\"1520\":4}}],[\"直接get\",{\"1\":{\"742\":1}}],[\"直接冲到安全的跑道\",{\"1\":{\"471\":1}}],[\"直接拉脆骨法师\",{\"1\":{\"458\":1}}],[\"直接野性成长接万灵\",{\"1\":{\"448\":1}}],[\"直接互相发数据吧\",{\"1\":{\"368\":1}}],[\"直接对module\",{\"1\":{\"365\":1}}],[\"直接使用官方打包好的镜像\",{\"1\":{\"1076\":1}}],[\"直接使用消息的\",{\"1\":{\"715\":1}}],[\"直接使用最新的ecmascript\",{\"1\":{\"360\":1}}],[\"直接使用new\",{\"1\":{\"114\":1}}],[\"直接给array的length赋一个新的值会导致array大小的变化\",{\"1\":{\"298\":1}}],[\"直接用\",{\"1\":{\"273\":1}}],[\"直接执行静态方法\",{\"0\":{\"267\":1}}],[\"直接连接远程计算机上运行的erlang系统\",{\"1\":{\"171\":1}}],[\"直接复制粘贴系统剪贴板内容\",{\"1\":{\"158\":1}}],[\"直接关闭连接\",{\"1\":{\"128\":1}}],[\"直接创建\",{\"1\":{\"121\":1}}],[\"被挂起的\",{\"1\":{\"1512\":1,\"1521\":1}}],[\"被过滤\",{\"1\":{\"1427\":1}}],[\"被创建\",{\"1\":{\"1395\":1}}],[\"被削减的\",{\"1\":{\"1379\":1}}],[\"被定时的消息\",{\"1\":{\"1346\":1}}],[\"被调用后\",{\"1\":{\"1300\":1}}],[\"被调用函数可能会抛出这个异常错误\",{\"1\":{\"193\":1}}],[\"被丢弃则放弃消费\",{\"1\":{\"1188\":1}}],[\"被动触发\",{\"1\":{\"1136\":1}}],[\"被动饰品备选\",{\"0\":{\"483\":1}}],[\"被关闭\",{\"1\":{\"972\":1}}],[\"被客户端拉取\",{\"1\":{\"945\":1}}],[\"被认为是不可信数据\",{\"1\":{\"883\":1}}],[\"被其他线程占用\",{\"1\":{\"866\":1}}],[\"被删除\",{\"1\":{\"847\":1}}],[\"被\",{\"1\":{\"815\":1,\"945\":1}}],[\"被putmessagepositioninfowrapper调用\",{\"1\":{\"765\":1}}],[\"被用于做线程之间的异步通知\",{\"1\":{\"726\":1}}],[\"被用作路由键\",{\"1\":{\"715\":1}}],[\"被添加到交换器时\",{\"1\":{\"716\":1}}],[\"被正确安装\",{\"1\":{\"645\":1}}],[\"被追踪的信息保存在rabbit\",{\"1\":{\"624\":1}}],[\"被阻塞\",{\"1\":{\"622\":1}}],[\"被熔浆火花\",{\"1\":{\"472\":1}}],[\"被缝针点名时开减伤\",{\"1\":{\"459\":1}}],[\"被通灵箭点名的人要开减伤\",{\"1\":{\"458\":1}}],[\"被深重呕吐点名时变熊并且开个减\",{\"1\":{\"457\":1}}],[\"被标记为猎物点名时开个减\",{\"1\":{\"453\":1}}],[\"被吓傻了\",{\"1\":{\"428\":1}}],[\"被重新施加时\",{\"1\":{\"419\":1}}],[\"被slow\",{\"1\":{\"379\":1}}],[\"被称为该表的键\",{\"1\":{\"248\":1}}],[\"被执行\",{\"1\":{\"187\":1}}],[\"被多个消费者同时消费来加快消费速率\",{\"1\":{\"1126\":1}}],[\"被多个\",{\"1\":{\"135\":1}}],[\"被触发\",{\"1\":{\"122\":1}}],[\"被注册的通道\",{\"1\":{\"118\":1}}],[\"被屏蔽\",{\"1\":{\"34\":1}}],[\"第2版\",{\"1\":{\"884\":1,\"974\":1,\"1504\":1,\"1522\":1}}],[\"第三个参数\",{\"1\":{\"1006\":1,\"1007\":1}}],[\"第三个参数用来指定缩进\",{\"1\":{\"337\":1}}],[\"第三个为2\",{\"1\":{\"582\":1}}],[\"第三轮或第四轮\",{\"1\":{\"433\":1}}],[\"第一层过滤\",{\"0\":{\"1325\":1}}],[\"第一层利用布隆过滤器判断这个消息是否大概率要被对应的消费者拉取\",{\"1\":{\"1322\":1}}],[\"第一层根据消费队列过滤主要是用来在许多消费组之间筛选出有可能匹配的消费组\",{\"1\":{\"1315\":1}}],[\"第一点可以在并发消费的基础上修改消费线程池的逻辑\",{\"1\":{\"1204\":1}}],[\"第一阶段生产者\",{\"1\":{\"724\":1}}],[\"第一波大波次也可以开野性之心星火来奶\",{\"1\":{\"461\":1}}],[\"第一时间转火\",{\"1\":{\"442\":1}}],[\"第一次拉取\",{\"1\":{\"1228\":1}}],[\"第一次查询\",{\"1\":{\"1039\":1}}],[\"第一次调用该方法时尝试从\",{\"1\":{\"897\":1}}],[\"第一次拒绝删除之后能保留文件的最大时间\",{\"1\":{\"870\":1}}],[\"第一次执行会报如下错误\",{\"1\":{\"643\":1}}],[\"第一次走一步\",{\"1\":{\"453\":1}}],[\"第一次奶\",{\"1\":{\"433\":1}}],[\"第一次打\",{\"1\":{\"428\":1}}],[\"第一次把javascript带入到后端服务器开发\",{\"1\":{\"360\":1}}],[\"第一个场景下\",{\"1\":{\"931\":1}}],[\"第一个成员的值默认为整数0\",{\"1\":{\"582\":1}}],[\"第一个参数就是需要绑定的this变量\",{\"1\":{\"318\":1}}],[\"第一个元素称为列表头\",{\"1\":{\"177\":1}}],[\"第一个进程执行测试\",{\"1\":{\"11\":1}}],[\"第二层则执行精确的过滤匹配\",{\"1\":{\"1322\":1}}],[\"第二层过滤的时间占用减少了\",{\"1\":{\"1325\":1}}],[\"第二层过滤\",{\"1\":{\"1315\":1}}],[\"第二点需要用到多个锁来保证\",{\"1\":{\"1204\":1}}],[\"第二版\",{\"1\":{\"1057\":1}}],[\"第二次使用默认主题查询\",{\"1\":{\"1051\":1}}],[\"第二次走两步就行\",{\"1\":{\"453\":1}}],[\"第二份是修改后的\",{\"1\":{\"737\":1}}],[\"第二波怪可以卡视角规避沉默\",{\"1\":{\"468\":1}}],[\"第二阶段放蛛网的人需要重点刷血\",{\"1\":{\"447\":1}}],[\"第二个场景就需要对定时消息的投递做流控和失败重试\",{\"1\":{\"931\":1}}],[\"第二个为1\",{\"1\":{\"582\":1}}],[\"第二个\",{\"1\":{\"465\":1}}],[\"第二个小\",{\"1\":{\"428\":1}}],[\"第二个参数即启用消息轨迹\",{\"1\":{\"1006\":1,\"1007\":1}}],[\"第二个参数用于筛选需要输出的属性\",{\"1\":{\"337\":1}}],[\"第二个参数是array\",{\"1\":{\"318\":1}}],[\"第二个参数可以是上面\",{\"1\":{\"118\":1}}],[\"第二部分中\",{\"1\":{\"275\":1}}],[\"让主节点发送\",{\"1\":{\"1520\":1}}],[\"让定时消息不受老化时间的限制\",{\"1\":{\"1343\":1}}],[\"让这条消息的可见时间推迟了\",{\"1\":{\"1251\":1}}],[\"让这个队列不可用\",{\"1\":{\"678\":1}}],[\"让其他队列也有被消费到的机会\",{\"1\":{\"1206\":1}}],[\"让其保存消息在定时消息存储中的位点\",{\"1\":{\"930\":1}}],[\"让同一\",{\"1\":{\"1203\":1}}],[\"让用户在使用时感觉像\",{\"1\":{\"1119\":1}}],[\"让用户留在当前页面中\",{\"1\":{\"347\":1}}],[\"让生产者发送消息时也能够查询到\",{\"1\":{\"1039\":1}}],[\"让他能够在发送请求时起作用\",{\"1\":{\"988\":1}}],[\"让我们来设想这两个场景\",{\"1\":{\"931\":1}}],[\"让消费进度管理器更新消费进度\",{\"1\":{\"1191\":1}}],[\"让消费服务消费\",{\"1\":{\"1149\":1}}],[\"让消费者可以消费\",{\"1\":{\"930\":1}}],[\"让消息看似主动从\",{\"1\":{\"1147\":1}}],[\"让消息必须保存在磁盘中\",{\"1\":{\"681\":1}}],[\"让工作线程去处理\",{\"1\":{\"915\":1}}],[\"让挂起的拉取请求立刻进行处理\",{\"1\":{\"806\":1}}],[\"让挂起的拉取请求立刻进行拉取操作\",{\"1\":{\"806\":1}}],[\"让节点间负载均衡\",{\"1\":{\"707\":1}}],[\"让整个镜像队列仍然保持可用\",{\"1\":{\"693\":1}}],[\"让整个队列有很好的弹性\",{\"1\":{\"690\":1}}],[\"让本来通不过类型检查的代码能够通过\",{\"1\":{\"589\":1}}],[\"让队员不要在侵蚀喷涌\",{\"1\":{\"447\":1}}],[\"让你更频繁地使用小迅捷\",{\"1\":{\"405\":1}}],[\"让你能用一个技能就上\",{\"1\":{\"405\":1}}],[\"让它们切换对应消费者组和\",{\"1\":{\"1248\":1}}],[\"让它变得很灵活\",{\"1\":{\"405\":1}}],[\"让它能够处理最新订阅的\",{\"1\":{\"124\":1}}],[\"让使用者可以通过简单的业务逻辑开发完成并行任务设计开发\",{\"1\":{\"371\":1}}],[\"让所有创建的对象共享一个\",{\"1\":{\"341\":1}}],[\"让应用\",{\"1\":{\"276\":1}}],[\"让任何进程都能与该进程通信\",{\"1\":{\"234\":1}}],[\"让\",{\"1\":{\"118\":1,\"121\":1,\"132\":1,\"133\":1,\"191\":1,\"438\":1,\"611\":1,\"1200\":2,\"1209\":1}}],[\"到所有\",{\"1\":{\"1516\":1,\"1518\":1}}],[\"到缓冲区的一条消息\",{\"1\":{\"1427\":1}}],[\"到分级存储\",{\"1\":{\"1403\":2,\"1417\":1,\"1427\":1}}],[\"到下一个消费队列索引\",{\"1\":{\"1370\":1}}],[\"到期则投递到真正的\",{\"1\":{\"1342\":1}}],[\"到队列\",{\"1\":{\"1270\":1}}],[\"到队列中\",{\"1\":{\"916\":1}}],[\"到内存\",{\"1\":{\"1270\":1}}],[\"到的消息\",{\"1\":{\"1258\":1}}],[\"到消息\",{\"1\":{\"1257\":1}}],[\"到达水位线后\",{\"1\":{\"1300\":1}}],[\"到达高水位线后调用\",{\"1\":{\"1300\":1}}],[\"到达唤醒重试时间\",{\"1\":{\"1261\":1}}],[\"到达\",{\"1\":{\"1241\":1}}],[\"到达了流的末尾\",{\"1\":{\"125\":1}}],[\"到那时同一个消费组中的订阅关系必须一致\",{\"1\":{\"1239\":1}}],[\"到底是生产方没有发送\",{\"1\":{\"1003\":1}}],[\"到磁盘来保证数据的一致性和持久性\",{\"1\":{\"942\":1}}],[\"到了设置的每天固定删除时间\",{\"1\":{\"870\":1}}],[\"到投递时间时执行\",{\"1\":{\"845\":1,\"860\":1}}],[\"到其他节点的方式来提升消息的高可用性\",{\"1\":{\"648\":1}}],[\"到最远\",{\"1\":{\"490\":1}}],[\"到函数顶部\",{\"1\":{\"311\":1}}],[\"到索引3结束\",{\"1\":{\"298\":1}}],[\"到2025年\",{\"1\":{\"276\":1}}],[\"到编译器选项列表中\",{\"1\":{\"203\":1}}],[\"到单独的\",{\"1\":{\"127\":1}}],[\"到对应的处理器中进行处理\",{\"1\":{\"119\":1}}],[\"到\",{\"1\":{\"118\":2,\"124\":1,\"131\":1,\"421\":1,\"789\":1,\"1257\":1,\"1260\":1,\"1262\":1,\"1348\":1,\"1357\":1}}],[\"到一个输出流\",{\"1\":{\"54\":1}}],[\"从当前消费进度开始遍历\",{\"1\":{\"1468\":1}}],[\"从当前时间格的任务链表中取出待执行的任务\",{\"1\":{\"379\":1}}],[\"从未压缩的索引文件中查询索引项\",{\"1\":{\"1436\":1}}],[\"从已压缩并上传到二级存储的索引文件中查询索引项\",{\"1\":{\"1436\":2}}],[\"从已上传分级存储的\",{\"1\":{\"1415\":1}}],[\"从二级存储中读取索引文件\",{\"1\":{\"1436\":1}}],[\"从二级存储中读取消息\",{\"0\":{\"1432\":1},\"1\":{\"1432\":1}}],[\"从二级存储拉消息\",{\"1\":{\"1431\":1}}],[\"从二级存储读消息\",{\"1\":{\"1431\":1}}],[\"从二级存储读到数据后放入缓存\",{\"1\":{\"1402\":1}}],[\"从二级存储读取消息的过程\",{\"1\":{\"1391\":1}}],[\"从缓存中读一批消息\",{\"1\":{\"1431\":1}}],[\"从缓存中读取消息\",{\"0\":{\"1431\":1}}],[\"从缓存读消息\",{\"1\":{\"1430\":1}}],[\"从读到的索引项开始遍历\",{\"1\":{\"1415\":1}}],[\"从本地获取日志数据\",{\"1\":{\"1511\":1}}],[\"从本地未压缩的索引文件中查询索引项\",{\"1\":{\"1436\":1}}],[\"从本地未压缩的临时索引文件查询\",{\"1\":{\"1415\":1}}],[\"从本地缓存中获取该\",{\"1\":{\"1137\":1}}],[\"从本地缓存中获取该消费者订阅的所有\",{\"1\":{\"1137\":1}}],[\"从本地缓存中获取\",{\"1\":{\"1130\":1}}],[\"从下到上进行调用\",{\"1\":{\"1415\":1}}],[\"从预读缓存读取\",{\"0\":{\"1409\":1}}],[\"从最后一条消息开始往前缩小\",{\"1\":{\"1408\":1,\"1432\":1}}],[\"从起始位置到结束位置遍历队列逻辑偏移量\",{\"1\":{\"1403\":1}}],[\"从分级存储预读缓存读消息\",{\"1\":{\"1431\":1}}],[\"从分级存储文件获取最小和最大偏移量\",{\"1\":{\"1430\":1,\"1432\":1}}],[\"从分级存储读消息\",{\"1\":{\"1430\":2}}],[\"从分级存储读取\",{\"0\":{\"1408\":1}}],[\"从分级存储读取消息数据\",{\"1\":{\"1405\":1}}],[\"从分级存储读取时是否启用预读缓存\",{\"1\":{\"1382\":1}}],[\"从分级存储\",{\"1\":{\"1408\":1,\"1432\":1}}],[\"从分级存储中每次读取消息的长度阈值\",{\"1\":{\"1382\":1}}],[\"从分级存储时每次读取消息数量阈值\",{\"1\":{\"1382\":1}}],[\"从时间轮和\",{\"1\":{\"1358\":1}}],[\"从时间轮中扫描到期的定时消息\",{\"1\":{\"1348\":1,\"1357\":1}}],[\"从定时消息\",{\"1\":{\"1348\":1}}],[\"从定时消息存储中查出消息\",{\"1\":{\"930\":1}}],[\"从队列中弹出\",{\"1\":{\"1342\":1}}],[\"从队列中移除该投递任务\",{\"1\":{\"861\":1}}],[\"从队列头开始扫描\",{\"1\":{\"1342\":1}}],[\"从队列偏移量表中查询当前队列偏移量\",{\"1\":{\"1296\":1}}],[\"从原始消息属性中获取分发的队列列表\",{\"1\":{\"1296\":1}}],[\"从内存中\",{\"1\":{\"1277\":1}}],[\"从内存中移除\",{\"1\":{\"1277\":1}}],[\"从内存中移除保存到磁盘的\",{\"1\":{\"1263\":1}}],[\"从内存中移除该\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"从请求头解析和构造\",{\"1\":{\"1260\":1}}],[\"从重试\",{\"1\":{\"1257\":1}}],[\"从图上可以看见\",{\"1\":{\"1251\":1}}],[\"从图中可以看出实验持续10分钟\",{\"1\":{\"284\":1}}],[\"从锁容器中获取消息队列消费锁\",{\"1\":{\"1230\":1}}],[\"从锁容器中移除\",{\"1\":{\"1214\":1}}],[\"从处理队列中取一批\",{\"1\":{\"1230\":1}}],[\"从处理队列中取一批消息\",{\"1\":{\"1218\":1}}],[\"从处理队列中移除这批已经处理过的消息\",{\"1\":{\"1188\":1}}],[\"从属性中获取\",{\"1\":{\"1188\":1}}],[\"从属性中恢复它的真实\",{\"1\":{\"857\":1}}],[\"从拉取到的消息保存的处理队列获取消息\",{\"1\":{\"1179\":1}}],[\"从拉取请求队列中获取一个拉取请求\",{\"1\":{\"1168\":1}}],[\"从拉取请求中获取处理队列\",{\"1\":{\"1159\":1}}],[\"从broker拉取消息\",{\"1\":{\"1171\":1}}],[\"从broker拉取完成的回调函数\",{\"1\":{\"1170\":1}}],[\"从filterserver上拉取消息\",{\"1\":{\"1171\":1}}],[\"从那个消费队列拉取消息\",{\"1\":{\"1170\":1}}],[\"从服务端拉取\",{\"1\":{\"1170\":1}}],[\"从消费队列中获取消费队列单元\",{\"1\":{\"1427\":1}}],[\"从消费队列中读取消息\",{\"1\":{\"767\":1,\"1174\":1}}],[\"从消费队列扩展存储中取出这个消息的布隆过滤器产生的二进制数组\",{\"1\":{\"1315\":1}}],[\"从消息属性中复原真实的\",{\"1\":{\"1469\":1}}],[\"从消息属性中取出\",{\"1\":{\"1360\":1}}],[\"从消息属性中获取它真正的\",{\"1\":{\"1218\":1}}],[\"从消息\",{\"1\":{\"1333\":1}}],[\"从消息队列中\",{\"1\":{\"1270\":1}}],[\"从消息存储\",{\"1\":{\"1188\":1}}],[\"从消息存储中查询需要拉取的一批消息\",{\"1\":{\"1164\":1}}],[\"从消息存储查询消息\",{\"1\":{\"1163\":1}}],[\"从待消费消息数量\",{\"1\":{\"1159\":1}}],[\"从阻塞队列中获取拉取请求之后\",{\"1\":{\"1159\":1}}],[\"从订阅信息中找到所有的\",{\"1\":{\"1142\":1}}],[\"从左上角第一个方框开始看\",{\"1\":{\"1104\":1}}],[\"从第三个等级开始\",{\"1\":{\"1100\":1}}],[\"从追加队列中获取一批待发送的消息轨迹数据\",{\"1\":{\"1021\":1}}],[\"从轨迹上下文获取消费前的轨迹数据\",{\"1\":{\"1020\":1}}],[\"从集群信息表中移除该\",{\"1\":{\"972\":1}}],[\"从路由表\",{\"1\":{\"957\":1,\"973\":1}}],[\"从nameserver更新\",{\"1\":{\"950\":1}}],[\"从存储获取要推送的日志数据\",{\"1\":{\"1510\":1}}],[\"从存储中获取对应的日志\",{\"1\":{\"1510\":1}}],[\"从存储中获取末尾的日志\",{\"1\":{\"1510\":1}}],[\"从存储中查询出事务半消息\",{\"1\":{\"1451\":2,\"1464\":2}}],[\"从存储中查询要被拉取的消息返回相应给消费者\",{\"1\":{\"1149\":1}}],[\"从存储中查询消息\",{\"1\":{\"814\":1}}],[\"从存储和投递两个方面详解了华为云\",{\"1\":{\"936\":1}}],[\"从投递位移之后开始扫描消息\",{\"1\":{\"932\":1}}],[\"从中可以学习和借鉴需多东西\",{\"1\":{\"925\":1}}],[\"从中可以看出队列的主节点\",{\"1\":{\"655\":1}}],[\"从火焰图上可以看出\",{\"1\":{\"911\":1}}],[\"从火焰图上看出\",{\"1\":{\"896\":1,\"908\":1}}],[\"从火焰图中可以看到\",{\"1\":{\"896\":1}}],[\"从耗时较多的方法想办法入手优化\",{\"1\":{\"887\":1}}],[\"从磁盘消息存储中根据逻辑偏移量查询消息\",{\"1\":{\"1270\":1}}],[\"从磁盘中根据起始偏移量查询一批消息\",{\"1\":{\"1258\":1}}],[\"从磁盘中加载offsettable\",{\"1\":{\"840\":1,\"844\":1}}],[\"从磁盘重新加载数据至内存\",{\"1\":{\"882\":1}}],[\"从store中获取该队列消息的最大offset\",{\"1\":{\"825\":1}}],[\"从store中获取队列的最大偏移量\",{\"1\":{\"823\":1}}],[\"从该索引文件中根据key查找offsets\",{\"1\":{\"797\":1}}],[\"从该索引文件中根据\",{\"1\":{\"790\":1,\"797\":1}}],[\"从该索引文件到消息保存时间的时间差\",{\"1\":{\"787\":1}}],[\"从后往前遍历indexfile\",{\"1\":{\"794\":1}}],[\"从后往前遍历\",{\"1\":{\"789\":1,\"1410\":1}}],[\"从indexfile中查找消息\",{\"1\":{\"789\":1,\"794\":2}}],[\"从倒数第三个文件开始恢复\",{\"1\":{\"771\":1}}],[\"从倒数第三个文件开始往后遍历\",{\"1\":{\"753\":1,\"759\":1,\"771\":1}}],[\"从上至下分别是接入层\",{\"1\":{\"1387\":1}}],[\"从上一步拉取消息到消费者后\",{\"1\":{\"1179\":1}}],[\"从上一条消息的结束位置开始获取下一条消息\",{\"1\":{\"762\":1}}],[\"从上述结果能够看出\",{\"1\":{\"285\":1}}],[\"从这当中可以学到的是在打印日志时需要谨慎\",{\"1\":{\"722\":1}}],[\"从副本不与客户端进行交互\",{\"1\":{\"695\":1}}],[\"从rabbitmq的backing\",{\"1\":{\"690\":1}}],[\"从q1到q4\",{\"1\":{\"690\":1}}],[\"从镜像队列中消费的客户端可能希望知道他们所消费的队列已经失败转移\",{\"1\":{\"665\":1}}],[\"从节点向\",{\"1\":{\"970\":1}}],[\"从节点上想要同步\",{\"1\":{\"930\":1}}],[\"从节点的\",{\"0\":{\"910\":1}}],[\"从节点与主节点完成数据同步\",{\"1\":{\"659\":1}}],[\"从节点晋升策略\",{\"0\":{\"659\":1}}],[\"从节点和镜像策略\",{\"1\":{\"655\":1}}],[\"从节点会准确地按照主节点执行命令的顺序执行动作\",{\"1\":{\"649\":1}}],[\"从节点会提升为主节点继续向外提供服务\",{\"1\":{\"648\":1}}],[\"从节点仅仅接收主节点发送的消息\",{\"1\":{\"649\":1}}],[\"从web\",{\"1\":{\"613\":1}}],[\"从哈希环中移除物理节点\",{\"1\":{\"396\":1}}],[\"从日志表instanceinfo中查询运行状态的jobid\",{\"1\":{\"374\":1}}],[\"从jobinfo表查询所有enable状态的秒级任务\",{\"1\":{\"374\":1}}],[\"从指定索引开始删除若干元素\",{\"1\":{\"298\":1}}],[\"从索引2开始删除3个元素\",{\"1\":{\"298\":1}}],[\"从索引3开始到结束\",{\"1\":{\"298\":1}}],[\"从索引0开始\",{\"1\":{\"298\":1}}],[\"从全链路压测\",{\"1\":{\"276\":1}}],[\"从而进行消息的投递和消费\",{\"1\":{\"941\":1}}],[\"从而绕过了排序这个问题\",{\"1\":{\"925\":1}}],[\"从而在后续实际使用这个文件时提升读写性能\",{\"1\":{\"882\":1}}],[\"从而在消息分配时提供更多的均匀性\",{\"1\":{\"716\":1}}],[\"从而达到在一个节点宕机时\",{\"1\":{\"692\":1}}],[\"从而增加代码的可读性和可维护性\",{\"1\":{\"582\":1}}],[\"从而充分调度整个集群的能力\",{\"1\":{\"378\":1}}],[\"从而实现高并发\",{\"1\":{\"372\":1}}],[\"从而实现容错行为\",{\"1\":{\"251\":1}}],[\"从而停止系统\",{\"1\":{\"224\":1}}],[\"从而管理多个网络连接\",{\"1\":{\"118\":1}}],[\"从列表a中移除列表b\",{\"1\":{\"212\":1}}],[\"从列表\",{\"1\":{\"184\":1}}],[\"从行尾移动到char前一个字符\",{\"1\":{\"145\":1}}],[\"从行尾开始搜索移动到char\",{\"1\":{\"145\":1}}],[\"从客户端缓存表中获取\",{\"1\":{\"1143\":1}}],[\"从客户端\",{\"1\":{\"128\":1}}],[\"从\",{\"1\":{\"127\":1,\"130\":1,\"131\":1,\"133\":2,\"241\":1,\"310\":1,\"614\":2,\"617\":1,\"621\":1,\"733\":1,\"767\":1,\"812\":1,\"825\":1,\"845\":1,\"857\":1,\"861\":1,\"954\":3,\"957\":1,\"972\":3,\"973\":1,\"1075\":1,\"1117\":1,\"1119\":1,\"1120\":2,\"1122\":1,\"1123\":1,\"1143\":1,\"1169\":1,\"1188\":1,\"1195\":1,\"1279\":1,\"1321\":1,\"1324\":1,\"1333\":1,\"1359\":2,\"1370\":1,\"1372\":1,\"1373\":1,\"1408\":1,\"1418\":1,\"1432\":1,\"1435\":1,\"1446\":1,\"1511\":1,\"1519\":2,\"1520\":1,\"1521\":1}}],[\"从通道读取字节\",{\"1\":{\"125\":1}}],[\"从入门到精通\",{\"0\":{\"1\":1},\"1\":{\"138\":1}}],[\"个配置项注册到配置类中\",{\"1\":{\"1523\":1}}],[\"个状态\",{\"1\":{\"1510\":1}}],[\"个部分\",{\"1\":{\"1507\":1}}],[\"个心跳周期没有收到心跳包\",{\"1\":{\"1495\":1}}],[\"个心跳周期\",{\"1\":{\"1495\":1,\"1496\":1,\"1499\":1}}],[\"个心跳周期都没有半数以上成功响应\",{\"1\":{\"1488\":1}}],[\"个心跳周期内没有收到心跳请求\",{\"1\":{\"1484\":1}}],[\"个角色之间的行为和转换\",{\"1\":{\"1477\":1}}],[\"个数量级\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"个条件之一则进行回查\",{\"1\":{\"1468\":1}}],[\"个条件之一就会触发删除\",{\"1\":{\"870\":1}}],[\"个固定延迟时间\",{\"1\":{\"1338\":1}}],[\"个固定延迟时间的延迟等级\",{\"1\":{\"925\":1}}],[\"个字节的存储位置用于存储消息的\",{\"1\":{\"1319\":1}}],[\"个字符的\",{\"1\":{\"167\":1}}],[\"个消费者共享\",{\"1\":{\"1255\":1}}],[\"个消费者同时消费\",{\"1\":{\"1247\":1}}],[\"个消费者同时进行消费\",{\"1\":{\"1203\":1}}],[\"个消费线程\",{\"1\":{\"1104\":1}}],[\"个触发点\",{\"1\":{\"1136\":1}}],[\"个步骤有专门的线程进行处理\",{\"1\":{\"1508\":1}}],[\"个步骤都主要在类\",{\"1\":{\"1508\":1}}],[\"个步骤来进行分析\",{\"1\":{\"1507\":1}}],[\"个步骤\",{\"1\":{\"1086\":1,\"1156\":1,\"1252\":1}}],[\"个主要步骤\",{\"1\":{\"1508\":1}}],[\"个主节点\",{\"1\":{\"1075\":1}}],[\"个主副本\",{\"1\":{\"695\":1}}],[\"个主副本和\",{\"1\":{\"695\":1}}],[\"个工作线程\",{\"1\":{\"1021\":1}}],[\"个定时任务\",{\"1\":{\"947\":1,\"961\":1}}],[\"个模块\",{\"1\":{\"944\":1}}],[\"个索引项加载进内存\",{\"1\":{\"931\":1}}],[\"个等级改为定时任意时间\",{\"1\":{\"925\":1}}],[\"个等级之外的延迟时间\",{\"1\":{\"925\":1}}],[\"个文件\",{\"1\":{\"866\":1,\"870\":2,\"881\":1}}],[\"个延迟等级的定时消息\",{\"1\":{\"1341\":1}}],[\"个延迟等级的定时消息扫描和投递任务都是由一个\",{\"1\":{\"852\":1}}],[\"个延迟等级\",{\"1\":{\"925\":1}}],[\"个延迟等级发送延迟消息\",{\"1\":{\"852\":1}}],[\"个操作系统页\",{\"1\":{\"758\":1,\"769\":1}}],[\"个对象和\",{\"1\":{\"741\":1}}],[\"个线程同时进行消费\",{\"1\":{\"1203\":1}}],[\"个线程池\",{\"1\":{\"1021\":1}}],[\"个线程\",{\"1\":{\"733\":1,\"1055\":1,\"1155\":1,\"1165\":1,\"1179\":1,\"1187\":1,\"1217\":1}}],[\"个线程是比较合理的数值\",{\"1\":{\"733\":1}}],[\"个线程的从\",{\"1\":{\"134\":1}}],[\"个子队列\",{\"1\":{\"711\":1,\"712\":1}}],[\"个队列最多可以被\",{\"1\":{\"1247\":1}}],[\"个队列中\",{\"1\":{\"711\":1}}],[\"个队列的权重都设为\",{\"1\":{\"711\":1}}],[\"个队列与\",{\"1\":{\"711\":1}}],[\"个队列每个都设置成\",{\"1\":{\"700\":1}}],[\"个队列\",{\"1\":{\"700\":1,\"906\":1,\"1187\":1,\"1203\":1,\"1267\":1,\"1342\":1,\"1453\":1,\"1468\":1}}],[\"个从副本\",{\"1\":{\"695\":1}}],[\"个低保里的奖币换\",{\"1\":{\"485\":1}}],[\"个孔\",{\"1\":{\"485\":1}}],[\"个本里面唯一推荐树奶的本\",{\"1\":{\"443\":1}}],[\"个连击点\",{\"1\":{\"417\":1}}],[\"个目标\",{\"1\":{\"416\":1}}],[\"个额外\",{\"1\":{\"411\":1}}],[\"个脆皮\",{\"1\":{\"411\":1}}],[\"个人推荐把萌芽之叶换成赛梦\",{\"1\":{\"449\":1}}],[\"个人推荐的适合集合石的\",{\"1\":{\"423\":1}}],[\"个人副本难度评级\",{\"1\":{\"422\":1}}],[\"个人没有用过双回春\",{\"1\":{\"403\":1}}],[\"个人觉得比较好用的点主要在于一个在于支持代码中自定义实现mapreduce动态分片\",{\"1\":{\"371\":1}}],[\"个愈合的\",{\"1\":{\"405\":1}}],[\"个愈合就可以获得一个瞬发星火\",{\"1\":{\"401\":1}}],[\"个愈合\",{\"1\":{\"401\":1}}],[\"个盟友造成\",{\"1\":{\"401\":1}}],[\"个盟友恢复\",{\"1\":{\"401\":1}}],[\"个虚拟节点\",{\"1\":{\"393\":1,\"396\":2}}],[\"个节点或\",{\"1\":{\"662\":1}}],[\"个节点集群中的\",{\"1\":{\"662\":2}}],[\"个节点\",{\"1\":{\"388\":2,\"662\":2}}],[\"个节点均匀分布在范围为\",{\"1\":{\"387\":1}}],[\"个参数的函数\",{\"1\":{\"180\":1}}],[\"个\",{\"1\":{\"118\":1,\"135\":1,\"392\":1,\"411\":1,\"433\":1,\"655\":1,\"834\":1,\"836\":1,\"866\":2,\"910\":4,\"915\":1,\"925\":1,\"944\":1,\"949\":1,\"1035\":1,\"1095\":1,\"1100\":1,\"1164\":1,\"1339\":1,\"1481\":1}}],[\"个测试陷阱\",{\"1\":{\"15\":1}}],[\"写分级存储索引\",{\"0\":{\"1414\":1}}],[\"写到一个新的文件中\",{\"1\":{\"1411\":1}}],[\"写到后面发现消费涉及到的内容太多\",{\"1\":{\"1086\":1}}],[\"写消息等操作接口\",{\"1\":{\"1402\":1}}],[\"写消息逻辑由分级存储消息分发器处理\",{\"1\":{\"1388\":1}}],[\"写消息经过一次重构\",{\"1\":{\"1388\":1}}],[\"写消息\",{\"0\":{\"1388\":1,\"1400\":1,\"1403\":1,\"1426\":1},\"1\":{\"1427\":1}}],[\"写消息时写堆外内存\",{\"1\":{\"883\":1}}],[\"写缓冲区水位配置\",{\"0\":{\"1299\":1},\"1\":{\"1538\":1}}],[\"写队列数量\",{\"1\":{\"964\":1}}],[\"写数据的耗时占比比较大\",{\"1\":{\"911\":1}}],[\"写数据是完全写内存\",{\"1\":{\"883\":1}}],[\"写内存映射文件\",{\"1\":{\"756\":1}}],[\"写一下就好了\",{\"1\":{\"736\":1}}],[\"写之前要先获取一个锁\",{\"1\":{\"733\":1,\"736\":1}}],[\"写请求同步给所有从队列\",{\"1\":{\"693\":1}}],[\"写于\",{\"1\":{\"692\":1}}],[\"写起来和同步代码没啥区别\",{\"1\":{\"354\":1}}],[\"写法二\",{\"1\":{\"533\":1,\"551\":1,\"573\":1}}],[\"写法一\",{\"1\":{\"533\":1,\"551\":1,\"573\":1}}],[\"写法\",{\"1\":{\"215\":1}}],[\"写完后将将\",{\"1\":{\"125\":1}}],[\"写入底层文件\",{\"1\":{\"1509\":1}}],[\"写入位置后移\",{\"1\":{\"1435\":1}}],[\"写入索引文件\",{\"1\":{\"1434\":1,\"1509\":1}}],[\"写入索引项\",{\"0\":{\"1434\":1},\"1\":{\"1297\":1}}],[\"写入\",{\"1\":{\"1371\":2,\"1517\":1,\"1521\":1}}],[\"写入的物理偏移量\",{\"1\":{\"1368\":1}}],[\"写入的消息放入时间轮槽\",{\"1\":{\"1367\":1}}],[\"写入的时候\",{\"1\":{\"1300\":1}}],[\"写入速度将逐渐变慢\",{\"1\":{\"1364\":1}}],[\"写入时需要排序\",{\"1\":{\"1364\":1}}],[\"写入时就从一个固定位置一直写下去\",{\"1\":{\"876\":1}}],[\"写入后会在由\",{\"1\":{\"1300\":1}}],[\"写入失败返回\",{\"1\":{\"1368\":1}}],[\"写入失败\",{\"1\":{\"1297\":1,\"1434\":1}}],[\"写入consumequeue\",{\"1\":{\"1297\":2}}],[\"写入过程首先会获取写锁\",{\"1\":{\"953\":1}}],[\"写入内存中的路由表\",{\"1\":{\"953\":1}}],[\"写入消息时主要面对堆外内存\",{\"1\":{\"883\":1}}],[\"写入一个任意值\",{\"1\":{\"882\":1}}],[\"写入hash槽\",{\"1\":{\"797\":1}}],[\"写入三个参数\",{\"1\":{\"765\":1}}],[\"写入放大\",{\"0\":{\"699\":1}}],[\"写入和读取数据\",{\"1\":{\"118\":1}}],[\"写入int最低\",{\"1\":{\"54\":1}}],[\"写\",{\"1\":{\"118\":1,\"135\":1,\"733\":1,\"736\":1,\"912\":1}}],[\"指针为\",{\"1\":{\"1519\":1}}],[\"指针\",{\"1\":{\"1519\":1}}],[\"指明要消费的\",{\"1\":{\"1288\":1}}],[\"指明镜像队列的模式\",{\"1\":{\"652\":1}}],[\"指消费者主动拉取消息进行消费\",{\"1\":{\"1093\":1}}],[\"指令的加速\",{\"1\":{\"904\":1}}],[\"指内存映射文件\",{\"1\":{\"880\":1}}],[\"指引进行安装\",{\"1\":{\"644\":1}}],[\"指的是确定\",{\"1\":{\"597\":1}}],[\"指的是多个类型组成的一个新类型\",{\"1\":{\"515\":1}}],[\"指的是这些值在需要时\",{\"1\":{\"508\":1}}],[\"指向\",{\"1\":{\"1402\":1}}],[\"指向下一个索引项位置\",{\"1\":{\"1435\":1}}],[\"指向下一个链表元素\",{\"1\":{\"797\":1}}],[\"指向下一条消息位置的指针\",{\"1\":{\"786\":1}}],[\"指向rabbit\",{\"1\":{\"626\":1}}],[\"指向新创建的对象\",{\"1\":{\"341\":1}}],[\"指向哪个对象\",{\"1\":{\"318\":1}}],[\"指向array对象本身\",{\"1\":{\"303\":1}}],[\"指向当前索引\",{\"1\":{\"303\":1}}],[\"指向当前元素的值\",{\"1\":{\"303\":1}}],[\"指带有\",{\"1\":{\"180\":1}}],[\"指\",{\"1\":{\"118\":2,\"1094\":1}}],[\"指定集群和需要切换的消费组\",{\"1\":{\"1247\":1}}],[\"指定队列负载算法\",{\"1\":{\"1111\":1}}],[\"指定\",{\"1\":{\"1039\":1,\"1040\":1}}],[\"指定用户名和密码\",{\"1\":{\"979\":1}}],[\"指定配置文件路径\",{\"1\":{\"960\":1}}],[\"指定了\",{\"1\":{\"812\":1}}],[\"指定了要跟踪的事件\",{\"1\":{\"261\":1}}],[\"指定不同的\",{\"1\":{\"711\":1}}],[\"指定要被\",{\"1\":{\"636\":1}}],[\"指定要对哪些代码应用跟踪模式\",{\"1\":{\"261\":1}}],[\"指定模块定位时必须查找的其他目录\",{\"1\":{\"601\":1}}],[\"指定模块的版本号\",{\"1\":{\"203\":1}}],[\"指定非相对路径的模块与实际脚本的映射\",{\"1\":{\"601\":1}}],[\"指定使用哪一种方法\",{\"1\":{\"597\":1}}],[\"指定使用的maven版本\",{\"1\":{\"65\":1}}],[\"指定一组检查条件\",{\"1\":{\"570\":1}}],[\"指定编译后的\",{\"1\":{\"498\":1}}],[\"指定保存到其他目录\",{\"1\":{\"498\":1}}],[\"指定appid\",{\"1\":{\"374\":1}}],[\"指定调度类型\",{\"1\":{\"374\":1}}],[\"指定寄存器\",{\"1\":{\"157\":1}}],[\"指定执行的线程池\",{\"1\":{\"135\":1}}],[\"指定某个bean\",{\"1\":{\"82\":1}}],[\"指定别名\",{\"1\":{\"82\":1}}],[\"指定远程地址和端口\",{\"1\":{\"73\":1}}],[\"指定起始位置和长度\",{\"1\":{\"72\":1}}],[\"指定byte\",{\"1\":{\"53\":1}}],[\"指定输出的class版本要兼容java\",{\"1\":{\"25\":1}}],[\"前一条记录的位置\",{\"1\":{\"1352\":1}}],[\"前一个文件异步刷盘\",{\"1\":{\"793\":1}}],[\"前置检查\",{\"1\":{\"1163\":1}}],[\"前置知识\",{\"0\":{\"118\":1,\"724\":1}}],[\"前面的文件都是只读的\",{\"1\":{\"1402\":1}}],[\"前面的都是不可变的\",{\"1\":{\"1386\":1}}],[\"前面说到消息轨迹数据也以消息的形式发送到\",{\"1\":{\"1021\":1}}],[\"前面说到\",{\"1\":{\"1014\":1}}],[\"前面用\",{\"1\":{\"309\":1}}],[\"前文曾就\",{\"1\":{\"886\":1}}],[\"前缀是\",{\"1\":{\"605\":1}}],[\"前也可以先变熊一下\",{\"1\":{\"492\":1}}],[\"前都可以堆\",{\"1\":{\"476\":1}}],[\"前预铺愈合和野性\",{\"1\":{\"465\":1}}],[\"前\",{\"1\":{\"411\":2,\"1215\":1,\"1277\":1,\"1294\":1,\"1354\":1}}],[\"前列的高手也基本都是双绽放天赋\",{\"1\":{\"403\":1}}],[\"前者负责服务端与服务端的通讯\",{\"1\":{\"374\":1}}],[\"前者表示分布式系统并行化的性能和效果\",{\"1\":{\"285\":1}}],[\"前提\",{\"0\":{\"269\":1}}],[\"前向\",{\"1\":{\"149\":1}}],[\"前向搜索\",{\"1\":{\"149\":1}}],[\"前最好先安装一下配套的\",{\"1\":{\"6\":1}}],[\"缺乏观测手段\",{\"1\":{\"1003\":1}}],[\"缺乏足够信息\",{\"1\":{\"533\":1}}],[\"缺点是\",{\"1\":{\"1364\":1}}],[\"缺点则是只能判断出元素大概率存在集合中\",{\"1\":{\"1322\":1}}],[\"缺点\",{\"1\":{\"883\":1,\"928\":1}}],[\"缺少统一的框架标准\",{\"1\":{\"277\":1}}],[\"缺页中断等\",{\"1\":{\"117\":1}}],[\"缺陷\",{\"0\":{\"114\":1}}],[\"提交或回滚事务消息\",{\"1\":{\"1472\":1}}],[\"提交失败\",{\"1\":{\"1428\":1}}],[\"提交成功\",{\"1\":{\"1428\":1}}],[\"提交一个\",{\"1\":{\"1427\":1}}],[\"提交一个分级存储的\",{\"1\":{\"1403\":1}}],[\"提交拉取请求前会先判断处理队列的锁定状态\",{\"1\":{\"1228\":1}}],[\"提交消费进度\",{\"1\":{\"1218\":1}}],[\"提交消费请求到消费线程池\",{\"1\":{\"1187\":1}}],[\"提交偏移量\",{\"1\":{\"1171\":1}}],[\"提交的拉取请求\",{\"1\":{\"1155\":1}}],[\"提交给\",{\"1\":{\"1516\":1}}],[\"提交给消费线程池\",{\"1\":{\"1217\":1}}],[\"提交给消费线程池消费\",{\"1\":{\"1194\":1}}],[\"提交给消费线程池进行消费\",{\"1\":{\"1179\":1}}],[\"提交给异步发送线程池执行\",{\"1\":{\"1021\":1}}],[\"提交给发送线程池执行\",{\"1\":{\"1021\":1}}],[\"提交到消费线程池进行处理\",{\"1\":{\"1187\":1}}],[\"提交到消费线程池进行并发消费\",{\"1\":{\"1179\":1}}],[\"提交到线程池中执行\",{\"1\":{\"1021\":1}}],[\"提交到taskprocesspool线程池中执行\",{\"1\":{\"379\":1}}],[\"提交说明上的\",{\"1\":{\"894\":1}}],[\"提醒长轮询请求管理容器\",{\"1\":{\"828\":1}}],[\"提醒\",{\"1\":{\"825\":1}}],[\"提前进行计算或者用函数式接口懒加载\",{\"1\":{\"917\":1}}],[\"提前做好\",{\"1\":{\"736\":1}}],[\"提前去对准台子上的\",{\"1\":{\"459\":1}}],[\"提示缺少\",{\"1\":{\"645\":1}}],[\"提高下面循环中访问该位图的速度\",{\"1\":{\"904\":1}}],[\"提高下面循环的变量访问速度\",{\"1\":{\"904\":1}}],[\"提高编解码性能\",{\"0\":{\"892\":1}}],[\"提高消息消费的性能\",{\"1\":{\"747\":1}}],[\"提高治疗量\",{\"1\":{\"407\":1}}],[\"提高资源利用率\",{\"1\":{\"379\":1}}],[\"提高开发效率\",{\"1\":{\"372\":1}}],[\"提高系统的吞吐能力\",{\"1\":{\"116\":1}}],[\"提升性能\",{\"1\":{\"1313\":1,\"1318\":1,\"1380\":1}}],[\"提升传输效率\",{\"1\":{\"1028\":1}}],[\"提升到\",{\"1\":{\"910\":2,\"913\":1}}],[\"提升消息消费\",{\"0\":{\"910\":1}}],[\"提升效率\",{\"1\":{\"742\":1,\"883\":1}}],[\"提升了分级存储的代码可读性\",{\"1\":{\"1380\":1}}],[\"提升了消息发送的\",{\"1\":{\"886\":1}}],[\"提升了约\",{\"1\":{\"720\":1}}],[\"提升了副本的理解\",{\"1\":{\"399\":1}}],[\"提升移动速度\",{\"1\":{\"477\":1}}],[\"提升\",{\"0\":{\"853\":1,\"898\":1},\"1\":{\"311\":1}}],[\"提出了openchaos后续的发展方向\",{\"1\":{\"275\":1}}],[\"提取\",{\"1\":{\"191\":1}}],[\"提取1到n的所有a值\",{\"1\":{\"184\":1}}],[\"提取列表元素\",{\"1\":{\"177\":1}}],[\"提供分布式事务功能\",{\"1\":{\"1028\":1}}],[\"提供仲裁队列的原因\",{\"1\":{\"692\":1}}],[\"提供amqqueue调用的接口\",{\"1\":{\"689\":1}}],[\"提供一个原生接口classmethoddecoratorcontext\",{\"1\":{\"606\":1}}],[\"提供前端web界面\",{\"1\":{\"371\":1}}],[\"提供工作流来编排任务解决依赖关系\",{\"1\":{\"370\":1}}],[\"提供了日志写入和读取的接口\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"提供了消费者实现的一些公用方法\",{\"1\":{\"1118\":1}}],[\"提供了消息生产和消费的钩子\",{\"1\":{\"1010\":1}}],[\"提供了发送消息的\",{\"1\":{\"1036\":1}}],[\"提供了参数\",{\"1\":{\"1029\":1}}],[\"提供了管理一个配置文件的功能\",{\"1\":{\"840\":1}}],[\"提供了importsnotusedasvalues编译设置项\",{\"1\":{\"593\":1}}],[\"提供了\",{\"1\":{\"372\":1,\"589\":1,\"659\":1,\"880\":1,\"897\":1,\"1117\":1,\"1138\":1,\"1246\":1}}],[\"提供了详细的栈跟踪信息\",{\"1\":{\"195\":1}}],[\"提供了概括信息\",{\"1\":{\"194\":1}}],[\"提供了灵活的方式编排业务\",{\"1\":{\"135\":1}}],[\"提供的安装包\",{\"1\":{\"642\":1}}],[\"提供的\",{\"1\":{\"2\":1,\"644\":1}}],[\"生产消息\",{\"0\":{\"1287\":1}}],[\"生产消息样例\",{\"1\":{\"1057\":1}}],[\"生产消息和消费消息\",{\"1\":{\"649\":1}}],[\"生产和消费的对象是异步投递的任务\",{\"1\":{\"855\":1}}],[\"生产\",{\"1\":{\"712\":1,\"913\":1,\"1187\":1}}],[\"生产者处理\",{\"1\":{\"1454\":1}}],[\"生产者处理事务状态回查请求\",{\"0\":{\"1454\":1}}],[\"生产者收到服务端事务回查请求\",{\"1\":{\"1464\":1}}],[\"生产者收到\",{\"1\":{\"1451\":1}}],[\"生产者收到消息回查请求后\",{\"1\":{\"1446\":1}}],[\"生产者第一次发送事务消息\",{\"1\":{\"1464\":1}}],[\"生产者第一次发送事务半消息\",{\"1\":{\"1451\":1}}],[\"生产者第一次发送消息时\",{\"1\":{\"945\":1}}],[\"生产者开始执行本地事务逻辑\",{\"1\":{\"1446\":1}}],[\"生产者开启消息轨迹\",{\"0\":{\"1006\":1}}],[\"生产者的运行日志如下\",{\"1\":{\"1445\":1}}],[\"生产者的钩子类是\",{\"1\":{\"1014\":1}}],[\"生产者需要知道消息要发往哪个\",{\"1\":{\"1039\":1}}],[\"生产者启动\",{\"0\":{\"1037\":1,\"1046\":1}}],[\"生产者类图\",{\"0\":{\"1036\":1}}],[\"生产者高可用\",{\"0\":{\"1032\":1}}],[\"生产者每\",{\"1\":{\"1030\":1}}],[\"生产者采集时为生产者的\",{\"1\":{\"1017\":1}}],[\"生产者采集时为\",{\"1\":{\"1017\":1}}],[\"生产者或消费者组名称\",{\"1\":{\"1017\":1}}],[\"生产者或消费者启动时\",{\"1\":{\"945\":1}}],[\"生产者使用\",{\"0\":{\"984\":1}}],[\"生产者在消息发送时如果出现失败\",{\"1\":{\"1032\":1}}],[\"生产者在发送消息前后的钩子函数中分别添加消息轨迹采集逻辑\",{\"1\":{\"1011\":1}}],[\"生产者在发送消息时为消息指定发送时间\",{\"1\":{\"832\":1}}],[\"生产者在第一次发送消息的时候从\",{\"1\":{\"942\":1}}],[\"生产者将本地事务执行状态上报给服务端\",{\"1\":{\"1446\":1}}],[\"生产者将本地事务执行结果上报给服务端\",{\"1\":{\"1446\":1}}],[\"生产者将消息发送到消息队列服务端\",{\"1\":{\"920\":2}}],[\"生产者将被完全阻塞\",{\"1\":{\"613\":1}}],[\"生产者线程将消息\",{\"1\":{\"916\":1}}],[\"生产者线程负责将到期的消息创建投递任务\",{\"1\":{\"855\":1}}],[\"生产者发送事务消息\",{\"0\":{\"1449\":1,\"1457\":1}}],[\"生产者发送了\",{\"1\":{\"1090\":1}}],[\"生产者发送生产请求\",{\"1\":{\"1061\":1}}],[\"生产者发送消息时\",{\"1\":{\"834\":1,\"1030\":1}}],[\"生产者发送一条消息\",{\"1\":{\"668\":1}}],[\"生产者可以不受影响的继续添加数据\",{\"1\":{\"724\":1}}],[\"生产者和消费者使用\",{\"1\":{\"984\":1}}],[\"生产者和消费者信息上报给\",{\"1\":{\"945\":1}}],[\"生产者和消费者仍然是操作通知任务\",{\"1\":{\"916\":1}}],[\"生产者和消费者\",{\"1\":{\"695\":1,\"1048\":1}}],[\"生产者消费者连接的节点是3进3出\",{\"1\":{\"669\":1}}],[\"生产者\",{\"0\":{\"1232\":1,\"1306\":1,\"1309\":1},\"1\":{\"668\":1,\"834\":1,\"941\":1,\"1030\":1,\"1116\":1,\"1120\":1,\"1446\":1}}],[\"生产者会一直被阻塞\",{\"1\":{\"664\":1}}],[\"生产者进行当前消息确认的前提是该消息被全部镜像接收\",{\"1\":{\"663\":1}}],[\"生产者确认和事务\",{\"0\":{\"663\":1}}],[\"生产环境不要使用\",{\"1\":{\"89\":1}}],[\"生命药水\",{\"1\":{\"485\":1}}],[\"生命值时触发\",{\"1\":{\"475\":1}}],[\"生命值越低\",{\"1\":{\"405\":1}}],[\"生命之树持续时间\",{\"1\":{\"427\":1}}],[\"生命绽放\",{\"1\":{\"419\":1,\"489\":4}}],[\"生命绽放进行最终绽放时\",{\"1\":{\"405\":1}}],[\"生命绽放的治疗效果提高\",{\"1\":{\"401\":1}}],[\"生存能力\",{\"1\":{\"400\":1}}],[\"生成布隆过滤器的位数据\",{\"1\":{\"1331\":1}}],[\"生成布隆过滤器位数组\",{\"0\":{\"1323\":1}}],[\"生成的文件\",{\"1\":{\"1321\":1}}],[\"生成的\",{\"1\":{\"1314\":1}}],[\"生成的索引顺序就会与\",{\"1\":{\"930\":1}}],[\"生成消费者过滤信息\",{\"1\":{\"1331\":1}}],[\"生成消费索引\",{\"1\":{\"1294\":1}}],[\"生成消息的消费索引之后\",{\"1\":{\"1294\":1}}],[\"生成随机数\",{\"1\":{\"1269\":1}}],[\"生成规则与生产者一样\",{\"1\":{\"1240\":1}}],[\"生成拉取请求\",{\"1\":{\"1120\":1}}],[\"生成一个事务操作消息\",{\"1\":{\"1446\":1}}],[\"生成一个新消息\",{\"1\":{\"1180\":1}}],[\"生成一个\",{\"1\":{\"1119\":1,\"1257\":1}}],[\"生成一个比\",{\"1\":{\"184\":1}}],[\"生成\",{\"1\":{\"1074\":1,\"1235\":1,\"1294\":1,\"1319\":1,\"1323\":2,\"1324\":1,\"1332\":1,\"1403\":1}}],[\"生成索引占用\",{\"1\":{\"1325\":1}}],[\"生成索引\",{\"1\":{\"834\":1}}],[\"生成时会拼接消费者的\",{\"1\":{\"1240\":1}}],[\"生成时会拼接\",{\"1\":{\"1235\":1}}],[\"生成时\",{\"1\":{\"439\":1}}],[\"生成业务报表等\",{\"1\":{\"371\":1}}],[\"生成了新的包装类型\",{\"1\":{\"333\":3}}],[\"生成式ai等能力可以进一步解决目前随机故障注入\",{\"1\":{\"277\":1}}],[\"生成器的写法是\",{\"1\":{\"184\":1}}],[\"生成器\",{\"1\":{\"184\":2}}],[\"生成响应内容并编码\",{\"1\":{\"116\":1}}],[\"发来的\",{\"1\":{\"1520\":5}}],[\"发来的推送请求会进行处理\",{\"1\":{\"1511\":1}}],[\"发来的事务消息执行状态回查请求\",{\"1\":{\"1472\":1}}],[\"发来的事务回查请求\",{\"1\":{\"1471\":1}}],[\"发到重试队列\",{\"1\":{\"1280\":2}}],[\"发请求解锁该队列\",{\"1\":{\"1225\":1}}],[\"发请求解除注册\",{\"1\":{\"1128\":1}}],[\"发请求\",{\"1\":{\"1214\":2,\"1226\":1}}],[\"发请求进行加解锁\",{\"1\":{\"1212\":1}}],[\"发回的事务半消息\",{\"1\":{\"1472\":1}}],[\"发回的半消息获取本地事务执行结果\",{\"1\":{\"1454\":1}}],[\"发回\",{\"1\":{\"1117\":1,\"1197\":1}}],[\"发给\",{\"1\":{\"1514\":1}}],[\"发给异步发送者处理\",{\"1\":{\"1020\":1}}],[\"发给所有进程\",{\"1\":{\"229\":1}}],[\"发往消息队列中的消息存在一些可观测性上的问题\",{\"1\":{\"1003\":1}}],[\"发起投票节点的投票轮次小于对端节点的个数\",{\"1\":{\"1497\":1}}],[\"发起投票后\",{\"1\":{\"1480\":1}}],[\"发起新一轮投票\",{\"1\":{\"1486\":1}}],[\"发起新的选举轮次\",{\"1\":{\"1480\":1}}],[\"发起请求\",{\"1\":{\"1478\":1,\"1479\":1,\"1480\":1}}],[\"发起一次请求\",{\"1\":{\"945\":1}}],[\"发起\",{\"1\":{\"944\":1,\"1519\":1}}],[\"发布\",{\"1\":{\"886\":1}}],[\"发布一条消息后\",{\"1\":{\"700\":1}}],[\"发布页面下载对应的\",{\"1\":{\"645\":1}}],[\"发出后\",{\"1\":{\"673\":1}}],[\"发过来的消息时\",{\"1\":{\"621\":1}}],[\"发现其他节点的心跳请求响应有更大的投票轮次\",{\"1\":{\"1479\":1}}],[\"发现\",{\"1\":{\"1079\":1,\"1510\":1,\"1519\":1}}],[\"发现如果是用\",{\"1\":{\"1075\":1}}],[\"发现创建消费索引的\",{\"1\":{\"911\":1}}],[\"发现每次主节点被分区时\",{\"1\":{\"284\":1}}],[\"发现在主节点网络断开\",{\"1\":{\"284\":1}}],[\"发生故障时\",{\"1\":{\"1033\":1}}],[\"发生故障时可以进行自动恢复\",{\"1\":{\"372\":1}}],[\"发生写\",{\"1\":{\"116\":1}}],[\"发生读\",{\"1\":{\"116\":1}}],[\"发送命令的类型\",{\"1\":{\"1519\":1}}],[\"发送命令的前后\",{\"1\":{\"994\":1}}],[\"发送日志追加请求\",{\"1\":{\"1510\":1}}],[\"发送不同类型的请求\",{\"1\":{\"1510\":1}}],[\"发送投票请求到其他节点\",{\"1\":{\"1502\":1}}],[\"发送拉票请求时\",{\"1\":{\"1491\":1}}],[\"发送拉票请求的方法是\",{\"1\":{\"1491\":1}}],[\"发送拉取请求\",{\"1\":{\"812\":1}}],[\"发送拉取消息请求\",{\"1\":{\"806\":1}}],[\"发送节点的\",{\"1\":{\"1489\":2}}],[\"发送事务执行结果\",{\"1\":{\"1472\":1}}],[\"发送事务消息结束请求\",{\"1\":{\"1460\":1}}],[\"发送事务消息\",{\"1\":{\"1458\":1,\"1459\":1}}],[\"发送本地事务执行状态到\",{\"1\":{\"1471\":1}}],[\"发送回查请求到生产者客户端\",{\"1\":{\"1469\":2}}],[\"发送回查请求给生产者组中的一个生产者\",{\"1\":{\"1453\":1}}],[\"发送最终的事务消息\",{\"1\":{\"1464\":1}}],[\"发送结束事务请求\",{\"1\":{\"1460\":1}}],[\"发送半事务消息\",{\"1\":{\"1459\":1}}],[\"发送半消息到\",{\"1\":{\"1449\":1}}],[\"发送重平衡请求\",{\"1\":{\"1331\":1}}],[\"发送重试\",{\"0\":{\"1233\":1}}],[\"发送缓冲区\",{\"1\":{\"1300\":2}}],[\"发送缓冲区中的数据会分包发送给对端\",{\"1\":{\"1300\":1}}],[\"发送到真实的\",{\"1\":{\"1446\":1}}],[\"发送到\",{\"1\":{\"1261\":1,\"1471\":1,\"1472\":1,\"1519\":1}}],[\"发送锁定队列请求\",{\"1\":{\"1224\":1,\"1226\":1}}],[\"发送消费进度更新和持久化的请求\",{\"1\":{\"1191\":1}}],[\"发送消息到\",{\"1\":{\"1446\":1}}],[\"发送消息的时候通过设置\",{\"1\":{\"1287\":1}}],[\"发送消息的请求header会类似如\",{\"1\":{\"742\":1}}],[\"发送消息处理器处理\",{\"0\":{\"1056\":1}}],[\"发送消息实现\",{\"1\":{\"1050\":1}}],[\"发送消息后\",{\"1\":{\"1039\":1}}],[\"发送消息时\",{\"1\":{\"1027\":3}}],[\"发送消息时可以从18个延迟等级中选一个\",{\"1\":{\"833\":1}}],[\"发送消息是\",{\"1\":{\"1024\":1}}],[\"发送消息轨迹的消息生产者\",{\"1\":{\"1021\":1}}],[\"发送消息\",{\"0\":{\"1042\":1,\"1053\":1},\"1\":{\"230\":1,\"639\":2,\"1038\":1,\"1050\":2,\"1234\":1,\"1339\":1,\"1507\":1}}],[\"发送异常消息\",{\"1\":{\"1163\":1}}],[\"发送异步请求\",{\"1\":{\"349\":1}}],[\"发送给\",{\"1\":{\"1149\":1,\"1191\":1}}],[\"发送注销请求\",{\"1\":{\"1136\":1}}],[\"发送的重平衡请求时触发\",{\"1\":{\"1136\":1}}],[\"发送的消息队列\",{\"1\":{\"1053\":1}}],[\"发送的拉取请求时\",{\"1\":{\"809\":1}}],[\"发送失败后的\",{\"1\":{\"1234\":1}}],[\"发送失败\",{\"1\":{\"1050\":1}}],[\"发送成功\",{\"1\":{\"1050\":1}}],[\"发送前需要做的就是将多条普通消息体编码\",{\"1\":{\"1044\":1}}],[\"发送一次消息失败后\",{\"1\":{\"1041\":2}}],[\"发送一个查询请求\",{\"1\":{\"804\":1}}],[\"发送大概率还是会失败\",{\"1\":{\"1032\":1}}],[\"发送路由信息\",{\"1\":{\"1030\":1}}],[\"发送效率最高\",{\"1\":{\"1028\":1}}],[\"发送线程不阻塞\",{\"1\":{\"1027\":1}}],[\"发送线程池将这些轨迹消息发送给指定的\",{\"1\":{\"1015\":1}}],[\"发送逻辑采用生产\",{\"1\":{\"1015\":1}}],[\"发送权限\",{\"1\":{\"978\":1}}],[\"发送心跳给\",{\"1\":{\"1137\":1}}],[\"发送心跳标识消费者的数量变化\",{\"1\":{\"1136\":1}}],[\"发送心跳等\",{\"1\":{\"1120\":1,\"1123\":1}}],[\"发送心跳请求的方法是\",{\"1\":{\"1488\":1}}],[\"发送心跳请求\",{\"1\":{\"970\":1,\"1136\":1,\"1496\":1}}],[\"发送心跳包\",{\"1\":{\"952\":1,\"954\":1,\"970\":1}}],[\"发送心跳包的定时任务在\",{\"1\":{\"952\":1}}],[\"发送心跳\",{\"1\":{\"941\":1,\"945\":1,\"1037\":1,\"1047\":1,\"1136\":1}}],[\"发送心跳的间隔可以用\",{\"1\":{\"664\":1}}],[\"发送了\",{\"1\":{\"931\":1}}],[\"发送参数优化\",{\"0\":{\"733\":1}}],[\"发送更多消息将会更平均\",{\"1\":{\"711\":1}}],[\"发送bump\",{\"1\":{\"627\":1}}],[\"发送方确认开启后\",{\"1\":{\"615\":1}}],[\"发送方确认\",{\"0\":{\"615\":1}}],[\"发送请求的节点\",{\"1\":{\"1500\":1}}],[\"发送请求给\",{\"1\":{\"1188\":1,\"1200\":1}}],[\"发送请求到生产者客户端\",{\"1\":{\"1467\":1,\"1468\":1}}],[\"发送请求到\",{\"1\":{\"1137\":1}}],[\"发送请求解除注册\",{\"1\":{\"1136\":1}}],[\"发送请求让所有消费者重平衡\",{\"1\":{\"1128\":1}}],[\"发送请求等\",{\"1\":{\"1109\":1}}],[\"发送请求前执行\",{\"1\":{\"981\":1}}],[\"发送请求获取最新的路由信息\",{\"1\":{\"955\":1}}],[\"发送请求\",{\"1\":{\"348\":1,\"945\":1,\"981\":1,\"1024\":1,\"1118\":1,\"1161\":1,\"1171\":1,\"1200\":1,\"1209\":1,\"1214\":1,\"1219\":1}}],[\"发送仍交给\",{\"1\":{\"128\":1}}],[\"发送响应的所有逻辑\",{\"1\":{\"112\":1}}],[\"发送响应\",{\"1\":{\"111\":1,\"125\":1}}],[\"发送\",{\"0\":{\"981\":1},\"1\":{\"73\":1,\"116\":1,\"978\":1,\"1017\":1,\"1040\":1,\"1200\":1,\"1234\":1,\"1252\":1,\"1259\":1,\"1415\":1,\"1510\":5,\"1511\":1,\"1519\":5,\"1520\":1}}],[\"发送数据\",{\"1\":{\"72\":1}}],[\"事先创建好一个\",{\"1\":{\"1441\":1}}],[\"事件预订等等\",{\"1\":{\"921\":1,\"1337\":1}}],[\"事件和执行异步任务的时间比例\",{\"1\":{\"135\":1}}],[\"事件到达则调用附加在其\",{\"1\":{\"132\":1}}],[\"事件的不同和分发时执行的处理器不同\",{\"1\":{\"132\":1}}],[\"事件然后分发出去\",{\"1\":{\"132\":1}}],[\"事件能立即被响应\",{\"1\":{\"128\":1}}],[\"事件都不感兴趣\",{\"1\":{\"124\":1}}],[\"事件就绪时从\",{\"1\":{\"124\":1}}],[\"事件就绪\",{\"1\":{\"122\":1}}],[\"事件分发\",{\"1\":{\"119\":1}}],[\"事件驱动架构设计\",{\"1\":{\"286\":1}}],[\"事件驱动架构的服务实现复杂度也更高\",{\"1\":{\"117\":1}}],[\"事件驱动\",{\"0\":{\"117\":1}}],[\"事件\",{\"1\":{\"116\":2,\"118\":1,\"119\":2,\"121\":1,\"122\":1,\"123\":1,\"124\":3,\"125\":1,\"126\":1,\"128\":1,\"132\":2,\"133\":2,\"135\":1}}],[\"事件关联的任务\",{\"1\":{\"116\":1}}],[\"事件来分发\",{\"1\":{\"116\":1}}],[\"事件来触发执行\",{\"1\":{\"116\":1}}],[\"事务超时时间\",{\"1\":{\"1468\":1}}],[\"事务半消息存在时长小于免疫回查时长\",{\"1\":{\"1468\":1}}],[\"事务半消息已经存在的时长\",{\"1\":{\"1468\":1}}],[\"事务半消息\",{\"1\":{\"1468\":1,\"1469\":2}}],[\"事务半消息队列的最新消费进度\",{\"1\":{\"1468\":1}}],[\"事务半消息的发送结果\",{\"1\":{\"1460\":1}}],[\"事务的最大检测次数\",{\"1\":{\"1467\":1}}],[\"事务的执行结果会保存到该\",{\"1\":{\"1453\":1}}],[\"事务执行状态未知则不做处理\",{\"1\":{\"1464\":1}}],[\"事务回滚\",{\"1\":{\"1464\":1}}],[\"事务提交\",{\"1\":{\"1464\":1}}],[\"事务状态回查\",{\"0\":{\"1452\":1,\"1465\":1}}],[\"事务在业务系统中也有大规模的应用\",{\"1\":{\"1439\":1}}],[\"事务指的是一系列操作\",{\"1\":{\"1439\":1}}],[\"事务消息一直执行中\",{\"1\":{\"1468\":1}}],[\"事务消息逃逸\",{\"1\":{\"1468\":1}}],[\"事务消息首次回查的最小时间\",{\"1\":{\"1468\":1}}],[\"事务消息回查免疫期\",{\"1\":{\"1467\":1}}],[\"事务消息转换成事务半消息保存\",{\"0\":{\"1463\":1}}],[\"事务消息发送结果\",{\"1\":{\"1458\":1}}],[\"事务消息发送的主要逻辑都在该方法中\",{\"1\":{\"1449\":1}}],[\"事务消息发送\",{\"0\":{\"1448\":1,\"1456\":1}}],[\"事务消息生产者\",{\"0\":{\"1443\":1}}],[\"事务消息的实现原理\",{\"1\":{\"1439\":1}}],[\"事务消息原理详解\",{\"0\":{\"1438\":1},\"1\":{\"1538\":1}}],[\"事务消息\",{\"1\":{\"1025\":1,\"1028\":1,\"1459\":1,\"1460\":1,\"1473\":2}}],[\"事务消息二阶段处理线程大小\",{\"0\":{\"734\":1}}],[\"事务消息日志优化\",{\"0\":{\"722\":1}}],[\"事务只能在当前线程传播\",{\"1\":{\"87\":1}}],[\"事务等处理\",{\"1\":{\"85\":1}}],[\"具体逻辑查看下面的源码解析部分\",{\"1\":{\"1510\":1}}],[\"具体逻辑后面会讲\",{\"1\":{\"1403\":1}}],[\"具体包括以下一些考虑\",{\"1\":{\"1385\":1}}],[\"具体顺序生产和消费代码见\",{\"1\":{\"1102\":1}}],[\"具体地说\",{\"1\":{\"1043\":1}}],[\"具体选择队列的方式是轮询\",{\"1\":{\"1029\":1}}],[\"具体完成监控acl配置文件变化的是\",{\"1\":{\"999\":1}}],[\"具体模块的初始化和启动\",{\"1\":{\"960\":1}}],[\"具体压测结果请看\",{\"1\":{\"917\":1}}],[\"具体修改如上两图所示\",{\"1\":{\"912\":1}}],[\"具体可以看\",{\"1\":{\"902\":1}}],[\"具体优化方法\",{\"0\":{\"897\":1}}],[\"具体存储结构和内容如图所示\",{\"1\":{\"787\":1}}],[\"具体为\",{\"1\":{\"786\":1}}],[\"具体的原理可以看\",{\"1\":{\"1338\":1}}],[\"具体的原理是用原来\",{\"1\":{\"1074\":1}}],[\"具体的做法是引入一个新的锁\",{\"1\":{\"1215\":1}}],[\"具体的做法是\",{\"1\":{\"927\":1,\"1315\":1}}],[\"具体的做法是开启\",{\"1\":{\"887\":1}}],[\"具体的方法为\",{\"1\":{\"1235\":1}}],[\"具体的方法很简单\",{\"1\":{\"903\":1}}],[\"具体的方法是用\",{\"1\":{\"990\":1,\"996\":1}}],[\"具体的方法是通过\",{\"1\":{\"979\":1}}],[\"具体的方法是消除了\",{\"1\":{\"894\":1}}],[\"具体的方法是调用\",{\"1\":{\"812\":1}}],[\"具体的实现方法是\",{\"1\":{\"765\":1}}],[\"具体的解析可以看\",{\"1\":{\"12\":1}}],[\"具体是哪个变为mirror\",{\"1\":{\"659\":1}}],[\"具有全量数据\",{\"1\":{\"659\":1}}],[\"具有iterable类型的集合可以通过新的for\",{\"1\":{\"303\":1}}],[\"具有一个值\",{\"1\":{\"194\":1}}],[\"具备低延迟\",{\"1\":{\"115\":1}}],[\"能找到\",{\"1\":{\"1520\":1}}],[\"能想到的办法主要是两个\",{\"1\":{\"1347\":1}}],[\"能想到的要点主要有如下几点\",{\"1\":{\"1010\":1}}],[\"能不能在现有的消息存储中存储\",{\"1\":{\"935\":1}}],[\"能先准备好的数据就先准备好\",{\"1\":{\"736\":1}}],[\"能极大地提升大米游戏体验\",{\"1\":{\"491\":1}}],[\"能提供\",{\"1\":{\"421\":1}}],[\"能让用户轻松完成作业的调度与繁杂任务的分布式计算\",{\"1\":{\"370\":1}}],[\"能够让\",{\"1\":{\"1246\":1}}],[\"能够清晰地表示客户端\",{\"1\":{\"1104\":1}}],[\"能够想到的比较笨的方法是\",{\"1\":{\"804\":1}}],[\"能够在编译时在命令行显示模块定位的每一步\",{\"1\":{\"602\":1}}],[\"能够在控制台上统一看到所有worker上报的日志\",{\"1\":{\"371\":1}}],[\"能够进行的运算是有限的\",{\"1\":{\"503\":1}}],[\"能够获取震地回响驱散后的盾\",{\"1\":{\"438\":1}}],[\"能够帮助发现并应对分布式云这种底座对架构设计以及上层应用带来的诸如可靠\",{\"1\":{\"276\":1}}],[\"能够达到\",{\"1\":{\"115\":1,\"913\":1}}],[\"能大大简化代码\",{\"1\":{\"75\":1}}],[\"难点3\",{\"0\":{\"1344\":1}}],[\"难点2\",{\"0\":{\"1343\":1}}],[\"难点1\",{\"0\":{\"1342\":1}}],[\"难点和取舍\",{\"0\":{\"924\":1}}],[\"难度提升巨大\",{\"1\":{\"399\":1}}],[\"难于管理和扩展\",{\"1\":{\"114\":1}}],[\"难以实现更复杂的并发控制和优化\",{\"1\":{\"114\":1}}],[\"难以进行线程管理和池化\",{\"1\":{\"114\":1}}],[\"难以管理依赖关系\",{\"1\":{\"81\":1}}],[\"难以测试\",{\"1\":{\"81\":1}}],[\"线程后续从等待表中提取和处理\",{\"1\":{\"1511\":1}}],[\"线程会优先处理这个表中的请求\",{\"1\":{\"1511\":1}}],[\"线程会扫描\",{\"1\":{\"1403\":1}}],[\"线程会定时将任务从\",{\"1\":{\"1300\":1}}],[\"线程模式\",{\"1\":{\"1380\":1}}],[\"线程模型进行分工的模式\",{\"1\":{\"109\":1}}],[\"线程阻塞等待请求队列中的拉取请求\",{\"1\":{\"1119\":1}}],[\"线程的\",{\"1\":{\"1119\":1,\"1511\":1}}],[\"线程关闭之前\",{\"1\":{\"947\":1,\"960\":1}}],[\"线程移到\",{\"0\":{\"913\":1}}],[\"线程有新消息到达\",{\"1\":{\"825\":1}}],[\"线程也是一个线程\",{\"1\":{\"135\":1}}],[\"线程继续执行\",{\"1\":{\"128\":1}}],[\"线程处理实际的\",{\"1\":{\"130\":1}}],[\"线程处理\",{\"1\":{\"128\":2,\"130\":1}}],[\"线程池执行\",{\"1\":{\"1155\":1}}],[\"线程池异步处理结果\",{\"1\":{\"1104\":1}}],[\"线程池处理\",{\"1\":{\"1043\":1}}],[\"线程池内部队列\",{\"1\":{\"1021\":1}}],[\"线程池为每个延迟等级创建并执行一个\",{\"1\":{\"857\":1}}],[\"线程池之后多线程处理任务\",{\"1\":{\"852\":1}}],[\"线程池中启动了一个状态更新线程\",{\"1\":{\"858\":1}}],[\"线程池中业务处理很快\",{\"1\":{\"130\":1}}],[\"线程池中处理\",{\"1\":{\"127\":1}}],[\"线程池去处理\",{\"1\":{\"127\":1}}],[\"线程只关注事件分发和实际的\",{\"1\":{\"127\":1}}],[\"线程中有较大的耗时占比\",{\"1\":{\"911\":1}}],[\"线程中拆分出来\",{\"1\":{\"130\":1}}],[\"线程中拆出来\",{\"1\":{\"127\":1}}],[\"线程中处理客户端\",{\"1\":{\"123\":1}}],[\"线程主循环\",{\"0\":{\"122\":1},\"1\":{\"815\":1,\"1519\":1}}],[\"线程初始化\",{\"0\":{\"121\":1}}],[\"线程同步处理完业务后\",{\"1\":{\"116\":1}}],[\"线程返回线程池\",{\"1\":{\"116\":1}}],[\"线程是以\",{\"1\":{\"116\":1}}],[\"线程上下文切换开销也会随之增加\",{\"1\":{\"114\":1}}],[\"线程资源消耗高\",{\"1\":{\"114\":1}}],[\"线程\",{\"0\":{\"913\":1},\"1\":{\"112\":1,\"121\":1,\"122\":1,\"126\":1,\"131\":1,\"133\":1,\"135\":1,\"812\":1,\"990\":1,\"996\":1,\"1512\":1}}],[\"解锁队列\",{\"1\":{\"1258\":1}}],[\"解锁则是将\",{\"1\":{\"1214\":1}}],[\"解析消息属性中是否有需要分发的\",{\"1\":{\"1294\":1}}],[\"解析请求头\",{\"1\":{\"1273\":1}}],[\"解析请求体和一系列校验\",{\"1\":{\"1269\":1}}],[\"解析数据版本\",{\"1\":{\"998\":1}}],[\"解析账号权限配置\",{\"1\":{\"998\":1}}],[\"解析全局\",{\"1\":{\"998\":1}}],[\"解析配置\",{\"1\":{\"998\":1}}],[\"解析所有\",{\"1\":{\"998\":1}}],[\"解析策略工厂\",{\"1\":{\"997\":1}}],[\"解析命令行参数\",{\"1\":{\"960\":1}}],[\"解析的性能\",{\"0\":{\"739\":1}}],[\"解析\",{\"1\":{\"621\":1,\"996\":1}}],[\"解析http协议\",{\"1\":{\"78\":1}}],[\"解决的问题\",{\"0\":{\"1379\":1}}],[\"解决了\",{\"1\":{\"1404\":1}}],[\"解决了消费端异常\",{\"1\":{\"1131\":1}}],[\"解决了定时消息顺序问题\",{\"1\":{\"927\":1}}],[\"解决了定时消息排序的问题\",{\"1\":{\"848\":1}}],[\"解决方案不难想到\",{\"1\":{\"806\":1}}],[\"解决\",{\"1\":{\"503\":1}}],[\"解构赋值\",{\"0\":{\"316\":1,\"554\":1}}],[\"解码时就走具体的实现类而不用反射\",{\"1\":{\"891\":1}}],[\"解码性能\",{\"0\":{\"889\":1}}],[\"解码成\",{\"1\":{\"742\":1}}],[\"解码\",{\"1\":{\"111\":1,\"112\":1,\"120\":1}}],[\"服务先将消息保存到本地存储\",{\"1\":{\"1507\":1}}],[\"服务进行消息存储\",{\"1\":{\"1507\":1}}],[\"服务线程\",{\"1\":{\"1353\":1}}],[\"服务\",{\"1\":{\"273\":1,\"372\":1,\"999\":1,\"1078\":1}}],[\"服务器拉取一批消息\",{\"1\":{\"1117\":1}}],[\"服务器地址\",{\"1\":{\"967\":1}}],[\"服务器在收到客户端的请求之后\",{\"1\":{\"766\":1}}],[\"服务器目录\",{\"1\":{\"643\":1}}],[\"服务器或集群\",{\"1\":{\"635\":1}}],[\"服务器如果接受该请求\",{\"1\":{\"368\":1}}],[\"服务器可以在任意时刻发送消息给浏览器\",{\"1\":{\"368\":1}}],[\"服务器\",{\"0\":{\"230\":1},\"1\":{\"262\":1}}],[\"服务器端用datagramsocket\",{\"1\":{\"73\":1}}],[\"服务器端\",{\"0\":{\"69\":1,\"72\":1}}],[\"服务处理程序判断传入请求发生的事件\",{\"1\":{\"119\":1}}],[\"服务端和客户端的请求实现类\",{\"1\":{\"1482\":1}}],[\"服务端和客户端的协议处理器接口\",{\"1\":{\"1482\":1}}],[\"服务端仍按照步骤\",{\"1\":{\"1446\":1}}],[\"服务端进行定时回查\",{\"1\":{\"1446\":1}}],[\"服务端在一定时间后\",{\"1\":{\"1446\":1}}],[\"服务端将事务半消息复原或丢弃\",{\"1\":{\"1446\":1}}],[\"服务端收到确认结果后处理逻辑如下\",{\"1\":{\"1446\":1}}],[\"服务端收到\",{\"1\":{\"1253\":1}}],[\"服务端收到请求后也会对请求参数进行排序\",{\"1\":{\"989\":1}}],[\"服务端实现\",{\"0\":{\"1253\":1}}],[\"服务端交互\",{\"0\":{\"1252\":1}}],[\"服务端技术栈\",{\"1\":{\"1105\":1}}],[\"服务端接收到后\",{\"1\":{\"1044\":1}}],[\"服务端处理请求\",{\"1\":{\"981\":1}}],[\"服务端配置\",{\"1\":{\"960\":1}}],[\"服务端\",{\"0\":{\"112\":1},\"1\":{\"121\":1,\"369\":1,\"1446\":1}}],[\"服务端或分布式服务端等应用中\",{\"1\":{\"111\":1}}],[\"我把重平衡的触发分为主动触发和被动触发\",{\"1\":{\"1136\":1}}],[\"我把\",{\"1\":{\"1125\":1,\"1147\":1,\"1177\":1,\"1203\":1}}],[\"我把它当作我这个版本大米之路的总结\",{\"1\":{\"399\":1}}],[\"我将\",{\"1\":{\"1086\":1}}],[\"我全都要\",{\"1\":{\"924\":1}}],[\"我想说的是\",{\"1\":{\"924\":1}}],[\"我还有一些理解\",{\"1\":{\"492\":1}}],[\"我做了很多双向宏来节省键位\",{\"1\":{\"488\":1}}],[\"我没有甲虫所以没有体验过\",{\"1\":{\"482\":1}}],[\"我打的\",{\"1\":{\"476\":1}}],[\"我个人也推荐点赛梦\",{\"1\":{\"455\":1}}],[\"我个人习惯是用欣欣向荣\",{\"1\":{\"403\":1}}],[\"我推测是为了用大树奶过老二球\",{\"1\":{\"443\":1}}],[\"我的设计目标是\",{\"1\":{\"923\":1}}],[\"我的规划是每次出来的柱子都消\",{\"1\":{\"438\":1}}],[\"我的理解是双回春\",{\"1\":{\"403\":1}}],[\"我的理解是\",{\"1\":{\"401\":1}}],[\"我居然一次过\",{\"1\":{\"422\":1}}],[\"我认为每个人追求不同\",{\"1\":{\"412\":1}}],[\"我认为不太准确\",{\"1\":{\"118\":1}}],[\"我通灵和仙林能打到\",{\"1\":{\"403\":1}}],[\"我两种英雄天赋都用\",{\"1\":{\"401\":1}}],[\"我是用它奶过\",{\"1\":{\"403\":1}}],[\"我是听着露露语音才进行的预铺\",{\"1\":{\"399\":1}}],[\"我是大米开了几周后才和朋友们灭的死去活来拿了\",{\"1\":{\"399\":1}}],[\"我记忆犹新的是回响尾王灭了\",{\"1\":{\"399\":1}}],[\"我一开始就把主要目标定为大米\",{\"1\":{\"399\":1}}],[\"我在\",{\"1\":{\"399\":1}}],[\"我可以算老\",{\"1\":{\"399\":1}}],[\"我觉得调的很合理了\",{\"1\":{\"399\":1}}],[\"我会把我所有的理解都在译者注中分享出来\",{\"1\":{\"399\":1}}],[\"我会进行解答和回复\",{\"1\":{\"399\":1}}],[\"我会实现一个简单的服务端逻辑\",{\"1\":{\"110\":1}}],[\"我希望能随时调用看到的每一个方法\",{\"1\":{\"271\":1}}],[\"我发现仍然很难调用看到的方法\",{\"1\":{\"271\":1}}],[\"我使用了久负盛名的\",{\"1\":{\"271\":1}}],[\"我要做些什么才能让这条语句为真\",{\"1\":{\"173\":1}}],[\"我借鉴了\",{\"1\":{\"131\":1}}],[\"我们把\",{\"1\":{\"1508\":1}}],[\"我们把定时消息存储文件也按投递时间段拆分\",{\"1\":{\"928\":1}}],[\"我们并不希望事务半消息被消费者消费到\",{\"1\":{\"1446\":1}}],[\"我们在一开始提到的水位线\",{\"1\":{\"1300\":1}}],[\"我们在双绽放天赋下用一个愈合可以上\",{\"1\":{\"401\":1}}],[\"我们对一个\",{\"1\":{\"1300\":1}}],[\"我们只在\",{\"1\":{\"1253\":1}}],[\"我们姑且把这个锁叫做\",{\"1\":{\"1209\":1}}],[\"我们选择\",{\"1\":{\"1073\":1}}],[\"我们首先看一下客户端如何注册\",{\"1\":{\"988\":1}}],[\"我们设想这样一个场景\",{\"1\":{\"978\":1}}],[\"我们设计了实验以探索单个topic分区的扩容能力\",{\"1\":{\"285\":1}}],[\"我们完成了任意时间定时消息的设计旅程\",{\"1\":{\"934\":1}}],[\"我们要达到的定时精度为\",{\"1\":{\"931\":1}}],[\"我们知道\",{\"1\":{\"912\":1,\"1245\":1,\"1343\":1}}],[\"我们一般使用\",{\"1\":{\"802\":1}}],[\"我们常常遇到队列中消息不平衡的场景\",{\"1\":{\"707\":1}}],[\"我们用一个\",{\"1\":{\"700\":1}}],[\"我们访问rabbit\",{\"1\":{\"626\":1}}],[\"我们来看看这个方法具体做了什么\",{\"1\":{\"825\":1}}],[\"我们来看看这个方法中做了什么\",{\"1\":{\"625\":1}}],[\"我们来分析一下rabbit\",{\"1\":{\"625\":1}}],[\"我们使用对象类型\",{\"1\":{\"512\":1}}],[\"我们使用openchaos对etcd集群进行可靠性测试\",{\"1\":{\"284\":1}}],[\"我们希望实现一个定时消息的底座\",{\"1\":{\"928\":1}}],[\"我们希望让对相同\",{\"1\":{\"384\":1}}],[\"我们希望能构建更高性能且可伸缩的服务\",{\"1\":{\"115\":1}}],[\"我们可以把日志复制的流程分为\",{\"1\":{\"1507\":1}}],[\"我们可以通过\",{\"1\":{\"976\":1}}],[\"我们可以人为地为阻塞队列设置一个长度上限\",{\"1\":{\"933\":1}}],[\"我们可以发送json格式的文本\",{\"1\":{\"368\":1}}],[\"我们可以使用\",{\"1\":{\"191\":1}}],[\"我们强烈建议使用module\",{\"1\":{\"365\":1}}],[\"我们会继续打磨该项目\",{\"1\":{\"286\":1}}],[\"我们与混沌工程师实验室紧密合作\",{\"1\":{\"286\":1}}],[\"我们开放了更多分布式系统接入的工作\",{\"1\":{\"286\":1}}],[\"我们开始认真审视并思考\",{\"1\":{\"276\":1}}],[\"我们有不同的方式来获取信息\",{\"1\":{\"276\":1}}],[\"我们构建\",{\"1\":{\"276\":1}}],[\"我们注明了\",{\"1\":{\"193\":1}}],[\"我们需要在进程内接收消息\",{\"1\":{\"230\":1}}],[\"我们需要在\",{\"1\":{\"191\":1}}],[\"我们能在很多地方看到子句\",{\"1\":{\"180\":1}}],[\"我们第一次说\",{\"1\":{\"173\":1}}],[\"我们先来看一下\",{\"1\":{\"1477\":1,\"1508\":1}}],[\"我们先来看一下开源版本\",{\"1\":{\"925\":1}}],[\"我们先来看一下定时消息涉及到的类分别实现了什么功能\",{\"1\":{\"836\":1}}],[\"我们先来看一下ack函数的实现\",{\"1\":{\"626\":1}}],[\"我们先把客户输入的字符缓存到\",{\"1\":{\"125\":1}}],[\"我们先考虑将处理过程拆分成更小的任务\",{\"1\":{\"116\":1}}],[\"我们还可以使用自定义插件\",{\"1\":{\"64\":1}}],[\"我们总是执行phase默认绑定的goal\",{\"1\":{\"63\":1}}],[\"我们自己的java程序是无法创建class实例的\",{\"1\":{\"36\":1}}],[\"我们就可以把每个定时消息的投递作为一个任务\",{\"1\":{\"931\":1}}],[\"我们就可以将一个队列拆分成多个子队列\",{\"1\":{\"707\":1}}],[\"我们就可以直接运行class文件了\",{\"1\":{\"21\":1}}],[\"我们就不必在命令行指定启动的类名\",{\"1\":{\"24\":1}}],[\"我们怎么一次性编译这些java源码呢\",{\"1\":{\"21\":1}}],[\"我们编写代码来测试一下\",{\"1\":{\"9\":1}}],[\"我们的神器\",{\"1\":{\"2\":1}}],[\"本身不处理请求\",{\"1\":{\"1482\":1}}],[\"本身的实现非常轻量\",{\"1\":{\"942\":1}}],[\"本身的机制达到\",{\"1\":{\"925\":1}}],[\"本示例使用\",{\"1\":{\"1440\":1}}],[\"本\",{\"1\":{\"1373\":1}}],[\"本来消息会在中间这个时间点再一次的可见的\",{\"1\":{\"1251\":1}}],[\"本想一篇文章写完\",{\"1\":{\"1086\":1}}],[\"本次心跳包开始发送的时间戳\",{\"1\":{\"1499\":1}}],[\"本次拉取消息的消费者的过滤信息\",{\"1\":{\"1323\":1}}],[\"本次要发送的数据\",{\"1\":{\"1021\":1}}],[\"本次操作无需权限验证\",{\"1\":{\"1000\":1}}],[\"本次和上次的性能优化主要由快手的黄理老师提交\",{\"1\":{\"886\":1}}],[\"本次删除的文件数量\",{\"1\":{\"870\":1}}],[\"本次改动将延迟消息的写入改成可配置同步或异步写入\",{\"1\":{\"853\":1}}],[\"本次优化中也包含了生产和消费性能的提升\",{\"1\":{\"886\":1}}],[\"本次优化单独定义了解析发送消息请求头的方法\",{\"1\":{\"742\":1}}],[\"本次优化减少了需要进入同步代码块的次数\",{\"1\":{\"726\":1}}],[\"本次对刷盘相关的参数也进行了调整\",{\"1\":{\"735\":1}}],[\"本次修改点是在主从复制的\",{\"1\":{\"729\":1}}],[\"本次测试的测试方法\",{\"1\":{\"11\":1}}],[\"本着抄顶尖选手作业的想法我更推荐用双绽放\",{\"1\":{\"403\":1}}],[\"本地已写入存储的最大\",{\"1\":{\"1508\":1}}],[\"本地事务执行状态\",{\"1\":{\"1460\":1}}],[\"本地事务执行状态回查线程池\",{\"1\":{\"1443\":1}}],[\"本地事务执行参数\",{\"1\":{\"1459\":1}}],[\"本地事务执行和状态检查器\",{\"1\":{\"1459\":1}}],[\"本地事务执行器的参数\",{\"1\":{\"1458\":1}}],[\"本地事务执行结果\",{\"1\":{\"1449\":1,\"1451\":1}}],[\"本地操作和消息发送\",{\"1\":{\"1439\":1}}],[\"本地存储的日志\",{\"1\":{\"1510\":1}}],[\"本地存储的最大\",{\"1\":{\"1509\":1}}],[\"本地存储的\",{\"1\":{\"1386\":3}}],[\"本地存储\",{\"1\":{\"1364\":1,\"1386\":1,\"1390\":1,\"1507\":1,\"1509\":1,\"1511\":1}}],[\"本地缓存的\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"本地缓存变量中取pullrequest请求\",{\"1\":{\"815\":1}}],[\"本地消费成功才会提交\",{\"1\":{\"1095\":1}}],[\"本地构建的最大意义在于\",{\"1\":{\"1072\":1}}],[\"本地构建\",{\"0\":{\"1072\":1}}],[\"本地构建或者从\",{\"1\":{\"1071\":1}}],[\"本地没有缓存\",{\"1\":{\"1039\":1}}],[\"本地变量\",{\"1\":{\"904\":1}}],[\"本地不希望任务在跑\",{\"1\":{\"273\":1}}],[\"本地开发时有两个操作最耗时\",{\"1\":{\"270\":1}}],[\"本方法最适用于\",{\"1\":{\"269\":1}}],[\"本质上是一块内存\",{\"1\":{\"118\":1}}],[\"本文暂不展开\",{\"1\":{\"1477\":1}}],[\"本文基于\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"本文会涉及\",{\"1\":{\"1147\":1}}],[\"本文着重介绍推模式下\",{\"1\":{\"1147\":1}}],[\"本文着重讲解定时消息异步投递的逻辑\",{\"1\":{\"850\":1}}],[\"本文是\",{\"1\":{\"1107\":1,\"1125\":1,\"1147\":1,\"1177\":1,\"1203\":1}}],[\"本文作为消费系列的第一篇\",{\"1\":{\"1086\":1}}],[\"本文第一节从定时消息的定义和需求出发\",{\"1\":{\"936\":1}}],[\"本文介绍的是步骤\",{\"1\":{\"1177\":1}}],[\"本文介绍\",{\"1\":{\"976\":1}}],[\"本文介绍如何在\",{\"1\":{\"919\":1}}],[\"本文介绍了\",{\"1\":{\"917\":1}}],[\"本文详细分析一下三种存储文件的过期删除机制\",{\"1\":{\"863\":1}}],[\"本文主要讲解的是另一个改动\",{\"1\":{\"850\":1}}],[\"本文主要讨论基于信用证的进程内流控实现\",{\"1\":{\"614\":1}}],[\"本文将基于\",{\"1\":{\"1439\":1}}],[\"本文将会详解\",{\"1\":{\"886\":1}}],[\"本文将讲解镜像队列的使用方法和原理\",{\"1\":{\"648\":1}}],[\"本文将介绍\",{\"1\":{\"110\":1,\"681\":1}}],[\"本文讲解\",{\"1\":{\"641\":1}}],[\"本文更适合有一定大米经验并且想提升打更高层的玩家\",{\"1\":{\"398\":1}}],[\"本文在正式服开大米之前第一版就已经发布\",{\"1\":{\"398\":1}}],[\"本文首先以现今分布式系统的复杂性和稳定性的需求引出混沌工程概念\",{\"1\":{\"275\":1}}],[\"本文的代码完整实现地址\",{\"1\":{\"110\":1}}],[\"本文内容\",{\"0\":{\"110\":1}}],[\"异键或同键表\",{\"1\":{\"253\":1}}],[\"异键表\",{\"1\":{\"248\":1}}],[\"异常关闭\",{\"1\":{\"1520\":1}}],[\"异常\",{\"1\":{\"1511\":1}}],[\"异常退出时\",{\"1\":{\"883\":1}}],[\"异常恢复时\",{\"1\":{\"789\":1}}],[\"异常故障情况下从节点是否提升为主节点\",{\"1\":{\"659\":1}}],[\"异常错误如果发生在\",{\"1\":{\"195\":1}}],[\"异常处理\",{\"0\":{\"32\":1}}],[\"异步操作\",{\"1\":{\"1519\":2}}],[\"异步存储消息\",{\"1\":{\"1462\":1}}],[\"异步处理等的重要组件\",{\"1\":{\"1439\":1}}],[\"异步处理生产者发送过来的请求\",{\"1\":{\"1043\":1}}],[\"异步查询索引项\",{\"1\":{\"1436\":2}}],[\"异步上传\",{\"0\":{\"1428\":1}}],[\"异步执行\",{\"1\":{\"1403\":1}}],[\"异步执行请求处理和返回\",{\"1\":{\"820\":1}}],[\"异步拉取消息的流程主要分为\",{\"1\":{\"1149\":1}}],[\"异步和单向\",{\"1\":{\"1027\":1}}],[\"异步发送\",{\"1\":{\"1519\":1}}],[\"异步发送心跳\",{\"1\":{\"1499\":2}}],[\"异步发送单向消息回查请求\",{\"1\":{\"1453\":1}}],[\"异步发送回调函数\",{\"1\":{\"1053\":1}}],[\"异步发送只执行一次\",{\"1\":{\"1050\":1}}],[\"异步发送的重试逻辑在\",{\"1\":{\"1040\":1}}],[\"异步发送是最为广泛使用的发送方式\",{\"1\":{\"1027\":1}}],[\"异步发送是使用最广泛的发送方式\",{\"1\":{\"1027\":1}}],[\"异步发送请求\",{\"1\":{\"1021\":1}}],[\"异步发送线程池\",{\"1\":{\"1021\":1}}],[\"异步转发队列长度\",{\"1\":{\"1021\":1}}],[\"异步实现消息轨迹数据的发送\",{\"1\":{\"1021\":1}}],[\"异步消息投递后\",{\"1\":{\"857\":1}}],[\"异步投递任务由一个阻塞队列来承载\",{\"1\":{\"933\":1}}],[\"异步投递过程状态更新任务\",{\"0\":{\"861\":1}}],[\"异步投递\",{\"1\":{\"860\":1}}],[\"异步投递详解\",{\"0\":{\"856\":1}}],[\"异步投递采用了生产\",{\"1\":{\"855\":1}}],[\"异步投递逻辑\",{\"0\":{\"855\":1}}],[\"异步投递的逻辑相比于同步投递有一些不同\",{\"1\":{\"855\":1}}],[\"异步投递的两个主要缺点是\",{\"1\":{\"854\":1}}],[\"异步投递的注意点\",{\"0\":{\"854\":1},\"1\":{\"854\":1}}],[\"异步投递支持\",{\"0\":{\"849\":1},\"1\":{\"1338\":1,\"1538\":1}}],[\"异步写入在\",{\"1\":{\"853\":1}}],[\"异步提交重新pull消息的请求任务\",{\"1\":{\"820\":1}}],[\"异步保存批量消息\",{\"1\":{\"731\":1}}],[\"异步保存单条消息\",{\"1\":{\"731\":1}}],[\"异步解耦\",{\"1\":{\"372\":1}}],[\"异步的远程通信\",{\"1\":{\"372\":1}}],[\"异步错误处理\",{\"0\":{\"359\":1}}],[\"异步函数和promise可以看作是等价的\",{\"1\":{\"354\":1}}],[\"异步\",{\"1\":{\"109\":1,\"1025\":1,\"1027\":1,\"1053\":1,\"1161\":1,\"1170\":1,\"1171\":1,\"1175\":1,\"1229\":1}}],[\"多余的日志\",{\"1\":{\"1510\":1}}],[\"多级存储设计与实现\",{\"1\":{\"1437\":1}}],[\"多了索引项总长度\",{\"1\":{\"1418\":1}}],[\"多副本中多数派的最小位点\",{\"1\":{\"1403\":1}}],[\"多批\",{\"1\":{\"1194\":1}}],[\"多语言支持不友好\",{\"1\":{\"1095\":1}}],[\"多见于关机恢复的场景\",{\"1\":{\"765\":1}}],[\"多少个镜像才是最优的\",{\"0\":{\"662\":1}}],[\"多维数组\",{\"0\":{\"525\":1}}],[\"多利塔\",{\"0\":{\"440\":1}}],[\"多目标\",{\"1\":{\"435\":1}}],[\"多目标的手法是潜行\",{\"1\":{\"412\":1}}],[\"多打多研究就会有提升\",{\"1\":{\"399\":1}}],[\"多行\",{\"1\":{\"297\":1}}],[\"多租共池等等无不在逼迫我们重新审视老式架构的合理性\",{\"1\":{\"276\":1}}],[\"多文件操作\",{\"0\":{\"151\":1}}],[\"多个消费者共同消费一个\",{\"1\":{\"1181\":1}}],[\"多个消费任务提交到消费线程池\",{\"1\":{\"1104\":1}}],[\"多个字符串\",{\"1\":{\"900\":1}}],[\"多个同名接口会合并成一个接口\",{\"1\":{\"563\":1}}],[\"多个文件编译成一个\",{\"1\":{\"498\":1}}],[\"多个变量用中括号括起来\",{\"1\":{\"316\":1}}],[\"多个\",{\"1\":{\"130\":1,\"724\":1,\"1287\":1,\"1386\":1}}],[\"多线程处理比较好\",{\"1\":{\"733\":1}}],[\"多线程在\",{\"1\":{\"135\":1}}],[\"多线程的情况下\",{\"1\":{\"130\":1}}],[\"多线程进行处理\",{\"1\":{\"128\":1}}],[\"多线程版本设计了一个\",{\"1\":{\"130\":1}}],[\"多线程版本将业务处理和\",{\"1\":{\"127\":1}}],[\"多线程版本\",{\"1\":{\"127\":1}}],[\"多线程\",{\"0\":{\"127\":1,\"129\":1,\"130\":1},\"1\":{\"128\":1}}],[\"多路复用技术\",{\"1\":{\"119\":1}}],[\"多路复用地监听\",{\"1\":{\"118\":1}}],[\"多路复用来实现\",{\"1\":{\"109\":1}}],[\"多路复用\",{\"1\":{\"109\":1,\"119\":2}}],[\"多进程串行执行\",{\"1\":{\"9\":1}}],[\"内容一致返回\",{\"1\":{\"1520\":1}}],[\"内容不一致返回\",{\"1\":{\"1511\":1}}],[\"内没有被使用则清理\",{\"1\":{\"1406\":1}}],[\"内没有匹配成功\",{\"1\":{\"1253\":1}}],[\"内获取不到\",{\"1\":{\"1215\":1}}],[\"内可能会进行重平衡\",{\"1\":{\"1136\":1}}],[\"内投不完\",{\"1\":{\"932\":1}}],[\"内要投递的消息\",{\"1\":{\"932\":1}}],[\"内的所有时间窗\",{\"1\":{\"1346\":1}}],[\"内的\",{\"1\":{\"1278\":1}}],[\"内的一批\",{\"1\":{\"1263\":1}}],[\"内的负载均衡\",{\"1\":{\"949\":1}}],[\"内的定时消息\",{\"1\":{\"924\":1}}],[\"内的数据刷盘至物理磁盘上\",{\"1\":{\"879\":1}}],[\"内的消息\",{\"1\":{\"789\":1}}],[\"内核线程将\",{\"1\":{\"879\":1}}],[\"内核空间的网络数据收发模型\",{\"1\":{\"109\":1}}],[\"内如果没有执行过刷盘操作\",{\"1\":{\"758\":1}}],[\"内存存储\",{\"1\":{\"1519\":1}}],[\"内存的\",{\"1\":{\"1406\":1}}],[\"内存匹配服务是否开启\",{\"1\":{\"1275\":1}}],[\"内存匹配未开启\",{\"1\":{\"1271\":1}}],[\"内存匹配逻辑由一个线程\",{\"1\":{\"1262\":1}}],[\"内存匹配\",{\"0\":{\"1262\":1}}],[\"内存匹配性能较高\",{\"1\":{\"1261\":1}}],[\"内存中不处理\",{\"1\":{\"1276\":1}}],[\"内存中仅保存\",{\"1\":{\"1276\":1}}],[\"内存中\",{\"1\":{\"1175\":1}}],[\"内存中当前消费队列的消费进度\",{\"1\":{\"1170\":1}}],[\"内存\",{\"1\":{\"1080\":1,\"1390\":1}}],[\"内存无法承受会导致程序崩溃\",{\"1\":{\"931\":1}}],[\"内存级读写分离\",{\"0\":{\"883\":1}}],[\"内存映射\",{\"1\":{\"880\":2}}],[\"内存映射文件\",{\"0\":{\"1528\":1},\"1\":{\"880\":1}}],[\"内存映射文件队列组成的\",{\"1\":{\"876\":1}}],[\"内存映射文件mmap\",{\"0\":{\"728\":1}}],[\"内存使用\",{\"0\":{\"702\":1}}],[\"内存不足\",{\"1\":{\"690\":1}}],[\"内存和磁盘的流控相当于全局流控\",{\"1\":{\"613\":1}}],[\"内存高水位\",{\"0\":{\"613\":1},\"1\":{\"702\":1}}],[\"内存占用也小很多\",{\"1\":{\"247\":1}}],[\"内\",{\"1\":{\"310\":1,\"922\":1}}],[\"内置\",{\"1\":{\"371\":1}}],[\"内置的方法\",{\"1\":{\"303\":1}}],[\"内置可扩展的模型支持\",{\"1\":{\"278\":1}}],[\"内置函数apply\",{\"1\":{\"200\":1}}],[\"内置函数\",{\"0\":{\"185\":1},\"1\":{\"196\":1}}],[\"内部消费组\",{\"1\":{\"1468\":2}}],[\"内部有排序的\",{\"1\":{\"1412\":1}}],[\"内部有一个\",{\"1\":{\"1402\":1}}],[\"内部有一个阻塞队列\",{\"1\":{\"1152\":1}}],[\"内部实际上是一个数组\",{\"1\":{\"1351\":1}}],[\"内部实现是一个数组\",{\"1\":{\"118\":1}}],[\"内部不断尝试从阻塞队列中获取拉去请求进行拉取操作\",{\"1\":{\"1155\":1}}],[\"内部构造一个\",{\"1\":{\"1111\":1}}],[\"内部仅仅多了消息列表\",{\"1\":{\"1044\":1}}],[\"内部的大部分方法都通过调用代理\",{\"1\":{\"1109\":1}}],[\"内部的\",{\"1\":{\"1036\":1}}],[\"内部注册了一个\",{\"1\":{\"1036\":1}}],[\"内部包含了由\",{\"1\":{\"1402\":1}}],[\"内部包含字符串的拷贝\",{\"1\":{\"906\":1}}],[\"内部包装了一个\",{\"1\":{\"1036\":1}}],[\"内部保存了一个二级\",{\"1\":{\"944\":1}}],[\"内部保存该\",{\"1\":{\"755\":1}}],[\"内部用\",{\"1\":{\"893\":1}}],[\"内部可以不用反射而是直接进行字段赋值\",{\"1\":{\"891\":1}}],[\"内部可以使用\",{\"1\":{\"317\":1}}],[\"内部只有一个线程同步执行\",{\"1\":{\"840\":1}}],[\"内部调用\",{\"1\":{\"837\":1,\"1321\":1}}],[\"内部调用了\",{\"1\":{\"756\":1}}],[\"内部遍历所有dispatcherlist中的分发器\",{\"1\":{\"763\":1}}],[\"内部使用二分查找算法\",{\"1\":{\"751\":1}}],[\"内部会创建对应的\",{\"1\":{\"668\":1}}],[\"内部\",{\"1\":{\"380\":1,\"724\":1}}],[\"内部函数可以访问外部函数定义的变量\",{\"1\":{\"310\":1}}],[\"内部时一个死循环\",{\"1\":{\"135\":1}}],[\"内部类\",{\"0\":{\"22\":1}}],[\"框架和一些中间件的\",{\"1\":{\"108\":1}}],[\"针对资源能进行的操作\",{\"1\":{\"978\":1}}],[\"针对一些分布式系统特有属性\",{\"1\":{\"278\":1}}],[\"针对分布式系统韧性能力\",{\"1\":{\"278\":1}}],[\"针对异常的编程样式\",{\"0\":{\"196\":1}}],[\"针对\",{\"1\":{\"95\":1,\"886\":1}}],[\"绑定\",{\"1\":{\"637\":2,\"700\":1,\"711\":1,\"1379\":1}}],[\"绑定其他方法到primarystudent原型\",{\"1\":{\"342\":1}}],[\"绑定到对象上的函数\",{\"1\":{\"317\":1}}],[\"绑定到端口上\",{\"1\":{\"133\":1}}],[\"绑定到服务端口\",{\"1\":{\"132\":1,\"133\":1}}],[\"绑定服务端端口\",{\"1\":{\"121\":1}}],[\"绑定pwd参数\",{\"1\":{\"92\":1}}],[\"绑定e参数\",{\"1\":{\"92\":1}}],[\"集中站位放水来节省场地\",{\"1\":{\"453\":1}}],[\"集群内各个节点已经确认存储的最大\",{\"1\":{\"1508\":1}}],[\"集群内节点个数\",{\"1\":{\"1499\":1}}],[\"集群模式的消费进度管理涉及到消费者端和\",{\"1\":{\"1183\":1}}],[\"集群模式消费进度管理\",{\"0\":{\"1183\":1}}],[\"集群模式下\",{\"1\":{\"1103\":1,\"1181\":1}}],[\"集群模式\",{\"1\":{\"1103\":1,\"1120\":1,\"1122\":1,\"1195\":1,\"1218\":1,\"1266\":1}}],[\"集群消费模式下\",{\"1\":{\"1091\":1}}],[\"集群消费模式\",{\"0\":{\"1091\":1}}],[\"集群消费\",{\"1\":{\"1088\":1}}],[\"集群状态\",{\"1\":{\"1076\":1}}],[\"集群信息\",{\"1\":{\"949\":1}}],[\"集群名称\",{\"1\":{\"944\":1,\"952\":1}}],[\"集群的客户端\",{\"1\":{\"1235\":1}}],[\"集群的每台机器都发送心跳包\",{\"1\":{\"945\":1}}],[\"集群的路由信息\",{\"1\":{\"941\":1}}],[\"集群的注册信息并且保存下来作为路由信息的基本数据\",{\"1\":{\"941\":1}}],[\"集群时\",{\"1\":{\"707\":1}}],[\"集群中队列副本的数量\",{\"1\":{\"657\":1}}],[\"集群创建\",{\"1\":{\"630\":1}}],[\"集群以及它们连接的那一台\",{\"1\":{\"380\":1}}],[\"集群\",{\"0\":{\"1068\":1},\"1\":{\"285\":1,\"380\":1,\"648\":1,\"978\":1,\"1266\":1,\"1538\":1}}],[\"集群均可在故障期间自行转移主节点\",{\"1\":{\"284\":1}}],[\"集群无法自行恢复\",{\"1\":{\"284\":1}}],[\"集群在主节点与从节点网络断开\",{\"1\":{\"284\":1}}],[\"集群缺乏自动恢复能力\",{\"1\":{\"284\":1}}],[\"集成\",{\"0\":{\"88\":1}}],[\"集合中包含消息的\",{\"1\":{\"1314\":1,\"1329\":1}}],[\"集合的元素只能是字符串\",{\"1\":{\"1308\":1}}],[\"集合石很容易漏打断\",{\"1\":{\"469\":1}}],[\"集合石使用的\",{\"1\":{\"436\":1}}],[\"集合石来擦屁股\",{\"1\":{\"403\":1}}],[\"集合跟他走\",{\"1\":{\"431\":1}}],[\"集合\",{\"0\":{\"50\":1},\"1\":{\"122\":2}}],[\"要修改的目标状态\",{\"1\":{\"1519\":1}}],[\"要求\",{\"1\":{\"1510\":1}}],[\"要计算当次上传的结束位置\",{\"1\":{\"1403\":1}}],[\"要实现其他存储介质的分级存储\",{\"1\":{\"1382\":1}}],[\"要实现跨线程传播事务\",{\"1\":{\"87\":1}}],[\"要测试分级存储\",{\"1\":{\"1382\":1}}],[\"要理解水位线\",{\"1\":{\"1300\":1}}],[\"要消费\",{\"1\":{\"1293\":1}}],[\"要被重试的消息\",{\"1\":{\"1280\":1}}],[\"要支持一种新语言的客户端就必须实现完整的重平衡逻辑\",{\"1\":{\"1249\":1}}],[\"要锁定的队列中已经锁定的队列\",{\"1\":{\"1222\":1}}],[\"要锁定的消息队列\",{\"1\":{\"1222\":1,\"1226\":1}}],[\"要从\",{\"1\":{\"1174\":1}}],[\"要拉取的逻辑偏移量\",{\"1\":{\"1149\":1}}],[\"要解决这个问题只能通过划分领域\",{\"1\":{\"942\":1}}],[\"要把这一\",{\"1\":{\"931\":1}}],[\"要同时投递\",{\"1\":{\"931\":1}}],[\"要等待\",{\"1\":{\"806\":1}}],[\"要补充空的消息索引\",{\"1\":{\"765\":1}}],[\"要使用消息轨迹\",{\"1\":{\"1004\":1}}],[\"要使用\",{\"1\":{\"630\":1,\"897\":1}}],[\"要使用这个插件\",{\"1\":{\"64\":1}}],[\"要么全部失败的需求\",{\"1\":{\"1439\":1}}],[\"要么全部失败\",{\"1\":{\"1439\":1}}],[\"要么全部成功\",{\"1\":{\"1439\":2}}],[\"要么返回一个新对象取代所修饰的目标对象\",{\"1\":{\"605\":1}}],[\"要么是返回布尔值的函数\",{\"1\":{\"568\":1}}],[\"要\",{\"1\":{\"482\":1}}],[\"要近战位躲开的头前顺劈\",{\"1\":{\"461\":1}}],[\"要驱散\",{\"1\":{\"454\":1}}],[\"要用一些爆发去打高个子\",{\"1\":{\"451\":1}}],[\"要用到\",{\"1\":{\"230\":1}}],[\"要时刻保持全队\",{\"1\":{\"448\":1}}],[\"要交替使用治疗手牌和个减\",{\"1\":{\"446\":1}}],[\"要注意的点\",{\"1\":{\"445\":1}}],[\"要注意的技能\",{\"1\":{\"435\":1,\"442\":1,\"448\":1,\"454\":1,\"461\":1,\"468\":1}}],[\"要开个减\",{\"1\":{\"432\":1}}],[\"要打断的重要技能\",{\"1\":{\"428\":1,\"435\":1,\"442\":1,\"448\":1,\"454\":1,\"461\":1,\"468\":1}}],[\"要最大化百花齐放的效果最重要的就是圈的位置\",{\"1\":{\"416\":1}}],[\"要不停预铺\",{\"1\":{\"399\":1}}],[\"要通过回调函数获得响应\",{\"1\":{\"347\":1}}],[\"要比较两个浮点数是否相等\",{\"1\":{\"295\":1}}],[\"要在\",{\"1\":{\"253\":1}}],[\"要改变其他某个进程的内存\",{\"1\":{\"227\":1}}],[\"要附上模块名\",{\"1\":{\"180\":1}}],[\"要替换的模式\",{\"1\":{\"150\":1}}],[\"要达到以上目标\",{\"1\":{\"116\":1}}],[\"要想办法把当前线程绑定到threadlocal的connection和transactionstatus实例传递给新线程\",{\"1\":{\"87\":1}}],[\"否则无动作\",{\"1\":{\"1480\":1}}],[\"否则使用事务超时时间\",{\"1\":{\"1468\":1}}],[\"否则使用消息存储的地\",{\"1\":{\"1197\":1}}],[\"否则全部上传\",{\"1\":{\"1403\":1}}],[\"否则等待下一次扫描\",{\"1\":{\"1403\":1}}],[\"否则重新处理本\",{\"1\":{\"1373\":1}}],[\"否则重新放入\",{\"1\":{\"1347\":1}}],[\"否则将查出的原始消息放入\",{\"1\":{\"1359\":1}}],[\"否则将抛出异常\",{\"1\":{\"87\":1}}],[\"否则仅进行第二层过滤\",{\"1\":{\"1322\":1}}],[\"否则从\",{\"1\":{\"1321\":1}}],[\"否则不消费\",{\"1\":{\"1314\":1,\"1329\":1}}],[\"否则消费者客户端启动会报错\",{\"1\":{\"1308\":1}}],[\"否则消费者客户端启动时会报错\",{\"1\":{\"1308\":2}}],[\"否则返回错误\",{\"1\":{\"1164\":1}}],[\"否则返回异常信息\",{\"1\":{\"981\":1}}],[\"否则继续重新投递\",{\"1\":{\"858\":1}}],[\"否则继续循环进行轮询操作\",{\"1\":{\"806\":1}}],[\"否则继续读取\",{\"1\":{\"125\":1}}],[\"否则查找失败\",{\"1\":{\"797\":1}}],[\"否则直接跳出\",{\"1\":{\"1519\":2}}],[\"否则直接退出循环\",{\"1\":{\"771\":1}}],[\"否则直接退出\",{\"1\":{\"759\":1}}],[\"否则直接写\",{\"1\":{\"272\":1}}],[\"否则采用\",{\"1\":{\"597\":1}}],[\"否则报错\",{\"1\":{\"593\":1}}],[\"否则会出现先扫描的消息要后投递的情况\",{\"1\":{\"1342\":1}}],[\"否则会报错\",{\"1\":{\"560\":1}}],[\"否则会招来附近的所有怪\",{\"1\":{\"428\":1}}],[\"否则计算任务的目标执行时间\",{\"1\":{\"379\":1}}],[\"否则就会发生异常错误\",{\"1\":{\"188\":1}}],[\"否则\",{\"1\":{\"87\":1,\"178\":1,\"327\":1,\"1486\":1}}],[\"等日志转发线程回填该\",{\"1\":{\"1509\":1}}],[\"等元数据信息\",{\"1\":{\"1402\":1}}],[\"等技术来降低延迟\",{\"1\":{\"1385\":1}}],[\"等信息放入请求中\",{\"1\":{\"1491\":1}}],[\"等信息复原\",{\"1\":{\"1374\":1}}],[\"等信息组合计算生成一个字符串\",{\"1\":{\"899\":1}}],[\"等于\",{\"1\":{\"1511\":1,\"1520\":1}}],[\"等于当前\",{\"1\":{\"1503\":1}}],[\"等于和不等于\",{\"1\":{\"1308\":1}}],[\"等于文件最后修改的时间\",{\"1\":{\"870\":1}}],[\"等价于<\",{\"1\":{\"1308\":1}}],[\"等价于>=\",{\"1\":{\"1308\":1}}],[\"等到到一定时间或者缓冲区中消息到一定数量\",{\"1\":{\"1388\":1}}],[\"等到\",{\"1\":{\"1230\":1}}],[\"等到下一次重平衡\",{\"1\":{\"1215\":1}}],[\"等消息队列有较大的不同\",{\"1\":{\"681\":1}}],[\"等同于\",{\"1\":{\"563\":1,\"582\":1,\"584\":1,\"595\":1,\"596\":1}}],[\"等同于1234\",{\"1\":{\"294\":1}}],[\"等号右边是变量\",{\"1\":{\"555\":1}}],[\"等蜘蛛孵出来了就可以和\",{\"1\":{\"425\":1}}],[\"等待队列清空\",{\"1\":{\"1520\":1}}],[\"等待获取请求结果\",{\"1\":{\"1519\":1}}],[\"等待的\",{\"1\":{\"1519\":1}}],[\"等待的时间根据长轮询\",{\"1\":{\"815\":1}}],[\"等待响应挂起的\",{\"1\":{\"1514\":1}}],[\"等待日志转发完成\",{\"1\":{\"1508\":1}}],[\"等待日志转发线程将日志转发到\",{\"1\":{\"1507\":1}}],[\"等待各个节点响应\",{\"1\":{\"1502\":1}}],[\"等待心跳结果\",{\"1\":{\"1499\":1}}],[\"等待心跳响应\",{\"1\":{\"1488\":1}}],[\"等待在指定时间内收到\",{\"1\":{\"1497\":1}}],[\"等待所有节点的心跳响应\",{\"1\":{\"1499\":1}}],[\"等待所有节点响应并仲裁结果\",{\"1\":{\"1486\":1}}],[\"等待所有响应结果\",{\"1\":{\"1497\":1}}],[\"等待所有查询任务完成\",{\"1\":{\"1415\":1,\"1436\":1}}],[\"等待直到获取锁成功\",{\"1\":{\"1427\":1}}],[\"等待压缩后的索引文件刷盘到分级存储\",{\"1\":{\"1435\":1}}],[\"等待压缩\",{\"1\":{\"1414\":1,\"1434\":1}}],[\"等待批量上传\",{\"1\":{\"1403\":1}}],[\"等待定时消息请求处理\",{\"1\":{\"1372\":1}}],[\"等待定时消息删除请求处理\",{\"1\":{\"1372\":1}}],[\"等待处理完毕\",{\"1\":{\"1358\":2}}],[\"等待1s继续写入\",{\"1\":{\"1297\":1}}],[\"等待重新投票\",{\"1\":{\"1491\":1,\"1497\":1}}],[\"等待重新消费\",{\"1\":{\"1197\":1,\"1218\":1}}],[\"等待重试\",{\"1\":{\"921\":1,\"1337\":1}}],[\"等待pullinterval毫秒后重新拉取\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"等待一会再开始新一个投递任务\",{\"1\":{\"933\":1}}],[\"等待一定时间\",{\"1\":{\"824\":1}}],[\"等待0\",{\"1\":{\"860\":1,\"861\":1}}],[\"等待下一次消息队列重新负载\",{\"1\":{\"1175\":1}}],[\"等待下次检查\",{\"1\":{\"825\":1}}],[\"等待下游进程授予更多信用\",{\"1\":{\"622\":1}}],[\"等待ack的消息数量\",{\"1\":{\"690\":1}}],[\"等待indicator任务去取数据\",{\"1\":{\"379\":1}}],[\"等待\",{\"0\":{\"1518\":1},\"1\":{\"379\":1,\"726\":1,\"845\":1,\"1140\":1,\"1228\":3,\"1271\":1,\"1278\":1,\"1371\":1,\"1374\":1,\"1483\":1,\"1510\":2,\"1516\":1,\"1518\":3,\"1519\":2}}],[\"等待调度器调度\",{\"1\":{\"378\":1}}],[\"等待worker接受状态的任务\",{\"1\":{\"374\":1}}],[\"等待派发\",{\"1\":{\"374\":1}}],[\"等待进一步修复\",{\"1\":{\"284\":1}}],[\"等\",{\"1\":{\"262\":1,\"687\":1,\"1385\":1,\"1521\":1}}],[\"等等\",{\"1\":{\"261\":1,\"597\":1,\"671\":1}}],[\"等模式进行匹配\",{\"1\":{\"187\":1}}],[\"等高\",{\"1\":{\"153\":1}}],[\"等这个方法执行完成后\",{\"1\":{\"87\":1}}],[\"等新事务完成后\",{\"1\":{\"87\":1}}],[\"都响应\",{\"1\":{\"1499\":1}}],[\"都降为\",{\"1\":{\"1479\":1}}],[\"都写入失败则打印错误日志\",{\"1\":{\"1414\":1}}],[\"都写在属性或方法的最前面\",{\"1\":{\"575\":1}}],[\"都扩展了这个类\",{\"1\":{\"1402\":1}}],[\"都取出\",{\"1\":{\"1371\":1}}],[\"都不可避免发生随机读\",{\"1\":{\"1363\":1}}],[\"都有做定时持久化\",{\"1\":{\"1362\":1}}],[\"都有对应的包装对象\",{\"1\":{\"508\":1}}],[\"都需要实现\",{\"1\":{\"1318\":1}}],[\"都需要用用户名和密码新建一个\",{\"1\":{\"984\":1}}],[\"都被设计成先尝试放入内存中匹配\",{\"1\":{\"1261\":1}}],[\"都涉及到从存储中\",{\"1\":{\"1258\":1}}],[\"都涉及到其他方面的一些取舍\",{\"1\":{\"924\":1}}],[\"都要进行重平衡操作\",{\"1\":{\"1249\":1}}],[\"都要求技能规划和奶量\",{\"1\":{\"443\":1}}],[\"都消费相同的\",{\"1\":{\"1089\":1}}],[\"都未启动成功\",{\"1\":{\"1079\":1}}],[\"都将会是\",{\"1\":{\"1075\":1}}],[\"都保存所有对应延迟等级的定时消息\",{\"1\":{\"836\":1}}],[\"都对应一个\",{\"1\":{\"746\":1}}],[\"都挂载\",{\"1\":{\"720\":1}}],[\"都必须显式设置\",{\"1\":{\"585\":1}}],[\"都必须开启一个新的事务执行\",{\"1\":{\"87\":1}}],[\"都会封装成消息进行定时投递\",{\"1\":{\"1263\":1}}],[\"都会判断是否持有\",{\"1\":{\"1209\":1}}],[\"都会遍历\",{\"1\":{\"954\":1}}],[\"都会有一个消费队列\",{\"1\":{\"867\":1}}],[\"都会进行检查和删除\",{\"1\":{\"866\":1}}],[\"都会进行\",{\"1\":{\"864\":1}}],[\"都会从链表的头部插入\",{\"1\":{\"787\":1}}],[\"都会创建一个\",{\"1\":{\"755\":1}}],[\"都会发送一次消息和接收一次消息\",{\"1\":{\"668\":1}}],[\"都会向rabbit\",{\"1\":{\"626\":1}}],[\"都会自动声明对应修饰符的实例属性\",{\"1\":{\"576\":1}}],[\"都会打的情况下这个\",{\"1\":{\"445\":1}}],[\"都是在消息生产到\",{\"1\":{\"1338\":1}}],[\"都是消费失败的\",{\"1\":{\"1195\":2}}],[\"都是消费者收到\",{\"1\":{\"1136\":1}}],[\"都是构建消费请求\",{\"1\":{\"1187\":1}}],[\"都是\",{\"1\":{\"869\":1,\"894\":1}}],[\"都是非相对模块\",{\"1\":{\"598\":1}}],[\"都是相对模块\",{\"1\":{\"598\":1}}],[\"都是object类型\",{\"1\":{\"511\":1}}],[\"都是使用字面量\",{\"1\":{\"509\":1}}],[\"都是通过某个插件\",{\"1\":{\"64\":1}}],[\"都提升\",{\"1\":{\"485\":1}}],[\"都灭的死去活来\",{\"1\":{\"399\":1}}],[\"都只有较少的映射关系需要改变\",{\"1\":{\"387\":1}}],[\"都可以存储消息轨迹数据\",{\"1\":{\"1012\":1}}],[\"都可以使用子类型\",{\"1\":{\"520\":1}}],[\"都可以使用相同的方式来通信\",{\"1\":{\"372\":1}}],[\"都可以配置成非阻塞模式\",{\"1\":{\"118\":1}}],[\"都为\",{\"1\":{\"186\":1,\"1519\":1}}],[\"都关联一个\",{\"1\":{\"135\":1}}],[\"那要继续进行任务的转移\",{\"1\":{\"931\":1}}],[\"那它真的完美吗\",{\"1\":{\"931\":1}}],[\"那这个文件的删除时间需要在延迟最大的消息投递之后\",{\"1\":{\"928\":1}}],[\"那就直接读取\",{\"1\":{\"879\":1}}],[\"那就是镜像队列\",{\"1\":{\"692\":1}}],[\"那就必须使用格式化的写语句\",{\"1\":{\"178\":1}}],[\"那时候有大量\",{\"1\":{\"472\":1}}],[\"那是唯一有伤害的时候\",{\"1\":{\"452\":1}}],[\"那个时候确实基本功太差\",{\"1\":{\"399\":1}}],[\"那样强大\",{\"1\":{\"237\":1}}],[\"那也不开启事务执行\",{\"1\":{\"87\":1}}],[\"那么为分级存储\",{\"1\":{\"1403\":1}}],[\"那么起始位置即该\",{\"1\":{\"1403\":1}}],[\"那么开启布隆过滤器之后消费和生产的性能如何\",{\"1\":{\"1325\":1}}],[\"那么轻量级队列的实现也就呼之欲出\",{\"1\":{\"1291\":1}}],[\"那么本次无法将该队列解锁\",{\"1\":{\"1225\":1}}],[\"那么需要将\",{\"1\":{\"1203\":1}}],[\"那么进行分页\",{\"1\":{\"1194\":1}}],[\"那么进程会解除阻塞\",{\"1\":{\"626\":1}}],[\"那么进程阻塞之后\",{\"1\":{\"625\":1}}],[\"那么挂起当前拉取请求\",{\"1\":{\"1173\":1}}],[\"那么可以用消费队列来表示一个\",{\"1\":{\"1291\":1}}],[\"那么可以用如下命令打镜像\",{\"1\":{\"1072\":1}}],[\"那么可以表示不同的\",{\"1\":{\"902\":1}}],[\"那么该\",{\"1\":{\"1028\":1}}],[\"那么该拉取请求会重新放回\",{\"1\":{\"825\":1}}],[\"那么如何在发送普通消息的同时发送消息轨迹消息\",{\"1\":{\"1010\":1}}],[\"那么下任务会在上个任务\",{\"1\":{\"932\":1}}],[\"那么下次\",{\"1\":{\"789\":1}}],[\"那么最大延迟时间还是会受到普通消息文件过期时间的限制\",{\"1\":{\"926\":1}}],[\"那么他们的投递就是按顺序的\",{\"1\":{\"925\":1}}],[\"那么他们之间可以直接通信\",{\"1\":{\"67\":1}}],[\"那么服务端在收到消息后需要对消息进行排序再投递\",{\"1\":{\"925\":1}}],[\"那么消息的\",{\"1\":{\"924\":1}}],[\"那么消息索引都还没有被存入\",{\"1\":{\"765\":1}}],[\"那么只能把定时消息单独存储\",{\"1\":{\"928\":1}}],[\"那么只要发送一条定时消息取消的命令就可以取消之前发送的定时消息投递\",{\"1\":{\"921\":1,\"1337\":1}}],[\"那么只有变量c1可以调用这些属性和方法\",{\"1\":{\"573\":1}}],[\"那么既然已经直到\",{\"1\":{\"906\":1}}],[\"那么想要优化这个方法最直接的方式就是\",{\"1\":{\"896\":1}}],[\"那么等下次到达\",{\"1\":{\"866\":1}}],[\"那么等待一会后再次执行扫描\",{\"1\":{\"855\":1}}],[\"那么等待0\",{\"1\":{\"845\":1}}],[\"那么会删除这些文件\",{\"1\":{\"864\":1}}],[\"那么会将该拉取请求挂起\",{\"1\":{\"806\":1}}],[\"那么无法重新投递\",{\"1\":{\"847\":1}}],[\"那么无需额外引入依赖\",{\"1\":{\"8\":1}}],[\"那么创建一个定时任务\",{\"1\":{\"845\":1,\"860\":1}}],[\"那么创建一个新的文件\",{\"1\":{\"789\":1}}],[\"那么延迟时间最长为3天\",{\"1\":{\"833\":1}}],[\"那么按照上述流程\",{\"1\":{\"806\":1}}],[\"那么根据\",{\"1\":{\"806\":1}}],[\"那么将新建处理轨迹的钩子\",{\"1\":{\"1014\":1}}],[\"那么将唤醒对应的拉取请求\",{\"1\":{\"812\":1}}],[\"那么将拉取到的消息直接返回\",{\"1\":{\"806\":1}}],[\"那么将在另一个节点上创建一个新镜像\",{\"1\":{\"657\":1}}],[\"那么你有没有想过\",{\"1\":{\"802\":1}}],[\"那么索引文件的存储格式也是\",{\"1\":{\"780\":1}}],[\"那么队列数据就永久丢失了\",{\"1\":{\"703\":1}}],[\"那么队列应该是没有消息堆积或者堆积非常少的\",{\"1\":{\"693\":1}}],[\"那么同步的影响就比较小\",{\"1\":{\"693\":1}}],[\"那么就可以把这个正则表达式匹配给优化掉\",{\"1\":{\"904\":1}}],[\"那么就意味着要将当前所有的消息从主队列同步到从队列\",{\"1\":{\"693\":1}}],[\"那么就会出现数据的丢失\",{\"1\":{\"659\":1}}],[\"那么b节点需要再将消息发送给新增的e节点\",{\"1\":{\"674\":1}}],[\"那么节点b感知后节点c失效后需要重新将消息发送给d\",{\"1\":{\"674\":1}}],[\"那么相邻的节点可能需要重新发送给新的节点\",{\"1\":{\"674\":1}}],[\"那么由于ha\",{\"1\":{\"659\":1}}],[\"那么这里就还需要一个投递任务状态更新线程\",{\"1\":{\"933\":1}}],[\"那么这个订单不再需要被取消\",{\"1\":{\"921\":1,\"1337\":1}}],[\"那么这个方法做了什么\",{\"1\":{\"896\":1}}],[\"那么这个任务实例的状态就停留在dispatch\",{\"1\":{\"375\":1}}],[\"那么这是一个很好的选择\",{\"1\":{\"658\":1}}],[\"那么模块定位采用\",{\"1\":{\"597\":1}}],[\"那么没有其他选择只能使用type\",{\"1\":{\"564\":1}}],[\"那么前一个函数就称为高阶函数\",{\"1\":{\"546\":1}}],[\"那么类型a就称为类型b的子类型\",{\"1\":{\"520\":1}}],[\"那么完全不打伤害也是可以限\",{\"1\":{\"412\":1}}],[\"那么一开始就应该照着上限最高的方式去练习\",{\"1\":{\"412\":1}}],[\"那么server的性能就会成为瓶颈\",{\"1\":{\"380\":1}}],[\"那么在这个小型\",{\"1\":{\"380\":1}}],[\"那么剩余的任务实例是否就没有调度了\",{\"1\":{\"374\":1}}],[\"那么a只会移除前k个x\",{\"1\":{\"212\":1}}],[\"那么expattern1等捕捉模式就会与它进行匹配\",{\"1\":{\"194\":1}}],[\"那么整个\",{\"1\":{\"194\":1}}],[\"那么函数的返回值就会与pattern1\",{\"1\":{\"194\":1}}],[\"那么if的值就是执行表达式序列\",{\"1\":{\"188\":1}}],[\"那么\",{\"1\":{\"177\":1,\"804\":1,\"874\":1}}],[\"那么它会打开一个新的jdbc连接\",{\"1\":{\"87\":1}}],[\"那么当前事务会挂起\",{\"1\":{\"87\":2}}],[\"那么计算该计算机的网络号是\",{\"1\":{\"67\":1}}],[\"访问控制列表\",{\"1\":{\"996\":1}}],[\"访问控制的基本要素\",{\"1\":{\"978\":1}}],[\"访问对象属性时会逐级往上查\",{\"1\":{\"340\":1}}],[\"访问列表头是一种非常高效的操作\",{\"1\":{\"177\":1}}],[\"访问数据库\",{\"0\":{\"86\":1}}],[\"访问字段\",{\"0\":{\"38\":1}}],[\"目录创建一个新格式的索引文件\",{\"1\":{\"1394\":1}}],[\"目录下\",{\"1\":{\"1074\":1}}],[\"目录下所有acl配置文件和\",{\"1\":{\"999\":1}}],[\"目录下的\",{\"1\":{\"749\":1}}],[\"目录\",{\"1\":{\"998\":1}}],[\"目录中\",{\"1\":{\"749\":1}}],[\"目录如下\",{\"1\":{\"379\":1}}],[\"目前最小的偏移量\",{\"1\":{\"1519\":1}}],[\"目前提供了内存和本地磁盘的实现\",{\"1\":{\"1387\":1}}],[\"目前的分级存储方案考虑到商业和开源技术架构的一致性\",{\"1\":{\"1385\":1}}],[\"目前还不能在broker配置文件中设置\",{\"1\":{\"999\":1}}],[\"目前支持的protocol包括akka和http\",{\"1\":{\"374\":1}}],[\"目前\",{\"1\":{\"286\":1,\"1382\":1}}],[\"目前市面上绝大部分混沌工程工具\",{\"1\":{\"277\":1}}],[\"目标节点\",{\"1\":{\"1519\":1}}],[\"目标是友方则按一下变人按两下冲锋\",{\"1\":{\"490\":1}}],[\"目标是敌人则按一下变豹子按两下冲锋\",{\"1\":{\"490\":1}}],[\"目标为友放时使用治疗技能\",{\"1\":{\"488\":1}}],[\"目标的\",{\"1\":{\"417\":1}}],[\"目标的情况下你应该也使用上述策略\",{\"1\":{\"417\":1}}],[\"目标\",{\"1\":{\"412\":2}}],[\"目标代码块\",{\"1\":{\"180\":1}}],[\"目标对象和切面都是普通java类\",{\"1\":{\"85\":1}}],[\"目的是避免多线程下的竞争条件和同步问题\",{\"1\":{\"124\":1}}],[\"目的是为了少写代码\",{\"1\":{\"30\":1}}],[\"其最大\",{\"1\":{\"1511\":1}}],[\"其它的客户端请求和日志追加请求不在\",{\"1\":{\"1477\":1}}],[\"其延迟在热数据读写的情况下也不是瓶颈\",{\"1\":{\"1385\":1}}],[\"其会生成如下七个\",{\"1\":{\"1321\":1}}],[\"其支持多种消息过滤方式\",{\"1\":{\"1303\":1}}],[\"其内用\",{\"1\":{\"1155\":1}}],[\"其内部的局部变量还被新函数引用\",{\"1\":{\"330\":1}}],[\"其次这样还是又违反了cap中的a的设计\",{\"1\":{\"942\":1}}],[\"其必须有如下的特点\",{\"1\":{\"923\":1}}],[\"其对\",{\"1\":{\"886\":1}}],[\"其每次最多预分配\",{\"1\":{\"881\":1}}],[\"其\",{\"1\":{\"756\":1,\"1386\":1,\"1509\":1,\"1520\":1}}],[\"其格式和大小是固定的\",{\"1\":{\"755\":1}}],[\"其默认长度\",{\"1\":{\"741\":1}}],[\"其作用是通知\",{\"1\":{\"674\":1}}],[\"其可设置的值为\",{\"1\":{\"659\":1}}],[\"其余的调整点主要是破晨和通灵可以把强化驱散那点拿掉\",{\"1\":{\"403\":1}}],[\"其逻辑如下\",{\"1\":{\"379\":1}}],[\"其uml类图如下\",{\"1\":{\"379\":1}}],[\"其用于远程通信的优势如下\",{\"1\":{\"372\":1}}],[\"其适用场景如下\",{\"1\":{\"371\":1}}],[\"其一是将调用包裹在`try\",{\"1\":{\"193\":1,\"194\":1}}],[\"其实在\",{\"1\":{\"1510\":1}}],[\"其实在最初还实现了另一种方案\",{\"1\":{\"930\":1}}],[\"其实作用不同\",{\"1\":{\"889\":1}}],[\"其实就是文件预分配的请求\",{\"1\":{\"881\":1}}],[\"其实现了一个新的定时消息\",{\"1\":{\"848\":1}}],[\"其实是\",{\"1\":{\"780\":1}}],[\"其实是指\",{\"1\":{\"272\":1}}],[\"其实同步保存和异步保存消息的逻辑差不多\",{\"1\":{\"731\":1}}],[\"其实\",{\"1\":{\"692\":1,\"741\":1}}],[\"其实用猫奶\",{\"1\":{\"443\":1}}],[\"其实治疗量压力没那么大\",{\"1\":{\"441\":1}}],[\"其实这个值在消息被保存到\",{\"1\":{\"765\":1}}],[\"其实这个\",{\"1\":{\"431\":1}}],[\"其实树奶在大多数情况下和猫奶差不太多\",{\"1\":{\"401\":1}}],[\"其实只是简单规定了一下\",{\"1\":{\"368\":1}}],[\"其实只是一个列表的简写\",{\"1\":{\"178\":1}}],[\"其实默认的required已经满足绝大部分需求\",{\"1\":{\"87\":1}}],[\"其他的几个\",{\"1\":{\"1508\":1}}],[\"其他的版本已经跟不上时代了\",{\"1\":{\"1073\":1}}],[\"其他情况\",{\"1\":{\"1491\":1}}],[\"其他选项为\",{\"1\":{\"1382\":1}}],[\"其他存储介质分级存储的实现需要用户自行扩展来实现\",{\"1\":{\"1380\":1}}],[\"其他设计\",{\"0\":{\"1361\":1}}],[\"其他消费者会获取\",{\"1\":{\"1215\":1}}],[\"其他消费者收到消费者数量变化请求时进行重平衡\",{\"1\":{\"1136\":1}}],[\"其他线程都在等待锁释放\",{\"1\":{\"1207\":1}}],[\"其他请求类型由\",{\"1\":{\"944\":1}}],[\"其他逻辑有所省略\",{\"1\":{\"812\":1}}],[\"其他队列流量较小\",{\"1\":{\"707\":1}}],[\"其他队列只会保存这条消息的引用\",{\"1\":{\"700\":1}}],[\"其他4个队列则是由erlang\",{\"1\":{\"690\":1}}],[\"其他任何值都可以赋值给object类型\",{\"1\":{\"511\":1}}],[\"其他运算都会报错\",{\"1\":{\"503\":1}}],[\"其他推荐的宏\",{\"0\":{\"490\":1}}],[\"其他人的个减要留到喷丝射线\",{\"1\":{\"447\":1}}],[\"其他人轮流使用个减和群减来降低晦影腐朽的伤害\",{\"1\":{\"446\":1}}],[\"其他使用场景\",{\"1\":{\"316\":1}}],[\"其他函数\",{\"1\":{\"313\":1}}],[\"其他变量\",{\"1\":{\"313\":1,\"502\":1}}],[\"其他语句\",{\"1\":{\"311\":1}}],[\"其他故障期间花费7秒会恢复集群为可用状态\",{\"1\":{\"284\":1}}],[\"其他环境配置\",{\"1\":{\"272\":1}}],[\"其他\",{\"1\":{\"118\":1,\"1480\":1}}],[\"其他基本不会用到\",{\"1\":{\"87\":1}}],[\"其他必须用\",{\"1\":{\"82\":1}}],[\"其中后面\",{\"1\":{\"1508\":1}}],[\"其中中间的是主节点\",{\"1\":{\"1481\":1}}],[\"其中最大偏移量取的是消费队列的已提交偏移量\",{\"1\":{\"1430\":1,\"1432\":1}}],[\"其中最多只有最后一个\",{\"1\":{\"1402\":1}}],[\"其中索引文件单独存放\",{\"1\":{\"1383\":1}}],[\"其中重平衡是消费者开始消费的起点\",{\"1\":{\"1125\":1}}],[\"其中启动参数设置脚本如下\",{\"1\":{\"1080\":1}}],[\"其中生产者负责发送消息\",{\"1\":{\"1030\":1}}],[\"其中包含有消费者名称经过\",{\"1\":{\"1323\":1}}],[\"其中包含每个\",{\"1\":{\"1029\":1}}],[\"其中包含该\",{\"1\":{\"950\":1}}],[\"其中key表示accesskey\",{\"1\":{\"997\":1}}],[\"其中key表示acl配置文件的绝对路径\",{\"1\":{\"997\":2}}],[\"其中key是string类型表示accesskey\",{\"1\":{\"997\":1}}],[\"其中红色线为初始化的方法调用链\",{\"1\":{\"990\":1,\"997\":1}}],[\"其中数据内容如下\",{\"1\":{\"944\":1}}],[\"其中华为云\",{\"1\":{\"922\":1}}],[\"其中主要包含了复杂的\",{\"1\":{\"896\":1}}],[\"其中保存有消息在\",{\"1\":{\"751\":1}}],[\"其中4\",{\"1\":{\"729\":1}}],[\"其中400表示每个进程初始的信用值\",{\"1\":{\"618\":1}}],[\"其中一个broker节点定义为存储消息轨迹数据的服务端\",{\"1\":{\"1004\":1}}],[\"其中一个在另外节点的从副本会被选举成为主副本\",{\"1\":{\"695\":1}}],[\"其中一个从队列会晋升成主队列\",{\"1\":{\"693\":1}}],[\"其中一个会重新变为mirror\",{\"1\":{\"659\":1}}],[\"其中只有主节点向外提供服务\",{\"1\":{\"649\":1}}],[\"其中self\",{\"1\":{\"626\":1}}],[\"其中mainloop会调用recvloop函数\",{\"1\":{\"625\":1}}],[\"其中map\",{\"1\":{\"371\":1}}],[\"其中存放的元素是hashedwheeltimerfuture\",{\"1\":{\"379\":1}}],[\"其中timer用于精确调度\",{\"1\":{\"379\":1}}],[\"其中cron\",{\"1\":{\"374\":1}}],[\"其中changecost\",{\"1\":{\"285\":1}}],[\"其中参数是对象\",{\"1\":{\"266\":1}}],[\"其中参数是普通变量\",{\"1\":{\"266\":1}}],[\"其中每一行都是\",{\"1\":{\"253\":1}}],[\"其中橙色的\",{\"1\":{\"120\":1}}],[\"其中的每个\",{\"1\":{\"1126\":1}}],[\"其中的多个\",{\"1\":{\"1074\":1}}],[\"其中的\",{\"1\":{\"118\":1,\"184\":2,\"1017\":1,\"1317\":1,\"1346\":1}}],[\"其中第一个字节的最高位始终为1\",{\"1\":{\"27\":1}}],[\"其中\",{\"1\":{\"21\":1,\"68\":1,\"385\":1,\"644\":1,\"755\":1,\"756\":1,\"815\":1,\"850\":1,\"869\":1,\"870\":2,\"890\":1,\"930\":1,\"944\":1,\"961\":1,\"1038\":1,\"1055\":1,\"1072\":1,\"1109\":1,\"1116\":1,\"1245\":1,\"1247\":1,\"1300\":1,\"1315\":1,\"1318\":1,\"1321\":1,\"1481\":1,\"1482\":1}}],[\"相等\",{\"1\":{\"1492\":2,\"1503\":1}}],[\"相等则遍历每个acl配置文件\",{\"1\":{\"999\":1}}],[\"相似的\",{\"1\":{\"1352\":1}}],[\"相对于起始偏移量\",{\"1\":{\"1258\":1}}],[\"相对于长轮询通知\",{\"1\":{\"1173\":1}}],[\"相对应地\",{\"1\":{\"989\":1}}],[\"相对模块依然是以当前脚本的路径作为\",{\"1\":{\"600\":1}}],[\"相对模块指的是路径以\",{\"1\":{\"598\":1}}],[\"相对模块\",{\"0\":{\"598\":1}}],[\"相关消息属性\",{\"1\":{\"1286\":1}}],[\"相关类设计\",{\"0\":{\"1155\":1}}],[\"相关的类\",{\"1\":{\"990\":1}}],[\"相关的类有\",{\"1\":{\"760\":1}}],[\"相关信息移除\",{\"1\":{\"954\":1}}],[\"相关操作的源码实现\",{\"1\":{\"760\":1}}],[\"相邻的节点会接管以保证本次广播的消息会复制到所有的节点\",{\"1\":{\"673\":1}}],[\"相邻的节点保证当前广播的消息会复制到新的节点上\",{\"1\":{\"673\":1}}],[\"相反如果b节点成为赢家\",{\"1\":{\"659\":1}}],[\"相应地\",{\"1\":{\"591\":1}}],[\"相应的表达式序列就会执行\",{\"1\":{\"187\":1}}],[\"相生\",{\"1\":{\"405\":1}}],[\"相同会导致\",{\"1\":{\"1240\":1}}],[\"相同\",{\"0\":{\"1240\":1},\"1\":{\"1240\":2,\"1489\":1}}],[\"相同的\",{\"1\":{\"998\":1}}],[\"相同的输入一定得到相同的输出\",{\"1\":{\"385\":1}}],[\"相同名称的\",{\"1\":{\"902\":1}}],[\"相同类型的bean只能有一个指定为\",{\"1\":{\"82\":1}}],[\"相较于传统混沌工程\",{\"1\":{\"282\":1}}],[\"相比之前的\",{\"1\":{\"132\":1}}],[\"相当于将所有需要过滤的消费者名称存入布隆过滤器\",{\"1\":{\"1323\":1}}],[\"相当于一个\",{\"1\":{\"896\":1,\"897\":1}}],[\"相当于最后带\",{\"1\":{\"188\":1}}],[\"相当于从连接池获取到一个新的connection\",{\"1\":{\"89\":1}}],[\"相当于b\",{\"1\":{\"54\":1}}],[\"允许的最大挂起条目数量\",{\"1\":{\"1519\":1}}],[\"允许上传到分级存储的消息\",{\"1\":{\"1403\":1}}],[\"允许任意\",{\"1\":{\"1328\":1}}],[\"允许加载模块时\",{\"1\":{\"591\":1}}],[\"允许函数增加一个名为this的参数\",{\"1\":{\"580\":1}}],[\"允许在类的定义前面\",{\"1\":{\"579\":1}}],[\"允许继承多个\",{\"1\":{\"560\":1}}],[\"允许省略参数\",{\"1\":{\"533\":1}}],[\"允许声明只读数组\",{\"1\":{\"524\":1}}],[\"允许开发者在tsconfig\",{\"1\":{\"601\":1}}],[\"允许开发者在某个位置\",{\"1\":{\"589\":1}}],[\"允许开发者在代码中\",{\"1\":{\"589\":1}}],[\"允许开发者在前端界面上可视化完成任务\",{\"1\":{\"372\":1}}],[\"允许开发者可视化地完成调度任务的管理\",{\"1\":{\"371\":1}}],[\"允许多个元素拥有相同的键\",{\"1\":{\"248\":1}}],[\"允许可选注入\",{\"1\":{\"82\":1}}],[\"允许把函数本身作为参数传入另一个函数\",{\"1\":{\"74\":1}}],[\"定期扫描和更新内部数据\",{\"1\":{\"945\":1}}],[\"定期请求\",{\"1\":{\"941\":1}}],[\"定期向\",{\"1\":{\"941\":1}}],[\"定时上传消息到分级存储\",{\"0\":{\"1427\":1}}],[\"定时上报到\",{\"1\":{\"1104\":1}}],[\"定时精度\",{\"1\":{\"1367\":1}}],[\"定时时间\",{\"1\":{\"1364\":1}}],[\"定时时间为当前时间\",{\"1\":{\"1339\":1}}],[\"定时投递时间\",{\"1\":{\"1367\":1,\"1371\":1}}],[\"定时投递\",{\"1\":{\"1339\":1}}],[\"定时到重试时间\",{\"1\":{\"1263\":1}}],[\"定时到唤醒重试时间投递\",{\"1\":{\"1260\":1,\"1273\":1}}],[\"定时持久化消费进度\",{\"1\":{\"1201\":1}}],[\"定时持久化的设计\",{\"1\":{\"1190\":1}}],[\"定时持久化的设计方法\",{\"1\":{\"1190\":1}}],[\"定时触发\",{\"1\":{\"1128\":1}}],[\"定时任务划分和解耦\",{\"0\":{\"1348\":1}}],[\"定时任务\",{\"1\":{\"1112\":1,\"1427\":1}}],[\"定时任务中记录的offset已经被删除\",{\"1\":{\"845\":1}}],[\"定时刷盘\",{\"1\":{\"1104\":1}}],[\"定时将\",{\"1\":{\"1521\":1}}],[\"定时将本地已经攒批的数据上传到分级存储\",{\"1\":{\"1402\":1}}],[\"定时将内存中的消费进度提交到\",{\"1\":{\"1103\":1}}],[\"定时将offsettable持久化\",{\"1\":{\"840\":1,\"844\":1}}],[\"定时调用\",{\"1\":{\"841\":1}}],[\"定时消息请求列表\",{\"1\":{\"1372\":1}}],[\"定时消息是不是近\",{\"1\":{\"1371\":1}}],[\"定时消息放入时间轮\",{\"0\":{\"1371\":1}}],[\"定时消息主题只有一个队列\",{\"1\":{\"1370\":1}}],[\"定时消息主题队列\",{\"1\":{\"1370\":1}}],[\"定时消息主要的逻辑可以分为保存和投递两个阶段\",{\"1\":{\"1353\":1}}],[\"定时消息数据\",{\"1\":{\"1364\":1}}],[\"定时消息文件\",{\"0\":{\"1366\":1}}],[\"定时消息文件的恢复\",{\"0\":{\"1362\":1}}],[\"定时消息文件设计\",{\"0\":{\"1350\":1}}],[\"定时消息在被保存到\",{\"1\":{\"1354\":1}}],[\"定时消息在当前的互联网环境中有非常大的需求\",{\"1\":{\"921\":1}}],[\"定时消息保存\",{\"0\":{\"1354\":1}}],[\"定时消息索引文件\",{\"0\":{\"1352\":1}}],[\"定时消息索引的存储方案设计就变得很简单\",{\"1\":{\"927\":1}}],[\"定时消息轮转\",{\"0\":{\"1347\":1}}],[\"定时消息更详细的原理可以看这篇文章\",{\"1\":{\"1188\":1}}],[\"定时消息已经上线\",{\"0\":{\"937\":1}}],[\"定时消息由于其延迟投递的特性\",{\"1\":{\"935\":1}}],[\"定时消息取消请求栈\",{\"1\":{\"1372\":1}}],[\"定时消息取消\",{\"0\":{\"935\":1},\"1\":{\"1373\":1}}],[\"定时消息和普通消息同时大量投递\",{\"1\":{\"931\":1}}],[\"定时消息和延迟消息是消息队列中对于消息的基本概念\",{\"1\":{\"920\":1}}],[\"定时消息和延迟消息是什么\",{\"0\":{\"920\":1}}],[\"定时消息的存储和老化\",{\"0\":{\"1343\":1}}],[\"定时消息的机制会不停扫描定时消息\",{\"1\":{\"1188\":1}}],[\"定时消息的投递默认使用异步刷盘的方式\",{\"1\":{\"930\":1}}],[\"定时消息的处理逻辑主要分为两个部分\",{\"1\":{\"930\":1}}],[\"定时消息的顺序\",{\"1\":{\"926\":1}}],[\"定时消息的实现\",{\"1\":{\"925\":1}}],[\"定时消息的精度越高就意味着定时任务执行越频繁\",{\"1\":{\"924\":1}}],[\"定时消息的需求和应用场景\",{\"0\":{\"921\":1}}],[\"定时消息如何投递\",{\"1\":{\"924\":1}}],[\"定时消息还能用于更多其他场景\",{\"1\":{\"921\":1,\"1337\":1}}],[\"定时消息投递步骤\",{\"0\":{\"1353\":1,\"1369\":1}}],[\"定时消息投递失败\",{\"1\":{\"931\":1}}],[\"定时消息投递\",{\"0\":{\"930\":1,\"1357\":1}}],[\"定时消息投递任务\",{\"0\":{\"860\":1}}],[\"定时消息投递线程\",{\"0\":{\"857\":1}}],[\"定时消息时序图\",{\"0\":{\"837\":1}}],[\"定时消息涉及到的类\",{\"0\":{\"836\":1}}],[\"定时消息指消息发送后\",{\"1\":{\"832\":1}}],[\"定时消息指发送一条消息\",{\"1\":{\"832\":1}}],[\"定时消息概念\",{\"0\":{\"832\":1}}],[\"定时消息\",{\"0\":{\"830\":1,\"849\":1},\"1\":{\"850\":1,\"920\":1,\"1273\":1,\"1337\":1,\"1338\":2,\"1538\":2}}],[\"定时策略完善\",{\"1\":{\"371\":1}}],[\"定位到对应的消费队列文件\",{\"1\":{\"766\":1}}],[\"定位到对应消息\",{\"1\":{\"757\":1}}],[\"定制\",{\"0\":{\"82\":1}}],[\"定义持久化哪些数据\",{\"1\":{\"1420\":1}}],[\"定义临时变量\",{\"1\":{\"998\":1}}],[\"定义了一个\",{\"1\":{\"1482\":2}}],[\"定义了更新\",{\"1\":{\"1190\":1}}],[\"定义了\",{\"1\":{\"1119\":1}}],[\"定义了初始长度\",{\"1\":{\"741\":1}}],[\"定义了所有输入流的超类\",{\"1\":{\"53\":1}}],[\"定义交换器\",{\"1\":{\"712\":1}}],[\"定义静态成员\",{\"1\":{\"577\":1}}],[\"定义成小写类型\",{\"1\":{\"509\":1}}],[\"定义一个异步函数\",{\"1\":{\"354\":1}}],[\"定义新的构造函数\",{\"1\":{\"342\":1}}],[\"定义\",{\"0\":{\"344\":1},\"1\":{\"191\":1,\"332\":1,\"712\":1}}],[\"定义可以包含在\",{\"1\":{\"191\":1}}],[\"定义子类是否可继承父类定义的annotation\",{\"1\":{\"43\":1}}],[\"定义annotation能够被应用于源码的哪些位置\",{\"1\":{\"43\":1}}],[\"定义注解\",{\"0\":{\"43\":1}}],[\"大多数节点已经写入的日志序号和它之前的日志序号都认为已经写入完成\",{\"1\":{\"1507\":1}}],[\"大多数时候\",{\"1\":{\"512\":1}}],[\"大多数时候你只要站在百花齐放圈里面\",{\"1\":{\"415\":1}}],[\"大\",{\"1\":{\"1499\":1}}],[\"大量消息的存储会导致\",{\"1\":{\"1364\":1}}],[\"大量的随机写\",{\"1\":{\"1363\":1}}],[\"大量定时消息的极端情况\",{\"0\":{\"1344\":1}}],[\"大量地处理消息\",{\"1\":{\"1003\":1}}],[\"大主流开源消息队列对定时消息的实现都有局限性\",{\"1\":{\"922\":1}}],[\"大于自身\",{\"1\":{\"1497\":1}}],[\"大于当前\",{\"1\":{\"1503\":1}}],[\"大于当前的\",{\"1\":{\"1492\":1}}],[\"大于当前节点\",{\"1\":{\"1491\":1}}],[\"大于当前节点的\",{\"1\":{\"1489\":1}}],[\"大于2000\",{\"1\":{\"1170\":1}}],[\"大于\",{\"1\":{\"952\":1,\"965\":1,\"1195\":2,\"1510\":1,\"1511\":1,\"1519\":2,\"1520\":1}}],[\"大于阈值\",{\"1\":{\"916\":1}}],[\"大于1024的端口可以由任意用户的应用程序打开\",{\"1\":{\"68\":1}}],[\"大小计算内存使用量\",{\"1\":{\"1406\":1}}],[\"大小和待消费消息偏移量差来判断\",{\"1\":{\"1159\":1}}],[\"大小\",{\"1\":{\"1080\":1,\"1352\":1,\"1420\":1}}],[\"大小为\",{\"1\":{\"904\":1}}],[\"大小的内存映射文件组成的文件队列\",{\"1\":{\"866\":1}}],[\"大幅度提升了延迟消息的性能\",{\"1\":{\"850\":1}}],[\"大致会经过从内存到磁盘再到内存的流程\",{\"1\":{\"681\":1}}],[\"大迅捷+愈合\",{\"1\":{\"490\":1}}],[\"大迅捷万灵\",{\"1\":{\"446\":2}}],[\"大红其实也可以作为一个治疗手牌来用\",{\"1\":{\"485\":1}}],[\"大米获取的替代品\",{\"0\":{\"480\":1}}],[\"大灵猫之踏\",{\"1\":{\"479\":1}}],[\"大山猫绑腿\",{\"1\":{\"479\":1}}],[\"大树的天赋组合\",{\"1\":{\"443\":1}}],[\"大概是一次捻接\",{\"1\":{\"434\":1}}],[\"大概鎏金刷满到\",{\"1\":{\"399\":1}}],[\"大捻接师艾佐\",{\"0\":{\"434\":1}}],[\"大大增加新绿的触发\",{\"1\":{\"415\":1}}],[\"大大增强了对次要目标的治疗\",{\"1\":{\"405\":1}}],[\"大大提高了开发效率\",{\"1\":{\"81\":1}}],[\"大秘境整体评分\",{\"1\":{\"400\":1}}],[\"大学到现在已经有\",{\"1\":{\"399\":1}}],[\"大学时候军团再临版本玩过几个月又\",{\"1\":{\"399\":1}}],[\"大脑中最后几块拼图也终于拼上了\",{\"1\":{\"271\":1}}],[\"大都具备这些处理流程\",{\"1\":{\"111\":1}}],[\"大部分情况下\",{\"1\":{\"917\":1}}],[\"大部分时候都可以变猫打\",{\"1\":{\"473\":1}}],[\"大部分时候都可以变猫输出\",{\"1\":{\"466\":1}}],[\"大部分时间都可以趴下输出\",{\"1\":{\"458\":1,\"460\":1}}],[\"大部分时间可以变猫输出\",{\"1\":{\"431\":1}}],[\"大部分的时间都花在\",{\"1\":{\"130\":1}}],[\"大部分\",{\"1\":{\"108\":1}}],[\"或不在有效范围内\",{\"1\":{\"1519\":1}}],[\"或应立即发起投票\",{\"1\":{\"1497\":1}}],[\"或需要立即开始下一轮投票\",{\"1\":{\"1486\":1}}],[\"或连接断开时触发\",{\"1\":{\"1331\":1}}],[\"或立即重新拉取\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"或它的变种算法\",{\"1\":{\"879\":1}}],[\"或开启强制删除\",{\"1\":{\"870\":1}}],[\"或刷盘间隔时间超过\",{\"1\":{\"752\":1}}],[\"或其他绑定\",{\"1\":{\"716\":1}}],[\"或配置文件中定义\",{\"1\":{\"660\":1}}],[\"或从一个\",{\"1\":{\"630\":1}}],[\"或自己\",{\"1\":{\"411\":1}}],[\"或parsefloat\",{\"1\":{\"333\":1}}],[\"或系统响应的预期时间为100ms\",{\"1\":{\"285\":1}}],[\"或进行分布式跟踪\",{\"1\":{\"276\":1}}],[\"或\",{\"1\":{\"196\":1,\"283\":1,\"419\":1,\"455\":1,\"591\":1,\"636\":1,\"715\":1,\"1278\":1,\"1307\":1,\"1395\":1,\"1442\":1,\"1519\":4}}],[\"或at\",{\"1\":{\"175\":1}}],[\"或者等待上传的消息超过一定数量\",{\"1\":{\"1388\":1}}],[\"或者按时间轮的定位情况写入多个文件\",{\"1\":{\"1363\":1}}],[\"或者全部消息都匹配成功\",{\"1\":{\"1277\":1}}],[\"或者全队吃隐身药\",{\"1\":{\"455\":1}}],[\"或者抛异常\",{\"1\":{\"1251\":1}}],[\"或者集群模式下处理队列被锁定且锁未超时\",{\"1\":{\"1230\":1}}],[\"或者处理队列中消息消费完\",{\"1\":{\"1217\":1}}],[\"或者更新现有锁\",{\"1\":{\"1214\":1}}],[\"或者小于\",{\"1\":{\"1198\":1}}],[\"或者频繁上下线时\",{\"1\":{\"1128\":1}}],[\"或者传入队列选择方法\",{\"1\":{\"1029\":1}}],[\"或者自研存储\",{\"1\":{\"928\":1}}],[\"或者时区不一致\",{\"1\":{\"866\":1}}],[\"或者磁盘空间告急\",{\"1\":{\"864\":1}}],[\"或者重试\",{\"1\":{\"855\":1}}],[\"或者延迟时间\",{\"1\":{\"832\":1}}],[\"或者是否需要跳过\",{\"1\":{\"1453\":1,\"1468\":1}}],[\"或者是存储在内存中以达到更高的生产和消费效率\",{\"1\":{\"681\":1}}],[\"或者是将队列中的消息存入磁盘的过程中引起服务器\",{\"1\":{\"622\":1}}],[\"或者有的镜像从集群中断开\",{\"1\":{\"664\":1}}],[\"或者您在rabbitmq节点和ha\",{\"1\":{\"658\":1}}],[\"或者原有的的队列\",{\"1\":{\"655\":1}}],[\"或者可以根据\",{\"1\":{\"644\":1}}],[\"或者执行后可以得到一个函数\",{\"1\":{\"605\":1}}],[\"或者多个条一起点你\",{\"1\":{\"492\":1}}],[\"或者跑路\",{\"1\":{\"459\":1}}],[\"或者规划团队减伤\",{\"1\":{\"426\":1}}],[\"或者直接调用某个对象的tostring\",{\"1\":{\"333\":1}}],[\"或者后续会发生变化的变量\",{\"1\":{\"330\":1}}],[\"或者其他可以使用表达式的地方\",{\"1\":{\"186\":1}}],[\"或者\",{\"1\":{\"119\":1,\"365\":1,\"433\":1,\"570\":1,\"583\":1,\"972\":1,\"978\":1,\"1419\":1}}],[\"或者称之为切面\",{\"1\":{\"85\":1}}],[\"或者说\",{\"1\":{\"81\":1}}],[\"或底层硬件可能对这部分测试代码进行许多优化\",{\"1\":{\"3\":1}}],[\"销毁时\",{\"1\":{\"81\":1}}],[\"组装读取到的索引项\",{\"1\":{\"1436\":1}}],[\"组元数据表\",{\"1\":{\"1420\":1}}],[\"组合\",{\"1\":{\"1386\":1}}],[\"组播\",{\"1\":{\"668\":1}}],[\"组中轮询选择一个\",{\"1\":{\"133\":1}}],[\"组\",{\"1\":{\"133\":2,\"134\":2}}],[\"组件会对实验中的业务和非业务数据进行自动化分析\",{\"1\":{\"280\":1}}],[\"组件定义的执行流程控制客户端对集群进行操作\",{\"1\":{\"280\":1}}],[\"组件负责客户端连接事件的分发\",{\"1\":{\"123\":1}}],[\"组件负责处理读取\",{\"1\":{\"120\":1}}],[\"组件\",{\"1\":{\"121\":1}}],[\"组件与\",{\"1\":{\"120\":1}}],[\"组件处理\",{\"1\":{\"120\":1}}],[\"组件根本不知道自己在spring的容器中运行\",{\"1\":{\"81\":1}}],[\"组件中用\",{\"1\":{\"81\":1}}],[\"组成的列表\",{\"1\":{\"184\":1}}],[\"组成的链表\",{\"1\":{\"135\":1,\"1386\":1,\"1402\":1}}],[\"组成\",{\"1\":{\"68\":1,\"1021\":1,\"1036\":1}}],[\"开关和多队列转发开关\",{\"1\":{\"1286\":1}}],[\"开源的延迟消息实现经过\",{\"1\":{\"925\":1}}],[\"开源\",{\"1\":{\"925\":1,\"932\":1}}],[\"开源版本的做法是\",{\"1\":{\"925\":1}}],[\"开源版本\",{\"1\":{\"925\":1}}],[\"开源顶级项目apache\",{\"1\":{\"277\":1}}],[\"开启新的投票轮次\",{\"1\":{\"1480\":1}}],[\"开启布隆过滤器\",{\"1\":{\"1325\":1}}],[\"开启之后可以消费的更快吗\",{\"1\":{\"1325\":1}}],[\"开启这两项相当于开启了第一层过滤\",{\"1\":{\"1315\":1}}],[\"开启消息轨迹的文档\",{\"1\":{\"1004\":1}}],[\"开启一个消费者消费订单取消\",{\"1\":{\"921\":1,\"1337\":1}}],[\"开启\",{\"1\":{\"883\":1,\"1041\":1,\"1286\":1}}],[\"开启强制删除\",{\"1\":{\"866\":1}}],[\"开启文件删除\",{\"1\":{\"866\":1}}],[\"开启长轮询\",{\"1\":{\"824\":1}}],[\"开启长轮询的情况下\",{\"1\":{\"806\":1}}],[\"开启定时刷盘\",{\"0\":{\"735\":1}}],[\"开启插件后\",{\"1\":{\"711\":1}}],[\"开启插件\",{\"0\":{\"710\":1}}],[\"开销比较大的工作\",{\"1\":{\"733\":1}}],[\"开销更少\",{\"1\":{\"117\":1}}],[\"开减伤\",{\"1\":{\"464\":1}}],[\"开铁皮\",{\"1\":{\"446\":1}}],[\"开个减\",{\"1\":{\"441\":1}}],[\"开始倒序遍历\",{\"1\":{\"1521\":1}}],[\"开始向从节点重新转发日志\",{\"1\":{\"1519\":1}}],[\"开始时进行判断\",{\"1\":{\"1403\":1}}],[\"开始定时\",{\"1\":{\"1354\":1}}],[\"开始\",{\"1\":{\"1241\":1}}],[\"开始拉取\",{\"1\":{\"1137\":1,\"1144\":1,\"1224\":1}}],[\"开始拉取消息\",{\"1\":{\"1134\":1}}],[\"开始拉取新队列\",{\"1\":{\"1130\":1}}],[\"开始消费流程\",{\"1\":{\"1120\":1}}],[\"开始支持访问权限控制\",{\"1\":{\"976\":1}}],[\"开始扫描\",{\"1\":{\"857\":1}}],[\"开始扫描新的消息\",{\"1\":{\"855\":1}}],[\"开始扫描后面的消息\",{\"1\":{\"845\":1}}],[\"开始的\",{\"1\":{\"787\":1}}],[\"开始遍历\",{\"1\":{\"747\":1}}],[\"开始引入了自旋锁并作为默认值\",{\"1\":{\"733\":1}}],[\"开始尝试打\",{\"1\":{\"399\":1}}],[\"开始起飞\",{\"0\":{\"273\":1}}],[\"开始监听上面的\",{\"1\":{\"135\":1}}],[\"开始监听客户端\",{\"1\":{\"133\":1}}],[\"开始监听\",{\"1\":{\"126\":1}}],[\"开放电信平台\",{\"1\":{\"262\":1}}],[\"开发人员\",{\"1\":{\"978\":1}}],[\"开发量大\",{\"1\":{\"928\":1}}],[\"开发量较小\",{\"1\":{\"928\":1}}],[\"开发\",{\"0\":{\"77\":1,\"79\":1,\"93\":1,\"94\":1,\"367\":1}}],[\"开头的所有队列进行镜像\",{\"1\":{\"653\":1}}],[\"开头的队列创建\",{\"1\":{\"652\":1}}],[\"开头的模块\",{\"1\":{\"598\":1}}],[\"开头的地址\",{\"1\":{\"368\":1}}],[\"开头\",{\"1\":{\"29\":1}}],[\"代价是十分昂贵的\",{\"1\":{\"1393\":1}}],[\"代言人夏多克朗\",{\"0\":{\"445\":1}}],[\"代言人布洛克\",{\"0\":{\"440\":1}}],[\"代表最基本的\",{\"1\":{\"508\":1}}],[\"代表\",{\"1\":{\"215\":1}}],[\"代表函数的数据类型是\",{\"1\":{\"181\":1}}],[\"代码切换\",{\"0\":{\"1248\":1}}],[\"代码硬编码属性\",{\"1\":{\"917\":1}}],[\"代码中添加相关属性\",{\"1\":{\"696\":1}}],[\"代码中提供获取\",{\"1\":{\"272\":1}}],[\"代码如下\",{\"1\":{\"378\":1}}],[\"代码总是以单线程执行\",{\"1\":{\"359\":1}}],[\"代码终止执行\",{\"1\":{\"358\":1}}],[\"代码等价\",{\"1\":{\"354\":1}}],[\"代码更加简单\",{\"1\":{\"349\":1}}],[\"代码就可以随写随测\",{\"1\":{\"272\":1}}],[\"代码热变更方面\",{\"1\":{\"271\":1}}],[\"代码随写随测\",{\"1\":{\"270\":1}}],[\"代码深层次的一个方法\",{\"1\":{\"270\":1}}],[\"代码的性能分析工具\",{\"0\":{\"255\":1}}],[\"代码某处的erlang语法要求单个表达式\",{\"1\":{\"205\":1}}],[\"代码\",{\"0\":{\"1536\":1},\"1\":{\"132\":1,\"497\":1,\"500\":1}}],[\"代码较繁琐\",{\"1\":{\"76\":1}}],[\"代理名称通过ha\",{\"1\":{\"652\":1}}],[\"代理的个数由ha\",{\"1\":{\"652\":1}}],[\"代理\",{\"1\":{\"41\":1}}],[\"传来的日志序号在\",{\"1\":{\"1520\":1}}],[\"传输消息\",{\"1\":{\"1269\":1}}],[\"传到\",{\"1\":{\"737\":1}}],[\"传到写\",{\"1\":{\"730\":1}}],[\"传统混沌工程主要关注系统的稳定性\",{\"1\":{\"282\":1}}],[\"传统服务端设计模式\",{\"0\":{\"111\":1}}],[\"传统写法\",{\"1\":{\"76\":1}}],[\"传入的偏移量非法\",{\"1\":{\"1468\":1}}],[\"传入的参数是客户端发送请求时指定的用户信息\",{\"1\":{\"991\":1}}],[\"传入一个字节\",{\"1\":{\"894\":1}}],[\"传入一个\",{\"1\":{\"894\":1}}],[\"传入一个构造函数\",{\"1\":{\"548\":1}}],[\"传入\",{\"1\":{\"738\":1,\"882\":1}}],[\"传入参数个数多或者少都允许\",{\"1\":{\"307\":1}}],[\"传入处理调用方法的invocationhandler\",{\"1\":{\"41\":1}}],[\"传入要实现的接口\",{\"1\":{\"41\":1}}],[\"传入classloader\",{\"1\":{\"41\":1}}],[\"接入方式\",{\"0\":{\"1397\":1}}],[\"接入层作为操作分级存储数据的入口\",{\"1\":{\"1387\":1}}],[\"接近于\",{\"1\":{\"922\":3}}],[\"接受\",{\"1\":{\"941\":1}}],[\"接受消息后再解析成map\",{\"1\":{\"740\":1}}],[\"接受不同类型或不同个数的参数\",{\"1\":{\"547\":1}}],[\"接受其他函数作为参数的函数\",{\"1\":{\"321\":1}}],[\"接着刷别人\",{\"1\":{\"434\":1}}],[\"接着处理列表尾\",{\"1\":{\"177\":1}}],[\"接着处理后续的请求\",{\"1\":{\"125\":1}}],[\"接一个尖刺\",{\"1\":{\"434\":1}}],[\"接下来是拉消费者和推消费者接口\",{\"1\":{\"1117\":1}}],[\"接下来\",{\"1\":{\"368\":1}}],[\"接口中包含了对索引文件操作的封装\",{\"1\":{\"1412\":1}}],[\"接口的\",{\"1\":{\"1119\":2}}],[\"接口的实现类\",{\"1\":{\"76\":1}}],[\"接口来执行消息消费\",{\"1\":{\"1119\":1}}],[\"接口很简单\",{\"1\":{\"1116\":1}}],[\"接口提供了客户端的一些基本的管理接口\",{\"1\":{\"1116\":1}}],[\"接口名\",{\"1\":{\"595\":1}}],[\"接口或\",{\"1\":{\"570\":1}}],[\"接口合并\",{\"0\":{\"563\":1}}],[\"接口\",{\"0\":{\"569\":1},\"1\":{\"522\":1,\"891\":1,\"1036\":1,\"1118\":1,\"1155\":1,\"1190\":1,\"1318\":1,\"1387\":1,\"1397\":1,\"1442\":1,\"1482\":1}}],[\"接口调用过来很麻烦\",{\"1\":{\"271\":1}}],[\"接口技术\",{\"0\":{\"240\":1}}],[\"接收和保存\",{\"1\":{\"1508\":1}}],[\"接收日志请求并存储\",{\"1\":{\"1507\":1,\"1508\":1}}],[\"接收事务消息\",{\"0\":{\"1461\":1}}],[\"接收事务执行结果请求\",{\"0\":{\"1451\":1}}],[\"接收事务半消息\",{\"0\":{\"1450\":1,\"1462\":1}}],[\"接收缓冲区\",{\"1\":{\"1300\":1}}],[\"接收客户端的参数之后根据这些参数进行重平衡\",{\"1\":{\"1255\":1}}],[\"接收客户端连接\",{\"1\":{\"121\":1,\"123\":1}}],[\"接收拉取请求后从存储中查询消息并返回\",{\"1\":{\"1086\":1,\"1125\":1,\"1147\":1,\"1177\":1,\"1203\":1}}],[\"接收到客户端请求后根据配置的权限匹配\",{\"1\":{\"979\":1}}],[\"接收到来自白名单中\",{\"1\":{\"978\":1}}],[\"接收到\",{\"1\":{\"953\":1}}],[\"接收到的数据存在一个\",{\"1\":{\"729\":1}}],[\"接收到数据后\",{\"1\":{\"347\":1}}],[\"接收方法中\",{\"1\":{\"614\":1}}],[\"接收函数\",{\"1\":{\"338\":1}}],[\"接收多个参数\",{\"1\":{\"325\":1}}],[\"接收并打印出任何发给它的消息\",{\"1\":{\"235\":1}}],[\"接收一个函数作为参数\",{\"1\":{\"230\":1}}],[\"接收消息的权限\",{\"1\":{\"978\":1}}],[\"接收消息时\",{\"1\":{\"742\":1}}],[\"接收消息\",{\"1\":{\"230\":1}}],[\"接收发送给某个进程的消息\",{\"1\":{\"229\":1}}],[\"接收\",{\"0\":{\"1520\":1},\"1\":{\"73\":1,\"75\":1}}],[\"接收新的连接\",{\"1\":{\"69\":1}}],[\"标志位\",{\"1\":{\"1171\":1}}],[\"标识\",{\"1\":{\"309\":1}}],[\"标准的选主逻辑实现上有一些差异\",{\"1\":{\"1483\":1}}],[\"标准的erlang分发套装包含otp库\",{\"1\":{\"262\":1}}],[\"标准对象\",{\"0\":{\"333\":1}}],[\"标准库高阶函数\",{\"1\":{\"181\":1}}],[\"标签文件关键字\",{\"1\":{\"162\":1}}],[\"标记需要进行泄漏检测\",{\"1\":{\"1521\":1}}],[\"标记消息为事务消息\",{\"1\":{\"1459\":1}}],[\"标记该\",{\"1\":{\"1276\":1}}],[\"标记\",{\"1\":{\"75\":1}}],[\"标注了\",{\"1\":{\"9\":1}}],[\"只提供了主从同步功能\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"只提供编译器\",{\"1\":{\"497\":1}}],[\"只收到\",{\"1\":{\"1445\":1}}],[\"只保存了消息在\",{\"1\":{\"1352\":1}}],[\"只保留活动标签页\",{\"1\":{\"154\":1}}],[\"只订阅消息标签为\",{\"1\":{\"1307\":1}}],[\"只对\",{\"1\":{\"1278\":1}}],[\"只对z赋值第三个元素\",{\"1\":{\"316\":1}}],[\"只不过在使用的\",{\"1\":{\"1338\":1}}],[\"只不过变成了\",{\"1\":{\"1255\":1}}],[\"只不过封装了订阅和监听器这样的对外接口\",{\"1\":{\"1119\":1}}],[\"只打印日志\",{\"1\":{\"1188\":1}}],[\"只作为消息轨迹接收的节点\",{\"1\":{\"1012\":1}}],[\"只允许存在在一个acl配置文件中\",{\"1\":{\"998\":1}}],[\"只注册了默认\",{\"1\":{\"964\":1}}],[\"只是互为备份\",{\"1\":{\"941\":1}}],[\"只是建立了进程虚拟内存地址与物理内存地址之间的映射关系\",{\"1\":{\"882\":1}}],[\"只是指定检查条件\",{\"1\":{\"570\":1}}],[\"只支持指定时间延迟\",{\"1\":{\"836\":1}}],[\"只会消费一个队列的消息\",{\"1\":{\"1257\":1}}],[\"只会打印警告日志\",{\"1\":{\"1195\":1}}],[\"只会存储一次\",{\"1\":{\"700\":1}}],[\"只会与主副本进行交互\",{\"1\":{\"695\":1}}],[\"只会初始化一个线程\",{\"1\":{\"121\":1}}],[\"只考虑在命令行传入的模块\",{\"1\":{\"603\":1}}],[\"只读属性\",{\"0\":{\"552\":1}}],[\"只读参数\",{\"0\":{\"540\":1}}],[\"只读元组\",{\"0\":{\"528\":1}}],[\"只读数组\",{\"0\":{\"524\":1}}],[\"只包含单个值的值类型\",{\"1\":{\"514\":1}}],[\"只包含对象\",{\"1\":{\"512\":1}}],[\"只希望包含真正的对象\",{\"1\":{\"512\":1}}],[\"只检查类型是否正确\",{\"1\":{\"498\":1}}],[\"只留下能运行的\",{\"1\":{\"497\":1}}],[\"只存在着一台\",{\"1\":{\"380\":1}}],[\"只需要实现与其他存储后端的适配层就可以轻松切换多种存储后端\",{\"1\":{\"1385\":1}}],[\"只需要扩展\",{\"1\":{\"1382\":1}}],[\"只需要在生产消息时带有需要分发的\",{\"1\":{\"1293\":1}}],[\"只需要在合适的地方来个统一捕获\",{\"1\":{\"358\":1}}],[\"只需要发回偏移量\",{\"1\":{\"1188\":1}}],[\"只需要改变下次拉取的偏移量即可\",{\"1\":{\"1155\":1}}],[\"只需要订阅一个\",{\"1\":{\"1117\":1}}],[\"只需要找到对应的\",{\"1\":{\"747\":1}}],[\"只需列出参数名\",{\"1\":{\"76\":1}}],[\"只在函数内部有效\",{\"1\":{\"545\":1}}],[\"只在函数内部起作用\",{\"1\":{\"308\":1}}],[\"只在必要时才对参数求值\",{\"1\":{\"219\":1}}],[\"只遍历集合本身的元素\",{\"1\":{\"303\":1}}],[\"只遍历列表一次\",{\"1\":{\"189\":1}}],[\"只添加\",{\"1\":{\"298\":1}}],[\"只删除过期的文件\",{\"1\":{\"870\":1}}],[\"只删除\",{\"1\":{\"298\":1}}],[\"只有最后一个文件是可写的\",{\"1\":{\"1386\":1}}],[\"只有一种情况会失败\",{\"1\":{\"1297\":1}}],[\"只有一个队列的情况下能够实现\",{\"1\":{\"1102\":1}}],[\"只有一个队列\",{\"1\":{\"1012\":1}}],[\"只有一个线程调用\",{\"1\":{\"793\":1}}],[\"只有一个\",{\"1\":{\"687\":1}}],[\"只有master支持存储offset\",{\"1\":{\"1173\":1}}],[\"只有拉取偏移量大于等于最小偏移量\",{\"1\":{\"1164\":1}}],[\"只有指定队列进行拉取的接口\",{\"1\":{\"1136\":1}}],[\"只有第一次启动才执行\",{\"1\":{\"1122\":1}}],[\"只有拥有某种权限才能进行某些操作\",{\"1\":{\"976\":1}}],[\"只有\",{\"1\":{\"700\":1,\"1390\":2,\"1405\":2,\"1434\":1,\"1445\":1,\"1508\":1}}],[\"只有死信队列\",{\"1\":{\"698\":1}}],[\"只有delta状态的消息\",{\"1\":{\"690\":1}}],[\"只有将消息和队列都设置为持久化之后\",{\"1\":{\"685\":1}}],[\"只有当前事务在全部镜像中执行之后\",{\"1\":{\"663\":1}}],[\"只有主节点运行该匹配线程\",{\"1\":{\"1262\":1}}],[\"只有主节点才保存\",{\"1\":{\"1171\":1}}],[\"只有主节点向外提供服务\",{\"1\":{\"669\":1}}],[\"只有主节点\",{\"1\":{\"657\":1,\"971\":1}}],[\"只有在执行完gen\",{\"1\":{\"624\":1}}],[\"只有经过类型缩小\",{\"1\":{\"503\":1}}],[\"只有never唯一一个\",{\"1\":{\"501\":1}}],[\"只有铁钩的时候会有伤害\",{\"1\":{\"464\":1}}],[\"只有寒冰镰刀造成大规模\",{\"1\":{\"432\":1}}],[\"只有尾王有灭点\",{\"1\":{\"422\":1}}],[\"只有老一数值比较高\",{\"1\":{\"422\":1}}],[\"只有父进程知道子进程的\",{\"1\":{\"234\":1}}],[\"只有jvm能创建class实例\",{\"1\":{\"36\":1}}],[\"只能同时被一个消费者消费\",{\"1\":{\"1126\":1}}],[\"只能往自己申请的\",{\"1\":{\"978\":1}}],[\"只能单线程操作\",{\"1\":{\"733\":1,\"736\":1}}],[\"只能被强制删除\",{\"1\":{\"703\":1}}],[\"只能被赋值一次\",{\"1\":{\"173\":1}}],[\"只能使用import\",{\"1\":{\"596\":1}}],[\"只能当作其他类的模板\",{\"1\":{\"579\":1}}],[\"只能在对象初始化时赋值\",{\"1\":{\"552\":1}}],[\"只能进行比较运算\",{\"1\":{\"503\":1}}],[\"只能通过api完成任务配置\",{\"1\":{\"371\":1}}],[\"只能写在最后\",{\"1\":{\"309\":1}}],[\"只能计算它们之差的绝对值\",{\"1\":{\"295\":1}}],[\"只能更新值\",{\"1\":{\"192\":1}}],[\"只要有一个为\",{\"1\":{\"1128\":1}}],[\"只要有这个分组对应的\",{\"1\":{\"380\":1}}],[\"只要能将\",{\"1\":{\"925\":1}}],[\"只要实现这个接口\",{\"1\":{\"891\":1}}],[\"只要随机的那块区域还在page\",{\"1\":{\"878\":1}}],[\"只要属性名为字符串\",{\"1\":{\"553\":1}}],[\"只要\",{\"1\":{\"449\":1}}],[\"只要执行器集群有足够的计算节点\",{\"1\":{\"371\":1}}],[\"只要一个为\",{\"1\":{\"186\":1}}],[\"只要源码或配置文件发生修改\",{\"1\":{\"95\":1}}],[\"只要求方法参数\",{\"1\":{\"76\":1}}],[\"只定义了单方法的接口称之为\",{\"1\":{\"75\":1}}],[\"单元查找本地存储\",{\"1\":{\"1403\":1}}],[\"单元\",{\"1\":{\"1403\":1}}],[\"单元的伸缩能力\",{\"1\":{\"285\":1}}],[\"单次上传最大消息数据量也有一个阈值\",{\"1\":{\"1403\":1}}],[\"单位为秒\",{\"1\":{\"1468\":1}}],[\"单位\",{\"1\":{\"1382\":1}}],[\"单体硬件无法支撑\",{\"1\":{\"1378\":1}}],[\"单体有\",{\"1\":{\"403\":1}}],[\"单项\",{\"1\":{\"1053\":1}}],[\"单向请求\",{\"1\":{\"1469\":1}}],[\"单向\",{\"1\":{\"1025\":1,\"1027\":1,\"1161\":1,\"1171\":1}}],[\"单队列处于飞行状态的消息数限制为2万条\",{\"1\":{\"922\":1}}],[\"单独发送\",{\"1\":{\"1519\":1}}],[\"单独目录存放\",{\"1\":{\"1383\":1}}],[\"单独启动\",{\"0\":{\"1077\":1}}],[\"单独创建一个目录\",{\"1\":{\"749\":2}}],[\"单独成为一个分区时的表现\",{\"1\":{\"284\":1}}],[\"单独成为一个分区的场景下\",{\"1\":{\"284\":1}}],[\"单个索引文件的读取逻辑如下\",{\"1\":{\"1415\":1}}],[\"单个索引文件的写入逻辑如下\",{\"1\":{\"1414\":1}}],[\"单个消费者速度有限\",{\"1\":{\"1089\":1}}],[\"单个\",{\"1\":{\"736\":1,\"1516\":1}}],[\"单个值也是一种类型\",{\"1\":{\"514\":1}}],[\"单节点的压力被分散\",{\"1\":{\"648\":1}}],[\"单节点的\",{\"1\":{\"648\":1}}],[\"单手武器\",{\"1\":{\"480\":1}}],[\"单点\",{\"1\":{\"448\":1}}],[\"单目标\",{\"1\":{\"412\":1}}],[\"单机执行耗时非常长\",{\"1\":{\"371\":1}}],[\"单词\",{\"1\":{\"147\":1}}],[\"单\",{\"0\":{\"127\":1},\"1\":{\"130\":1,\"1028\":1}}],[\"单线程处理复制结果\",{\"1\":{\"724\":1}}],[\"单线程非阻塞处理器\",{\"1\":{\"124\":1}}],[\"单线程版本就是用一个线程完成所有步骤\",{\"1\":{\"120\":1}}],[\"单线程版本\",{\"1\":{\"120\":1}}],[\"单线程版本的基本设计\",{\"1\":{\"120\":1}}],[\"单线程\",{\"0\":{\"119\":1,\"126\":1}}],[\"单线程执行\",{\"1\":{\"11\":1}}],[\"单方法接口被称为\",{\"1\":{\"75\":1}}],[\"还没有新消息需要同步的场景\",{\"1\":{\"1519\":1}}],[\"还没有新日志要推送\",{\"1\":{\"1510\":1}}],[\"还没有被匹配的\",{\"1\":{\"1253\":1,\"1261\":1}}],[\"还未上传到外部存储\",{\"1\":{\"1394\":1,\"1412\":1}}],[\"还未投递的消息是否到期\",{\"1\":{\"1342\":1}}],[\"还未提交\",{\"1\":{\"905\":1}}],[\"还存在重平衡的可能性\",{\"1\":{\"1181\":1}}],[\"还要从\",{\"1\":{\"1300\":1}}],[\"还要修改\",{\"1\":{\"1075\":1}}],[\"还要不停躲地板\",{\"1\":{\"399\":1}}],[\"还剩下最后的问题是流控和消息的重投\",{\"1\":{\"932\":1}}],[\"还支持按客户端\",{\"1\":{\"976\":1}}],[\"还支持延迟消息的取消\",{\"1\":{\"922\":1}}],[\"还支持通过消息存储时间来查询具体消息\",{\"1\":{\"751\":1}}],[\"还支持在线日志功能\",{\"1\":{\"371\":1}}],[\"还用自旋锁可能就不合适了\",{\"1\":{\"733\":1}}],[\"还允许使用import\",{\"1\":{\"595\":1}}],[\"还允许返回一个函数\",{\"1\":{\"74\":1}}],[\"还会将消息发送给队列所有的\",{\"1\":{\"668\":1}}],[\"还会为编译后的代码加入一个对象\",{\"1\":{\"582\":1}}],[\"还会\",{\"1\":{\"502\":1}}],[\"还能腾出\",{\"1\":{\"492\":1}}],[\"还更丰富\",{\"1\":{\"488\":1}}],[\"还好\",{\"1\":{\"422\":1}}],[\"还有一个消费锁\",{\"1\":{\"1209\":1}}],[\"还有一些\",{\"1\":{\"733\":1}}],[\"还有一些其他的传播级别\",{\"1\":{\"87\":1}}],[\"还有几个战斗药水推荐\",{\"1\":{\"485\":1}}],[\"还有尽量把队友血奶满防止猝死\",{\"1\":{\"468\":1}}],[\"还有从e\",{\"1\":{\"356\":1}}],[\"还可以包含大量轻量级队列\",{\"1\":{\"1291\":1}}],[\"还可以使用消息属性作为路由键\",{\"1\":{\"715\":1}}],[\"还可以用旋风和吹风来控小虫子\",{\"1\":{\"457\":1}}],[\"还可以用yield返回多次\",{\"1\":{\"332\":1}}],[\"还可恶意针对分布式基础软件如消息或缓存等的主备倒换\",{\"1\":{\"282\":1}}],[\"还包含白名单概念\",{\"1\":{\"978\":1}}],[\"还包含如弹性\",{\"1\":{\"282\":1}}],[\"还包括其他许多功能\",{\"1\":{\"118\":1}}],[\"还需要重试消费\",{\"1\":{\"1188\":1}}],[\"还需要将消费进度让其他消费者知道\",{\"1\":{\"1103\":1}}],[\"还需要设置端口\",{\"1\":{\"712\":1}}],[\"还需要完备的监测系统\",{\"1\":{\"277\":1}}],[\"还需要执行异步任务和定时任务\",{\"1\":{\"135\":1}}],[\"还引入了\",{\"1\":{\"135\":1}}],[\"还是继续攒批\",{\"1\":{\"1427\":1}}],[\"还是要修改\",{\"1\":{\"1078\":1}}],[\"还是在之后一段时间都避开该\",{\"1\":{\"1032\":1}}],[\"还是消费方没有消费成功\",{\"1\":{\"1003\":1}}],[\"还是可以充分利用page\",{\"1\":{\"878\":1}}],[\"还是上面那个例子\",{\"1\":{\"701\":1}}],[\"还是保证队列的一致性\",{\"1\":{\"659\":1}}],[\"还是因为追求治疗量\",{\"1\":{\"403\":1}}],[\"还是\",{\"1\":{\"2\":4}}],[\"函数中先解析命令行参数\",{\"1\":{\"947\":1,\"960\":1}}],[\"函数触发启动流程\",{\"1\":{\"947\":1}}],[\"函数通常不带有this参数\",{\"1\":{\"580\":1}}],[\"函数等\",{\"1\":{\"564\":1}}],[\"函数重载\",{\"0\":{\"547\":1},\"1\":{\"547\":1,\"563\":1,\"566\":1}}],[\"函数的返回值还是一个函数\",{\"1\":{\"546\":1}}],[\"函数计算得到\",{\"1\":{\"388\":1}}],[\"函数被回调\",{\"1\":{\"348\":1}}],[\"函数内部判断某个变量是否存在用typeof\",{\"1\":{\"333\":1}}],[\"函数作为返回值\",{\"0\":{\"329\":1}}],[\"函数返回一个pid\",{\"1\":{\"230\":1}}],[\"函数引用\",{\"0\":{\"210\":1}}],[\"函数多半应该返回\",{\"1\":{\"196\":1}}],[\"函数`rr`\",{\"1\":{\"191\":1}}],[\"函数\",{\"0\":{\"304\":1,\"354\":1,\"532\":1},\"1\":{\"183\":1,\"224\":2,\"230\":1,\"295\":1,\"341\":1,\"506\":1,\"558\":2,\"591\":1,\"606\":1}}],[\"函数有两个子句\",{\"1\":{\"180\":1}}],[\"函数定义和调用\",{\"0\":{\"305\":1}}],[\"函数定义\",{\"0\":{\"306\":1},\"1\":{\"180\":1}}],[\"函数式编程\",{\"0\":{\"74\":1}}],[\"函数固然也可以\",{\"1\":{\"2\":1}}],[\"无\",{\"1\":{\"1478\":1}}],[\"无界\",{\"1\":{\"1300\":1}}],[\"无动作\",{\"1\":{\"858\":1,\"1479\":2,\"1486\":1}}],[\"无需截断\",{\"1\":{\"1519\":1}}],[\"无需比较主从数据是否一致\",{\"1\":{\"1519\":1}}],[\"无需比较\",{\"1\":{\"1510\":1}}],[\"无需再次回查\",{\"1\":{\"1451\":1}}],[\"无需创建新的文件\",{\"1\":{\"1351\":1}}],[\"无需等待\",{\"1\":{\"1027\":1}}],[\"无需额外开发\",{\"1\":{\"928\":1}}],[\"无需考虑队列类型\",{\"1\":{\"696\":1}}],[\"无需特殊规划治疗手牌\",{\"1\":{\"451\":1}}],[\"无限次重试\",{\"1\":{\"1370\":1}}],[\"无限执行的函数\",{\"0\":{\"544\":1}}],[\"无限循环调用\",{\"1\":{\"1510\":1}}],[\"无限循环从\",{\"1\":{\"1360\":1}}],[\"无限循环\",{\"1\":{\"72\":1,\"1168\":1,\"1519\":2}}],[\"无礼放血者\",{\"1\":{\"480\":1}}],[\"无制造业\",{\"0\":{\"480\":1}}],[\"无羁拟态者\",{\"1\":{\"479\":1,\"480\":1}}],[\"无面腐蚀者\",{\"1\":{\"475\":1}}],[\"无损补\",{\"0\":{\"419\":1}}],[\"无锁化设计\",{\"1\":{\"380\":1}}],[\"无锁化设计和高可用的关键\",{\"0\":{\"380\":1}}],[\"无参数\",{\"1\":{\"331\":1}}],[\"无论我们使用什么语言编写的程序\",{\"1\":{\"879\":1}}],[\"无论什么情况下从节点都将被提升为主节点\",{\"1\":{\"659\":1}}],[\"无论是客户端还是服务端都需要检查一次这个消息的\",{\"1\":{\"904\":1}}],[\"无论是增加还是减少节点\",{\"1\":{\"387\":1}}],[\"无论是服务端还是客户端\",{\"1\":{\"135\":1}}],[\"无论\",{\"1\":{\"372\":1}}],[\"无论该循环变量后续如何更改\",{\"1\":{\"330\":1}}],[\"无名寄存器\",{\"1\":{\"157\":2}}],[\"无法成为\",{\"1\":{\"1492\":2,\"1503\":2}}],[\"无法迁移\",{\"1\":{\"1379\":1}}],[\"无法直接执行\",{\"1\":{\"1348\":1}}],[\"无法达到任意时间定时\",{\"1\":{\"922\":1}}],[\"无法支持大规模使用\",{\"1\":{\"922\":1}}],[\"无法保证消息投递的顺序\",{\"1\":{\"854\":1}}],[\"无法同时投递多个延迟等级的消息\",{\"1\":{\"840\":1}}],[\"无法被消费者消费\",{\"1\":{\"836\":1}}],[\"无法并行\",{\"1\":{\"733\":1}}],[\"无法使用函数重载的语法\",{\"1\":{\"558\":1}}],[\"无法兼顾加血和躲地板\",{\"1\":{\"399\":1}}],[\"无法在调用时捕获异常\",{\"1\":{\"359\":1}}],[\"无法定义在\",{\"1\":{\"314\":1}}],[\"无法给出全面彻底的诊断建议\",{\"1\":{\"277\":1}}],[\"无法执行其他任务\",{\"1\":{\"114\":1}}],[\"无法跨线程传播\",{\"1\":{\"87\":1}}],[\"无实质意义\",{\"1\":{\"31\":1}}],[\"打包完成后可以用如下命令查看\",{\"1\":{\"1072\":1}}],[\"打包之后也自带可以运行基准测试代码的\",{\"1\":{\"7\":1}}],[\"打孔\",{\"1\":{\"485\":1}}],[\"打死\",{\"1\":{\"464\":1}}],[\"打断他和小怪的通灵箭\",{\"1\":{\"455\":1}}],[\"打断左右\",{\"1\":{\"455\":1}}],[\"打盾\",{\"1\":{\"453\":1}}],[\"打盾前要满预铺\",{\"1\":{\"439\":1}}],[\"打完之后看嗜血的\",{\"1\":{\"443\":1}}],[\"打\",{\"1\":{\"438\":1}}],[\"打了很多次\",{\"1\":{\"422\":1}}],[\"打印日志\",{\"1\":{\"1521\":1}}],[\"打印错误日志\",{\"1\":{\"1218\":1}}],[\"打印\",{\"1\":{\"960\":1}}],[\"打印当前加载配置属性\",{\"1\":{\"960\":1}}],[\"打印一次\",{\"1\":{\"947\":1,\"961\":2}}],[\"打印每个队列堆积的消息数量\",{\"1\":{\"712\":1}}],[\"打印时总是使用各键排序后的顺序\",{\"1\":{\"192\":1}}],[\"打印成列表记法\",{\"1\":{\"178\":1}}],[\"打印提示\",{\"1\":{\"70\":1}}],[\"打开websocket连接后立刻发送一条消息\",{\"1\":{\"369\":1}}],[\"打开时会进行一致性检查\",{\"1\":{\"247\":1}}],[\"打开\",{\"1\":{\"154\":1}}],[\"打开的一个文件的内存缓冲区\",{\"1\":{\"151\":1}}],[\"有其他\",{\"1\":{\"1499\":1}}],[\"有其他的\",{\"1\":{\"1488\":1}}],[\"有效投票数\",{\"1\":{\"1497\":1}}],[\"有效投票未超过半数\",{\"1\":{\"1491\":1}}],[\"有效票未超过半数\",{\"1\":{\"1497\":1}}],[\"有效票\",{\"1\":{\"1491\":1,\"1497\":2}}],[\"有效票超过半数的情况\",{\"1\":{\"1497\":1}}],[\"有效票超过半数\",{\"1\":{\"1491\":1,\"1497\":1}}],[\"有效取值范围为\",{\"1\":{\"652\":1}}],[\"有效取值范围为all\",{\"1\":{\"652\":1}}],[\"有写入失败\",{\"1\":{\"1371\":1}}],[\"有概率消费到\",{\"1\":{\"1261\":1}}],[\"有个线程消费这个\",{\"1\":{\"1261\":1}}],[\"有个后台线程消费这个\",{\"1\":{\"1253\":1}}],[\"有可能是过滤匹配的\",{\"1\":{\"1314\":1}}],[\"有可能出现冲突\",{\"1\":{\"1237\":1}}],[\"有可能有节点失效\",{\"1\":{\"674\":1}}],[\"有必要根据业务上的唯一key对消息做幂等处理\",{\"1\":{\"1237\":1}}],[\"有多个队列\",{\"1\":{\"1102\":1}}],[\"有众多配置项和部署方式可以选择\",{\"1\":{\"1069\":1}}],[\"有全局和用户\",{\"1\":{\"978\":1}}],[\"有没有其他可取的方案\",{\"1\":{\"931\":1}}],[\"有没有办法来优化一下\",{\"1\":{\"911\":1}}],[\"有新消息来了可以消费了\",{\"1\":{\"914\":1}}],[\"有新的消息\",{\"1\":{\"1188\":1}}],[\"有新的消息落盘\",{\"1\":{\"762\":1,\"827\":1}}],[\"有新的客户端连接进来后\",{\"1\":{\"69\":1}}],[\"有许多\",{\"1\":{\"908\":1}}],[\"有直接\",{\"1\":{\"894\":1}}],[\"有文件需要被删除\",{\"1\":{\"872\":1}}],[\"有交集的索引文件\",{\"1\":{\"789\":1}}],[\"有了时间轮\",{\"1\":{\"931\":1}}],[\"有了它\",{\"1\":{\"707\":1}}],[\"有了这个配置文件\",{\"1\":{\"499\":1}}],[\"有时甚至会导致同步卡住\",{\"1\":{\"678\":1}}],[\"有时是本地的\",{\"1\":{\"621\":1}}],[\"有时上网查询可以找到答案\",{\"1\":{\"2\":1}}],[\"有三个可能的值\",{\"1\":{\"593\":1}}],[\"有两个实现类\",{\"1\":{\"1190\":1}}],[\"有两个提交\",{\"1\":{\"889\":1}}],[\"有两个\",{\"1\":{\"501\":1}}],[\"有两种消费方式\",{\"1\":{\"1187\":1}}],[\"有两种订阅消息的方式\",{\"1\":{\"1102\":1}}],[\"有两种轮询方式\",{\"1\":{\"804\":1}}],[\"有两种捕获异常的方法\",{\"1\":{\"193\":1,\"194\":1}}],[\"有两种方法可以代替它使用\",{\"1\":{\"193\":1}}],[\"有的消费者将无法分配到队列\",{\"1\":{\"1249\":1}}],[\"有的队列无法消费的情况\",{\"1\":{\"1240\":1}}],[\"有的\",{\"1\":{\"491\":1,\"1074\":1}}],[\"有更多的\",{\"1\":{\"471\":1}}],[\"有较高要求\",{\"1\":{\"441\":1}}],[\"有\",{\"1\":{\"422\":1,\"458\":1,\"724\":2,\"1075\":1,\"1446\":2}}],[\"有压力\",{\"1\":{\"422\":1}}],[\"有野心的时候可以打星火用赛梦来奶\",{\"1\":{\"403\":1}}],[\"有奇效\",{\"1\":{\"401\":1}}],[\"有些场合需要给出this类型\",{\"1\":{\"580\":1}}],[\"有些可以预料到的尖刺伤害都可以用变熊来吃\",{\"1\":{\"492\":1}}],[\"有些\",{\"1\":{\"401\":1,\"492\":1}}],[\"有些内置函数是用erlang实现的\",{\"1\":{\"185\":1}}],[\"有这么一段代码\",{\"1\":{\"380\":1}}],[\"有需要分布式处理的业务场景\",{\"1\":{\"371\":1}}],[\"有需要全部机器一同执行的业务场景\",{\"1\":{\"371\":1}}],[\"有定时执行需求的业务场景\",{\"1\":{\"371\":1}}],[\"有序异键\",{\"1\":{\"248\":1}}],[\"有一个服务线程不断运行节点的状态维护方法\",{\"1\":{\"1482\":1}}],[\"有一个线程默默主动拉取消息\",{\"1\":{\"1119\":1}}],[\"有一个定时任务每隔\",{\"1\":{\"1103\":1}}],[\"有一个表记录每个队列当前的投递位移\",{\"1\":{\"932\":1}}],[\"有一个配置来设置处理\",{\"1\":{\"135\":1}}],[\"有一大堆元组\",{\"1\":{\"190\":1}}],[\"有数据可读时\",{\"1\":{\"124\":1}}],[\"有3种方式\",{\"1\":{\"85\":1}}],[\"子接口与父接口的同名属性必须是类型兼容的\",{\"1\":{\"560\":1}}],[\"子系统\",{\"1\":{\"380\":1}}],[\"子句以分号隔开\",{\"1\":{\"180\":1}}],[\"子网掩码是255\",{\"1\":{\"67\":1}}],[\"子类可以获取父类的泛型类型<t>\",{\"1\":{\"48\":1}}],[\"某公司运维团队维护了一个\",{\"1\":{\"978\":1}}],[\"某一时刻要投递的定时消息太多\",{\"1\":{\"932\":1}}],[\"某一时刻的定时消息\",{\"1\":{\"931\":1}}],[\"某进程处于流控状态时\",{\"1\":{\"614\":1}}],[\"某个值的类型\",{\"1\":{\"589\":1}}],[\"某些\",{\"1\":{\"622\":1}}],[\"某些资源每次都实例化可能导致过载\",{\"1\":{\"81\":1}}],[\"某些情况下需要手动调用outputstream的flush\",{\"1\":{\"54\":1}}],[\"某台计算机的ip是101\",{\"1\":{\"67\":1}}],[\"也继续下面的逻辑\",{\"1\":{\"1503\":1}}],[\"也继续下面逻辑\",{\"1\":{\"1492\":1}}],[\"也唤醒心跳线程\",{\"1\":{\"1499\":1}}],[\"也拒绝\",{\"1\":{\"1492\":1}}],[\"也遍历元数据来恢复\",{\"1\":{\"1421\":1}}],[\"也用到的配置文件抽象类\",{\"1\":{\"1420\":1}}],[\"也直接返回\",{\"1\":{\"1409\":1}}],[\"也直接拿盾来用\",{\"1\":{\"455\":1}}],[\"也由一组文件构成\",{\"1\":{\"1386\":1}}],[\"也叫\",{\"1\":{\"1300\":1}}],[\"也叫愈合顺劈\",{\"1\":{\"405\":1}}],[\"也无法消费到其\",{\"1\":{\"1293\":1}}],[\"也无法开始消费\",{\"1\":{\"1225\":1}}],[\"也减少元数据的内存占用\",{\"1\":{\"1291\":1}}],[\"也不会存在频繁的重平衡导致消息积压\",{\"1\":{\"1250\":1}}],[\"也不会主动重平衡来解决这个问题\",{\"1\":{\"1249\":1}}],[\"也不注册回调函数\",{\"1\":{\"1027\":1}}],[\"也依然需要创建一个新的消息保存到\",{\"1\":{\"1188\":1}}],[\"也没有这个必要\",{\"1\":{\"1188\":1}}],[\"也没有预先设定长度\",{\"1\":{\"909\":1}}],[\"也要重试下\",{\"1\":{\"1170\":1}}],[\"也要打断\",{\"1\":{\"461\":1}}],[\"也会放入磁盘\",{\"1\":{\"1253\":1}}],[\"也会把消息放到重试队列\",{\"1\":{\"1251\":1}}],[\"也会启动重平衡线程每\",{\"1\":{\"1136\":1}}],[\"也会概括性地讲一下消费流程\",{\"1\":{\"1086\":1}}],[\"也会在本地查询\",{\"1\":{\"1030\":1}}],[\"也会配置对应的业务线程池来执行这些逻辑\",{\"1\":{\"135\":1}}],[\"也仅保存在内存\",{\"1\":{\"950\":1}}],[\"也意味着需要单独对定时消息进行存储\",{\"1\":{\"924\":1}}],[\"也几乎看不到rmq进程从磁盘read数据\",{\"1\":{\"879\":1}}],[\"也触发响应\",{\"1\":{\"825\":1}}],[\"也进行flush\",{\"1\":{\"769\":1}}],[\"也避免了\",{\"1\":{\"741\":1}}],[\"也支持通过配置队列和消息都持久化的方式\",{\"1\":{\"681\":1}}],[\"也能在其之上构建其他服务\",{\"1\":{\"923\":1}}],[\"也能对敌人造成伤害\",{\"1\":{\"461\":1}}],[\"也能提升你队友的\",{\"1\":{\"416\":1}}],[\"也有两层过滤机制\",{\"1\":{\"1315\":1}}],[\"也有定时任务将内存中的消费偏移量持久化到磁盘\",{\"1\":{\"1103\":1}}],[\"也有几个选择\",{\"1\":{\"928\":1}}],[\"也有许多不同于\",{\"1\":{\"874\":1}}],[\"也有每次消\",{\"1\":{\"438\":1}}],[\"也有不驱散开减伤强吃的打法\",{\"1\":{\"431\":1}}],[\"也有双回春的天赋点法\",{\"1\":{\"403\":1}}],[\"也有文章说\",{\"1\":{\"118\":1}}],[\"也在没有引入其它中间件的情况下实现了高可用\",{\"1\":{\"380\":1}}],[\"也就不存在重复调度问题了\",{\"1\":{\"380\":1}}],[\"也就是把上次还在缓冲区的数据重新上传一次\",{\"1\":{\"1403\":1}}],[\"也就是上传数据的结束位置最多\",{\"1\":{\"1403\":1}}],[\"也就是遍历每个\",{\"1\":{\"1403\":1}}],[\"也就是文件在内存中缓存的副本\",{\"1\":{\"879\":1}}],[\"也就是msgid的索引\",{\"1\":{\"794\":1}}],[\"也就是定时刷盘\",{\"1\":{\"735\":1}}],[\"也就是每放\",{\"1\":{\"401\":1}}],[\"也就是每个节点上processor最大的数量\",{\"1\":{\"372\":1}}],[\"也就是\",{\"1\":{\"387\":1,\"412\":1,\"794\":1}}],[\"也就是大于1分钟后等待调度的\",{\"1\":{\"379\":1}}],[\"也就是将30秒内即将执行的任务加载到时间轮中待执行\",{\"1\":{\"379\":1}}],[\"也就是真正的执行单元\",{\"1\":{\"372\":1}}],[\"也就是说默认只会进行\",{\"1\":{\"1315\":1}}],[\"也就是说重平衡是消息拉取唯一的起点\",{\"1\":{\"1137\":1}}],[\"也就是说在查询某个\",{\"1\":{\"1418\":1}}],[\"也就是说在第一次拉取消息之后的\",{\"1\":{\"1136\":1}}],[\"也就是说在初始化状态下\",{\"1\":{\"882\":1}}],[\"也就是说定时消息延迟时间最大也不能超过这个清除时间\",{\"1\":{\"924\":1}}],[\"也就是说每\",{\"1\":{\"866\":1,\"870\":1}}],[\"也就是说如果\",{\"1\":{\"833\":1}}],[\"也就是说可能会存在节点分布不均衡的问题\",{\"1\":{\"388\":1}}],[\"也就是说一个appid分组下所有worker都是由一个server节点去接管\",{\"1\":{\"380\":1}}],[\"也就是说\",{\"1\":{\"347\":1,\"421\":1,\"564\":1,\"622\":1,\"634\":1,\"700\":1,\"803\":1,\"920\":1,\"931\":1,\"942\":1,\"1091\":1,\"1346\":1}}],[\"也就是附加\",{\"1\":{\"212\":1}}],[\"也就是调用者没有准备好处理的非常严重的问题\",{\"1\":{\"193\":1}}],[\"也就是事实陈述\",{\"1\":{\"173\":1}}],[\"也就是网络号是相同的\",{\"1\":{\"67\":1}}],[\"也较难针对表现分析系统缺陷\",{\"1\":{\"277\":1}}],[\"也需要有类似\",{\"1\":{\"270\":1}}],[\"也是\",{\"1\":{\"1412\":1}}],[\"也是将消费队列数据放入刷盘缓冲区\",{\"1\":{\"1388\":1}}],[\"也是发送请求给集群中的所有\",{\"1\":{\"1248\":1}}],[\"也是主流场景中普遍采用的消费形式\",{\"1\":{\"1094\":1}}],[\"也是有两种方法\",{\"1\":{\"1079\":1}}],[\"也是真正的路由信息\",{\"1\":{\"944\":1}}],[\"也是从\",{\"1\":{\"879\":1}}],[\"也是顺序写\",{\"1\":{\"877\":1}}],[\"也是以当前脚本的路径作为起点\",{\"1\":{\"599\":1}}],[\"也是不断地从linkedblockingqueue类型的canceledtasks队列中取数据\",{\"1\":{\"379\":1}}],[\"也是查找符合条件的第一个元素\",{\"1\":{\"327\":1}}],[\"也是openchaos强大能力的秘密所在\",{\"1\":{\"280\":1}}],[\"也是一个服务线程\",{\"1\":{\"1412\":1}}],[\"也是一个数值很高的饰品\",{\"1\":{\"483\":1}}],[\"也是一个列表\",{\"1\":{\"177\":1}}],[\"也是一种类\",{\"1\":{\"36\":1}}],[\"也是基于\",{\"1\":{\"135\":1}}],[\"也可能是因为消费端或者下游服务非常慢或者挂掉\",{\"1\":{\"693\":1}}],[\"也可以通过\",{\"1\":{\"1306\":1}}],[\"也可以在\",{\"1\":{\"1095\":1}}],[\"也可以在变形的状态下使用\",{\"1\":{\"413\":1}}],[\"也可以用\",{\"1\":{\"1076\":1}}],[\"也可以用队列参数\",{\"1\":{\"660\":1}}],[\"也可以从\",{\"1\":{\"1072\":1}}],[\"也可以每\",{\"1\":{\"932\":1}}],[\"也可以构建这样一个索引文件\",{\"1\":{\"927\":1}}],[\"也可以写成接口motorvehicle\",{\"1\":{\"573\":1}}],[\"也可以赋值为包装对象\",{\"1\":{\"509\":1}}],[\"也可以作为类型\",{\"1\":{\"506\":1}}],[\"也可以脱战\",{\"1\":{\"487\":1}}],[\"也可以调动整个集群的计算资源完成任务的分布式计算\",{\"1\":{\"372\":1}}],[\"也可以引用其他模块\",{\"1\":{\"361\":1}}],[\"也可以传入函数对每个键值对进行处理\",{\"1\":{\"337\":1}}],[\"也可以是number\",{\"1\":{\"582\":1}}],[\"也可以是元组\",{\"1\":{\"539\":1}}],[\"也可以是虚拟节点类\",{\"1\":{\"391\":1}}],[\"也可以是容器或者云厂商承载的分布式系统\",{\"1\":{\"280\":1}}],[\"也可以是布尔表达式\",{\"1\":{\"184\":1}}],[\"也可以保存在磁盘上\",{\"1\":{\"251\":1}}],[\"也可以放在后缀为`\",{\"1\":{\"191\":1}}],[\"也可以放在单引号内\",{\"1\":{\"175\":1}}],[\"也可以返回函数\",{\"1\":{\"181\":1}}],[\"也可以视作枚举类型\",{\"1\":{\"175\":1}}],[\"也可以不需要事务\",{\"1\":{\"87\":1}}],[\"也可以自己编写代码自行组装配置\",{\"1\":{\"81\":1}}],[\"也可指定scope为prototype\",{\"1\":{\"82\":1}}],[\"对零拷贝的使用\",{\"0\":{\"1524\":1}}],[\"对客户端发送的数据进行编码\",{\"1\":{\"1517\":1}}],[\"对端投票轮次小于当前轮次\",{\"1\":{\"1497\":1}}],[\"对端节点\",{\"1\":{\"1519\":1}}],[\"对端节点等信息\",{\"1\":{\"1514\":1}}],[\"对端节点会用本节点的轮次进入\",{\"1\":{\"1497\":1}}],[\"对端节点列表等\",{\"1\":{\"1482\":1}}],[\"对端\",{\"1\":{\"1491\":1,\"1497\":2}}],[\"对方会切换成\",{\"1\":{\"1500\":1}}],[\"对方会切换回\",{\"1\":{\"1489\":1}}],[\"对方法进行初始化\",{\"1\":{\"606\":1}}],[\"对操作队列的消费进度\",{\"1\":{\"1468\":1}}],[\"对事务半消息的消费进度\",{\"1\":{\"1468\":1}}],[\"对半事务消息进行处理\",{\"1\":{\"1446\":1}}],[\"对半消息\",{\"1\":{\"1446\":1}}],[\"对生产者实例发起定时回查\",{\"1\":{\"1446\":1}}],[\"对他们执行\",{\"1\":{\"1403\":1}}],[\"对启用了分级存储的\",{\"1\":{\"1383\":1}}],[\"对之前的分级存储实现进行了重构\",{\"1\":{\"1380\":1}}],[\"对取出的\",{\"1\":{\"1359\":1}}],[\"对需要查询的数据进行\",{\"1\":{\"1322\":1}}],[\"对要插入的元素进行\",{\"1\":{\"1322\":1}}],[\"对没有\",{\"1\":{\"1263\":1}}],[\"对没有减伤的腐败之水目标用铁皮\",{\"1\":{\"467\":1}}],[\"对成功消费的消息\",{\"1\":{\"1252\":1}}],[\"对消费者不可见\",{\"1\":{\"1446\":1}}],[\"对消费失败的消息不会重复消费\",{\"1\":{\"1195\":1}}],[\"对消息进行tag模式过滤\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"对该队列的消息的回查最多持续\",{\"1\":{\"1468\":1}}],[\"对该\",{\"1\":{\"1143\":1}}],[\"对所有消费者执行一次重平衡检查\",{\"1\":{\"1140\":1}}],[\"对每隔消费者负载不同\",{\"1\":{\"1138\":1}}],[\"对每个主题的队列进行重平衡\",{\"1\":{\"1142\":1}}],[\"对每个\",{\"1\":{\"1137\":1}}],[\"对每个consumequeue执行恢复操作\",{\"1\":{\"753\":1}}],[\"对每个新的客户端连接都启动一个新的线程去处理\",{\"1\":{\"111\":1}}],[\"对比数据是否一致\",{\"1\":{\"1519\":1}}],[\"对比投票轮次\",{\"1\":{\"1480\":1}}],[\"对比分配给自己的消息队列是否发生变化\",{\"1\":{\"1143\":1}}],[\"对比之前的负载来判断是否要改变队列进行消息拉取\",{\"1\":{\"1133\":1}}],[\"对比定时消息的实现\",{\"1\":{\"935\":1}}],[\"对请求参数验计算签名\",{\"1\":{\"991\":1,\"1000\":1}}],[\"对请求\",{\"1\":{\"981\":1}}],[\"对字符串和字节数组操作时减少创建和拷贝\",{\"1\":{\"917\":1}}],[\"对延迟消息做了很大的优化\",{\"1\":{\"850\":1}}],[\"对其执行\",{\"1\":{\"815\":1}}],[\"对其定义进行延伸扩展\",{\"1\":{\"278\":1}}],[\"对其定义如下\",{\"1\":{\"119\":1}}],[\"对队列名称以\",{\"1\":{\"653\":1}}],[\"对奶来说老二和它前面的几个小\",{\"1\":{\"443\":1}}],[\"对\",{\"0\":{\"1143\":1},\"1\":{\"441\":1,\"756\":1,\"877\":1,\"894\":1,\"897\":1,\"911\":1,\"1134\":1,\"1198\":1,\"1284\":1,\"1519\":1}}],[\"对治疗量要求极高\",{\"1\":{\"434\":1}}],[\"对别人也是\",{\"1\":{\"433\":1}}],[\"对中感染\",{\"1\":{\"426\":1}}],[\"对受到伤害的目标上回春术\",{\"1\":{\"411\":1}}],[\"对受到伤害并且没有愈合\",{\"1\":{\"411\":1}}],[\"对虚拟节点名称使用哈希算法\",{\"1\":{\"393\":1}}],[\"对同一个\",{\"1\":{\"385\":1}}],[\"对相同的\",{\"1\":{\"385\":1}}],[\"对任意一组输入数据进行计算\",{\"1\":{\"385\":1}}],[\"对内部分则负责完成开发者所录入任务的调度和派发\",{\"1\":{\"372\":1}}],[\"对外部分面向用户\",{\"1\":{\"372\":1}}],[\"对普通函数\",{\"1\":{\"319\":1}}],[\"对singe设置默认值\",{\"1\":{\"316\":1}}],[\"对分布式系统一致性算法\",{\"1\":{\"286\":1}}],[\"对底层基础设施\",{\"1\":{\"277\":1}}],[\"对象组成\",{\"1\":{\"1321\":1}}],[\"对象启动客户端的各种服务\",{\"1\":{\"1112\":1}}],[\"对象还没有被创建出来\",{\"1\":{\"1111\":1}}],[\"对象中的\",{\"1\":{\"1111\":1}}],[\"对象只是一个壳\",{\"1\":{\"1109\":1}}],[\"对象时会在内部一个创建\",{\"1\":{\"1109\":1}}],[\"对象编码\",{\"1\":{\"957\":1,\"973\":1}}],[\"对象构造时需要拷贝一遍\",{\"1\":{\"900\":1}}],[\"对象和\",{\"1\":{\"900\":1}}],[\"对象的属性索引\",{\"1\":{\"558\":1}}],[\"对象的模板\",{\"1\":{\"558\":1}}],[\"对象属性\",{\"1\":{\"558\":1}}],[\"对象\",{\"0\":{\"299\":1,\"348\":1,\"549\":1},\"1\":{\"294\":1,\"351\":1,\"506\":1,\"900\":1,\"957\":2,\"973\":2,\"984\":1,\"990\":1,\"996\":1,\"1035\":1,\"1109\":1,\"1111\":2,\"1112\":1,\"1324\":1,\"1402\":1}}],[\"对象并执行方法\",{\"1\":{\"266\":1}}],[\"对象方法\",{\"0\":{\"265\":1},\"1\":{\"558\":2}}],[\"对线程进行分工\",{\"1\":{\"119\":1}}],[\"对应单个文件\",{\"1\":{\"1386\":1}}],[\"对应用不完全透明\",{\"1\":{\"1385\":1}}],[\"对应槽位时间窗所要投递的所有定时消息\",{\"1\":{\"1346\":1}}],[\"对应一个固定的延迟时长\",{\"1\":{\"1342\":1}}],[\"对应数据是否在\",{\"1\":{\"1323\":1}}],[\"对应服务端结果\",{\"1\":{\"1175\":2}}],[\"对应18个延迟等级\",{\"1\":{\"836\":1}}],[\"对应延迟1分钟\",{\"1\":{\"835\":1}}],[\"对应消息在\",{\"1\":{\"782\":1}}],[\"对应副本的天赋将在下面提供\",{\"1\":{\"403\":1}}],[\"对应哈希环上的位置\",{\"1\":{\"390\":1}}],[\"对应的日志条目在\",{\"1\":{\"1519\":1}}],[\"对应的文件句柄元数据也会被创建和持久化\",{\"1\":{\"1395\":1}}],[\"对应的队列的消息\",{\"1\":{\"1257\":1}}],[\"对应的队列信息\",{\"1\":{\"1143\":1}}],[\"对应的处理类为pullmessageprocessor\",{\"1\":{\"757\":1,\"766\":1}}],[\"对应的\",{\"1\":{\"673\":2,\"1395\":1}}],[\"对应的值达到\",{\"1\":{\"624\":1}}],[\"对应的数据来说\",{\"1\":{\"385\":1}}],[\"对应的服务端\",{\"1\":{\"118\":1}}],[\"对应\",{\"1\":{\"171\":1,\"925\":1,\"1290\":1,\"1418\":1}}],[\"对应执行的phase\",{\"1\":{\"64\":1}}],[\"对应执行的goal\",{\"1\":{\"63\":1}}],[\"对服务性能的挑战也越来越大\",{\"1\":{\"115\":1}}],[\"对目标类的字节码重新\",{\"1\":{\"85\":1}}],[\"对于已确认\",{\"1\":{\"1512\":1}}],[\"对于已经到重试时间的\",{\"1\":{\"1263\":1}}],[\"对于启动\",{\"1\":{\"1509\":1}}],[\"对于没有在\",{\"1\":{\"1453\":1}}],[\"对于没有处理完的半消息\",{\"1\":{\"1453\":1}}],[\"对于没有成功\",{\"1\":{\"1279\":1}}],[\"对于目标偏移量之前的每个偏移量\",{\"1\":{\"1427\":1}}],[\"对于上传失败的情况\",{\"1\":{\"1403\":1}}],[\"对于上面两个痛点\",{\"1\":{\"1291\":1}}],[\"对于在内存中还未持久化的数据\",{\"1\":{\"1362\":1}}],[\"对于队列数据重复保存的问题\",{\"1\":{\"1291\":1}}],[\"对于匹配完成或者存盘的\",{\"1\":{\"1262\":1}}],[\"对于集群模式\",{\"1\":{\"1255\":1}}],[\"对于广播模式\",{\"1\":{\"1255\":1}}],[\"对于超过\",{\"1\":{\"1253\":1}}],[\"对于长时间没有\",{\"1\":{\"1251\":1}}],[\"对于顺序消费情况\",{\"1\":{\"1228\":1}}],[\"对于重试消息\",{\"1\":{\"1218\":1}}],[\"对于对分配到的队列尝试请求\",{\"1\":{\"1213\":1}}],[\"对于要丢弃的队列\",{\"1\":{\"1213\":1}}],[\"对于要多次计算的操作\",{\"1\":{\"917\":1}}],[\"对于新分配到的队列\",{\"1\":{\"1209\":1}}],[\"对于新分配的\",{\"1\":{\"1137\":1,\"1144\":1,\"1224\":1}}],[\"对于新的worker进行注册逻辑\",{\"1\":{\"378\":1}}],[\"对于消费失败的消息\",{\"1\":{\"1117\":1}}],[\"对于消息的存储\",{\"1\":{\"1010\":1}}],[\"对于消息轨迹数据量较大的场景\",{\"1\":{\"1004\":1}}],[\"对于批量消息\",{\"1\":{\"1053\":1}}],[\"对于每条消息较小且消息较多的场景\",{\"1\":{\"1044\":1}}],[\"对于每个延迟等级\",{\"1\":{\"925\":1}}],[\"对于每个\",{\"1\":{\"878\":1}}],[\"对于客户端消息发送\",{\"1\":{\"1025\":1}}],[\"对于异步投递\",{\"1\":{\"933\":1}}],[\"对于流控也不需要重新投递这么多任务\",{\"1\":{\"932\":1}}],[\"对于任意时间定时消息的投递\",{\"1\":{\"932\":1}}],[\"对于定时消息的投递\",{\"1\":{\"931\":1}}],[\"对于定时消息\",{\"1\":{\"927\":1}}],[\"对于单队列支持任意时间定时消息的难点是消息的顺序问题\",{\"1\":{\"925\":1}}],[\"对于这批操作消息已经提交的事务半消息\",{\"1\":{\"1468\":1}}],[\"对于这些取舍\",{\"1\":{\"924\":1}}],[\"对于这种情况\",{\"1\":{\"380\":1}}],[\"对于磁盘\",{\"1\":{\"917\":1}}],[\"对于写\",{\"1\":{\"894\":1}}],[\"对于写字符串\",{\"1\":{\"894\":1}}],[\"对于机械硬盘来说\",{\"1\":{\"876\":1}}],[\"对于同一个\",{\"1\":{\"755\":1}}],[\"对于一条要投递到多个队列的消息\",{\"1\":{\"700\":1}}],[\"对于一个算是新开始玩的加班狗来说我已经满意了\",{\"1\":{\"399\":1}}],[\"对于持久化消息\",{\"1\":{\"690\":1}}],[\"对于3个或更多节点的集群\",{\"1\":{\"662\":1}}],[\"对于模块外部是不可见的\",{\"1\":{\"591\":1}}],[\"对于开发者没有指定类型\",{\"1\":{\"502\":1}}],[\"对于\",{\"1\":{\"411\":1,\"547\":1,\"878\":1,\"942\":1,\"1253\":2,\"1314\":1,\"1315\":1}}],[\"对于mapreduce任务会执行last\",{\"1\":{\"378\":1}}],[\"对于map不关心结果\",{\"1\":{\"378\":1}}],[\"对于map\",{\"1\":{\"378\":1}}],[\"对于秒级任务和map\",{\"1\":{\"375\":1}}],[\"对于未运行的job\",{\"1\":{\"374\":1}}],[\"对于分布式系统韧性的观测更需要一个简单直观的分析报告\",{\"1\":{\"283\":1}}],[\"对于执行异步任务的时间\",{\"1\":{\"135\":1}}],[\"对于aop的织入\",{\"1\":{\"85\":1}}],[\"对于普通的字符串+操作\",{\"1\":{\"28\":1}}],[\"对于绝大多数情况都够用了\",{\"1\":{\"23\":1}}],[\"执行追加条目钩子函数\",{\"1\":{\"1517\":1}}],[\"执行不同的状态维护逻辑\",{\"1\":{\"1482\":1}}],[\"执行事务消息状态回查后钩子\",{\"1\":{\"1472\":1}}],[\"执行事务结束钩子\",{\"1\":{\"1460\":1}}],[\"执行完本地事务后\",{\"1\":{\"1464\":1}}],[\"执行失败上报\",{\"1\":{\"1446\":1}}],[\"执行成功则上报\",{\"1\":{\"1446\":1}}],[\"执行本地事务\",{\"1\":{\"1442\":1,\"1449\":1,\"1451\":1,\"1459\":2}}],[\"执行逻辑上面讲过\",{\"1\":{\"1219\":1}}],[\"执行具体消费逻辑\",{\"1\":{\"1195\":1}}],[\"执行结果处理函数\",{\"1\":{\"1188\":1}}],[\"执行真正消费业务逻辑\",{\"1\":{\"1188\":1}}],[\"执行真正的业务逻辑\",{\"1\":{\"1179\":1}}],[\"执行hook\",{\"1\":{\"1173\":1}}],[\"执行拉取消息请求\",{\"1\":{\"1168\":1}}],[\"执行拉取任务\",{\"1\":{\"1104\":1}}],[\"执行长轮询逻辑\",{\"1\":{\"1163\":1}}],[\"执行分配策略的重分配方法\",{\"1\":{\"1137\":1}}],[\"执行消费后钩子函数\",{\"1\":{\"1188\":1,\"1195\":1,\"1218\":1}}],[\"执行消费前钩子函数\",{\"1\":{\"1188\":1,\"1195\":1,\"1218\":1}}],[\"执行消费请求的\",{\"1\":{\"1188\":1}}],[\"执行消费逻辑\",{\"1\":{\"1117\":1,\"1195\":1,\"1218\":1}}],[\"执行消费业务逻辑\",{\"1\":{\"1104\":1}}],[\"执行消息消费后钩子函数\",{\"1\":{\"1188\":1}}],[\"执行消息轨迹的消费钩子\",{\"1\":{\"1163\":1}}],[\"执行消息发送前的钩子函数\",{\"1\":{\"1053\":1}}],[\"执行消息发送后的钩子函数\",{\"1\":{\"1042\":1}}],[\"执行消息压缩和事务\",{\"1\":{\"1053\":1}}],[\"执行消息拉取\",{\"1\":{\"811\":1}}],[\"执行重平衡方法\",{\"1\":{\"1104\":1}}],[\"执行重投递逻辑\",{\"1\":{\"750\":1,\"781\":1}}],[\"执行客户端同步发送方法\",{\"1\":{\"1053\":1}}],[\"执行所有\",{\"1\":{\"1053\":1}}],[\"执行启动逻辑\",{\"1\":{\"1047\":1}}],[\"执行发送之后的钩子函数\",{\"1\":{\"1053\":1}}],[\"执行发送之前的钩子函数\",{\"1\":{\"1042\":1}}],[\"执行发送\",{\"1\":{\"1027\":1,\"1036\":1}}],[\"执行权限判断\",{\"1\":{\"981\":1}}],[\"执行该方法\",{\"1\":{\"960\":1}}],[\"执行新的handleputresulttask\",{\"1\":{\"858\":1}}],[\"执行入口\",{\"1\":{\"841\":1}}],[\"执行刷盘\",{\"1\":{\"769\":1}}],[\"执行刷盘有两个阈值\",{\"1\":{\"758\":1}}],[\"执行一个新的\",{\"1\":{\"845\":1}}],[\"执行一个phase又会触发一个或多个goal\",{\"1\":{\"63\":1}}],[\"执行一次扫描\",{\"1\":{\"1262\":1}}],[\"执行一次定时任务投递这\",{\"1\":{\"924\":1}}],[\"执行一次\",{\"1\":{\"769\":1,\"869\":1,\"1262\":1,\"1358\":1}}],[\"执行每个分发器的dispatch方法\",{\"1\":{\"763\":1}}],[\"执行每个phase\",{\"1\":{\"64\":1}}],[\"执行如下命令安装\",{\"1\":{\"643\":1}}],[\"执行器也可以通过集群部署实现高可用\",{\"1\":{\"372\":1}}],[\"执行器的整体逻辑就是监听来自调度中心的任务执行请求\",{\"1\":{\"372\":1}}],[\"执行器是一个普通的\",{\"1\":{\"372\":1}}],[\"执行器产生的日志可以在前端控制台页面实时显示\",{\"1\":{\"371\":1}}],[\"执行器支持广泛\",{\"1\":{\"371\":1}}],[\"执行模式丰富\",{\"1\":{\"371\":1}}],[\"执行层与被测组件层\",{\"1\":{\"280\":1}}],[\"执行带参数的方法\",{\"1\":{\"266\":2}}],[\"执行无参数\",{\"1\":{\"266\":1}}],[\"执行静态方法和\",{\"0\":{\"265\":1}}],[\"执行处理请求前被调用\",{\"1\":{\"996\":1}}],[\"执行处理\",{\"1\":{\"122\":1}}],[\"执行\",{\"0\":{\"125\":1},\"1\":{\"122\":1,\"135\":1,\"188\":1,\"960\":1,\"1427\":1,\"1510\":2}}],[\"执行的phase\",{\"1\":{\"63\":1}}],[\"会忽略它\",{\"1\":{\"1520\":1}}],[\"会按照这\",{\"1\":{\"1507\":1}}],[\"会成为\",{\"1\":{\"1477\":1}}],[\"会发起投票请求\",{\"1\":{\"1477\":1}}],[\"会发送到\",{\"1\":{\"1259\":1}}],[\"会最多重复存储\",{\"1\":{\"1468\":1}}],[\"会触发磁盘\",{\"1\":{\"1453\":1}}],[\"会触发异常\",{\"1\":{\"193\":1}}],[\"会查询本地事务执行结果\",{\"1\":{\"1451\":1}}],[\"会查询即将需要调度执行的任务\",{\"1\":{\"379\":1}}],[\"会待直到获取锁成功\",{\"1\":{\"1427\":1}}],[\"会递归恢复\",{\"1\":{\"1421\":1}}],[\"会走到上面分级存储读取的方法来读取消息然后放入预读缓存\",{\"1\":{\"1409\":1}}],[\"会额外消耗时间\",{\"1\":{\"1364\":1}}],[\"会检查其的属性\",{\"1\":{\"1354\":1}}],[\"会检查消息属性\",{\"1\":{\"1294\":1}}],[\"会检查挂起的请求中是否有可以进行拉取的数据\",{\"1\":{\"810\":1}}],[\"会消费\",{\"1\":{\"1263\":1}}],[\"会消耗时间\",{\"1\":{\"876\":1}}],[\"会继续后面的逻辑放入磁盘\",{\"1\":{\"1259\":1}}],[\"会保存一批获取到的消息的起始偏移量和相对偏移量\",{\"1\":{\"1258\":1}}],[\"会返回内存中\",{\"1\":{\"1258\":1}}],[\"会返回重平衡的结果\",{\"1\":{\"1252\":1}}],[\"会出现有的队列重复消费\",{\"1\":{\"1240\":1}}],[\"会尝试向\",{\"1\":{\"1209\":1}}],[\"会放入死信队列\",{\"1\":{\"1198\":1}}],[\"会被初始化为\",{\"1\":{\"1509\":1}}],[\"会被同步到从\",{\"1\":{\"1188\":1}}],[\"会被作为配置文件保存\",{\"1\":{\"840\":1}}],[\"会收到消费者端的请求\",{\"1\":{\"1183\":1}}],[\"会收到并分发\",{\"1\":{\"128\":1}}],[\"会等待一段时间后将拉取请求放入队列\",{\"1\":{\"1158\":1}}],[\"会向\",{\"1\":{\"1136\":1,\"1312\":1}}],[\"会向长轮询线程发送提醒\",{\"1\":{\"811\":1}}],[\"会更新订阅的\",{\"1\":{\"1136\":1}}],[\"会初始化一些服务和参数\",{\"1\":{\"1112\":1}}],[\"会初始化并且创建一个目录结构来保存\",{\"1\":{\"252\":1}}],[\"会引发重平衡\",{\"1\":{\"1101\":1}}],[\"会进行一次检查\",{\"1\":{\"1098\":1}}],[\"会进行重投递\",{\"1\":{\"750\":1,\"781\":1}}],[\"会启动\",{\"1\":{\"1077\":1}}],[\"会启动过期文件清理的定时任务\",{\"1\":{\"869\":1}}],[\"会拉取相应版本的\",{\"1\":{\"1072\":1}}],[\"会悲观地认为\",{\"1\":{\"1041\":1}}],[\"会规避上一次发送的\",{\"1\":{\"1041\":1}}],[\"会轮询所有队列进行发送\",{\"1\":{\"1041\":1}}],[\"会请求\",{\"1\":{\"1030\":1}}],[\"会构建一个轨迹上下文\",{\"1\":{\"1014\":1}}],[\"会观察配置文件改动并且自动重新加载\",{\"1\":{\"980\":1}}],[\"会遍历所有挂起的\",{\"1\":{\"1511\":1}}],[\"会遍历\",{\"1\":{\"952\":1}}],[\"会立即发送\",{\"1\":{\"945\":1}}],[\"会立刻执行删除\",{\"1\":{\"863\":1}}],[\"会造成其消费的队列的消息堆积\",{\"1\":{\"1249\":1}}],[\"会造成其他\",{\"1\":{\"1234\":1}}],[\"会造成\",{\"1\":{\"906\":1}}],[\"会提前准备好下一个文件的分配\",{\"1\":{\"881\":1}}],[\"会提取列表头作为x\",{\"1\":{\"177\":1}}],[\"会阻止删除\",{\"1\":{\"870\":1}}],[\"会阻塞整个队列\",{\"1\":{\"678\":1}}],[\"会删除未过期的文件\",{\"1\":{\"870\":1}}],[\"会删除\",{\"1\":{\"864\":1}}],[\"会计算出消息的真正投递时间\",{\"1\":{\"839\":1}}],[\"会判断是否是长轮询\",{\"1\":{\"806\":1}}],[\"会重排该索引文件\",{\"1\":{\"1411\":1}}],[\"会重试创建3次\",{\"1\":{\"789\":1}}],[\"会重新分发\",{\"1\":{\"375\":1}}],[\"会创建一个新的索引文件来保存\",{\"1\":{\"787\":1}}],[\"会强制刷盘\",{\"1\":{\"769\":1}}],[\"会从本地存储再读取一次\",{\"1\":{\"1405\":1}}],[\"会从\",{\"1\":{\"765\":1,\"789\":1}}],[\"会为\",{\"1\":{\"1517\":1}}],[\"会为每个分配到的新队列创建一个消息拉取请求\",{\"1\":{\"1104\":1}}],[\"会为每个\",{\"1\":{\"749\":1}}],[\"会为前三种进程分配信用值\",{\"1\":{\"619\":1}}],[\"会先投票给自己\",{\"1\":{\"1491\":1}}],[\"会先进行默认存储的初始化\",{\"1\":{\"1398\":1}}],[\"会先执行\",{\"1\":{\"1318\":1}}],[\"会先将需要\",{\"1\":{\"1300\":1}}],[\"会先在\",{\"1\":{\"1253\":1}}],[\"会先在本地查询\",{\"1\":{\"1030\":1}}],[\"会先查询队列索引\",{\"1\":{\"687\":1}}],[\"会先通过https创建安全的连接\",{\"1\":{\"368\":1}}],[\"会随着系统的负载而在几种不同的存储状态中不断地流动\",{\"1\":{\"681\":1}}],[\"会使消息丢失的概率加大\",{\"1\":{\"678\":1}}],[\"会使得服务器\",{\"1\":{\"622\":1}}],[\"会再次广播\",{\"1\":{\"674\":1}}],[\"会导致新的任务需要等待前一个任务执行结束\",{\"1\":{\"852\":1}}],[\"会导致从该位置中取不到数据\",{\"1\":{\"845\":1}}],[\"会导致查询结果错误\",{\"1\":{\"786\":1}}],[\"会导致生产者生产阻塞\",{\"1\":{\"664\":1}}],[\"会导致该进程邮箱过大\",{\"1\":{\"611\":1}}],[\"会授予rabbit\",{\"1\":{\"626\":1}}],[\"会调用该监听器的方法\",{\"1\":{\"1468\":1}}],[\"会调用\",{\"1\":{\"954\":1,\"1159\":1,\"1408\":1,\"1451\":1}}],[\"会调用pullmessageprocessor\",{\"1\":{\"825\":1}}],[\"会调用grant方法授予rabbit\",{\"1\":{\"626\":1}}],[\"会调用credit\",{\"1\":{\"625\":1}}],[\"会调用realschedule\",{\"1\":{\"379\":1}}],[\"会执行分级存储\",{\"1\":{\"1403\":1}}],[\"会执行\",{\"1\":{\"756\":1}}],[\"会执行如下加粗逻辑\",{\"1\":{\"624\":1}}],[\"会执行3个phase\",{\"1\":{\"62\":1}}],[\"会给\",{\"1\":{\"621\":1}}],[\"会给上有进程发一个ack消息\",{\"1\":{\"619\":1}}],[\"会有不同的函数行为\",{\"1\":{\"547\":1}}],[\"会认为这个序列的成员数量是不确定的\",{\"1\":{\"529\":1}}],[\"会自动产生的对象\",{\"1\":{\"508\":1}}],[\"会好打很多\",{\"1\":{\"458\":1}}],[\"会好很多\",{\"1\":{\"422\":1}}],[\"会法球和单点\",{\"1\":{\"448\":1}}],[\"会\",{\"1\":{\"448\":1,\"716\":1}}],[\"会打就还好\",{\"1\":{\"422\":1}}],[\"会非常吃紧\",{\"1\":{\"403\":1}}],[\"会对其进行预热\",{\"1\":{\"882\":1}}],[\"会对附近最多\",{\"1\":{\"401\":1}}],[\"会对集群节点根据不同的观测特性引入对应的事件\",{\"1\":{\"280\":1}}],[\"会将内容暂存到内存队列中\",{\"1\":{\"1516\":1}}],[\"会将引用次数设置为负数\",{\"1\":{\"870\":1}}],[\"会将请求加入到\",{\"1\":{\"815\":1}}],[\"会将响应码设置为\",{\"1\":{\"814\":1,\"819\":1}}],[\"会将\",{\"1\":{\"742\":1,\"906\":1,\"931\":1,\"1321\":1}}],[\"会将较小的消息体直接全量保存到队列索引\",{\"1\":{\"687\":1}}],[\"会将类型声明和类型相关的代码全部删除\",{\"1\":{\"497\":1}}],[\"会将子任务初始化为waiting\",{\"1\":{\"378\":1}}],[\"会将模块mod里的func函数应用到arg1\",{\"1\":{\"200\":1}}],[\"会分发给可用的processortracker\",{\"1\":{\"375\":1}}],[\"会根据执行结果将事务半消息查出来\",{\"1\":{\"1450\":1}}],[\"会根据消息的\",{\"1\":{\"1039\":1}}],[\"会根据topic和queueid定位到对应的消费队列\",{\"1\":{\"766\":1}}],[\"会根据topic和queueid定位到对应的\",{\"1\":{\"757\":1}}],[\"会根据集群中各个\",{\"1\":{\"372\":1}}],[\"会根据用户关注的不同观测特性引入对应的事件\",{\"1\":{\"280\":1}}],[\"会得到非常诡异的结果\",{\"1\":{\"295\":1}}],[\"会在根目录下创建一个\",{\"1\":{\"1074\":1}}],[\"会在本次消息发送过程中避开该\",{\"1\":{\"1041\":1}}],[\"会在初始化时加载目录中的所有配置文件\",{\"1\":{\"990\":1,\"996\":1}}],[\"会在每个\",{\"1\":{\"942\":1}}],[\"会在每次进入mfa指定的函数时进行测试\",{\"1\":{\"261\":1}}],[\"会在在其\",{\"1\":{\"834\":1}}],[\"会在讲解优化点前补充一些前置知识\",{\"1\":{\"720\":1}}],[\"会在信用证系统种进行\",{\"1\":{\"621\":1}}],[\"会在\",{\"1\":{\"252\":1}}],[\"会在内部将\",{\"1\":{\"135\":1}}],[\"会优先处理\",{\"1\":{\"135\":1}}],[\"会依次执行链表上的\",{\"1\":{\"135\":1}}],[\"会依次查找\",{\"1\":{\"23\":1}}],[\"会选择一个从\",{\"1\":{\"135\":1}}],[\"会让消费者端的管理器向\",{\"1\":{\"1183\":1}}],[\"会让\",{\"1\":{\"120\":1}}],[\"会把没有过期文件也删掉\",{\"1\":{\"866\":1}}],[\"会把内存映射文件中的数据强制写到磁盘\",{\"1\":{\"796\":1}}],[\"会把\",{\"1\":{\"118\":1,\"1344\":1}}],[\"会抛出异常拒绝执行\",{\"1\":{\"87\":1}}],[\"由原来的实时上传改为攒批\",{\"1\":{\"1388\":1}}],[\"由表达式直接匹配\",{\"1\":{\"1325\":1}}],[\"由消费者向\",{\"1\":{\"1212\":1}}],[\"由抽象类直接实现\",{\"1\":{\"1134\":1}}],[\"由启动脚本调用\",{\"1\":{\"947\":1}}],[\"由前文所说\",{\"1\":{\"928\":1}}],[\"由异步刷盘线程写入\",{\"1\":{\"883\":1}}],[\"由用户配置开启\",{\"1\":{\"883\":1}}],[\"由run\",{\"1\":{\"841\":1}}],[\"由其权重决定\",{\"1\":{\"716\":1}}],[\"由三个可访问性修饰符\",{\"1\":{\"575\":1}}],[\"由使用时目标的生命值决定\",{\"1\":{\"405\":1}}],[\"由如下方法处理\",{\"1\":{\"374\":1}}],[\"由function\",{\"1\":{\"332\":1}}],[\"由上下文确定\",{\"1\":{\"331\":1}}],[\"由键\",{\"1\":{\"294\":1}}],[\"由此可以引出\",{\"1\":{\"978\":1}}],[\"由此可知\",{\"1\":{\"256\":1}}],[\"由此拉开了混沌工程学的序幕\",{\"1\":{\"276\":1}}],[\"由\",{\"1\":{\"128\":1,\"184\":1,\"186\":1,\"786\":1,\"866\":1,\"877\":1,\"952\":1,\"967\":1,\"1015\":1,\"1036\":1,\"1188\":1,\"1212\":1,\"1250\":1,\"1290\":1,\"1321\":1,\"1332\":1,\"1396\":1,\"1508\":4,\"1520\":1}}],[\"由该线程池处理\",{\"1\":{\"128\":1}}],[\"由它来调用\",{\"1\":{\"121\":1}}],[\"由一组\",{\"1\":{\"1402\":2}}],[\"由一个单独的线程flushconsumequeueservice周期性检查和刷盘\",{\"1\":{\"758\":1}}],[\"由一个单独的线程进行持久化\",{\"1\":{\"752\":1}}],[\"由一个\",{\"1\":{\"116\":1}}],[\"由一系列\",{\"1\":{\"62\":1}}],[\"由hibernate自动转换为实际的表名和列名\",{\"1\":{\"92\":1}}],[\"由于一个节点可能同时收到多个其他节点的拉票请求\",{\"1\":{\"1503\":1}}],[\"由于是向其他节点请求投票\",{\"1\":{\"1477\":1}}],[\"由于定时消息对于写入更加敏感\",{\"1\":{\"1363\":1}}],[\"由于拿不到该队列的锁\",{\"1\":{\"1225\":1}}],[\"由于并发关系\",{\"1\":{\"1170\":1}}],[\"由于拉模式和推模式消费者的启动流程大致相同\",{\"1\":{\"1120\":1}}],[\"由于需要支持拉和推两种消费模式\",{\"1\":{\"1116\":1}}],[\"由于需要向后查找虚拟节点的位置\",{\"1\":{\"391\":1}}],[\"由于消息轨迹数据没有普通消息那样强的实时性要求\",{\"1\":{\"1010\":1}}],[\"由于消息队列需要高性能\",{\"1\":{\"1003\":1}}],[\"由于消费者是单线程\",{\"1\":{\"724\":1}}],[\"由于支持了从多文件加载权限配置\",{\"1\":{\"997\":1}}],[\"由于每个队列每次拉取所需要的元信息几乎没什么变化\",{\"1\":{\"1155\":1}}],[\"由于每个\",{\"1\":{\"925\":1,\"1393\":1}}],[\"由于每个索引项的大小是固定的\",{\"1\":{\"751\":1}}],[\"由于大部分情况下都用不到\",{\"1\":{\"903\":1}}],[\"由于各种指令对应的\",{\"1\":{\"890\":1}}],[\"由于它里面保存的每个\",{\"1\":{\"878\":1}}],[\"由于当前代码的复杂性\",{\"1\":{\"736\":1}}],[\"由于要保证消息保存到\",{\"1\":{\"733\":1}}],[\"由于发送的消息较少\",{\"1\":{\"711\":1}}],[\"由于使用了一种低效的消息复制方法\",{\"1\":{\"693\":1}}],[\"由于所有节点组成了一个循环链表\",{\"1\":{\"673\":1}}],[\"由于某些数据可能天生是短暂的或对时间非常敏感\",{\"1\":{\"662\":1}}],[\"由于对象内部定义方法时\",{\"1\":{\"558\":1}}],[\"由于翻译每个技能太麻烦\",{\"1\":{\"488\":1}}],[\"由于你每\",{\"1\":{\"417\":1}}],[\"由于快速生长天赋的存在\",{\"1\":{\"401\":1}}],[\"由于linkedblockingqueue是线程安全的\",{\"1\":{\"379\":1}}],[\"由于这种高精度的时间轮需要频繁地检查和执行任务\",{\"1\":{\"379\":1}}],[\"由于分布式系统的复杂性\",{\"1\":{\"283\":1}}],[\"由于\",{\"1\":{\"124\":1,\"131\":1,\"582\":1,\"707\":1,\"1187\":1,\"1188\":1,\"1203\":1,\"1240\":1}}],[\"由于jvm的动态代理要求必须实现接口\",{\"1\":{\"85\":1}}],[\"由于可能需要在\",{\"1\":{\"7\":1}}],[\"由编译器把切面调用编译进字节码\",{\"1\":{\"85\":1}}],[\"由编译器推断类型\",{\"1\":{\"76\":1}}],[\"由packet\",{\"1\":{\"72\":1}}],[\"把对应的\",{\"1\":{\"1521\":1}}],[\"把写入的条目\",{\"1\":{\"1516\":1,\"1518\":1}}],[\"把请求放入对应的等待表中\",{\"1\":{\"1511\":1}}],[\"把投递的\",{\"1\":{\"1354\":1}}],[\"把已经全部\",{\"1\":{\"1277\":1}}],[\"把已经匹配或存盘的\",{\"1\":{\"1277\":1}}],[\"把超时的\",{\"1\":{\"1262\":1}}],[\"把消费失败的消息发回\",{\"1\":{\"1197\":2}}],[\"把消息全部已经投递的\",{\"1\":{\"868\":1}}],[\"把commitoffset位去掉\",{\"1\":{\"1171\":1}}],[\"把重平衡逻辑从客户端移到了服务端\",{\"1\":{\"1095\":1}}],[\"把其中默认的\",{\"1\":{\"1075\":1}}],[\"把定时消息查出来重新投递\",{\"1\":{\"847\":1}}],[\"把真正的\",{\"1\":{\"843\":1}}],[\"把很多内置方法的参数\",{\"1\":{\"509\":1}}],[\"把铁木树皮也作为你的个减\",{\"1\":{\"492\":1}}],[\"把这个索引结构以文件的形式实现\",{\"1\":{\"1346\":1}}],[\"把这个文件做成可扩展的文件队列即可\",{\"1\":{\"927\":1}}],[\"把这个\",{\"1\":{\"473\":1}}],[\"把治疗手牌留到它拔剑的时候\",{\"1\":{\"472\":1}}],[\"把治疗手牌留到铁钩拉人之后\",{\"1\":{\"464\":1}}],[\"把治疗手牌留到冰缚之盾\",{\"1\":{\"460\":1}}],[\"把治疗手牌留到在最终收割后\",{\"1\":{\"458\":1}}],[\"把治疗手牌留到吞噬\",{\"1\":{\"453\":1}}],[\"把治疗手牌留到猜谜游戏\",{\"1\":{\"452\":1}}],[\"把治疗手牌留到黑暗之拥的时候\",{\"1\":{\"451\":1}}],[\"把万灵和树皮留到打盾的时候\",{\"1\":{\"439\":1}}],[\"把万灵和树皮留给寒冰镰刀\",{\"1\":{\"432\":1}}],[\"把林莽卫士的\",{\"1\":{\"413\":1}}],[\"把触发大树规划到治疗手牌里\",{\"1\":{\"403\":1}}],[\"把野性成长加强换成了双叶伴身和铁皮减\",{\"1\":{\"403\":1}}],[\"把后续执行的动作都放到了worker端\",{\"1\":{\"374\":1}}],[\"把一段javascript代码用一个函数包装起来\",{\"1\":{\"364\":1}}],[\"把结果继续与序列的下一个元素做积累计算\",{\"1\":{\"324\":1}}],[\"把函数作用在数组上\",{\"1\":{\"324\":1}}],[\"把参数按顺序传入\",{\"1\":{\"319\":1}}],[\"把参数打包成array再传入\",{\"1\":{\"319\":1}}],[\"把passport属性赋值给变量id\",{\"1\":{\"316\":1}}],[\"把所有申明的变量\",{\"1\":{\"311\":1}}],[\"把array的第一个元素删掉\",{\"1\":{\"298\":1}}],[\"把相连进程的\",{\"1\":{\"241\":1}}],[\"把未匹配的消息加入队列供以后处理\",{\"1\":{\"233\":1}}],[\"把它们对应的需要移除的半消息的逻辑偏移量放到\",{\"1\":{\"1453\":1}}],[\"把它改为\",{\"1\":{\"1394\":1}}],[\"把它当中已经\",{\"1\":{\"1277\":1}}],[\"把它保存到\",{\"1\":{\"729\":1}}],[\"把它存放在数据里并在后面用于比较是否相等\",{\"1\":{\"218\":1}}],[\"把它理解为\",{\"1\":{\"118\":1}}],[\"把调用封装在一个\",{\"1\":{\"193\":1}}],[\"把列表的头与尾分隔开\",{\"1\":{\"177\":1}}],[\"把当前窗口移到一个新标签页\",{\"1\":{\"154\":1}}],[\"把活动窗口的宽度设为\",{\"1\":{\"153\":1}}],[\"把活动窗口的高度设为\",{\"1\":{\"153\":1}}],[\"把屏幕置为中间\",{\"1\":{\"145\":1}}],[\"把提示发到界面\",{\"1\":{\"125\":1}}],[\"把\",{\"1\":{\"124\":1,\"130\":1,\"701\":1,\"1253\":1,\"1294\":1,\"1510\":1,\"1523\":1}}],[\"把资源存储在classpath中可以避免文件路径依赖\",{\"1\":{\"56\":1}}],[\"把integer变为int的赋值写法\",{\"1\":{\"30\":1}}],[\"利用布隆过滤器进行初筛\",{\"1\":{\"1324\":1}}],[\"利用命令行\",{\"1\":{\"1247\":1}}],[\"利用延迟消息特性\",{\"1\":{\"1179\":1}}],[\"利用了这个特性\",{\"1\":{\"876\":1}}],[\"利用缓冲区一次性读取多个字节效率往往要高很多\",{\"1\":{\"53\":1}}],[\"利用反射\",{\"1\":{\"44\":1}}],[\"返回追加结果\",{\"1\":{\"1509\":1}}],[\"返回结果给客户端\",{\"1\":{\"1507\":1}}],[\"返回拒绝\",{\"1\":{\"1492\":3}}],[\"返回成功\",{\"1\":{\"1488\":2,\"1489\":1,\"1500\":3,\"1510\":1,\"1521\":1}}],[\"返回成功并丢弃消息\",{\"1\":{\"1198\":1}}],[\"返回对应的本地事务状态\",{\"1\":{\"1442\":1}}],[\"返回对象\",{\"1\":{\"331\":1}}],[\"返回新文件\",{\"1\":{\"1435\":1}}],[\"返回新文件的\",{\"1\":{\"1435\":1}}],[\"返回文件已满\",{\"1\":{\"1414\":1,\"1434\":1}}],[\"返回过滤数据的\",{\"1\":{\"1328\":1}}],[\"返回全部队列\",{\"1\":{\"1267\":1}}],[\"返回该队列中待\",{\"1\":{\"1270\":1}}],[\"返回该\",{\"1\":{\"1266\":1}}],[\"返回锁定成功的队列集合\",{\"1\":{\"1226\":1}}],[\"返回错误\",{\"1\":{\"1198\":1}}],[\"返回移除这批消息的最小的偏移量\",{\"1\":{\"1188\":1}}],[\"返回查询结果\",{\"1\":{\"1164\":1}}],[\"返回发送结果\",{\"1\":{\"1027\":3,\"1050\":1}}],[\"返回包含\",{\"1\":{\"973\":1}}],[\"返回包含系统里所有注册进程的列表\",{\"1\":{\"234\":1}}],[\"返回路由信息\",{\"0\":{\"957\":1}}],[\"返回给消费者\",{\"1\":{\"1319\":1}}],[\"返回给客户端一个\",{\"1\":{\"1518\":1}}],[\"返回给客户端\",{\"1\":{\"950\":1}}],[\"返回给consumer\",{\"1\":{\"820\":1}}],[\"返回给用户\",{\"1\":{\"110\":1}}],[\"返回响应给\",{\"1\":{\"814\":1}}],[\"返回undefined\",{\"1\":{\"327\":1}}],[\"返回这个元素的索引\",{\"1\":{\"327\":1}}],[\"返回这个元素\",{\"1\":{\"327\":1}}],[\"返回一个新的\",{\"1\":{\"298\":1}}],[\"返回删除的元素\",{\"1\":{\"298\":1}}],[\"返回array新的长度\",{\"1\":{\"298\":2}}],[\"返回false\",{\"1\":{\"295\":1}}],[\"返回字典里面所有值为\",{\"1\":{\"217\":1}}],[\"返回整个进程字典\",{\"1\":{\"217\":1}}],[\"返回两个列表\",{\"1\":{\"189\":1}}],[\"返回由列表`l`中所有满足`p\",{\"1\":{\"187\":1}}],[\"返回客户端\",{\"1\":{\"123\":1}}],[\"返回已经就绪的通道的选择键\",{\"1\":{\"118\":1}}],[\"返回当前就绪的\",{\"1\":{\"118\":1}}],[\"返回线程池\",{\"1\":{\"116\":1}}],[\"返回读取的字节数\",{\"1\":{\"53\":1}}],[\"返回\",{\"1\":{\"53\":1,\"181\":1,\"298\":2,\"326\":1,\"327\":1,\"957\":1,\"973\":1,\"1052\":1,\"1170\":1,\"1258\":1,\"1328\":2,\"1430\":1,\"1442\":2,\"1500\":4,\"1510\":1,\"1520\":4,\"1521\":1}}],[\"返回常量定义的顺序\",{\"1\":{\"31\":1}}],[\"读模式\",{\"1\":{\"1435\":2}}],[\"读索引的调用链如图所示\",{\"1\":{\"1415\":1}}],[\"读分级存储索引\",{\"0\":{\"1415\":1}}],[\"读消息时会调用\",{\"1\":{\"1405\":1}}],[\"读消息时读\",{\"1\":{\"883\":1}}],[\"读消息的逻辑也经过一次重构\",{\"1\":{\"1404\":1}}],[\"读消息的逻辑引入预读缓存\",{\"1\":{\"1404\":1}}],[\"读消息\",{\"0\":{\"1389\":1,\"1401\":1,\"1404\":1,\"1405\":1,\"1407\":1,\"1410\":1,\"1429\":1}}],[\"读队列数量\",{\"1\":{\"964\":1}}],[\"读和写的区域都是被os智能cache过的热点区域\",{\"1\":{\"879\":1}}],[\"读到的\",{\"1\":{\"730\":1}}],[\"读到末尾\",{\"1\":{\"53\":1}}],[\"读完震地猛击前驱\",{\"1\":{\"438\":1}}],[\"读条点你就开减伤\",{\"1\":{\"468\":1}}],[\"读条震地猛击的时候驱散震地回响\",{\"1\":{\"438\":1}}],[\"读条很长\",{\"1\":{\"428\":1}}],[\"读一个野性成长\",{\"1\":{\"431\":1}}],[\"读出来前读野性成长\",{\"1\":{\"411\":1}}],[\"读愈合\",{\"1\":{\"399\":1}}],[\"读请求\",{\"1\":{\"111\":1}}],[\"读写难两全\",{\"1\":{\"1363\":1}}],[\"读写权限\",{\"1\":{\"964\":1}}],[\"读写性能比较可以参照这篇文章\",{\"1\":{\"880\":1}}],[\"读写文件的时候\",{\"1\":{\"879\":1}}],[\"读写文件时\",{\"1\":{\"2\":1}}],[\"读写\",{\"1\":{\"874\":1}}],[\"读写事件就绪时\",{\"1\":{\"135\":1}}],[\"读写事件\",{\"1\":{\"135\":1}}],[\"读写数据时如果没有命中写\",{\"1\":{\"882\":1}}],[\"读写数据\",{\"1\":{\"73\":1}}],[\"读取老索引项的下一个索引项位置\",{\"1\":{\"1435\":1}}],[\"读取压缩前索引项\",{\"1\":{\"1435\":1}}],[\"读取索引项\",{\"1\":{\"1415\":1}}],[\"读取方式和读取普通的本地索引文件类似\",{\"1\":{\"1415\":1}}],[\"读取到消息\",{\"1\":{\"1431\":1}}],[\"读取到消息数据后进行处理\",{\"1\":{\"1408\":1}}],[\"读取到了\",{\"1\":{\"125\":1}}],[\"读取分级存储\",{\"1\":{\"1408\":1}}],[\"读取本地存储中的消息数据\",{\"1\":{\"1405\":1}}],[\"读取器预读缓存\",{\"1\":{\"1402\":1}}],[\"读取一个\",{\"1\":{\"1393\":1}}],[\"读取一行输入\",{\"1\":{\"70\":1}}],[\"读取流程\",{\"0\":{\"1391\":1}}],[\"读取策略\",{\"0\":{\"1390\":1}}],[\"读取指定主题\",{\"1\":{\"1370\":1}}],[\"读取消费队列判断是否有消息可以消费\",{\"1\":{\"1153\":1}}],[\"读取消息时主要面对\",{\"1\":{\"883\":1}}],[\"读取消息\",{\"0\":{\"878\":1}}],[\"读取metainf\",{\"1\":{\"996\":1}}],[\"读取配置文件\",{\"1\":{\"980\":1}}],[\"读取文件的时候\",{\"1\":{\"879\":1}}],[\"读取进程被阻塞\",{\"1\":{\"621\":1}}],[\"读取该变量时\",{\"1\":{\"515\":1}}],[\"读取的操作被停止\",{\"1\":{\"621\":1}}],[\"读取的hello\",{\"1\":{\"364\":1}}],[\"读取的字节数\",{\"1\":{\"125\":2}}],[\"读取数据之后交给线程池进行处理\",{\"1\":{\"128\":1}}],[\"读取结束\",{\"1\":{\"125\":1}}],[\"读取结束后处理业务\",{\"1\":{\"116\":1}}],[\"读取内容到接收\",{\"1\":{\"125\":1}}],[\"读取和响应过程\",{\"1\":{\"120\":1}}],[\"读取或写入数据\",{\"1\":{\"118\":1}}],[\"读取客户端输入的一行内容\",{\"1\":{\"113\":1}}],[\"读取\",{\"0\":{\"56\":1},\"1\":{\"116\":2,\"125\":1,\"883\":1,\"990\":1,\"996\":1,\"1372\":2,\"1410\":1,\"1415\":1,\"1432\":1,\"1436\":1}}],[\"读取若干字节并填充到byte\",{\"1\":{\"53\":1}}],[\"值计算出\",{\"1\":{\"797\":1}}],[\"值的消息可能会被保存到不同的索引文件当中\",{\"1\":{\"787\":1}}],[\"值的前\",{\"1\":{\"396\":2}}],[\"值得重申的是\",{\"1\":{\"658\":1}}],[\"值都是独一无二的\",{\"1\":{\"531\":1}}],[\"值类型\",{\"0\":{\"514\":1},\"1\":{\"514\":1}}],[\"值找到下一个离它最近的节点\",{\"1\":{\"395\":1}}],[\"值可以是任意数据类型\",{\"1\":{\"294\":1}}],[\"值组成的无序集合\",{\"1\":{\"294\":1}}],[\"值查询表\",{\"1\":{\"247\":1}}],[\"值\",{\"1\":{\"53\":1,\"589\":1,\"606\":1,\"786\":2,\"1472\":1}}],[\"以维持领导地位\",{\"1\":{\"1477\":1}}],[\"以加快读取速度\",{\"1\":{\"1404\":1}}],[\"以加快消费速度\",{\"1\":{\"1089\":1}}],[\"以外的其他分级存储抽象\",{\"1\":{\"1387\":1}}],[\"以记录\",{\"1\":{\"1362\":1}}],[\"以订阅一组路径的\",{\"1\":{\"1290\":1}}],[\"以保证重分配的结果一致\",{\"1\":{\"1133\":1}}],[\"以保证消费的顺序性\",{\"1\":{\"1102\":1}}],[\"以其他部署形式启动\",{\"0\":{\"1082\":1}}],[\"以集群模式启动\",{\"0\":{\"1075\":1}}],[\"以供用户选择发往某个\",{\"1\":{\"1029\":1}}],[\"以提高消费速度\",{\"1\":{\"1028\":1}}],[\"以提升消息的吞吐量\",{\"1\":{\"648\":1}}],[\"以同样的方法签名\",{\"1\":{\"989\":1}}],[\"以此来达到周期性执行该任务的效果\",{\"1\":{\"841\":1}}],[\"以此循环\",{\"1\":{\"806\":1}}],[\"以此类推\",{\"1\":{\"188\":1,\"256\":1,\"582\":1}}],[\"以主从复制为例\",{\"1\":{\"724\":1}}],[\"以键值对的形式存储消息\",{\"1\":{\"687\":1}}],[\"以防止异常关机\",{\"1\":{\"683\":1}}],[\"以队列维度提供高可用的解决方案\",{\"1\":{\"649\":1}}],[\"以前的版本\",{\"1\":{\"648\":1}}],[\"以前\",{\"1\":{\"606\":1}}],[\"以前打团只要铺回春\",{\"1\":{\"399\":1}}],[\"以当前脚本的路径作为\",{\"1\":{\"599\":1}}],[\"以上\",{\"1\":{\"1079\":1}}],[\"以上8种类型可以看作\",{\"1\":{\"506\":1}}],[\"以上逻辑只适用于cron和daily\",{\"1\":{\"374\":1}}],[\"以免之后杀死队友\",{\"1\":{\"453\":1}}],[\"以下简称定时消息\",{\"1\":{\"1338\":1}}],[\"以下简称\",{\"1\":{\"1284\":1}}],[\"以下为参数含义\",{\"1\":{\"1247\":1}}],[\"以下为推模式下消息消费者端拉取相关类设计\",{\"1\":{\"1155\":1}}],[\"以下三种情况会将响应码设置为responsecode\",{\"1\":{\"819\":1}}],[\"以下技能是受这个机制影响的\",{\"1\":{\"419\":1}}],[\"以下割草用\",{\"1\":{\"403\":1}}],[\"以下是官方提供的server初始化流程图\",{\"1\":{\"374\":1}}],[\"以下是官方列出的主要特性\",{\"1\":{\"371\":1}}],[\"以下是准备工作\",{\"1\":{\"272\":1}}],[\"以下是主从\",{\"1\":{\"135\":1}}],[\"以后就变得不那么好玩了\",{\"1\":{\"399\":1}}],[\"以akka为例\",{\"1\":{\"374\":1}}],[\"以任务开启\",{\"1\":{\"374\":1}}],[\"以powerscheduleservice\",{\"1\":{\"374\":1}}],[\"以promise方式提供\",{\"1\":{\"349\":1}}],[\"以了解分区数量对消息吞吐量的影响和达到最大吞吐量的最优分区数数量\",{\"1\":{\"285\":1}}],[\"以消息系统的稳定性评估为例\",{\"1\":{\"283\":1}}],[\"以统一的标准化计算输出结果与图表\",{\"1\":{\"283\":1}}],[\"以观察他们在这种情况下的表现\",{\"1\":{\"282\":1}}],[\"以往支撑在线\",{\"1\":{\"276\":1}}],[\"以\",{\"1\":{\"272\":1,\"780\":1,\"1295\":1,\"1402\":1,\"1420\":1}}],[\"以`when`关键字开头\",{\"1\":{\"186\":1}}],[\"以句号结尾\",{\"1\":{\"180\":1}}],[\"以大写字母开头或包含字母数字以外字符的原子\",{\"1\":{\"175\":1}}],[\"以空白符分割的单词\",{\"1\":{\"145\":1}}],[\"以非空白符分割的单词\",{\"1\":{\"145\":1}}],[\"以满足更高的性能和更多的使用场景\",{\"1\":{\"135\":1}}],[\"以便故障恢复时使用\",{\"1\":{\"1509\":1}}],[\"以便插件中可以调用默认的消息存储实现\",{\"1\":{\"1424\":1}}],[\"以便构建\",{\"1\":{\"1294\":1}}],[\"以便能先消费到\",{\"1\":{\"1253\":1}}],[\"以便与\",{\"1\":{\"1253\":1}}],[\"以便有足够的重试次数来应对发送失败的场景\",{\"1\":{\"1233\":1}}],[\"以便让其他队列有机会消费\",{\"1\":{\"1230\":1}}],[\"以便\",{\"1\":{\"987\":1}}],[\"以便将消息更快地发给消费者\",{\"1\":{\"681\":1}}],[\"以便你能秒驱一个腐败之水\",{\"1\":{\"467\":1}}],[\"以便海潮涌动的时候中间台子边上有地方战\",{\"1\":{\"466\":1}}],[\"以便验证在大规模数据请求以及各种故障冲击下的韧性表现\",{\"1\":{\"278\":1}}],[\"以便新注册的\",{\"1\":{\"128\":1}}],[\"以便和ascii编码区分开\",{\"1\":{\"27\":1}}],[\"以接收客户输入\",{\"1\":{\"125\":1}}],[\"以在读取数据时调用\",{\"1\":{\"124\":1}}],[\"以换行符来识别每次用户输入\",{\"1\":{\"110\":1}}],[\"以内置的生命周期\",{\"1\":{\"62\":1}}],[\"以及从哪里开始截断\",{\"1\":{\"1510\":1}}],[\"以及从分级存储读数据的\",{\"1\":{\"1387\":1}}],[\"以及它后面一个\",{\"1\":{\"1410\":1}}],[\"以及当前正在写入的索引文件的引用\",{\"1\":{\"1402\":1}}],[\"以及破除一个队列只能保存同一个延迟等级的消息的限制\",{\"1\":{\"1346\":1}}],[\"以及消息生产\",{\"1\":{\"1010\":1}}],[\"以及每个acl配置文件最近一次修改的时间\",{\"1\":{\"999\":1}}],[\"以及上一步返回的\",{\"1\":{\"995\":1}}],[\"以及请求合并成一个\",{\"1\":{\"995\":1}}],[\"以及请求中\",{\"1\":{\"995\":1}}],[\"以及内部处理中都使用了重量级锁synchronized保证线程安全\",{\"1\":{\"725\":1}}],[\"以及在参数中配置镜像队列的具体参数\",{\"1\":{\"652\":1}}],[\"以及多云多活架构等策略的整体导入\",{\"1\":{\"276\":1}}],[\"以及可选的关卡guard1\",{\"1\":{\"194\":1}}],[\"以及shell里的表达式\",{\"1\":{\"180\":1}}],[\"以及case\",{\"1\":{\"180\":1}}],[\"以及\",{\"1\":{\"52\":1}}],[\"创建事务\",{\"0\":{\"1441\":1}}],[\"创建扩展\",{\"1\":{\"1425\":1}}],[\"创建时更新\",{\"1\":{\"1420\":2}}],[\"创建重试主题\",{\"1\":{\"1198\":1}}],[\"创建定时任务\",{\"1\":{\"1191\":1}}],[\"创建定时任务后直接返回\",{\"1\":{\"845\":1,\"860\":1}}],[\"创建拉取消息成功的回调\",{\"1\":{\"1159\":1}}],[\"创建拉取消息接口调用包装类\",{\"1\":{\"1120\":1,\"1122\":1}}],[\"创建客户端实例\",{\"1\":{\"1122\":1}}],[\"创建或获取已经创建的客户端实例\",{\"1\":{\"1120\":1}}],[\"创建或获取最新的索引文件\",{\"1\":{\"789\":1,\"794\":1}}],[\"创建和初始化一些对象\",{\"1\":{\"1120\":1}}],[\"创建和注册broker请求处理类\",{\"1\":{\"1055\":1}}],[\"创建和更新\",{\"1\":{\"191\":1}}],[\"创建主题\",{\"1\":{\"1039\":1}}],[\"创建消息轨迹上下文\",{\"1\":{\"1020\":1}}],[\"创建消息轨迹异步发送者\",{\"1\":{\"1019\":1}}],[\"创建消息key的索引\",{\"1\":{\"794\":1}}],[\"创建请求\",{\"1\":{\"981\":1}}],[\"创建uniquekey的索引\",{\"1\":{\"794\":1}}],[\"创建索引\",{\"1\":{\"794\":1}}],[\"创建新的压缩索引文件\",{\"1\":{\"1435\":1}}],[\"创建新的索引文件\",{\"1\":{\"1434\":1}}],[\"创建新的输入流\",{\"1\":{\"1428\":1}}],[\"创建新的mapedfile时报错或者超时\",{\"1\":{\"1297\":1}}],[\"创建新的\",{\"1\":{\"1144\":1,\"1224\":1,\"1435\":1}}],[\"创建新的文件\",{\"1\":{\"789\":1}}],[\"创建新的队列\",{\"1\":{\"655\":1}}],[\"创建新索引文件时如果创建失败\",{\"1\":{\"789\":1}}],[\"创建结果对象时将\",{\"1\":{\"738\":1}}],[\"创建完的策略如下图显示\",{\"1\":{\"652\":1}}],[\"创建job\",{\"0\":{\"376\":1}}],[\"创建任务实例instanceinfo\",{\"1\":{\"374\":1}}],[\"创建对象\",{\"0\":{\"340\":1}}],[\"创建包装对象\",{\"1\":{\"333\":1}}],[\"创建了数组\",{\"1\":{\"294\":1}}],[\"创建名为\",{\"1\":{\"252\":1}}],[\"创建初始数据库\",{\"0\":{\"252\":1}}],[\"创建进程\",{\"1\":{\"230\":1}}],[\"创建一个周期性定时任务\",{\"1\":{\"840\":1,\"844\":1}}],[\"创建一个线程\",{\"1\":{\"836\":1,\"925\":1}}],[\"创建一个空的request队列\",{\"1\":{\"822\":1}}],[\"创建一个匿名函数并立即执行\",{\"1\":{\"330\":1}}],[\"创建一个并行进程来执行\",{\"1\":{\"229\":1}}],[\"创建一个新的本地内存映射文件\",{\"1\":{\"1417\":1}}],[\"创建一个新的消息对象\",{\"1\":{\"1188\":1,\"1198\":1}}],[\"创建一个新的并发进程来执行\",{\"1\":{\"229\":1}}],[\"创建一个新的线程来处理该连接\",{\"1\":{\"112\":1}}],[\"创建一个新的线程处理\",{\"1\":{\"69\":1}}],[\"创建一个新文件\",{\"1\":{\"52\":1}}],[\"创建列表\",{\"1\":{\"182\":1}}],[\"创建单线程的主\",{\"1\":{\"134\":1}}],[\"创建\",{\"0\":{\"793\":1},\"1\":{\"132\":1,\"134\":1,\"191\":2,\"192\":1,\"218\":1,\"637\":4,\"638\":2,\"741\":1,\"789\":1,\"880\":1,\"945\":1,\"952\":1,\"1047\":1,\"1144\":1,\"1224\":1}}],[\"创建namedquery\",{\"1\":{\"92\":1}}],[\"创建file对象本身不涉及io操作\",{\"1\":{\"52\":1}}],[\"绝对路径可以表示成\",{\"1\":{\"52\":1}}],[\"绝对路径\",{\"1\":{\"52\":1}}],[\">6379\",{\"1\":{\"1079\":2}}],[\">30931\",{\"1\":{\"1079\":2}}],[\">30929\",{\"1\":{\"1079\":2}}],[\">8080\",{\"1\":{\"1077\":2}}],[\">8330\",{\"1\":{\"421\":1}}],[\">9876\",{\"1\":{\"1075\":2,\"1079\":4}}],[\">q4的顺序流动\",{\"1\":{\"690\":1}}],[\">q3\",{\"1\":{\"690\":1}}],[\">q2\",{\"1\":{\"690\":1}}],[\">ram这样的过程\",{\"1\":{\"690\":1}}],[\">a形成的循环链表\",{\"1\":{\"674\":1}}],[\">delta\",{\"1\":{\"690\":1}}],[\">decode\",{\"1\":{\"116\":1}}],[\">disk\",{\"1\":{\"690\":1}}],[\">d\",{\"1\":{\"674\":1}}],[\">c\",{\"1\":{\"674\":1}}],[\">b\",{\"1\":{\"674\":1}}],[\">>\",{\"1\":{\"476\":1,\"949\":1,\"966\":1,\"1212\":1,\"1346\":1,\"1514\":1}}],[\">>>\",{\"1\":{\"70\":1}}],[\">49980\",{\"1\":{\"421\":1}}],[\">26656\",{\"1\":{\"421\":1}}],[\">10912\",{\"1\":{\"1075\":2}}],[\">10911\",{\"1\":{\"1075\":4}}],[\">10909\",{\"1\":{\"1075\":4}}],[\">156000\",{\"1\":{\"421\":1}}],[\">140000\",{\"1\":{\"421\":2}}],[\">132000\",{\"1\":{\"421\":1}}],[\">try\",{\"1\":{\"194\":1}}],[\">=\",{\"1\":{\"184\":1,\"253\":1,\"306\":2,\"476\":1,\"769\":1,\"771\":2,\"794\":1,\"797\":2,\"825\":1,\"870\":2,\"882\":1,\"1144\":1,\"1173\":2,\"1195\":3,\"1198\":2,\"1224\":1,\"1230\":1,\"1267\":2,\"1270\":1,\"1277\":1,\"1308\":1,\"1332\":1,\"1371\":1,\"1372\":1,\"1425\":1,\"1427\":1,\"1434\":1,\"1468\":1,\"1503\":1,\"1519\":2}}],[\">i\",{\"1\":{\"182\":2}}],[\">normal\",{\"1\":{\"161\":1}}],[\">send\",{\"1\":{\"116\":1}}],[\">encode\",{\"1\":{\"116\":1}}],[\">process\",{\"1\":{\"116\":1}}],[\">\",{\"1\":{\"48\":2,\"64\":1,\"101\":1,\"102\":1,\"103\":1,\"106\":1,\"121\":2,\"123\":1,\"125\":2,\"133\":3,\"155\":1,\"161\":1,\"176\":1,\"180\":7,\"181\":9,\"182\":2,\"183\":6,\"184\":3,\"186\":9,\"187\":7,\"188\":7,\"189\":5,\"191\":4,\"192\":1,\"193\":11,\"194\":6,\"195\":3,\"196\":7,\"200\":1,\"213\":2,\"217\":6,\"224\":1,\"229\":2,\"230\":5,\"231\":1,\"232\":3,\"234\":2,\"235\":5,\"241\":1,\"248\":2,\"253\":23,\"256\":2,\"259\":1,\"261\":5,\"273\":2,\"340\":6,\"341\":3,\"396\":1,\"476\":2,\"500\":3,\"524\":1,\"528\":1,\"613\":2,\"614\":3,\"619\":3,\"624\":15,\"625\":10,\"626\":10,\"627\":5,\"690\":1,\"712\":1,\"722\":1,\"737\":8,\"738\":1,\"742\":2,\"762\":1,\"769\":1,\"771\":1,\"793\":1,\"794\":3,\"796\":1,\"797\":4,\"815\":1,\"824\":1,\"825\":1,\"839\":1,\"840\":1,\"843\":3,\"860\":3,\"870\":3,\"871\":3,\"872\":1,\"894\":1,\"949\":1,\"950\":1,\"968\":1,\"970\":1,\"972\":1,\"994\":2,\"997\":1,\"998\":2,\"999\":1,\"1020\":1,\"1021\":2,\"1050\":1,\"1052\":1,\"1170\":4,\"1174\":2,\"1175\":1,\"1198\":2,\"1229\":1,\"1230\":1,\"1248\":1,\"1269\":1,\"1270\":2,\"1275\":1,\"1276\":2,\"1277\":2,\"1278\":6,\"1279\":1,\"1308\":5,\"1368\":1,\"1370\":1,\"1371\":1,\"1372\":3,\"1373\":1,\"1390\":2,\"1427\":7,\"1428\":2,\"1430\":4,\"1431\":2,\"1432\":6,\"1435\":2,\"1436\":12,\"1443\":1,\"1462\":3,\"1464\":2,\"1467\":1,\"1468\":4,\"1495\":2,\"1496\":1,\"1497\":3,\"1499\":3,\"1516\":1,\"1519\":9,\"1520\":1,\"1521\":7}}],[\"xrunjdwp\",{\"1\":{\"1080\":1}}],[\"xdebug\",{\"1\":{\"1080\":1}}],[\"xdg\",{\"1\":{\"165\":2}}],[\"xs\",{\"1\":{\"566\":1}}],[\"xyrxqstasoclbthcolf1m6vkacec2wx452201ath8bytfulwqwsbhnptelxjqipdnpawqyzafrwdvizpenljd27balovqbiketcfiomhjms0hycdravufwzyqhdjxlzsuhlhxzozskptsunwtixsojdpkgknrtbtzbpskpnrzaltztlkzowkenqtm7aqqzfrck6lsahnjvbkhr8zhz3f70rbowfp7fxmlkkbvkp1sreijblduz8khsjghfgenw6sgiv5kygyhomakxn3hsmnldn1ma\",{\"1\":{\"455\":1}}],[\"xyz\",{\"1\":{\"23\":5}}],[\"xkpnqgjqai5qg\",{\"1\":{\"455\":1}}],[\"x8xbb4xuhhunuylqvxv0fuioe\",{\"1\":{\"443\":1}}],[\"x8\",{\"1\":{\"429\":1}}],[\"x初始化为1\",{\"1\":{\"311\":1}}],[\"xiaoming\",{\"1\":{\"299\":11,\"337\":2,\"339\":6,\"341\":3}}],[\"xor\",{\"1\":{\"206\":1}}],[\"xx1\",{\"1\":{\"1006\":1}}],[\"xxx\",{\"1\":{\"845\":2,\"1008\":4,\"1173\":2,\"1297\":2,\"1308\":10}}],[\"xxxx\",{\"1\":{\"836\":1,\"964\":1}}],[\"xxx的消息给客户端\",{\"1\":{\"369\":1}}],[\"xxx的方式来输出模块变量\",{\"1\":{\"365\":1}}],[\"xxx创建websocket连接时\",{\"1\":{\"368\":1}}],[\"xxl\",{\"1\":{\"273\":2,\"371\":1}}],[\"xx\",{\"1\":{\"192\":1,\"1006\":3,\"1080\":5}}],[\"x2\",{\"1\":{\"191\":3}}],[\"x1\",{\"1\":{\"191\":3}}],[\"x||x<\",{\"1\":{\"184\":1}}],[\"x|y\",{\"1\":{\"177\":1}}],[\"x=1\",{\"1\":{\"316\":1}}],[\"x=\",{\"1\":{\"178\":1}}],[\"x和y都是未绑定变量\",{\"1\":{\"177\":1}}],[\"xmn128m\",{\"1\":{\"1080\":4}}],[\"xmx128m\",{\"1\":{\"1080\":4}}],[\"xmx8g\",{\"1\":{\"1080\":1}}],[\"xms128m\",{\"1\":{\"1080\":4}}],[\"xms8g\",{\"1\":{\"1080\":1}}],[\"xmlhttprequest\",{\"0\":{\"348\":1},\"1\":{\"348\":1}}],[\"xml\",{\"1\":{\"347\":1,\"960\":1}}],[\"xml中声明它\",{\"1\":{\"64\":1}}],[\"xm\",{\"1\":{\"171\":1}}],[\"x\",{\"0\":{\"184\":2,\"641\":1,\"642\":1,\"773\":1},\"1\":{\"48\":1,\"147\":2,\"162\":6,\"171\":5,\"173\":4,\"176\":1,\"178\":5,\"181\":10,\"184\":12,\"186\":4,\"187\":3,\"188\":4,\"191\":1,\"193\":6,\"194\":6,\"196\":9,\"213\":2,\"217\":4,\"235\":2,\"253\":12,\"298\":3,\"303\":8,\"306\":8,\"311\":2,\"316\":4,\"323\":3,\"324\":2,\"325\":2,\"329\":2,\"330\":3,\"331\":10,\"332\":2,\"491\":1,\"500\":3,\"502\":2,\"504\":4,\"514\":5,\"515\":4,\"518\":3,\"531\":2,\"536\":1,\"537\":2,\"550\":4,\"551\":2,\"552\":3,\"555\":4,\"556\":2,\"558\":13,\"562\":1,\"566\":4,\"577\":3,\"642\":1,\"660\":1,\"665\":2,\"711\":1,\"712\":1,\"714\":1,\"715\":1,\"718\":1,\"733\":2,\"920\":3,\"1074\":13,\"1294\":3,\"1295\":1,\"1307\":3,\"1310\":2,\"1338\":5,\"1339\":1,\"1341\":1,\"1342\":2,\"1378\":1,\"1439\":1,\"1440\":1,\"1441\":1,\"1497\":6,\"1499\":4,\"1519\":8}}],[\"擦拭法\",{\"0\":{\"48\":1},\"1\":{\"48\":1}}],[\"静态成员是只能通过类本身使用的成员\",{\"1\":{\"577\":1}}],[\"静态成员\",{\"0\":{\"577\":1}}],[\"静态方法\",{\"1\":{\"47\":1}}],[\"静态内部类不再依附于outer的实例\",{\"1\":{\"22\":1}}],[\"泛型类\",{\"0\":{\"578\":1}}],[\"泛型写法readonly<t>\",{\"1\":{\"528\":1}}],[\"泛型\",{\"0\":{\"45\":1}}],[\"涉及到的类\",{\"0\":{\"808\":1}}],[\"涉及到异步代码\",{\"1\":{\"359\":1}}],[\"涉及到\",{\"1\":{\"44\":1}}],[\"一段时间\",{\"1\":{\"1519\":1}}],[\"一段时间后分级存储目录中的文件\",{\"1\":{\"1383\":1}}],[\"一段时间后进行重新消费\",{\"1\":{\"1179\":1}}],[\"一类是保存\",{\"1\":{\"1395\":1}}],[\"一定程度上避免\",{\"1\":{\"1364\":1}}],[\"一定时间内未执行刷盘\",{\"1\":{\"769\":1}}],[\"一同构成一个链表\",{\"1\":{\"1351\":1}}],[\"一层过滤\",{\"1\":{\"1333\":1}}],[\"一层层查找上级目录\",{\"1\":{\"599\":1}}],[\"一批结束之后再操作下一批\",{\"1\":{\"1356\":1}}],[\"一批消息的结果\",{\"1\":{\"1271\":1}}],[\"一批消息消费时加锁\",{\"1\":{\"1215\":1}}],[\"一批任务只需要一次\",{\"1\":{\"916\":1}}],[\"一批任务\",{\"1\":{\"915\":1}}],[\"一\",{\"1\":{\"1105\":1}}],[\"一组在\",{\"1\":{\"1102\":1}}],[\"一一对应\",{\"1\":{\"1036\":1}}],[\"一方面\",{\"1\":{\"874\":1}}],[\"一条消息在\",{\"1\":{\"1367\":1}}],[\"一条消息\",{\"1\":{\"1260\":1,\"1273\":1}}],[\"一条消息没有被成功消费\",{\"1\":{\"1003\":1}}],[\"一条消息从生产到消费\",{\"1\":{\"669\":1}}],[\"一条消息从生产者到消费\",{\"1\":{\"668\":1}}],[\"一条将要投递到多个队列的消息\",{\"1\":{\"700\":1}}],[\"一些动态配置\",{\"1\":{\"1420\":1}}],[\"一些秒杀场景可能慢\",{\"1\":{\"927\":1}}],[\"一些特性的基础\",{\"1\":{\"923\":1}}],[\"一些虚机的时间与现实时间不一致\",{\"1\":{\"866\":1}}],[\"一些规则\",{\"1\":{\"698\":1}}],[\"一些实现类\",{\"1\":{\"54\":1}}],[\"一起表示某一时刻需要投递的定时消息集合\",{\"1\":{\"1352\":1}}],[\"一起发送\",{\"1\":{\"1028\":1}}],[\"一起\",{\"1\":{\"425\":1}}],[\"一起使用\",{\"1\":{\"118\":2}}],[\"一星\",{\"1\":{\"422\":1}}],[\"一次拉取任务执行完\",{\"1\":{\"1168\":1}}],[\"一次发送一批消息轨迹数据\",{\"1\":{\"1021\":1}}],[\"一次发送最大消息大小\",{\"1\":{\"1021\":1}}],[\"一次发送的请求包含数据条数\",{\"1\":{\"1021\":1}}],[\"一次\",{\"1\":{\"931\":1,\"1510\":1}}],[\"一次最多删除10个文件\",{\"1\":{\"870\":1}}],[\"一次最多删除\",{\"1\":{\"870\":1}}],[\"一次最多删\",{\"1\":{\"866\":1}}],[\"一次是生产者对应的\",{\"1\":{\"668\":1}}],[\"一次是生产者发送的\",{\"1\":{\"668\":1}}],[\"一次是队列的\",{\"1\":{\"668\":1}}],[\"一次是队列\",{\"1\":{\"668\":1}}],[\"一次用万灵来奶\",{\"1\":{\"431\":1}}],[\"一次性用多个林莽卫士可以作为一个治疗手牌\",{\"1\":{\"413\":1}}],[\"一次请求的处理过程是由多个不同的线程完成的\",{\"1\":{\"116\":1}}],[\"一开始的默认低水位为\",{\"1\":{\"1299\":1}}],[\"一开始\",{\"1\":{\"399\":1}}],[\"一开始和朋友打\",{\"1\":{\"399\":1}}],[\"一直从上一条消息末尾位置开始循环扫描新消息\",{\"1\":{\"762\":1}}],[\"一直不断\",{\"1\":{\"492\":1}}],[\"一直变豹子过去踩然后变人解除定身被吸进去\",{\"1\":{\"399\":1}}],[\"一直沿着函数调用链向上抛出\",{\"1\":{\"358\":1}}],[\"一致性哈希就是为了解决这个问题\",{\"1\":{\"708\":1}}],[\"一致性哈希交换器的原理与普通的一致性哈希实现类似\",{\"1\":{\"716\":1}}],[\"一致性哈希交换器根据\",{\"1\":{\"708\":1}}],[\"一致性哈希交换器\",{\"0\":{\"705\":1},\"1\":{\"718\":1}}],[\"一致性哈希环\",{\"1\":{\"396\":1}}],[\"一致性哈希\",{\"0\":{\"382\":1,\"708\":1},\"1\":{\"608\":1,\"716\":1,\"1138\":1}}],[\"一改其他调度框架基于数据库锁的策略\",{\"1\":{\"371\":1}}],[\"一种\",{\"1\":{\"1364\":1}}],[\"一种称为\",{\"1\":{\"597\":1}}],[\"一种是配置文件的内容发生变化\",{\"1\":{\"999\":1}}],[\"一种是二进制数据\",{\"1\":{\"368\":1}}],[\"一种是文本\",{\"1\":{\"368\":1}}],[\"一种是将现有键k的值更新为新值v\",{\"1\":{\"192\":1}}],[\"一种好的做法是在发送消息到别的进程之前先把它打印出来\",{\"1\":{\"258\":1}}],[\"一旦消息发送失败\",{\"1\":{\"1234\":1}}],[\"一旦文件内容改变\",{\"1\":{\"997\":1}}],[\"一旦有新消息到达\",{\"1\":{\"803\":1}}],[\"一旦使用者耗尽了仅存在于主服务器上的消息\",{\"1\":{\"658\":1}}],[\"一旦发现新的索引项\",{\"1\":{\"836\":1}}],[\"一旦发现存在类型断言\",{\"1\":{\"589\":1}}],[\"一旦发现匹配\",{\"1\":{\"187\":1}}],[\"一旦server的master节点异常\",{\"1\":{\"380\":1}}],[\"一旦接收到任务就开始分配资源\",{\"1\":{\"372\":1}}],[\"一旦接受到连接事件\",{\"1\":{\"122\":1}}],[\"一旦调用了\",{\"1\":{\"261\":1}}],[\"一系列命令的集合\",{\"1\":{\"159\":1}}],[\"一文聊透\",{\"1\":{\"136\":1}}],[\"一个优化方案是直接将半消息的事务执行结果覆写到半消息本身\",{\"1\":{\"1453\":1}}],[\"一个简单的元数据文件示例如下\",{\"1\":{\"1420\":1}}],[\"一个消息的物理偏移量\",{\"1\":{\"1351\":1}}],[\"一个消息文件中可能包含延迟\",{\"1\":{\"928\":1}}],[\"一个消费者实例即是一个消费者进程\",{\"1\":{\"1089\":1}}],[\"一个工作线程负责消费客户端实例提交过来的轨迹数据\",{\"1\":{\"1015\":1}}],[\"一个每\",{\"1\":{\"947\":2,\"961\":2}}],[\"一个队列只支持一个延迟时间\",{\"1\":{\"922\":1}}],[\"一个队列主队列和一个队列镜像\",{\"1\":{\"657\":1}}],[\"一个文件写满了就开启一个新文件顺序读写下去\",{\"1\":{\"876\":1}}],[\"一个负责对\",{\"1\":{\"672\":1}}],[\"一个负责消息广播的\",{\"1\":{\"672\":1}}],[\"一个进程的flow状态会导致它的上游进程进入flow状态\",{\"1\":{\"622\":1}}],[\"一个对象\",{\"1\":{\"606\":1}}],[\"一个很强大的主动饰品\",{\"1\":{\"482\":1}}],[\"一个websocket连接就建立成功\",{\"1\":{\"368\":1}}],[\"一个ftp服务器和一个\",{\"1\":{\"262\":1}}],[\"一个\",{\"1\":{\"253\":1,\"361\":1,\"747\":1,\"906\":1,\"931\":1,\"971\":1,\"1065\":1,\"1203\":1,\"1291\":1}}],[\"一个tab管理所有html文件\",{\"1\":{\"154\":1}}],[\"一个缓冲区可以分割成多个窗口\",{\"1\":{\"153\":1}}],[\"一个socket就是由ip地址和端口号\",{\"1\":{\"68\":1}}],[\"一个应用程序通过一个socket来建立一个远程连接\",{\"1\":{\"68\":1}}],[\"一个迭代也是测试数据统计的最小单元\",{\"1\":{\"4\":1}}],[\"一般是已经\",{\"1\":{\"1519\":1}}],[\"一般由\",{\"1\":{\"1415\":1}}],[\"一般只有最后一个索引文件处于该状态\",{\"1\":{\"1394\":1,\"1412\":1}}],[\"一般无需开启\",{\"1\":{\"1234\":1}}],[\"一般不能删除数据\",{\"1\":{\"1322\":1}}],[\"一般不会用到该消费者的重平衡机制\",{\"1\":{\"1136\":1}}],[\"一般不用\",{\"1\":{\"44\":1}}],[\"一般情况下\",{\"1\":{\"564\":1}}],[\"一般情况下奶德点了变形大师天赋\",{\"1\":{\"492\":1}}],[\"一般大米里用最多的是洞穴住民的挚爱\",{\"1\":{\"485\":1}}],[\"一般让一个远程帮你消\",{\"1\":{\"438\":1}}],[\"一般在\",{\"1\":{\"413\":1}}],[\"一般常量用全部大写的名称\",{\"1\":{\"315\":1}}],[\"一般创建进程时\",{\"1\":{\"234\":1}}],[\"一般来说消息消费很快\",{\"1\":{\"1253\":1}}],[\"一般来说一个启动的客户端进程只有一个\",{\"1\":{\"1036\":1}}],[\"一般来说用户会有自己的角色\",{\"1\":{\"976\":1}}],[\"一般来说\",{\"1\":{\"135\":1,\"924\":1}}],[\"一般的\",{\"1\":{\"111\":1}}],[\"一般很少用到\",{\"1\":{\"44\":1}}],[\"参照\",{\"1\":{\"927\":1}}],[\"参数指定的时间\",{\"1\":{\"1257\":1}}],[\"参数指定消息的路由属性名称\",{\"1\":{\"715\":1}}],[\"参数无效\",{\"1\":{\"1238\":1}}],[\"参数来设置开启\",{\"1\":{\"1041\":1}}],[\"参数来声明需要作为路由键的\",{\"1\":{\"714\":1}}],[\"参数进行配置\",{\"1\":{\"833\":1}}],[\"参数表示是否定时刷盘\",{\"1\":{\"735\":1}}],[\"参数还是改为\",{\"1\":{\"733\":1}}],[\"参数解释\",{\"1\":{\"652\":1}}],[\"参数解构\",{\"0\":{\"538\":1}}],[\"参数为元组\",{\"1\":{\"539\":1}}],[\"参数为数组\",{\"1\":{\"539\":1}}],[\"参数\",{\"0\":{\"539\":1,\"602\":1,\"603\":1},\"1\":{\"1255\":1}}],[\"参数默认值\",{\"0\":{\"537\":1}}],[\"参数灵活\",{\"1\":{\"341\":1}}],[\"参数和默认值\",{\"1\":{\"43\":1}}],[\"参考的前\",{\"1\":{\"403\":1}}],[\"参考文献\",{\"0\":{\"381\":1}}],[\"参考\",{\"1\":{\"272\":1,\"423\":1,\"429\":1,\"436\":1,\"443\":1}}],[\"参考资料\",{\"0\":{\"15\":1,\"136\":1,\"397\":1,\"628\":1,\"640\":1,\"679\":1,\"691\":1,\"717\":1,\"743\":1,\"774\":1,\"798\":1,\"829\":1,\"884\":1,\"938\":1,\"974\":1,\"1001\":1,\"1022\":1,\"1057\":1,\"1105\":1,\"1281\":1,\"1298\":1,\"1334\":1,\"1375\":1,\"1437\":1,\"1473\":1,\"1504\":1,\"1522\":1,\"1527\":1,\"1537\":1}}],[\"默认超时时间为\",{\"1\":{\"1519\":1}}],[\"默认等于事务超时时间\",{\"1\":{\"1468\":1}}],[\"默认只有\",{\"1\":{\"1453\":1,\"1468\":1}}],[\"默认存储有两种类型\",{\"1\":{\"1398\":1}}],[\"默认时间为\",{\"1\":{\"1343\":1}}],[\"默认也未开启\",{\"1\":{\"1325\":1}}],[\"默认3s\",{\"1\":{\"1277\":1}}],[\"默认值\",{\"1\":{\"1234\":1,\"1251\":1,\"1382\":1}}],[\"默认提供了重试消费和死信队列功能\",{\"1\":{\"1180\":1}}],[\"默认一条\",{\"1\":{\"1206\":1}}],[\"默认一批只包含一条消息\",{\"1\":{\"1179\":1}}],[\"默认一比一\",{\"1\":{\"135\":1}}],[\"默认启用长轮询\",{\"1\":{\"1173\":1}}],[\"默认采用\",{\"1\":{\"1097\":1}}],[\"默认使用集群消费模式\",{\"1\":{\"1091\":1}}],[\"默认有\",{\"1\":{\"1055\":1,\"1104\":1,\"1155\":1,\"1165\":1}}],[\"默认有18\",{\"1\":{\"834\":1}}],[\"默认消息体超过\",{\"1\":{\"1053\":1}}],[\"默认不启用\",{\"1\":{\"1052\":1}}],[\"默认机制下\",{\"1\":{\"1041\":1}}],[\"默认机制\",{\"1\":{\"1041\":1,\"1052\":1}}],[\"默认都为\",{\"1\":{\"1040\":1}}],[\"默认会重试\",{\"1\":{\"1032\":1}}],[\"默认长度为\",{\"1\":{\"906\":1}}],[\"默认长度是\",{\"1\":{\"741\":1}}],[\"默认关闭\",{\"1\":{\"883\":1}}],[\"默认10s\",{\"1\":{\"1277\":1}}],[\"默认100ms\",{\"1\":{\"870\":1}}],[\"默认120s\",{\"1\":{\"870\":1}}],[\"默认72h\",{\"1\":{\"870\":1}}],[\"默认过期时间\",{\"1\":{\"870\":1}}],[\"默认支持的延迟等级为\",{\"1\":{\"833\":1}}],[\"默认true\",{\"1\":{\"819\":1,\"1173\":1}}],[\"默认push模式固定15s\",{\"1\":{\"805\":1}}],[\"默认60s\",{\"1\":{\"769\":1}}],[\"默认2\",{\"1\":{\"758\":1}}],[\"默认200\",{\"1\":{\"619\":1}}],[\"默认为消费线程池设置\",{\"1\":{\"1179\":1}}],[\"默认为可用内存的\",{\"1\":{\"1065\":1}}],[\"默认为关闭状态\",{\"1\":{\"1041\":1}}],[\"默认为75\",{\"1\":{\"870\":1}}],[\"默认为2次\",{\"1\":{\"1050\":1}}],[\"默认为2分钟\",{\"1\":{\"870\":1}}],[\"默认为2\",{\"1\":{\"769\":1}}],[\"默认为\",{\"1\":{\"758\":1,\"805\":2,\"812\":1,\"1145\":1,\"1194\":1,\"1195\":1,\"1197\":1,\"1230\":1,\"1241\":1,\"1367\":1,\"1370\":1,\"1403\":1,\"1405\":1,\"1467\":1}}],[\"默认每批\",{\"1\":{\"1188\":1}}],[\"默认每30s从nameserver获取topic路由信息\",{\"1\":{\"1048\":1}}],[\"默认每\",{\"1\":{\"735\":1,\"1467\":1}}],[\"默认400\",{\"1\":{\"619\":1}}],[\"默认是\",{\"1\":{\"350\":1,\"866\":1,\"1390\":1}}],[\"默认是第一个\",{\"1\":{\"248\":1}}],[\"默认情况下\",{\"1\":{\"350\":1,\"420\":1,\"678\":1,\"735\":1,\"883\":1,\"1012\":1}}],[\"默认返回\",{\"1\":{\"341\":1}}],[\"默认default\",{\"1\":{\"163\":1}}],[\"默认复制和剪切的内容放到了\",{\"1\":{\"157\":1}}],[\"默认配置下\",{\"1\":{\"95\":1}}],[\"默认的消息发送超时时间为\",{\"1\":{\"1233\":1}}],[\"默认的consumergroup权限\",{\"1\":{\"983\":1}}],[\"默认的topic权限\",{\"1\":{\"983\":1}}],[\"默认的配置文件名\",{\"1\":{\"983\":1}}],[\"默认的配置下每条消息都会打出一条日志\",{\"1\":{\"722\":1}}],[\"默认的一致性哈希方法\",{\"1\":{\"396\":1}}],[\"默认的事务传播级别是required\",{\"1\":{\"87\":1}}],[\"默认的当前目录\",{\"1\":{\"23\":1}}],[\"默认\",{\"1\":{\"43\":1,\"60\":1,\"688\":1,\"712\":1,\"758\":1,\"804\":1,\"866\":1,\"870\":1,\"916\":1,\"1021\":3,\"1039\":1,\"1042\":1,\"1067\":1,\"1091\":1,\"1138\":1,\"1187\":1,\"1212\":1,\"1215\":1,\"1217\":1,\"1218\":1,\"1230\":1,\"1253\":1,\"1297\":1,\"1346\":1,\"1367\":1,\"1382\":1,\"1388\":2,\"1414\":1,\"1425\":1,\"1434\":1,\"1436\":1,\"1453\":1,\"1467\":1,\"1468\":1,\"1519\":1}}],[\"仅在距离上次发送至少过了1秒后才发送commit请求\",{\"1\":{\"1519\":1}}],[\"仅在\",{\"1\":{\"1514\":2}}],[\"仅作为代理转发\",{\"1\":{\"1482\":1}}],[\"仅支持单个队列中的消息的顺序消费\",{\"1\":{\"1203\":1}}],[\"仅支持固定等级的延迟消息\",{\"1\":{\"922\":1}}],[\"仅有集群模式能使用顺序消费\",{\"1\":{\"1102\":1}}],[\"仅定义了\",{\"1\":{\"995\":1}}],[\"仅仅根据扫描到的消息创建分级存储对应的队列目录和空的分级存储\",{\"1\":{\"1403\":1}}],[\"仅仅是一个队列\",{\"1\":{\"1293\":1}}],[\"仅仅是遍历客户端上注册的所有消费者\",{\"1\":{\"1137\":1}}],[\"仅仅为了启动\",{\"1\":{\"1080\":1}}],[\"仅仅处理其他模块的请求\",{\"1\":{\"943\":1}}],[\"仅仅用于消息的查询\",{\"1\":{\"868\":1}}],[\"仅仅让新的消息复制到这个重新上线的镜像队列\",{\"1\":{\"693\":1}}],[\"仅通过观察系统应对故障的表现是有局限的\",{\"1\":{\"277\":1}}],[\"仅此而已\",{\"1\":{\"173\":1}}],[\"仅\",{\"1\":{\"43\":1,\"1322\":1}}],[\"仅编译期\",{\"1\":{\"43\":1}}],[\"构造返回体返回\",{\"1\":{\"1520\":1}}],[\"构造客户端响应的\",{\"1\":{\"1507\":1}}],[\"构造心跳包\",{\"1\":{\"1499\":1}}],[\"构造事务半消息并存储\",{\"1\":{\"1462\":2}}],[\"构造分级存储插件\",{\"0\":{\"1425\":1}}],[\"构造分级存储\",{\"1\":{\"1403\":1}}],[\"构造出\",{\"1\":{\"1372\":1}}],[\"构造布隆过滤器\",{\"1\":{\"1331\":1}}],[\"构造成二进制数组\",{\"1\":{\"1308\":1,\"1315\":1,\"1323\":1}}],[\"构造成一个消息\",{\"1\":{\"1259\":1}}],[\"构造新的消息\",{\"1\":{\"1280\":1}}],[\"构造锁定消息队列请求\",{\"1\":{\"1226\":1}}],[\"构造多个消费请求提交消费\",{\"1\":{\"1194\":1}}],[\"构造消费请求\",{\"1\":{\"1194\":1}}],[\"构造消息拉取系统标记\",{\"1\":{\"1159\":1}}],[\"构造一个新的消息\",{\"1\":{\"1374\":1}}],[\"构造一个用于存到磁盘的消息\",{\"1\":{\"1260\":1}}],[\"构造一个消息队列的消费进度更新请求\",{\"1\":{\"1191\":1}}],[\"构造一个pullrequest并交给pullrequestholdservice线程\",{\"1\":{\"1173\":1}}],[\"构造查询请求\",{\"1\":{\"1160\":1}}],[\"构造存储用的message对象\",{\"1\":{\"1056\":1}}],[\"构造response\",{\"1\":{\"1056\":1}}],[\"构造的回调方法中指定\",{\"1\":{\"1040\":1}}],[\"构造\",{\"1\":{\"1037\":1,\"1259\":1,\"1271\":1,\"1273\":1,\"1319\":1,\"1434\":1,\"1519\":3}}],[\"构造统一的请求体\",{\"1\":{\"970\":1}}],[\"构造了processormaptaskrequest请求发送给tasktracker\",{\"1\":{\"378\":1}}],[\"构造函数的类型写法\",{\"1\":{\"548\":1}}],[\"构造函数\",{\"0\":{\"341\":1,\"548\":1},\"1\":{\"548\":1,\"558\":2,\"1420\":1}}],[\"构造响应\",{\"1\":{\"125\":1}}],[\"构造用户输入内容字符串\",{\"1\":{\"125\":1}}],[\"构造方法的参数名只要有private\",{\"1\":{\"576\":1}}],[\"构造方法的参数x前面有public修饰符\",{\"1\":{\"576\":1}}],[\"构造方法注入\",{\"1\":{\"81\":1}}],[\"构造方法\",{\"1\":{\"43\":1}}],[\"构成的索引文件表\",{\"1\":{\"1402\":1}}],[\"构成\",{\"1\":{\"62\":1,\"372\":1}}],[\"构建投票请求\",{\"1\":{\"1502\":1}}],[\"构建的队列除了它本身的读写队列以外\",{\"1\":{\"1291\":1}}],[\"构建的项目已经写好了\",{\"1\":{\"9\":1}}],[\"构建轻量级队列\",{\"1\":{\"1291\":1}}],[\"构建主题配置\",{\"1\":{\"1198\":1}}],[\"构建过滤数据\",{\"1\":{\"1173\":1}}],[\"构建消息过滤器\",{\"1\":{\"1173\":1}}],[\"构建消息发送请求\",{\"1\":{\"1053\":1}}],[\"构建消息发送请求包\",{\"1\":{\"1053\":1}}],[\"构建消息请求\",{\"1\":{\"1042\":1}}],[\"构建消息的dispatchrequest\",{\"1\":{\"762\":1}}],[\"构建消费后的轨迹数据\",{\"1\":{\"1020\":1}}],[\"构建消费者\",{\"1\":{\"1007\":1}}],[\"构建生产者\",{\"1\":{\"1006\":1}}],[\"构建定时消息底座\",{\"1\":{\"923\":1}}],[\"构建索引\",{\"1\":{\"794\":1,\"1517\":1}}],[\"构建而成\",{\"1\":{\"786\":1}}],[\"构建该消息的索引\",{\"1\":{\"750\":1,\"781\":1}}],[\"构建\",{\"0\":{\"750\":1,\"756\":1,\"761\":1},\"1\":{\"1427\":1}}],[\"构建流程\",{\"0\":{\"61\":1}}],[\"构建项目\",{\"1\":{\"7\":2}}],[\"字节\",{\"1\":{\"390\":1,\"1314\":1}}],[\"字典查找\",{\"1\":{\"162\":1}}],[\"字段名\",{\"1\":{\"1508\":1}}],[\"字段都是对应的处理类在处理业务逻辑时需要临时用到的\",{\"1\":{\"1508\":1}}],[\"字段都是固定的\",{\"1\":{\"890\":1}}],[\"字段\",{\"1\":{\"43\":1,\"191\":1,\"737\":1,\"983\":1,\"1036\":2}}],[\"字符数组\",{\"1\":{\"900\":1}}],[\"字符的整数代码\",{\"1\":{\"215\":1}}],[\"字符串列表中包含消息的\",{\"1\":{\"1319\":1}}],[\"字符串的\",{\"1\":{\"1319\":1}}],[\"字符串的方法\",{\"1\":{\"894\":1}}],[\"字符串计算出的\",{\"1\":{\"1314\":1}}],[\"字符串换成\",{\"1\":{\"900\":1}}],[\"字符串操作的\",{\"1\":{\"900\":1}}],[\"字符串采用这种格式存储\",{\"1\":{\"740\":1}}],[\"字符串或者\",{\"1\":{\"606\":1}}],[\"字符串枚举的所有成员值\",{\"1\":{\"585\":1}}],[\"字符串连接\",{\"1\":{\"297\":1}}],[\"字符串`\",{\"1\":{\"297\":1}}],[\"字符串\",{\"0\":{\"178\":1,\"297\":1,\"585\":1},\"1\":{\"294\":1,\"606\":1,\"983\":2,\"1319\":1,\"1407\":1}}],[\"字符串和编码\",{\"0\":{\"27\":1}}],[\"字符\",{\"1\":{\"27\":2}}],[\"动态配置\",{\"0\":{\"1523\":1}}],[\"动态类型与静态类型\",{\"0\":{\"495\":1}}],[\"动态注册最新worker列表\",{\"1\":{\"378\":1}}],[\"动态代码载入\",{\"0\":{\"207\":1}}],[\"动态代理\",{\"0\":{\"41\":1}}],[\"动态加载\",{\"0\":{\"37\":1}}],[\"方案比较复杂\",{\"1\":{\"916\":1}}],[\"方括号读取成员类型\",{\"1\":{\"527\":1}}],[\"方便\",{\"1\":{\"1521\":1}}],[\"方便一次性把这个\",{\"1\":{\"1418\":1}}],[\"方便后续消息的过滤匹配\",{\"1\":{\"1321\":1}}],[\"方便后续调用网络请求\",{\"1\":{\"1047\":1}}],[\"方便运维\",{\"1\":{\"371\":1}}],[\"方便使用者进行对比分析\",{\"1\":{\"283\":1}}],[\"方式调用直接申请堆外内存中\",{\"1\":{\"883\":1}}],[\"方式创建依赖实例的缺点\",{\"1\":{\"81\":1}}],[\"方式构建项目\",{\"1\":{\"8\":1}}],[\"方法主逻辑从两个请求等待表中获取等待的请求进行处理\",{\"1\":{\"1511\":1}}],[\"方法接收\",{\"1\":{\"1511\":1}}],[\"方法接收一个普通消息\",{\"1\":{\"1449\":1}}],[\"方法从队列拉取任务进行处理\",{\"1\":{\"1520\":1}}],[\"方法从存储中查询出该半消息\",{\"1\":{\"1453\":1}}],[\"方法从分级存储查询消息\",{\"1\":{\"1409\":1}}],[\"方法逻辑如下\",{\"1\":{\"1421\":1}}],[\"方法逻辑里面包含了大量字符串和\",{\"1\":{\"899\":1}}],[\"方法恢复本地存储\",{\"1\":{\"1421\":1}}],[\"方法异步查询索引项\",{\"1\":{\"1415\":1}}],[\"方法写入\",{\"1\":{\"1414\":1}}],[\"方法进行日志推送\",{\"1\":{\"1510\":1}}],[\"方法进行事务消息的回查\",{\"1\":{\"1453\":1}}],[\"方法进行写入\",{\"1\":{\"1414\":1}}],[\"方法进行读取\",{\"1\":{\"1410\":1}}],[\"方法进行分发\",{\"1\":{\"1294\":1}}],[\"方法需要判断走预读缓存读消息还是直接走分级存储\",{\"1\":{\"1407\":1}}],[\"方法判断该消息\",{\"1\":{\"1319\":1}}],[\"方法设置\",{\"1\":{\"1306\":1}}],[\"方法设置消费者允许存在的的最大未ack消息数量\",{\"1\":{\"616\":1}}],[\"方法如其名\",{\"1\":{\"1263\":1}}],[\"方法每\",{\"1\":{\"1262\":1}}],[\"方法执行实际提交操作\",{\"1\":{\"1428\":1}}],[\"方法执行消息数据的获取\",{\"1\":{\"1403\":1}}],[\"方法执行消费逻辑\",{\"1\":{\"1188\":1}}],[\"方法执行重试\",{\"1\":{\"861\":1}}],[\"方法不断从阻塞队列中读取拉取请求来执行拉取\",{\"1\":{\"1158\":1}}],[\"方法为\",{\"1\":{\"1134\":1}}],[\"方法注册消息队列变更时的回调方法\",{\"1\":{\"1117\":1}}],[\"方法注入依赖\",{\"1\":{\"81\":1}}],[\"方法处理事务执行结果请求\",{\"1\":{\"1451\":1}}],[\"方法处理生产者发来的普通消息和事务消息\",{\"1\":{\"1450\":1}}],[\"方法处理客户端的消息拉取请求\",{\"1\":{\"1163\":1}}],[\"方法处理发送请求\",{\"1\":{\"1056\":1}}],[\"方法处理该请求\",{\"1\":{\"812\":1}}],[\"方法完成验证账号是否有该资源访问权限的逻辑\",{\"1\":{\"1000\":1}}],[\"方法完成加载指定acl配置文件内容的功能\",{\"1\":{\"998\":1}}],[\"方法重新加载该配置文件\",{\"1\":{\"999\":1}}],[\"方法重新加载所有配置文件\",{\"1\":{\"999\":1}}],[\"方法重新加载所有配置文件的数据\",{\"1\":{\"999\":1}}],[\"方法重新尝试发起pull消息的rpc请求\",{\"1\":{\"815\":1}}],[\"方法用来监控\",{\"1\":{\"999\":1}}],[\"方法用于查找符合条件的第一个元素\",{\"1\":{\"327\":1}}],[\"方法使用\",{\"1\":{\"995\":1}}],[\"方法发送事务消息\",{\"1\":{\"1449\":1}}],[\"方法发送一次心跳包\",{\"1\":{\"952\":1}}],[\"方法发送响应\",{\"1\":{\"125\":1}}],[\"方法消费\",{\"1\":{\"916\":1}}],[\"方法开销非常大\",{\"1\":{\"908\":1}}],[\"方法内部大量使用反射来设置属性\",{\"1\":{\"890\":1}}],[\"方法内部也是使用\",{\"1\":{\"741\":1}}],[\"方法在一个异常流程中被调用\",{\"1\":{\"888\":1}}],[\"方法即实现文件预热的功能\",{\"1\":{\"882\":1}}],[\"方法即消息投递的逻辑\",{\"1\":{\"857\":1}}],[\"方法调用了\",{\"1\":{\"870\":1}}],[\"方法调用\",{\"1\":{\"869\":1}}],[\"方法保存消息\",{\"1\":{\"837\":1}}],[\"方法会作为\",{\"1\":{\"1509\":1}}],[\"方法会找到要读取的\",{\"1\":{\"1410\":1}}],[\"方法会尝试从\",{\"1\":{\"1262\":1}}],[\"方法会遍历消费进度缓存表\",{\"1\":{\"1191\":1}}],[\"方法会报错\",{\"1\":{\"1122\":1}}],[\"方法会获取\",{\"1\":{\"998\":1}}],[\"方法会将上一步返回的\",{\"1\":{\"995\":1}}],[\"方法会在\",{\"1\":{\"816\":1}}],[\"方法会返回一个socket对象\",{\"1\":{\"112\":1}}],[\"方法检查匹配的情况并对达到唤醒时间还没有成功匹配的消息重试\",{\"1\":{\"1263\":1}}],[\"方法检查是否有请求需要唤醒\",{\"1\":{\"815\":1}}],[\"方法检查挂起的请求是否有消息可以拉取\",{\"1\":{\"812\":1}}],[\"方法加了锁\",{\"1\":{\"815\":1}}],[\"方法唤醒拉取请求\",{\"1\":{\"812\":1}}],[\"方法唤醒主从复制线程\",{\"1\":{\"726\":1}}],[\"方法循环等待轮询时间\",{\"1\":{\"812\":1}}],[\"方法将\",{\"1\":{\"1262\":1}}],[\"方法将消费进度更新到其内存缓存表\",{\"1\":{\"1191\":1}}],[\"方法将拉取到消息的处理队列提交消费服务处理\",{\"1\":{\"1188\":1}}],[\"方法将该请求挂起\",{\"1\":{\"812\":1}}],[\"方法将刚刚保存的消息存入\",{\"1\":{\"756\":1}}],[\"方法创建了\",{\"1\":{\"900\":1}}],[\"方法创建或者获取最新的索引文件\",{\"1\":{\"789\":1}}],[\"方法创建索引\",{\"1\":{\"789\":1,\"794\":1}}],[\"方法查找所有\",{\"1\":{\"789\":1}}],[\"方法的逻辑如下\",{\"1\":{\"1484\":1}}],[\"方法的结果\",{\"0\":{\"895\":1}}],[\"方法的类是\",{\"1\":{\"869\":1}}],[\"方法的效率很低\",{\"1\":{\"742\":1}}],[\"方法的\",{\"1\":{\"741\":1}}],[\"方法替换原来的\",{\"1\":{\"741\":1}}],[\"方法被调用\",{\"1\":{\"738\":1}}],[\"方法抽到了加锁之前\",{\"1\":{\"737\":1}}],[\"方法是其主逻辑循环\",{\"1\":{\"1512\":1}}],[\"方法是\",{\"1\":{\"1300\":1}}],[\"方法是该处理线程的入口\",{\"1\":{\"1263\":1}}],[\"方法是锁内操作\",{\"1\":{\"737\":1}}],[\"方法是在数组类型前面加上readonly关键字\",{\"1\":{\"524\":1}}],[\"方法做了以下这些事\",{\"1\":{\"729\":1}}],[\"方法等待\",{\"1\":{\"726\":1}}],[\"方法中先清空所有分级存储文件\",{\"1\":{\"1421\":1}}],[\"方法中循环发送执行发送逻辑\",{\"1\":{\"1040\":1}}],[\"方法中执行\",{\"1\":{\"1021\":1}}],[\"方法中就包含了权限验证的逻辑\",{\"1\":{\"990\":1}}],[\"方法中启动\",{\"1\":{\"952\":1}}],[\"方法中根据消费\",{\"1\":{\"916\":1}}],[\"方法中后面的逻辑\",{\"1\":{\"903\":1}}],[\"方法中会有反向\",{\"1\":{\"888\":1}}],[\"方法中会进行提醒\",{\"1\":{\"814\":1}}],[\"方法中也会查询\",{\"1\":{\"812\":1}}],[\"方法中已经生成并保存\",{\"1\":{\"765\":1}}],[\"方法中\",{\"1\":{\"765\":1,\"806\":1,\"820\":1,\"991\":1,\"1000\":1,\"1014\":2,\"1510\":1}}],[\"方法中使用\",{\"1\":{\"737\":1}}],[\"方法中的操作移动到了锁外\",{\"1\":{\"737\":1}}],[\"方法中只做了添加数据到列表的操作\",{\"1\":{\"725\":1}}],[\"方法中将读取到的字符转换成大写\",{\"1\":{\"125\":1}}],[\"方法就是模拟\",{\"1\":{\"600\":1}}],[\"方法可以直接跳过等待\",{\"1\":{\"1140\":1}}],[\"方法可以实现\",{\"1\":{\"880\":1}}],[\"方法可以传入一个原型对象\",{\"1\":{\"339\":1}}],[\"方法可以判断数组的所有元素是否满足测试条件\",{\"1\":{\"327\":1}}],[\"方法可以判断一个向上转型是否可以实现\",{\"1\":{\"40\":1}}],[\"方法指定\",{\"1\":{\"318\":1}}],[\"方法或\",{\"1\":{\"272\":1}}],[\"方法返回该\",{\"1\":{\"124\":1}}],[\"方法来检查本地事务执行的状态\",{\"1\":{\"1442\":1}}],[\"方法来通知上层应用\",{\"1\":{\"1300\":1}}],[\"方法来设置感兴趣的事件\",{\"1\":{\"124\":1}}],[\"方法来强制输出缓冲区\",{\"1\":{\"54\":1}}],[\"方法阻塞等待新的监听的事件\",{\"1\":{\"122\":1}}],[\"方法遍历和访问这些通道\",{\"1\":{\"118\":1}}],[\"方法之后调用\",{\"1\":{\"118\":1}}],[\"方法配置为非阻塞模式\",{\"1\":{\"118\":1}}],[\"方法都是阻塞式的\",{\"1\":{\"114\":1}}],[\"方法引用\",{\"0\":{\"76\":1}}],[\"方法参数\",{\"1\":{\"43\":1}}],[\"方法\",{\"0\":{\"317\":1,\"599\":1,\"600\":1,\"731\":1,\"1134\":1},\"1\":{\"43\":1,\"122\":2,\"124\":2,\"127\":1,\"128\":2,\"299\":1,\"333\":1,\"597\":4,\"606\":2,\"624\":1,\"731\":1,\"741\":1,\"756\":1,\"761\":1,\"809\":1,\"812\":3,\"814\":2,\"815\":1,\"820\":1,\"827\":1,\"869\":1,\"870\":2,\"882\":1,\"888\":1,\"894\":1,\"900\":1,\"902\":1,\"947\":1,\"954\":1,\"956\":1,\"957\":2,\"960\":1,\"961\":1,\"973\":2,\"981\":1,\"988\":1,\"990\":1,\"991\":1,\"994\":2,\"998\":1,\"1040\":1,\"1055\":1,\"1119\":6,\"1136\":1,\"1137\":1,\"1159\":1,\"1168\":1,\"1188\":2,\"1191\":3,\"1248\":1,\"1294\":1,\"1321\":1,\"1323\":2,\"1324\":1,\"1347\":2,\"1398\":1,\"1401\":2,\"1403\":2,\"1405\":2,\"1408\":1,\"1409\":1,\"1420\":2,\"1421\":2,\"1442\":1,\"1449\":2,\"1451\":1,\"1453\":1,\"1509\":1,\"1510\":3,\"1511\":1}}],[\"程序虚拟页面直接映射到页缓存上\",{\"1\":{\"880\":1}}],[\"程序退出时强制刷盘\",{\"1\":{\"769\":1}}],[\"程序是如何使用时间的\",{\"1\":{\"255\":1}}],[\"程序接口\",{\"0\":{\"242\":1}}],[\"程序在\",{\"1\":{\"237\":1}}],[\"程序执行一条接收语句时才会读取邮箱\",{\"1\":{\"229\":1}}],[\"程序执行到\",{\"1\":{\"37\":1}}],[\"程序对此一般无能为力\",{\"1\":{\"33\":1}}],[\"时激活\",{\"1\":{\"1520\":1}}],[\"时也会向\",{\"1\":{\"1510\":1}}],[\"时读分级存储\",{\"1\":{\"1382\":1}}],[\"时计算的\",{\"1\":{\"1333\":1}}],[\"时才使用布隆过滤器进行第一层过滤\",{\"1\":{\"1322\":1}}],[\"时提交的写请求将被放入队列\",{\"1\":{\"1299\":1}}],[\"时使用\",{\"1\":{\"1294\":1}}],[\"时就直接走分级存储\",{\"1\":{\"1404\":1}}],[\"时就会有严重的数据放大\",{\"1\":{\"1290\":1}}],[\"时就已经计算出来并保存到\",{\"1\":{\"765\":1}}],[\"时可以进行通配\",{\"1\":{\"1290\":1}}],[\"时可以用下面的语法\",{\"1\":{\"211\":1}}],[\"时要通过句柄来定位到它\",{\"1\":{\"1251\":1}}],[\"时指定消息类型\",{\"1\":{\"1441\":1}}],[\"时指定消息发送成功后的回调函数\",{\"1\":{\"1027\":1}}],[\"时指向一个特定的数据库\",{\"1\":{\"252\":1}}],[\"时原先用的是\",{\"1\":{\"912\":1}}],[\"时删\",{\"1\":{\"866\":1}}],[\"时被写入\",{\"1\":{\"827\":1}}],[\"时序图\",{\"0\":{\"812\":1}}],[\"时用的是\",{\"1\":{\"802\":1}}],[\"时会上锁\",{\"1\":{\"877\":1}}],[\"时会强制删除文件\",{\"1\":{\"864\":1}}],[\"时会触发垃圾回收\",{\"1\":{\"688\":1}}],[\"时会伴随地板\",{\"1\":{\"465\":1}}],[\"时怎么处理呢\",{\"1\":{\"593\":1}}],[\"时尽量不要站到靠近中间台子的地方\",{\"1\":{\"466\":1}}],[\"时捡炸弹\",{\"1\":{\"447\":1}}],[\"时他们最好能够都站在百花齐放圈里\",{\"1\":{\"416\":1}}],[\"时候玩的奶德重新出发\",{\"1\":{\"399\":1}}],[\"时间除以精度\",{\"1\":{\"1367\":1}}],[\"时间然后重新投递\",{\"1\":{\"1360\":1,\"1374\":1}}],[\"时间为选举超时\",{\"1\":{\"1478\":1}}],[\"时间为\",{\"1\":{\"1325\":1}}],[\"时间小于阈值\",{\"1\":{\"1277\":1}}],[\"时间戳\",{\"1\":{\"1017\":1,\"1367\":2,\"1394\":2,\"1412\":2,\"1417\":2}}],[\"时间超限\",{\"1\":{\"972\":1}}],[\"时间复杂度\",{\"1\":{\"931\":1}}],[\"时间\",{\"1\":{\"866\":1,\"914\":1,\"920\":2,\"1270\":1,\"1271\":1,\"1279\":1,\"1325\":1}}],[\"时间到达\",{\"1\":{\"866\":1}}],[\"时间够可以拆开打\",{\"1\":{\"455\":1}}],[\"时间来分配手牌\",{\"1\":{\"446\":1}}],[\"时间相对充裕一点\",{\"1\":{\"422\":1}}],[\"时间比较灵活\",{\"1\":{\"399\":1}}],[\"时间轮的槽位设计如下\",{\"1\":{\"1351\":1}}],[\"时间轮的每个槽位表示这一时刻需要投递的所有定时消息\",{\"1\":{\"1351\":1}}],[\"时间轮的实现在timewheel包下\",{\"1\":{\"379\":1}}],[\"时间轮是对时刻表的抽象\",{\"1\":{\"1351\":1}}],[\"时间轮看似一个完美的解决方案\",{\"1\":{\"931\":1}}],[\"时间轮保存在内存里面\",{\"1\":{\"931\":1}}],[\"时间轮常被用做定时器的实现\",{\"1\":{\"931\":1}}],[\"时间轮\",{\"0\":{\"379\":1,\"1351\":1},\"1\":{\"931\":1,\"1367\":1}}],[\"时的重平衡情况\",{\"1\":{\"1255\":1}}],[\"时的路由场景\",{\"1\":{\"716\":1}}],[\"时的\",{\"1\":{\"285\":1}}],[\"时为每个\",{\"1\":{\"135\":1}}],[\"时表示结束\",{\"1\":{\"125\":1}}],[\"时\",{\"0\":{\"901\":1,\"910\":1},\"1\":{\"37\":1,\"85\":1,\"131\":1,\"207\":1,\"285\":1,\"413\":1,\"432\":1,\"619\":1,\"625\":1,\"633\":1,\"701\":1,\"716\":1,\"747\":1,\"756\":1,\"840\":1,\"866\":3,\"1039\":2,\"1126\":1,\"1136\":1,\"1249\":1,\"1315\":1,\"1427\":1}}],[\"全都要\",{\"1\":{\"925\":1}}],[\"全程一般可以打\",{\"1\":{\"403\":1}}],[\"全程站桩\",{\"1\":{\"403\":1}}],[\"全部写入成功\",{\"1\":{\"1371\":1}}],[\"全部客户端id\",{\"1\":{\"1267\":1}}],[\"全部消息队列\",{\"1\":{\"1267\":1}}],[\"全部任务扫描完毕后等待一会\",{\"1\":{\"858\":1}}],[\"全部安装包列表\",{\"1\":{\"645\":1}}],[\"全部副属性\",{\"1\":{\"485\":1}}],[\"全部挪给输出\",{\"1\":{\"403\":1}}],[\"全部加载到内存\",{\"1\":{\"37\":1}}],[\"全限了\",{\"1\":{\"399\":1}}],[\"全限就差不多了\",{\"1\":{\"399\":1}}],[\"全能合剂也是一个选择\",{\"1\":{\"485\":1}}],[\"全能\",{\"1\":{\"162\":1,\"421\":2,\"476\":1}}],[\"全局ip白名单\",{\"1\":{\"983\":1}}],[\"全局流控时\",{\"1\":{\"613\":1}}],[\"全局流控\",{\"0\":{\"613\":1}}],[\"全局\",{\"1\":{\"364\":1}}],[\"全局模块和当前模块下查找hello\",{\"1\":{\"363\":1}}],[\"全局启用严格模式\",{\"1\":{\"360\":1}}],[\"全局作用域\",{\"0\":{\"312\":1}}],[\"全局范围执行\",{\"1\":{\"150\":1}}],[\"全局替换\",{\"1\":{\"143\":1}}],[\"全球统一码联盟发布了unicode编码\",{\"1\":{\"27\":1}}],[\"将向从节点发送\",{\"1\":{\"1519\":1}}],[\"将状态变为\",{\"1\":{\"1519\":1}}],[\"将发送\",{\"1\":{\"1519\":1}}],[\"将发生改变\",{\"1\":{\"385\":1}}],[\"将当前节点的投票轮次和日志序号强制覆盖写入到数据缓冲区中\",{\"1\":{\"1517\":1}}],[\"将当前生产者加入\",{\"1\":{\"1047\":1}}],[\"将条目追加到本地存储\",{\"1\":{\"1516\":1}}],[\"将请求放入待处理队列\",{\"1\":{\"1520\":1}}],[\"将请求中的\",{\"1\":{\"1511\":1}}],[\"将请求分发到具体的\",{\"1\":{\"764\":1}}],[\"将请求分发到\",{\"1\":{\"764\":1}}],[\"将推送的\",{\"1\":{\"1510\":1}}],[\"将日志转发到\",{\"1\":{\"1519\":3}}],[\"将日志从\",{\"0\":{\"1519\":1}}],[\"将日志复制追加到\",{\"1\":{\"1510\":1}}],[\"将日志推送到\",{\"1\":{\"1509\":1}}],[\"将日志追加到\",{\"1\":{\"1509\":1}}],[\"将构造\",{\"1\":{\"1509\":1}}],[\"将扫描到的请求对应的消息写入\",{\"1\":{\"1507\":1}}],[\"将角色转换为\",{\"1\":{\"1484\":1}}],[\"将本地事务执行状态发送到\",{\"1\":{\"1472\":1}}],[\"将半消息重新保存\",{\"1\":{\"1453\":1}}],[\"将半消息复原\",{\"1\":{\"1446\":1}}],[\"将事务半消息重新放入到事务半消息队列中\",{\"1\":{\"1468\":1}}],[\"将事务半消息发送到特殊的内部\",{\"1\":{\"1468\":1}}],[\"将事务半消息存储在事务消息操作\",{\"1\":{\"1464\":2}}],[\"将事务半消息存储在事务消息\",{\"1\":{\"1451\":1}}],[\"将事务半消息复原或丢弃\",{\"1\":{\"1451\":1}}],[\"将复原后的消息保存到存储\",{\"1\":{\"1451\":1}}],[\"将它包装成事务半消息发送给\",{\"1\":{\"1449\":1}}],[\"将它作为重新消费的消息存入消息存储\",{\"1\":{\"1188\":1}}],[\"将二阶段提交和本地事务绑定\",{\"1\":{\"1439\":1}}],[\"将二进制消息解析成对象\",{\"1\":{\"1329\":1}}],[\"将上传后的所以你文件封装成\",{\"1\":{\"1435\":1}}],[\"将上报的路由信息调用\",{\"1\":{\"953\":1}}],[\"将读到的消息放入缓存\",{\"1\":{\"1431\":1}}],[\"将结果返回\",{\"1\":{\"1409\":1}}],[\"将结果图形化\",{\"0\":{\"14\":1}}],[\"将返回结果解析成消息对象\",{\"1\":{\"1408\":1}}],[\"将返回体写入channel\",{\"1\":{\"820\":1}}],[\"将默认存储作为一个引用传入插件存储\",{\"1\":{\"1398\":1}}],[\"将默认值改为\",{\"1\":{\"1299\":1}}],[\"将内容重新排列后写入新的索引文件\",{\"1\":{\"1394\":1}}],[\"将内存中的消费进度持久化到磁盘\",{\"1\":{\"1182\":1}}],[\"将内存中所有队列的消费偏移量提交到\",{\"1\":{\"1103\":1}}],[\"将大部分冷数据卸载到更便宜的存储系统中后\",{\"1\":{\"1385\":1}}],[\"将查出的原始消息放入\",{\"1\":{\"1373\":1}}],[\"将查到的消息投递到\",{\"1\":{\"1348\":1,\"1357\":1}}],[\"将写入位置覆盖写入到数据缓冲区\",{\"1\":{\"1517\":1}}],[\"将写入\",{\"1\":{\"1371\":1}}],[\"将定时时间作为\",{\"1\":{\"1364\":1}}],[\"将定时消息索引写入\",{\"1\":{\"1368\":2}}],[\"将定时消息放入时间轮和\",{\"0\":{\"1356\":1}}],[\"将定时消息\",{\"1\":{\"1348\":1}}],[\"将定时消息的保存和投递分为多个步骤\",{\"1\":{\"1348\":1}}],[\"将定时消息直接投递到\",{\"1\":{\"930\":1}}],[\"将从该\",{\"1\":{\"1362\":1}}],[\"将时间轮槽位对应的定时消息请求从时间轮和\",{\"1\":{\"1358\":1}}],[\"将时间信息符合搜索条件的索引加入到结果列表中\",{\"1\":{\"797\":1}}],[\"将保存的过程分为扫描和入轮两个步骤\",{\"1\":{\"1354\":1}}],[\"将保存关于broker集群的整个路由信息和用于客户端查询的队列信息\",{\"1\":{\"941\":1}}],[\"将每个节点都拆分成不同的任务\",{\"1\":{\"1353\":1}}],[\"将每次运算结果保存到一个二进制数组的一个下标中\",{\"1\":{\"1322\":1}}],[\"将每次负载的结果加入最终结果\",{\"1\":{\"1267\":1}}],[\"将每次用户输入的字符都转成大写\",{\"1\":{\"110\":1}}],[\"将延迟消息先不存到真正的\",{\"1\":{\"1342\":1}}],[\"将延迟等级设置为\",{\"1\":{\"1198\":1}}],[\"将所有节点的水位倒序排序\",{\"1\":{\"1512\":1}}],[\"将所有消息加入结果\",{\"1\":{\"1432\":1}}],[\"将所有消费者名称经过\",{\"1\":{\"1323\":1}}],[\"将所有索引文件的查询结果放入结果列表\",{\"1\":{\"1415\":1}}],[\"将所有没有被过滤的消费者名称计算出的位映射\",{\"1\":{\"1332\":1}}],[\"将所有的节点形成一个循环链表\",{\"1\":{\"673\":1}}],[\"将再次开始返回\",{\"1\":{\"1299\":1}}],[\"将开始返回\",{\"1\":{\"1299\":1}}],[\"将已经匹配或存盘的\",{\"1\":{\"1262\":1}}],[\"将不符合内存中存活条件的\",{\"1\":{\"1262\":1}}],[\"将需要\",{\"1\":{\"1258\":1}}],[\"将这部分代码重构\",{\"1\":{\"1294\":1}}],[\"将这批消息的构建的\",{\"1\":{\"1253\":1}}],[\"将这两个文件合并\",{\"1\":{\"688\":1}}],[\"将锁定成功队列的处理队列加锁\",{\"1\":{\"1226\":1}}],[\"将真正的\",{\"1\":{\"1188\":1}}],[\"将重新消费次数\",{\"1\":{\"1180\":1}}],[\"将重平衡后丢弃的消费队列移除\",{\"1\":{\"1134\":1,\"1225\":1}}],[\"将由一个消费线程池并行处理消费逻辑\",{\"1\":{\"1179\":1}}],[\"将相应置为空\",{\"1\":{\"1173\":1}}],[\"将要拉取的偏移量与上述偏移量比较\",{\"1\":{\"1164\":1}}],[\"将订阅关系发送给\",{\"1\":{\"1145\":1}}],[\"将新插入的\",{\"1\":{\"1393\":1}}],[\"将新的队列订阅关系通过发送心跳请求上报给\",{\"1\":{\"1137\":1}}],[\"将新的消息自动发送给用户进行消费\",{\"1\":{\"801\":1}}],[\"将新建的\",{\"1\":{\"1137\":1,\"1144\":1,\"1224\":1}}],[\"将拉取到的一批消息提交给并发消费服务\",{\"1\":{\"1179\":1}}],[\"将拉取到的消息放入结果容器中\",{\"1\":{\"1270\":1}}],[\"将拉取到的消息放入处理队列\",{\"1\":{\"1104\":2,\"1165\":1,\"1219\":1}}],[\"将拉取到的消息提交到consumemessageservice中供消费者消费\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"将拉取到的消息存入processqueue\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"将拉取到的消息解码\",{\"1\":{\"1165\":1}}],[\"将拉取请求放入拉取线程继续下次拉取\",{\"1\":{\"1165\":1}}],[\"将拉取请求\",{\"1\":{\"1119\":1}}],[\"将具体的方法实现都实现在\",{\"1\":{\"1118\":1}}],[\"将处理队列让消息消费服务处理\",{\"1\":{\"1165\":1}}],[\"将处理队列和\",{\"1\":{\"1104\":1}}],[\"将处理后的响应写回客户端\",{\"1\":{\"135\":1}}],[\"将处理后的内容写回给客户端\",{\"1\":{\"113\":1}}],[\"将队列偏移量作为属性存入消息\",{\"1\":{\"1296\":1}}],[\"将队列和消费者客户端id\",{\"1\":{\"1266\":1}}],[\"将队列按数量平均分配给多个消费者\",{\"1\":{\"1097\":1}}],[\"将队列索引持久化\",{\"1\":{\"621\":1}}],[\"将镜像名称改成\",{\"1\":{\"1077\":1}}],[\"将进入死信队列\",{\"1\":{\"1043\":1}}],[\"将生产者的\",{\"1\":{\"1235\":1}}],[\"将生产消息的请求发往\",{\"1\":{\"1042\":1}}],[\"将生成的签名添加到请求的扩展属性中\",{\"1\":{\"995\":1}}],[\"将一批数据封装成一个发送请求\",{\"1\":{\"1021\":1}}],[\"将一个\",{\"1\":{\"1028\":1}}],[\"将一个索引文件强制刷盘\",{\"1\":{\"789\":1}}],[\"将一个consumequeue数据写盘\",{\"1\":{\"765\":1}}],[\"将一个队列拆分成多个队列也可以摆脱单队列的性能瓶颈\",{\"1\":{\"707\":1}}],[\"将一个队列的压力分散到多个集群\",{\"1\":{\"631\":1}}],[\"将消费组对应的位数据\",{\"1\":{\"1332\":1}}],[\"将消费者和消息存储的\",{\"1\":{\"1291\":1}}],[\"将消费者注册到客户端实例对象\",{\"1\":{\"1120\":1}}],[\"将消费进度保存到缓存表\",{\"1\":{\"1201\":1}}],[\"将消费进度缓存\",{\"1\":{\"1201\":1}}],[\"将消费进度管理器的内存缓存持久化到磁盘\",{\"1\":{\"1183\":1}}],[\"将消费失败的消息发回\",{\"1\":{\"1195\":1}}],[\"将消费请求提交给消费线程池\",{\"1\":{\"1188\":1}}],[\"将消费到的消息构建\",{\"1\":{\"1020\":1}}],[\"将消息追加到分级存储\",{\"1\":{\"1427\":1}}],[\"将消息追加到\",{\"1\":{\"1427\":1}}],[\"将消息写入到\",{\"1\":{\"1427\":1}}],[\"将消息数据\",{\"1\":{\"1403\":1}}],[\"将消息投递到\",{\"1\":{\"1360\":1}}],[\"将消息分发到一个或多个\",{\"1\":{\"1290\":1}}],[\"将消息分批打包成消费请求\",{\"1\":{\"1188\":1}}],[\"将消息主动\",{\"1\":{\"1245\":1}}],[\"将消息从\",{\"1\":{\"1360\":1}}],[\"将消息从处理队列移除\",{\"1\":{\"1218\":1}}],[\"将消息从拉取到的响应中解码出来\",{\"1\":{\"1149\":1}}],[\"将消息的真正\",{\"1\":{\"1198\":1}}],[\"将消息发送回重试\",{\"1\":{\"1197\":1}}],[\"将消息发送到\",{\"1\":{\"621\":1,\"729\":1}}],[\"将消息发回\",{\"0\":{\"1197\":1},\"1\":{\"1195\":2,\"1218\":1}}],[\"将消息发回给\",{\"1\":{\"1187\":1}}],[\"将消息字节数组解码成消息列表并填充msgfoundlist\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"将消息放入返回体\",{\"1\":{\"1163\":1}}],[\"将消息队列和消费者\",{\"1\":{\"1137\":1}}],[\"将消息偏移量持久化到磁盘\",{\"1\":{\"1103\":1}}],[\"将消息根据\",{\"1\":{\"1065\":1}}],[\"将消息保存到存储\",{\"1\":{\"1056\":1}}],[\"将消息同步到备\",{\"1\":{\"1033\":1}}],[\"将消息轨迹数据分类\",{\"1\":{\"1021\":1}}],[\"将消息轨迹交给异步发送者处理\",{\"1\":{\"1020\":1}}],[\"将消息定时设置为当前时间往后的\",{\"1\":{\"920\":1}}],[\"将消息存储起来\",{\"1\":{\"1024\":1}}],[\"将消息存储\",{\"1\":{\"839\":1}}],[\"将消息封装成dispatchrequest\",{\"1\":{\"762\":1}}],[\"将消息真正存入\",{\"1\":{\"756\":1}}],[\"将轨迹数据打包后提交给发送线程池\",{\"1\":{\"1015\":1}}],[\"将会把它放入\",{\"1\":{\"1251\":1}}],[\"将会调用\",{\"1\":{\"1191\":1}}],[\"将会保存到一个\",{\"1\":{\"1014\":1}}],[\"将会按照请求处理的先后顺序分为\",{\"1\":{\"986\":1}}],[\"将数据条目追加到\",{\"1\":{\"1517\":1}}],[\"将数据放入上传缓冲区\",{\"1\":{\"1403\":1}}],[\"将数据采集到该上下文中\",{\"1\":{\"1014\":1}}],[\"将数组\",{\"1\":{\"529\":1}}],[\"将配置文件中的全局白名单\",{\"1\":{\"998\":1}}],[\"将配置加载到内存\",{\"1\":{\"996\":1}}],[\"将注册一个\",{\"1\":{\"990\":1}}],[\"将权限配置信息加载到内存\",{\"1\":{\"990\":1,\"996\":1}}],[\"将用户的\",{\"1\":{\"1120\":1,\"1122\":1}}],[\"将用户名和签名加入请求\",{\"1\":{\"981\":1}}],[\"将用户输入转换成大写\",{\"1\":{\"125\":1}}],[\"将用户输入放入\",{\"1\":{\"125\":1}}],[\"将路由信息保存在内存中\",{\"1\":{\"945\":1}}],[\"将该请求放入待处理队列\",{\"1\":{\"1507\":1}}],[\"将该拉取请求放入拉取队列末尾\",{\"1\":{\"1207\":1}}],[\"将该消息队列从rebalanceimpl的处理队列中移除\",{\"1\":{\"1175\":1}}],[\"将该\",{\"1\":{\"931\":1,\"954\":1}}],[\"将静态变量位图复制到局部变量中\",{\"1\":{\"904\":1}}],[\"将位图从堆复制到栈里\",{\"1\":{\"904\":1}}],[\"将正则匹配简化成位图查表的过程\",{\"1\":{\"904\":1}}],[\"将常用的指令解码方法抽象出来\",{\"1\":{\"891\":1}}],[\"将于\",{\"1\":{\"889\":1,\"892\":1}}],[\"将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销\",{\"1\":{\"880\":1}}],[\"将磁盘上的物理文件直接映射到用户态的内存地址中\",{\"1\":{\"880\":1}}],[\"将删除的文件从mappedfiles中移除\",{\"1\":{\"870\":1}}],[\"将设置磁盘为不可写\",{\"1\":{\"866\":1}}],[\"将对应延迟等级的消息异步投递时\",{\"1\":{\"855\":1}}],[\"将多次重平衡分配到的队列都分给这个消费者消费\",{\"1\":{\"1255\":1}}],[\"将多个消息包装成一个批量消息\",{\"1\":{\"1028\":1}}],[\"将多个集群的消息收集到一个集群\",{\"1\":{\"631\":1}}],[\"将多延迟等级延迟消息扫描和投递的任务从单线程执行改为多线程\",{\"0\":{\"852\":1}}],[\"将多延迟等级下同时发送延迟消息的性能提升了\",{\"1\":{\"850\":1}}],[\"将到期的消息重新投递\",{\"1\":{\"840\":1,\"844\":1}}],[\"将原始定时消息的\",{\"1\":{\"1374\":1}}],[\"将原始消息的\",{\"1\":{\"1360\":1,\"1463\":1}}],[\"将原来的\",{\"1\":{\"900\":1}}],[\"将原消息的\",{\"1\":{\"839\":1,\"843\":1,\"1463\":1}}],[\"将原先用来启动周期性任务的\",{\"1\":{\"850\":1}}],[\"将原先\",{\"1\":{\"737\":1}}],[\"将hold的拉取请求唤醒\",{\"1\":{\"820\":1}}],[\"将索引文件状态置为\",{\"1\":{\"1434\":1}}],[\"将索引文件按照创建时间升序排序\",{\"1\":{\"793\":1}}],[\"将索引项和\",{\"1\":{\"1417\":1}}],[\"将索引项先写入本地的一个临时索引文件中\",{\"1\":{\"1414\":1}}],[\"将索引项的三个参数写入\",{\"1\":{\"765\":1}}],[\"将索引存入文件\",{\"1\":{\"797\":1}}],[\"将dispatchrequest分发给所有注册dispatcherlist中的commitlogdispatcher进行处理\",{\"1\":{\"762\":1}}],[\"将准备工作放到锁外\",{\"0\":{\"737\":1}}],[\"将文件直接映射到用户内存\",{\"1\":{\"728\":1}}],[\"将持久化和非持久化的消息在磁盘中区分存储\",{\"1\":{\"687\":1}}],[\"将丢弃其所有数据\",{\"1\":{\"678\":1}}],[\"将阻塞这个进程的下游进程id\",{\"1\":{\"625\":1}}],[\"将readonly\",{\"1\":{\"524\":1}}],[\"将typeof运算符移植到了类型运算\",{\"1\":{\"518\":1}}],[\"将值分成8种类型\",{\"1\":{\"506\":1}}],[\"将你造成的部分伤害和治疗转换为对你的治疗\",{\"1\":{\"477\":1}}],[\"将烈火斩引向最近的墙\",{\"1\":{\"472\":1}}],[\"将塞纳里奥结界用在蛛纱强袭\",{\"1\":{\"425\":1}}],[\"将愈合的持续治疗效果施加到所有生命绽放的目标\",{\"1\":{\"405\":1}}],[\"将节点相对均匀地放置在一个环上\",{\"1\":{\"387\":1}}],[\"将宏应用到多行\",{\"0\":{\"161\":1}}],[\"将窗口分组\",{\"0\":{\"154\":1}}],[\"将服务端\",{\"1\":{\"133\":1}}],[\"将客户端信息上报给\",{\"1\":{\"1122\":1}}],[\"将客户端信息\",{\"1\":{\"945\":1}}],[\"将客户端\",{\"1\":{\"133\":1,\"135\":1}}],[\"将客户端的信息\",{\"1\":{\"1120\":1}}],[\"将客户端的\",{\"1\":{\"124\":1,\"995\":1}}],[\"将客户端连接分发给\",{\"1\":{\"123\":1}}],[\"将客户端输入的内容转换为大写\",{\"1\":{\"113\":1}}],[\"将提示发送给客户端\",{\"1\":{\"123\":1}}],[\"将就绪通道的注册键关联的处理器取出并执行\",{\"1\":{\"122\":1}}],[\"将\",{\"0\":{\"913\":1},\"1\":{\"121\":1,\"125\":3,\"339\":1,\"341\":1,\"384\":1,\"387\":1,\"591\":1,\"711\":1,\"736\":2,\"738\":1,\"765\":1,\"814\":1,\"815\":1,\"857\":1,\"915\":1,\"951\":1,\"957\":1,\"971\":1,\"973\":1,\"984\":1,\"985\":1,\"995\":1,\"998\":1,\"1037\":1,\"1097\":1,\"1126\":1,\"1249\":1,\"1253\":2,\"1259\":1,\"1271\":2,\"1275\":2,\"1277\":1,\"1321\":1,\"1323\":1,\"1367\":1,\"1371\":2,\"1428\":1,\"1435\":1,\"1509\":1,\"1510\":1,\"1516\":1,\"1518\":1,\"1519\":4,\"1520\":2}}],[\"将监听到的\",{\"1\":{\"119\":1}}],[\"将其传入\",{\"1\":{\"1318\":1}}],[\"将其放入消费队列的扩展存储中\",{\"1\":{\"1315\":1}}],[\"将其清空\",{\"1\":{\"627\":1}}],[\"将其分成了三个执行单元\",{\"1\":{\"116\":1}}],[\"将其按utf\",{\"1\":{\"72\":1}}],[\"将其加载进内存\",{\"1\":{\"36\":1}}],[\"反悔\",{\"1\":{\"935\":1}}],[\"反向映射\",{\"0\":{\"587\":1}}],[\"反向搜索\",{\"1\":{\"149\":1}}],[\"反倒是\",{\"1\":{\"422\":1}}],[\"反序列化\",{\"0\":{\"338\":1}}],[\"反压效率\",{\"1\":{\"278\":1}}],[\"反射\",{\"0\":{\"35\":1}}],[\"反过来\",{\"1\":{\"30\":1}}],[\"通信\",{\"1\":{\"1112\":1,\"1118\":1}}],[\"通信的中介\",{\"1\":{\"1036\":1}}],[\"通信模块\",{\"1\":{\"944\":1}}],[\"通信协议\",{\"0\":{\"889\":1},\"1\":{\"743\":1}}],[\"通俗地说\",{\"1\":{\"879\":1}}],[\"通灵战潮\",{\"0\":{\"455\":1},\"1\":{\"479\":1,\"480\":2}}],[\"通灵\",{\"1\":{\"422\":1}}],[\"通灵和\",{\"1\":{\"403\":1}}],[\"通知消息消费长轮询线程\",{\"1\":{\"762\":1,\"827\":1}}],[\"通知机制\",{\"1\":{\"726\":1}}],[\"通知\",{\"1\":{\"121\":1,\"1449\":1,\"1451\":1,\"1460\":1}}],[\"通道\",{\"1\":{\"118\":1,\"124\":1,\"820\":1}}],[\"通常分布式文件系统跨可用区部署\",{\"1\":{\"1385\":1}}],[\"通常以\",{\"1\":{\"1321\":1}}],[\"通常以集群的方式部署\",{\"1\":{\"941\":1}}],[\"通常这些消费者都消费同一类消息\",{\"1\":{\"1089\":1}}],[\"通常队列由两部分组成\",{\"1\":{\"671\":1}}],[\"通常会阻塞较长时间\",{\"1\":{\"613\":1}}],[\"通常\",{\"1\":{\"368\":1,\"787\":1,\"1305\":1}}],[\"通常不必把任意类型转换为boolean再判断\",{\"1\":{\"333\":1}}],[\"通常不要在finally中抛出异常\",{\"1\":{\"34\":1}}],[\"通常把this绑定为null\",{\"1\":{\"319\":1}}],[\"通常运行在数据同一个局域网的集群上\",{\"1\":{\"237\":1}}],[\"通常只有\",{\"1\":{\"135\":1}}],[\"通常在非阻塞模式下返回\",{\"1\":{\"125\":1}}],[\"通常在\",{\"1\":{\"118\":1}}],[\"通常情况下上面已经返回\",{\"1\":{\"1500\":1}}],[\"通常情况下\",{\"1\":{\"693\":1}}],[\"通常情况\",{\"1\":{\"63\":1}}],[\"通配符\",{\"0\":{\"49\":1}}],[\"通过链表指针的方式连接起来\",{\"1\":{\"1418\":1}}],[\"通过缓冲区实现每个步骤的流量控制\",{\"1\":{\"1348\":1}}],[\"通过执行\",{\"1\":{\"1321\":1}}],[\"通过这两个过滤方法\",{\"1\":{\"1318\":1}}],[\"通过设置过滤表达式的方式进行过滤\",{\"1\":{\"1303\":1}}],[\"通过下列样式进行配置\",{\"1\":{\"1300\":1}}],[\"通过客户端的封装让用户使用时感觉像是\",{\"1\":{\"1152\":1}}],[\"通过比较签名的方式进行验证\",{\"1\":{\"989\":1}}],[\"通过固定几个延迟等级的方式\",{\"1\":{\"925\":1}}],[\"通过系统调用\",{\"1\":{\"882\":2}}],[\"通过jna方法访问一些native的系统调用\",{\"1\":{\"882\":1}}],[\"通过jna将内存页锁定在物理内存中\",{\"1\":{\"882\":1}}],[\"通过jvm的动态代理功能或者第三方库实现运行期动态织入\",{\"1\":{\"85\":1}}],[\"通过写入\",{\"1\":{\"882\":1}}],[\"通过对文件预热\",{\"1\":{\"882\":1}}],[\"通过业务线程池pullmessageexecutor\",{\"1\":{\"820\":1}}],[\"通过该通道向消息拉取客户端发送响应结果\",{\"1\":{\"819\":1,\"1173\":1}}],[\"通过该特性\",{\"1\":{\"37\":1}}],[\"通过hash槽绝对位置\",{\"1\":{\"797\":1}}],[\"通过hash槽下表计算出hash槽的绝对位置\",{\"1\":{\"797\":1}}],[\"通过死信交换器将这些消息转发到死信队列中\",{\"1\":{\"702\":1}}],[\"通过发送时设置消息的\",{\"1\":{\"685\":1}}],[\"通过将每个消费者的分配策略设置成一致\",{\"1\":{\"1127\":1}}],[\"通过将部分消息放到磁盘上来\",{\"1\":{\"690\":1}}],[\"通过将队列的\",{\"1\":{\"684\":1}}],[\"通过将单个节点的队列相对平均地分配到集群的不同节点\",{\"1\":{\"648\":1}}],[\"通过定时向所有节点发送心跳的方式检测断开的情况\",{\"1\":{\"664\":1}}],[\"通过定义一个类\",{\"1\":{\"564\":1}}],[\"通过在策略中设置\",{\"1\":{\"660\":1}}],[\"通过镜像队列\",{\"1\":{\"648\":1}}],[\"通过调用get\",{\"1\":{\"624\":1}}],[\"通过channel\",{\"1\":{\"616\":1}}],[\"通过class对象的isassignablefrom\",{\"1\":{\"40\":1}}],[\"通过使用\",{\"1\":{\"372\":1}}],[\"通过使用关卡\",{\"1\":{\"186\":1}}],[\"通过一致性哈希计算之后可以得到相同的节点编号\",{\"1\":{\"384\":1}}],[\"通过一两句代码就能实现可靠\",{\"1\":{\"372\":1}}],[\"通过一个特殊的类加载器\",{\"1\":{\"85\":1}}],[\"通过提供统一的地址方案实现了\",{\"1\":{\"372\":1}}],[\"通过模块化的javascript代码\",{\"1\":{\"360\":1}}],[\"通过responsetext拿到响应的文本\",{\"1\":{\"348\":1}}],[\"通过索引赋值时\",{\"1\":{\"298\":1}}],[\"通过分析源码\",{\"1\":{\"284\":1}}],[\"通过查看实验过程信息\",{\"1\":{\"284\":1}}],[\"通过全链路压测\",{\"1\":{\"276\":1}}],[\"通过可分可合的设计与部署方式去适配各种业务场景\",{\"1\":{\"276\":1}}],[\"通过端口对象与外部程序通信\",{\"1\":{\"241\":1}}],[\"通过它\",{\"1\":{\"171\":1}}],[\"通过感知\",{\"1\":{\"116\":1}}],[\"通过构造方法注入依赖\",{\"1\":{\"81\":1}}],[\"通过\",{\"1\":{\"81\":1,\"797\":2,\"878\":1,\"941\":1,\"1043\":1,\"1103\":1,\"1128\":1,\"1468\":1}}],[\"通过proxy创建代理对象\",{\"1\":{\"41\":1}}],[\"通过int\",{\"1\":{\"36\":1}}],[\"通过ordinal\",{\"1\":{\"31\":1}}],[\"通过name\",{\"1\":{\"31\":1}}],[\"了多少条消息\",{\"1\":{\"621\":1}}],[\"了解这个优化之前需要先学习一下前置知识\",{\"1\":{\"727\":1}}],[\"了解这些优化需要对\",{\"1\":{\"720\":1}}],[\"了解会影响手法的天赋\",{\"0\":{\"404\":1}}],[\"了解一致性哈希之前需要先了解哈希算法\",{\"1\":{\"385\":1}}],[\"了\",{\"1\":{\"34\":1,\"399\":3}}],[\"消除主从复制中不必要的数组拷贝\",{\"0\":{\"727\":1}}],[\"消费模型\",{\"1\":{\"1266\":1}}],[\"消费模式投递到\",{\"1\":{\"1364\":1}}],[\"消费模式衔接每个任务\",{\"1\":{\"1353\":1}}],[\"消费模式之后\",{\"1\":{\"1249\":1}}],[\"消费模式的重平衡逻辑是在客户端完成的\",{\"1\":{\"1249\":1}}],[\"消费模式的原因\",{\"0\":{\"1249\":1}}],[\"消费模式的一个实现\",{\"1\":{\"933\":1}}],[\"消费模式消费某个\",{\"1\":{\"1247\":1}}],[\"消费模式主要是用于\",{\"1\":{\"1245\":1}}],[\"消费模式用的阻塞队列\",{\"1\":{\"1187\":1}}],[\"消费模式探秘\",{\"1\":{\"1105\":1,\"1281\":1}}],[\"消费模式开发\",{\"1\":{\"1095\":1}}],[\"消费模式\",{\"0\":{\"802\":1,\"1243\":1},\"1\":{\"855\":1,\"881\":1,\"915\":1,\"916\":1,\"1015\":1,\"1104\":1,\"1152\":1,\"1155\":1,\"1158\":1,\"1245\":1,\"1348\":1,\"1354\":1,\"1538\":1}}],[\"消费和匹配\",{\"1\":{\"1263\":1}}],[\"消费由于要根据\",{\"1\":{\"1263\":1}}],[\"消费重试\",{\"1\":{\"1253\":1}}],[\"消费重试次数\",{\"0\":{\"1241\":1}}],[\"消费这批消息\",{\"1\":{\"1252\":1}}],[\"消费较为相似\",{\"1\":{\"1252\":1}}],[\"消费较慢\",{\"1\":{\"1173\":1}}],[\"消费提供了一个接口\",{\"1\":{\"1251\":1}}],[\"消费也沿用了这个设计\",{\"1\":{\"1251\":1}}],[\"消费引入了消息不可见时间\",{\"1\":{\"1251\":1}}],[\"消费一次请求可以拉取一批消息\",{\"1\":{\"1251\":1}}],[\"消费一批\",{\"1\":{\"1206\":1}}],[\"消费主要的设计思想是将繁重的客户端逻辑如重平衡\",{\"1\":{\"1250\":1}}],[\"消费主要的原因是由于\",{\"1\":{\"1249\":1}}],[\"消费接口用\",{\"1\":{\"1249\":1}}],[\"消费能力\",{\"1\":{\"1249\":1}}],[\"消费导致的可能的消息堆积问题和横向扩展能力问题\",{\"1\":{\"1249\":1}}],[\"消费暂不支持切换\",{\"1\":{\"1246\":1}}],[\"消费切换为使用\",{\"1\":{\"1246\":1}}],[\"消费都是由客户端完成重平衡\",{\"1\":{\"1245\":1}}],[\"消费很像\",{\"1\":{\"1245\":1}}],[\"消费幂等\",{\"0\":{\"1237\":1}}],[\"消费前钩子函数\",{\"1\":{\"1230\":1}}],[\"消费前后添加自定义的逻辑\",{\"1\":{\"1010\":1}}],[\"消费锁\",{\"1\":{\"1215\":2,\"1218\":2}}],[\"消费任务中添加的消息队列锁保证了同一消费者中的顺序消费\",{\"1\":{\"1208\":1}}],[\"消费任务结束时释放锁\",{\"1\":{\"1207\":1}}],[\"消费任务开始时获取锁\",{\"1\":{\"1207\":1}}],[\"消费任务由拉取任务提交\",{\"1\":{\"1206\":1}}],[\"消费上下文信息\",{\"1\":{\"1195\":1}}],[\"消费状态判断和处理\",{\"1\":{\"1195\":1}}],[\"消费状态\",{\"1\":{\"1195\":1}}],[\"消费状态码\",{\"1\":{\"1017\":1}}],[\"消费后\",{\"1\":{\"1195\":1}}],[\"消费后更新\",{\"1\":{\"1095\":1}}],[\"消费逻辑会概率性消费到重试\",{\"1\":{\"1253\":1}}],[\"消费逻辑\",{\"1\":{\"1195\":1}}],[\"消费请求\",{\"1\":{\"1195\":1}}],[\"消费请求运行\",{\"0\":{\"1195\":1},\"1\":{\"1195\":1}}],[\"消费请求队列\",{\"1\":{\"1187\":1}}],[\"消费请求由\",{\"1\":{\"1043\":1}}],[\"消费失败后发到\",{\"1\":{\"1250\":1}}],[\"消费失败后将消息发回\",{\"1\":{\"1249\":1}}],[\"消费失败统计数据更新\",{\"1\":{\"1195\":1}}],[\"消费失败\",{\"1\":{\"1195\":2}}],[\"消费失败则将消息发回\",{\"1\":{\"1187\":1}}],[\"消费失败则将失败的消息发回\",{\"1\":{\"1179\":1}}],[\"消费失败的消息将会过一段时间后重新消费\",{\"1\":{\"1180\":1}}],[\"消费结果处理方法\",{\"1\":{\"1187\":1}}],[\"消费结果处理\",{\"1\":{\"1179\":1,\"1230\":1}}],[\"消费正常\",{\"1\":{\"1173\":1}}],[\"消费分成如下几个步骤\",{\"1\":{\"1125\":1,\"1147\":1,\"1177\":1,\"1203\":1}}],[\"消费服务内部维护一个线程池\",{\"1\":{\"1120\":1}}],[\"消费线程池顺序消费任务流程\",{\"0\":{\"1218\":1}}],[\"消费线程池顺序消费设计\",{\"0\":{\"1217\":1}}],[\"消费线程池顺序消费逻辑\",{\"0\":{\"1216\":1}}],[\"消费线程池顺序消费\",{\"0\":{\"1206\":1}}],[\"消费线程池逻辑\",{\"0\":{\"1205\":1}}],[\"消费线程池从阻塞队列\",{\"1\":{\"1188\":1}}],[\"消费线程池\",{\"1\":{\"1187\":1}}],[\"消费线程池执行真正的消息消费逻辑\",{\"1\":{\"1119\":1}}],[\"消费线程池的每个消费线程会尝试从消费任务队列中获取消费请求\",{\"1\":{\"1104\":1}}],[\"消费完后解锁\",{\"1\":{\"1215\":1}}],[\"消费完成后\",{\"1\":{\"1104\":1}}],[\"消费完一批消息后将消息消费进度存在本地内存\",{\"1\":{\"1103\":1}}],[\"消费流程以重平衡为起点\",{\"1\":{\"1219\":1}}],[\"消费流程最后\",{\"1\":{\"1191\":1}}],[\"消费流程\",{\"0\":{\"1104\":1,\"1251\":1}}],[\"消费进度\",{\"1\":{\"1279\":1}}],[\"消费进度提交\",{\"1\":{\"1250\":1}}],[\"消费进度更新流程\",{\"0\":{\"1191\":1}}],[\"消费进度管理器的\",{\"1\":{\"1191\":1}}],[\"消费进度管理类设计\",{\"0\":{\"1190\":1}}],[\"消费进度管理\",{\"0\":{\"1189\":1,\"1199\":1}}],[\"消费进度管理设计\",{\"0\":{\"1181\":1}}],[\"消费进度上报\",{\"0\":{\"1176\":1},\"1\":{\"1538\":1}}],[\"消费进度保存在\",{\"1\":{\"1120\":1,\"1122\":1}}],[\"消费进度保存在消费者本地\",{\"1\":{\"1120\":1,\"1122\":1}}],[\"消费进度保存和提交\",{\"0\":{\"1103\":1}}],[\"消费进度在客户端维护\",{\"1\":{\"1090\":1}}],[\"消费消息锁解锁\",{\"1\":{\"1230\":1}}],[\"消费消息锁\",{\"1\":{\"1230\":1}}],[\"消费消息耗时较长的情况下\",{\"1\":{\"1215\":1}}],[\"消费消息服务接口定义了\",{\"1\":{\"1187\":1}}],[\"消费消息逻辑会调用\",{\"1\":{\"1119\":1}}],[\"消费消息\",{\"0\":{\"1288\":1},\"1\":{\"1105\":1}}],[\"消费消息的顺序和消息发送的顺序一致\",{\"1\":{\"1102\":1}}],[\"消费消息时重平衡\",{\"0\":{\"1215\":1}}],[\"消费消息时\",{\"1\":{\"878\":1}}],[\"消费端高可靠\",{\"0\":{\"1099\":1}}],[\"消费端的请求\",{\"1\":{\"1017\":1}}],[\"消费只是通过客户端\",{\"1\":{\"1094\":1}}],[\"消费\",{\"0\":{\"1245\":1,\"1246\":1},\"1\":{\"1094\":1,\"1255\":1,\"1278\":1}}],[\"消费其实也是由\",{\"1\":{\"1094\":1}}],[\"消费组偏移量等\",{\"1\":{\"1420\":1}}],[\"消费组客户端\",{\"1\":{\"1267\":1}}],[\"消费组线程数\",{\"0\":{\"1238\":1}}],[\"消费组名称\",{\"1\":{\"1188\":2,\"1198\":1}}],[\"消费组级别配置\",{\"1\":{\"1128\":1}}],[\"消费组中的消费者共同消费订阅的\",{\"1\":{\"1096\":1}}],[\"消费组的引入是用来在消费消息时更好地进行负载均衡和容错\",{\"1\":{\"1089\":1}}],[\"消费组是一个逻辑概念\",{\"1\":{\"1089\":1}}],[\"消费组\",{\"0\":{\"1089\":1},\"1\":{\"1143\":1,\"1222\":1,\"1263\":2,\"1267\":1,\"1332\":1}}],[\"消费组概念与消费模式\",{\"0\":{\"1088\":1}}],[\"消费涉及到地概念\",{\"1\":{\"1086\":1}}],[\"消费涉及到的模式和特性\",{\"1\":{\"1086\":1}}],[\"消费成功的消息数量的\",{\"1\":{\"1195\":1}}],[\"消费成功则更新消费进度\",{\"1\":{\"1187\":1}}],[\"消费成功则将这批消息从处理队列中移除\",{\"1\":{\"1179\":1}}],[\"消费成功则提交消费位点\",{\"1\":{\"1100\":1}}],[\"消费成功\",{\"1\":{\"1017\":1,\"1195\":2}}],[\"消费相关的数据\",{\"1\":{\"1010\":1}}],[\"消费索引文件\",{\"1\":{\"1386\":1}}],[\"消费索引\",{\"1\":{\"912\":1}}],[\"消费速度较快\",{\"1\":{\"1179\":1}}],[\"消费速度太慢\",{\"1\":{\"1158\":1}}],[\"消费速度从\",{\"1\":{\"910\":2}}],[\"消费速度只有\",{\"1\":{\"910\":1}}],[\"消费速度可以跟上生产速度\",{\"1\":{\"910\":1}}],[\"消费的消息\",{\"1\":{\"1278\":1}}],[\"消费的时刻\",{\"1\":{\"1275\":1}}],[\"消费的流程与\",{\"1\":{\"1252\":1}}],[\"消费的重平衡在\",{\"1\":{\"1255\":1}}],[\"消费的重平衡是在\",{\"1\":{\"1245\":1}}],[\"消费的重试间隔时间会随着重试次数而增加\",{\"1\":{\"1251\":1}}],[\"消费的特性是重平衡后每个消费者都分配到消费一定数量的队列\",{\"1\":{\"1249\":1}}],[\"消费的机制导致它存在一些痛点\",{\"1\":{\"1249\":1}}],[\"消费的行为和\",{\"1\":{\"1245\":1}}],[\"消费的当前队列的已经消费的最大的offset值\",{\"1\":{\"1171\":1}}],[\"消费的\",{\"1\":{\"910\":1,\"945\":1}}],[\"消费的过程都是顺序读\",{\"1\":{\"878\":1}}],[\"消费时间差\",{\"1\":{\"1278\":1}}],[\"消费时消费全部队列\",{\"1\":{\"1267\":1}}],[\"消费时将拉消息的动作替换成\",{\"1\":{\"1245\":1}}],[\"消费时将会调用订阅时注册的消费监听器中的业务方法\",{\"1\":{\"1179\":1}}],[\"消费时申请独占消息队列消费锁对象\",{\"1\":{\"1230\":1}}],[\"消费时可以通过设置\",{\"1\":{\"1195\":1}}],[\"消费时的轮询机制流程\",{\"1\":{\"806\":1}}],[\"消费时\",{\"1\":{\"803\":1,\"914\":1}}],[\"消费过程中的轮询机制是啥\",{\"1\":{\"800\":1}}],[\"消费队列过滤\",{\"1\":{\"1315\":2}}],[\"消费队列锁\",{\"1\":{\"1102\":1}}],[\"消费队列的最大offset\",{\"1\":{\"825\":1}}],[\"消费队列最大offset比消费者拉取请求的offset大\",{\"1\":{\"825\":2}}],[\"消费队列中没有任何消息\",{\"1\":{\"819\":1}}],[\"消费队列consumequeue\",{\"1\":{\"774\":1}}],[\"消费队列\",{\"1\":{\"751\":1,\"1318\":1}}],[\"消费队列文件\",{\"0\":{\"744\":1},\"1\":{\"1538\":1}}],[\"消费某一\",{\"1\":{\"747\":1}}],[\"消费来重新开始消费\",{\"1\":{\"665\":1}}],[\"消费者运行日志如下\",{\"1\":{\"1445\":1}}],[\"消费者名称\",{\"1\":{\"1333\":1}}],[\"消费者注册\",{\"1\":{\"1331\":1}}],[\"消费者上报心跳\",{\"1\":{\"1321\":1}}],[\"消费者就通过\",{\"1\":{\"1251\":1}}],[\"消费者无法无限扩展\",{\"1\":{\"1249\":1}}],[\"消费者无法消费到未到期的定时消息\",{\"1\":{\"836\":1}}],[\"消费者提供\",{\"1\":{\"1238\":1}}],[\"消费者解锁\",{\"0\":{\"1223\":1}}],[\"消费者在重平衡后\",{\"1\":{\"1209\":1}}],[\"消费者执行消费逻辑时\",{\"1\":{\"1203\":1}}],[\"消费者本地进度存储\",{\"1\":{\"1190\":1}}],[\"消费者更新消费进度\",{\"0\":{\"1184\":1}}],[\"消费者端\",{\"1\":{\"1190\":1}}],[\"消费者端仅保存一个消费进度内存缓存表\",{\"1\":{\"1183\":1}}],[\"消费者端有定时任务\",{\"1\":{\"1103\":1}}],[\"消费者之间不需要共享消费进度\",{\"1\":{\"1181\":1}}],[\"消费者拉取成功结果处理\",{\"0\":{\"1165\":1}}],[\"消费者拉取消息模式\",{\"0\":{\"1092\":1}}],[\"消费者拉取消息\",{\"0\":{\"1157\":1,\"1167\":1},\"1\":{\"1086\":1,\"1125\":1,\"1147\":1,\"1177\":1,\"1203\":1}}],[\"消费者收到\",{\"1\":{\"1155\":1}}],[\"消费者重平衡后\",{\"1\":{\"1213\":1}}],[\"消费者重平衡\",{\"1\":{\"1142\":1}}],[\"消费者停止时\",{\"1\":{\"1136\":1}}],[\"消费者订阅的所有\",{\"1\":{\"1133\":1}}],[\"消费者特性\",{\"1\":{\"1131\":1}}],[\"消费者按\",{\"1\":{\"1130\":1}}],[\"消费者关机时\",{\"1\":{\"1128\":1}}],[\"消费者系列的第六篇\",{\"1\":{\"1203\":1}}],[\"消费者系列的第五篇\",{\"1\":{\"1177\":1}}],[\"消费者系列的第四篇\",{\"1\":{\"1147\":1}}],[\"消费者系列的第三篇\",{\"1\":{\"1125\":1}}],[\"消费者系列的第二篇\",{\"1\":{\"1107\":1}}],[\"消费者实现\",{\"0\":{\"1118\":1}}],[\"消费者和命令工具都扩展了它\",{\"1\":{\"1116\":1}}],[\"消费者和下游服务\",{\"1\":{\"702\":1}}],[\"消费者类的设计中将会有一个消费者接口\",{\"1\":{\"1116\":1}}],[\"消费者接口提供一些共用方法\",{\"1\":{\"1116\":1}}],[\"消费者接口\",{\"0\":{\"1116\":1}}],[\"消费者的处理线程池处理拉取完成的回调\",{\"1\":{\"1149\":1}}],[\"消费者的\",{\"1\":{\"1136\":1,\"1240\":1}}],[\"消费者的启动主要涉及上面讲到的\",{\"1\":{\"1110\":1}}],[\"消费者的钩子类是\",{\"1\":{\"1014\":1}}],[\"消费者客户端如何实现通过拉取来模拟推的效果\",{\"1\":{\"1147\":1}}],[\"消费者客户端类设计\",{\"0\":{\"1114\":1}}],[\"消费者客户端启动\",{\"0\":{\"1110\":1}}],[\"消费者客户端设计\",{\"0\":{\"1109\":1}}],[\"消费者启动时\",{\"1\":{\"1136\":1,\"1312\":1}}],[\"消费者启动时唤醒重平衡服务\",{\"1\":{\"1104\":1}}],[\"消费者启动\",{\"0\":{\"1112\":1,\"1120\":1},\"1\":{\"1122\":1}}],[\"消费者启动过程中会向\",{\"1\":{\"945\":1}}],[\"消费者中有一个定时线程\",{\"1\":{\"1103\":1}}],[\"消费者线程池提交的偏移量是线程池消费的这一批消息中偏移量最小的消息的偏移量\",{\"1\":{\"1103\":1}}],[\"消费者向\",{\"1\":{\"1103\":2}}],[\"消费者数量大于队列数量\",{\"1\":{\"1267\":1}}],[\"消费者数量小于等于队列数量\",{\"1\":{\"1267\":1}}],[\"消费者数量发生变化\",{\"1\":{\"1128\":1}}],[\"消费者数量是否发生变化\",{\"1\":{\"1098\":1}}],[\"消费者数量无法无限扩展\",{\"1\":{\"1095\":1}}],[\"消费者发送拉取消息请求\",{\"1\":{\"1061\":1}}],[\"消费者并不马上收到消息\",{\"1\":{\"1028\":1}}],[\"消费者信息\",{\"1\":{\"1021\":1,\"1120\":1}}],[\"消费者采集时为消费者\",{\"1\":{\"1017\":2}}],[\"消费者开启消息轨迹\",{\"0\":{\"1007\":1}}],[\"消费者使用消息拉取线程\",{\"1\":{\"1158\":1}}],[\"消费者使用\",{\"0\":{\"985\":1}}],[\"消费者消费失败\",{\"0\":{\"1197\":1}}],[\"消费者消费一批消息完成之后\",{\"1\":{\"1103\":1}}],[\"消费者消费\",{\"1\":{\"1095\":1}}],[\"消费者消费消息\",{\"1\":{\"1086\":1,\"1125\":1,\"1147\":1,\"1177\":1,\"1203\":1}}],[\"消费者消费后\",{\"1\":{\"1017\":1}}],[\"消费者消费前\",{\"1\":{\"1017\":1}}],[\"消费者消费这些任务\",{\"1\":{\"855\":1}}],[\"消费者消费时查询\",{\"1\":{\"836\":1}}],[\"消费者可以消费到\",{\"1\":{\"1338\":1}}],[\"消费者可以消费到该消息\",{\"1\":{\"834\":1}}],[\"消费者可能希望知道这将会发生\",{\"1\":{\"665\":1}}],[\"消费者才可消费\",{\"1\":{\"832\":1}}],[\"消费者不立即能够消费\",{\"1\":{\"832\":1}}],[\"消费者调用\",{\"1\":{\"812\":1,\"916\":1}}],[\"消费者是在不断轮询\",{\"1\":{\"803\":1}}],[\"消费者组装拉取请求\",{\"1\":{\"1149\":1}}],[\"消费者组会自动订阅重试\",{\"1\":{\"1100\":1}}],[\"消费者组中的消费者实例会根据预设的负载均衡算法对\",{\"1\":{\"1094\":1}}],[\"消费者组\",{\"1\":{\"767\":1,\"1100\":2,\"1169\":1,\"1174\":1,\"1198\":1}}],[\"消费者\",{\"0\":{\"1085\":1,\"1106\":1,\"1124\":1,\"1146\":1,\"1176\":1,\"1202\":1,\"1236\":1,\"1307\":1,\"1310\":1,\"1444\":1},\"1\":{\"724\":1,\"834\":1,\"941\":1,\"1538\":6}}],[\"消费者正在处理数据的同时\",{\"1\":{\"724\":1}}],[\"消费者连接到\",{\"1\":{\"668\":1}}],[\"消费者直接连接\",{\"1\":{\"668\":1}}],[\"消费者预取\",{\"0\":{\"616\":1}}],[\"消\",{\"1\":{\"438\":1}}],[\"消尖刺的时候开一个减伤\",{\"1\":{\"438\":1}}],[\"消尖刺的时候需要用一个治疗手牌来抬血\",{\"1\":{\"438\":1}}],[\"消耗会更大\",{\"1\":{\"722\":1}}],[\"消耗品\",{\"0\":{\"485\":1}}],[\"消耗节能施法使你的愈合还能以60\",{\"1\":{\"405\":1}}],[\"消耗大量系统资源\",{\"1\":{\"114\":1}}],[\"消息回查死循环\",{\"1\":{\"1468\":1}}],[\"消息回到\",{\"1\":{\"674\":1}}],[\"消息繁琐的操作\",{\"1\":{\"1453\":1}}],[\"消息来判断半消息的执行结果\",{\"1\":{\"1446\":1}}],[\"消息来实现类似于\",{\"1\":{\"1245\":1}}],[\"消息持久化成功之后\",{\"1\":{\"1446\":1}}],[\"消息写多数派成功才能被消费\",{\"1\":{\"1385\":1}}],[\"消息写入时将写入\",{\"1\":{\"883\":1}}],[\"消息不在内存\",{\"1\":{\"1382\":1}}],[\"消息不会被复制\",{\"1\":{\"634\":1}}],[\"消息仅支持保留固定的时间\",{\"1\":{\"1379\":1}}],[\"消息作为\",{\"1\":{\"1364\":1}}],[\"消息条数\",{\"1\":{\"1351\":1}}],[\"消息属性中定义的免疫回查时长\",{\"1\":{\"1468\":2}}],[\"消息属性\",{\"1\":{\"1318\":1}}],[\"消息详情过滤\",{\"1\":{\"1315\":1}}],[\"消息分发\",{\"1\":{\"1294\":1}}],[\"消息分发的逻辑主要在\",{\"1\":{\"1294\":1}}],[\"消息需要分发的新偏移量也放入消息属性\",{\"1\":{\"1294\":1}}],[\"消息生产时构建布隆过滤器数据\",{\"0\":{\"1332\":1}}],[\"消息生产和消费\",{\"0\":{\"1293\":1}}],[\"消息生产者\",{\"1\":{\"1021\":1}}],[\"消息对应的真正消息\",{\"1\":{\"1280\":1}}],[\"消息根据\",{\"1\":{\"1278\":1}}],[\"消息放到\",{\"1\":{\"1278\":1}}],[\"消息放入\",{\"1\":{\"1263\":1}}],[\"消息放入内存\",{\"1\":{\"1260\":1}}],[\"消息和\",{\"1\":{\"1278\":1}}],[\"消息后\",{\"1\":{\"1275\":1}}],[\"消息请求\",{\"1\":{\"1269\":1,\"1273\":1}}],[\"消息重试\",{\"1\":{\"1261\":1}}],[\"消息接口每次只允许\",{\"1\":{\"1260\":1}}],[\"消息接受流程\",{\"1\":{\"1105\":1}}],[\"消息方法\",{\"0\":{\"1258\":1}}],[\"消息则从\",{\"1\":{\"1253\":1,\"1263\":1}}],[\"消息匹配后的最新位点\",{\"1\":{\"1258\":1}}],[\"消息匹配\",{\"1\":{\"1253\":1,\"1278\":1}}],[\"消息匹配成功后删除\",{\"1\":{\"1253\":1}}],[\"消息定时到\",{\"1\":{\"1253\":1}}],[\"消息也一样\",{\"1\":{\"1253\":1}}],[\"消息给消费者的效果\",{\"1\":{\"1245\":1}}],[\"消息调用监听器的方法进行消费\",{\"1\":{\"1195\":1}}],[\"消息将会被放入死信队列\",{\"1\":{\"1180\":1}}],[\"消息将进入\",{\"1\":{\"1056\":1}}],[\"消息表达式类型\",{\"1\":{\"1170\":1}}],[\"消息处理器将生产请求交给\",{\"1\":{\"1507\":1}}],[\"消息处理队列\",{\"1\":{\"1169\":1,\"1194\":1}}],[\"消息处理线程\",{\"1\":{\"724\":1}}],[\"消息选择器\",{\"1\":{\"1117\":1}}],[\"消息拉取时过滤\",{\"0\":{\"1333\":1}}],[\"消息拉取成功\",{\"0\":{\"1229\":1}}],[\"消息拉取操作\",{\"1\":{\"1228\":1}}],[\"消息拉取任务将拉取到的消息都放到消息队列对应的处理队列中\",{\"1\":{\"1217\":1}}],[\"消息拉取到后存入处理队列\",{\"1\":{\"1188\":1}}],[\"消息拉取模式\",{\"1\":{\"1170\":1}}],[\"消息拉取最大条数\",{\"1\":{\"1170\":1}}],[\"消息拉取最大数量\",{\"1\":{\"1164\":1}}],[\"消息拉取偏移量\",{\"1\":{\"1170\":1}}],[\"消息拉取流控检查\",{\"1\":{\"1159\":1}}],[\"消息拉取被流控\",{\"1\":{\"1158\":1}}],[\"消息拉取逻辑处理完成会更新拉取请求下次拉取的偏移量\",{\"1\":{\"1158\":1}}],[\"消息拉取线程从拉取任务队列中获取任务并执行拉取\",{\"1\":{\"1219\":1}}],[\"消息拉取线程\",{\"0\":{\"1168\":1}}],[\"消息拉取线程用了生产\",{\"1\":{\"1152\":1}}],[\"消息拉取线程应用生产\",{\"1\":{\"1104\":1}}],[\"消息拉取\",{\"0\":{\"1146\":1,\"1227\":1,\"1228\":1},\"1\":{\"1112\":1,\"1538\":1}}],[\"消息拉取请求主要包含拉取消息所需要的元数据\",{\"1\":{\"1169\":1}}],[\"消息拉取请求\",{\"0\":{\"1169\":1},\"1\":{\"819\":1,\"1173\":1}}],[\"消息堆积报警和订阅关系查询功能\",{\"1\":{\"1090\":1}}],[\"消息体和\",{\"1\":{\"1035\":1}}],[\"消息体长度\",{\"1\":{\"1017\":1}}],[\"消息类型\",{\"1\":{\"1017\":1}}],[\"消息偏移量\",{\"1\":{\"1017\":1}}],[\"消息轨迹存放的\",{\"1\":{\"1021\":1}}],[\"消息轨迹待发送数据队列\",{\"1\":{\"1021\":1}}],[\"消息轨迹异步转发器\",{\"1\":{\"1021\":1}}],[\"消息轨迹数据列表\",{\"1\":{\"1021\":1}}],[\"消息轨迹数据发送\",{\"0\":{\"1021\":1}}],[\"消息轨迹数据采集\",{\"0\":{\"1018\":1}}],[\"消息轨迹数据模型\",{\"0\":{\"1017\":1}}],[\"消息轨迹的模型类是\",{\"1\":{\"1017\":1}}],[\"消息轨迹的数据可以封装成消息\",{\"1\":{\"1010\":1}}],[\"消息轨迹保存在一个默认的\",{\"1\":{\"1012\":1}}],[\"消息轨迹关注是否被生产和消费\",{\"1\":{\"1010\":1}}],[\"消息轨迹\",{\"0\":{\"1002\":1},\"1\":{\"1022\":1,\"1173\":1,\"1198\":1,\"1538\":1}}],[\"消息投递毫秒级精度\",{\"1\":{\"937\":1}}],[\"消息投递线程和任务状态更新线程是生产\",{\"1\":{\"933\":1}}],[\"消息投递成功\",{\"1\":{\"861\":1}}],[\"消息是需要落盘的\",{\"1\":{\"925\":1}}],[\"消息到磁盘\",{\"1\":{\"1273\":1}}],[\"消息到达消息队列服务端后不会马上投递\",{\"1\":{\"920\":1}}],[\"消息到期之后会从\",{\"1\":{\"847\":1}}],[\"消息时尝试从内存\",{\"1\":{\"1262\":1}}],[\"消息时会先添加\",{\"1\":{\"1262\":1}}],[\"消息时支持不同的\",{\"0\":{\"905\":1}}],[\"消息时去遍历\",{\"1\":{\"747\":1}}],[\"消息发送到\",{\"1\":{\"1290\":1}}],[\"消息发送结果\",{\"1\":{\"1053\":1}}],[\"消息发送超时时间\",{\"1\":{\"1053\":1}}],[\"消息发送模式\",{\"1\":{\"1053\":1}}],[\"消息发送实现\",{\"0\":{\"1050\":1}}],[\"消息发送逻辑由\",{\"1\":{\"1042\":1}}],[\"消息发送重试机制\",{\"1\":{\"1032\":1}}],[\"消息发送流程\",{\"0\":{\"1030\":1},\"1\":{\"1057\":1}}],[\"消息发送的流程涉及到\",{\"1\":{\"1030\":1}}],[\"消息发送的\",{\"1\":{\"1029\":1}}],[\"消息发送后\",{\"1\":{\"1028\":1}}],[\"消息发送方式和特殊消息\",{\"0\":{\"1026\":1}}],[\"消息发送高性能\",{\"1\":{\"1024\":1}}],[\"消息发送并不仅仅牵扯到客户端操作\",{\"1\":{\"1024\":1}}],[\"消息发送设计和原理详解\",{\"0\":{\"1023\":1},\"1\":{\"1538\":1}}],[\"消息发送时没有设置\",{\"1\":{\"1328\":1}}],[\"消息发送时根据路由表进行\",{\"1\":{\"949\":1}}],[\"消息发送时由客户端生产\",{\"1\":{\"899\":1}}],[\"消息发送应该弱依赖注册中心\",{\"1\":{\"942\":1}}],[\"消息发送\",{\"0\":{\"1038\":1,\"1049\":1},\"1\":{\"890\":1,\"1017\":1,\"1053\":1}}],[\"消息发送是异步的\",{\"1\":{\"229\":1}}],[\"消息读取时\",{\"1\":{\"883\":1}}],[\"消息读写都通过\",{\"1\":{\"883\":1}}],[\"消息并不会直接投递成功\",{\"1\":{\"855\":1}}],[\"消息可能重复投递\",{\"1\":{\"854\":1}}],[\"消息可能未达到服务器就发送完毕\",{\"1\":{\"615\":1}}],[\"消息异步保存\",{\"1\":{\"843\":1}}],[\"消息队列作为微服务架构解耦\",{\"1\":{\"1439\":1}}],[\"消息队列加锁\",{\"0\":{\"1226\":1}}],[\"消息队列解锁\",{\"0\":{\"1225\":1}}],[\"消息队列锁定状态表\",{\"1\":{\"1222\":1}}],[\"消息队列锁\",{\"1\":{\"1207\":1}}],[\"消息队列的权限控制需求也也越来越迫切\",{\"1\":{\"976\":1}}],[\"消息队列\",{\"1\":{\"922\":1,\"1065\":1,\"1090\":1,\"1171\":1,\"1194\":1,\"1225\":1,\"1270\":1}}],[\"消息队列高手课\",{\"1\":{\"884\":1}}],[\"消息队列id\",{\"1\":{\"825\":1}}],[\"消息队列存储机制源码分析\",{\"1\":{\"691\":1}}],[\"消息topic\",{\"1\":{\"825\":1}}],[\"消息消费队列扩展属性\",{\"1\":{\"1318\":1}}],[\"消息消费时间\",{\"1\":{\"1230\":1}}],[\"消息消费后钩子函数\",{\"1\":{\"1230\":1}}],[\"消息消费后调用\",{\"1\":{\"1020\":1}}],[\"消息消费监听器执行真正的消费业务逻辑\",{\"1\":{\"1230\":1}}],[\"消息消费监听器\",{\"1\":{\"1187\":1}}],[\"消息消费类设计\",{\"0\":{\"1187\":1}}],[\"消息消费偏移量间隔流控\",{\"1\":{\"1170\":1}}],[\"消息消费大小流控\",{\"1\":{\"1170\":1}}],[\"消息消费数量流控\",{\"1\":{\"1170\":1}}],[\"消息消费服务从处理队列中获取消息并消费\",{\"1\":{\"1155\":1}}],[\"消息消费前调用\",{\"1\":{\"1020\":1}}],[\"消息消费的信息\",{\"1\":{\"1003\":1}}],[\"消息消费的延迟变高\",{\"1\":{\"915\":1}}],[\"消息消费的轮询机制指的是在\",{\"1\":{\"914\":1}}],[\"消息消费方式\",{\"0\":{\"801\":1}}],[\"消息消费\",{\"0\":{\"799\":1,\"1176\":1},\"1\":{\"829\":1,\"1105\":1,\"1538\":2}}],[\"消息存到\",{\"1\":{\"1291\":1,\"1294\":1}}],[\"消息存入\",{\"1\":{\"1294\":1}}],[\"消息存入磁盘\",{\"1\":{\"1277\":1}}],[\"消息存入commitlog之后重新分发到index文件的\",{\"1\":{\"794\":1}}],[\"消息存储模块\",{\"1\":{\"1537\":1}}],[\"消息存储的方案取舍\",{\"0\":{\"928\":1}}],[\"消息存储的实现\",{\"1\":{\"836\":1}}],[\"消息存储过期\",{\"1\":{\"926\":1}}],[\"消息存储逻辑\",{\"1\":{\"843\":1}}],[\"消息存储到\",{\"1\":{\"787\":1}}],[\"消息存储之概要设计\",{\"1\":{\"774\":1}}],[\"消息存储文件\",{\"1\":{\"736\":1}}],[\"消息存储\",{\"1\":{\"687\":1}}],[\"消息越老\",{\"1\":{\"787\":1}}],[\"消息过滤流程\",{\"1\":{\"1334\":1}}],[\"消息过滤相关\",{\"1\":{\"1170\":1}}],[\"消息过滤相关逻辑\",{\"1\":{\"1163\":1}}],[\"消息过滤表达式\",{\"1\":{\"1117\":1,\"1170\":1}}],[\"消息过滤服务器列表\",{\"1\":{\"970\":1}}],[\"消息过滤匹配\",{\"1\":{\"825\":1}}],[\"消息过滤\",{\"0\":{\"1301\":1,\"1324\":1},\"1\":{\"767\":1,\"814\":1,\"1173\":1,\"1174\":1,\"1329\":1,\"1334\":1,\"1538\":1}}],[\"消息过滤器\",{\"1\":{\"767\":1,\"1117\":1,\"1174\":1}}],[\"消息大小\",{\"1\":{\"749\":1}}],[\"消息大小size和消息tag的hashcode值\",{\"1\":{\"747\":1}}],[\"消息在存储到\",{\"1\":{\"1400\":1}}],[\"消息在队列中的逻辑偏移量\",{\"1\":{\"767\":1,\"1174\":1}}],[\"消息在consumequeue中的逻辑偏移量\",{\"1\":{\"765\":1}}],[\"消息在commitlog存储的大小\",{\"1\":{\"765\":1}}],[\"消息在\",{\"1\":{\"749\":1,\"786\":1,\"787\":1}}],[\"消息在投递到匹配的队列后会给发送方返回一个确认请求\",{\"1\":{\"615\":1}}],[\"消息保存时间与索引文件最早消息保存时间的差值\",{\"1\":{\"786\":1}}],[\"消息保存到\",{\"1\":{\"750\":1,\"781\":1,\"1446\":1}}],[\"消息保存\",{\"0\":{\"733\":1}}],[\"消息被回查的最大次数\",{\"1\":{\"1468\":1}}],[\"消息被写入\",{\"1\":{\"1403\":1}}],[\"消息被负载均衡到了同一个消费组的多个消费者实例上\",{\"1\":{\"1091\":1}}],[\"消息被分配到\",{\"1\":{\"711\":1}}],[\"消息被消费\",{\"1\":{\"690\":1}}],[\"消息被消费后会被删除\",{\"1\":{\"688\":1}}],[\"消息路由到该队列的概率也越高\",{\"1\":{\"711\":1}}],[\"消息复制和主副本选举的操作\",{\"1\":{\"695\":1}}],[\"消息要经历多个生命周期\",{\"1\":{\"690\":1}}],[\"消息又从磁盘回到内存中\",{\"1\":{\"690\":1}}],[\"消息实际经历了一个ram\",{\"1\":{\"690\":1}}],[\"消息内容和索引都在disk上\",{\"1\":{\"690\":1}}],[\"消息索引文件\",{\"1\":{\"816\":1}}],[\"消息索引在disk和ram上都有\",{\"1\":{\"690\":1}}],[\"消息索引保存在ram中\",{\"1\":{\"690\":1}}],[\"消息才会在重启之后仍然存在\",{\"1\":{\"685\":1}}],[\"消息的操作较为繁琐\",{\"1\":{\"1453\":1}}],[\"消息的存储位置也会经历\",{\"1\":{\"1390\":1}}],[\"消息的存储机制\",{\"1\":{\"681\":1}}],[\"消息的检索需要消耗较多的计算资源\",{\"1\":{\"1364\":1}}],[\"消息的两层过滤与\",{\"1\":{\"1324\":1}}],[\"消息的主要步骤有两步\",{\"1\":{\"1294\":1}}],[\"消息的码表以完成\",{\"1\":{\"1278\":1}}],[\"消息的匹配\",{\"1\":{\"1276\":1}}],[\"消息的起始偏移量\",{\"1\":{\"1258\":1,\"1271\":1}}],[\"消息的消费可能出现失败\",{\"1\":{\"1100\":1}}],[\"消息的路由指的是发送消息时需要先获取\",{\"1\":{\"1029\":1}}],[\"消息的轨迹数据\",{\"1\":{\"1017\":1}}],[\"消息的丢失是不能被接收的\",{\"1\":{\"934\":1}}],[\"消息的模式\",{\"1\":{\"803\":1}}],[\"消息的分发请求\",{\"1\":{\"764\":1}}],[\"消息的\",{\"1\":{\"749\":1,\"787\":1,\"1257\":1,\"1276\":1,\"1325\":1}}],[\"消息的内容保存在disk上\",{\"1\":{\"690\":2}}],[\"消息的内容和消息索引都在ram中\",{\"1\":{\"690\":1}}],[\"消息的生命周期有4个状态\",{\"1\":{\"690\":1}}],[\"消息的持久化\",{\"0\":{\"685\":1}}],[\"消息的广播\",{\"0\":{\"674\":1}}],[\"消息会默认为丢弃\",{\"1\":{\"1467\":1}}],[\"消息会保存到死信\",{\"1\":{\"1100\":1}}],[\"消息会被消费者发回\",{\"1\":{\"1100\":1}}],[\"消息会被先保存到\",{\"1\":{\"756\":1}}],[\"消息会被发送到本地的\",{\"1\":{\"633\":1}}],[\"消息会顺着节点链表经过所有的\",{\"1\":{\"674\":1}}],[\"消息\",{\"0\":{\"739\":1,\"1035\":1,\"1044\":1,\"1256\":1,\"1260\":1,\"1268\":1,\"1272\":1},\"1\":{\"674\":1,\"698\":1,\"1053\":1,\"1194\":1,\"1206\":1,\"1230\":1,\"1257\":1,\"1258\":1,\"1260\":1,\"1263\":4,\"1270\":1,\"1273\":1,\"1276\":1,\"1278\":4,\"1279\":1,\"1364\":1,\"1393\":1,\"1432\":2,\"1446\":6,\"1453\":1,\"1467\":1}}],[\"消息从\",{\"1\":{\"674\":1}}],[\"消息广播\",{\"1\":{\"648\":1}}],[\"消息有两种\",{\"1\":{\"368\":1}}],[\"消息中间件\",{\"1\":{\"0\":1,\"15\":1,\"95\":1,\"106\":1,\"136\":1,\"137\":1,\"167\":1,\"262\":1,\"274\":1,\"286\":1,\"290\":1,\"369\":1,\"381\":1,\"397\":1,\"492\":1,\"607\":1,\"628\":1,\"640\":1,\"646\":1,\"679\":1,\"691\":1,\"704\":1,\"717\":1,\"743\":1,\"774\":1,\"798\":1,\"829\":2,\"848\":1,\"861\":1,\"872\":1,\"884\":1,\"917\":1,\"938\":1,\"974\":1,\"1001\":1,\"1022\":1,\"1057\":1,\"1067\":1,\"1084\":1,\"1105\":2,\"1123\":1,\"1145\":1,\"1175\":1,\"1201\":1,\"1230\":1,\"1242\":1,\"1281\":1,\"1298\":1,\"1300\":1,\"1334\":1,\"1375\":1,\"1437\":1,\"1473\":1,\"1504\":1,\"1522\":1,\"1523\":1,\"1527\":1,\"1537\":1}}],[\"消失\",{\"1\":{\"34\":1}}],[\"原封不动地还原出来\",{\"1\":{\"1362\":1}}],[\"原先每个消息都会通知一次\",{\"1\":{\"916\":1}}],[\"原先的预读缓存使用了拥塞控制算法\",{\"1\":{\"1404\":1}}],[\"原先的负载就变得不再均衡\",{\"1\":{\"1098\":1}}],[\"原先的\",{\"1\":{\"900\":1}}],[\"原先的方法实现中\",{\"1\":{\"900\":1}}],[\"原先在主从复制逻辑中的数组拷贝步骤其实是可以省略的\",{\"1\":{\"730\":1}}],[\"原本的\",{\"1\":{\"1290\":1}}],[\"原本的定时消息投递为单线程同步投递\",{\"1\":{\"853\":1}}],[\"原本生成全局\",{\"1\":{\"899\":1}}],[\"原本\",{\"1\":{\"731\":1}}],[\"原来\",{\"1\":{\"1418\":1}}],[\"原来的默认值分别为\",{\"1\":{\"1299\":1}}],[\"原来的代码会新建一个字节数组\",{\"1\":{\"729\":1}}],[\"原来有两种消费模式\",{\"1\":{\"1245\":1}}],[\"原来锁内用来查位点哈希表的\",{\"1\":{\"736\":1}}],[\"原来在catch中准备抛出的异常就\",{\"1\":{\"34\":1}}],[\"原始之怒一般不会点出\",{\"1\":{\"417\":1}}],[\"原文作者\",{\"1\":{\"398\":1}}],[\"原文地址\",{\"1\":{\"1\":1,\"16\":1,\"96\":1,\"107\":1,\"137\":1,\"139\":1,\"168\":1,\"263\":1,\"275\":1,\"287\":1,\"291\":1,\"370\":1,\"382\":1,\"398\":2,\"493\":1,\"609\":1,\"629\":1,\"641\":1,\"647\":1,\"680\":1,\"692\":1,\"705\":1,\"719\":1,\"744\":1,\"775\":1,\"799\":1,\"830\":1,\"849\":1,\"862\":1,\"873\":1,\"885\":1,\"918\":1,\"939\":1,\"975\":1,\"1002\":1,\"1023\":1,\"1058\":1,\"1068\":1,\"1085\":1,\"1106\":1,\"1124\":1,\"1146\":1,\"1176\":1,\"1202\":1,\"1231\":1,\"1243\":1,\"1282\":1,\"1299\":1,\"1301\":1,\"1335\":1,\"1376\":1,\"1438\":1,\"1474\":1,\"1505\":1,\"1523\":1,\"1524\":1,\"1528\":1}}],[\"原因就是在捕获的当时\",{\"1\":{\"359\":1}}],[\"原型继承\",{\"0\":{\"342\":1}}],[\"原型对象\",{\"1\":{\"339\":1}}],[\"原子的值就是它本身\",{\"1\":{\"175\":1}}],[\"原子以小写字母开头\",{\"1\":{\"175\":1}}],[\"原子是全局性的\",{\"1\":{\"175\":1}}],[\"原子\",{\"0\":{\"175\":1},\"1\":{\"186\":1}}],[\"原\",{\"1\":{\"118\":1}}],[\"原理和\",{\"1\":{\"1527\":1}}],[\"原理和实现\",{\"0\":{\"382\":1},\"1\":{\"608\":1,\"716\":1}}],[\"原理详解\",{\"0\":{\"370\":1,\"1243\":1,\"1282\":1,\"1301\":1,\"1335\":1,\"1376\":1,\"1447\":1},\"1\":{\"608\":1,\"1538\":5}}],[\"原理是使用\",{\"1\":{\"87\":1}}],[\"原理\",{\"0\":{\"81\":1,\"716\":1}}],[\"必须保证消息上传到这两个文件成功才视作上传成功\",{\"1\":{\"1403\":1}}],[\"必须保证消息投递成功\",{\"1\":{\"1360\":1}}],[\"必须用\",{\"1\":{\"591\":2}}],[\"必须生成时一次性声明所有属性\",{\"1\":{\"556\":1}}],[\"必须声明每个成员的类型\",{\"1\":{\"527\":1}}],[\"必须自己推断类型的那些变量\",{\"1\":{\"502\":1}}],[\"必须直接对module\",{\"1\":{\"365\":1}}],[\"必须为字符串的问题\",{\"1\":{\"300\":1}}],[\"必须向它发送一个消息\",{\"1\":{\"227\":1}}],[\"必须是一个函数\",{\"1\":{\"605\":1}}],[\"必须是一个字面数据类型\",{\"1\":{\"204\":1}}],[\"必须是一个原子\",{\"1\":{\"204\":1}}],[\"必须是一个能够得出位串的表达式\",{\"1\":{\"184\":1}}],[\"必须是一个能够得出列表的表达式\",{\"1\":{\"184\":1}}],[\"必须使用特殊的语法才能输入某些字符\",{\"1\":{\"178\":1}}],[\"必须处于非阻塞模式才能与\",{\"1\":{\"118\":1}}],[\"必须将处理过程拆分成多个非阻塞的动作\",{\"1\":{\"117\":1}}],[\"必须手动绑定事件和动作\",{\"1\":{\"117\":1}}],[\"必须定义其他类型\",{\"1\":{\"47\":1}}],[\"必须捕获的异常\",{\"1\":{\"33\":1}}],[\"必须依附于一个outer\",{\"1\":{\"22\":1}}],[\"┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐\",{\"1\":{\"46\":1}}],[\"┌───────┐\",{\"1\":{\"78\":1}}],[\"┌───────┘\",{\"1\":{\"33\":1}}],[\"┌────────────┬────────┴─────────┬───────────────┐\",{\"1\":{\"46\":1}}],[\"┌─────────────────────────┐\",{\"1\":{\"33\":1}}],[\"┌─────────────────────┐\",{\"1\":{\"33\":1}}],[\"┌─────────────────┐┌───────────┐\",{\"1\":{\"33\":1}}],[\"┌─────────────────┐\",{\"1\":{\"33\":1}}],[\"┌───────────┴─────────────┐\",{\"1\":{\"33\":1}}],[\"┌───────────┐\",{\"1\":{\"33\":4,\"78\":1}}],[\"┌─────────┴─────────┐\",{\"1\":{\"33\":1}}],[\"┌────┐\",{\"1\":{\"46\":1}}],[\"┌────┴──────────┐\",{\"1\":{\"33\":1}}],[\"▲\",{\"1\":{\"33\":5,\"46\":1}}],[\"称为\",{\"1\":{\"514\":1}}],[\"称为自动拆箱\",{\"1\":{\"30\":1}}],[\"称为自动装箱\",{\"1\":{\"30\":1}}],[\"称为ascii编码\",{\"1\":{\"27\":1}}],[\"基准路径\",{\"1\":{\"599\":1,\"600\":1}}],[\"基准测试jmh\",{\"1\":{\"15\":1}}],[\"基准测试神器jmh\",{\"1\":{\"13\":1,\"15\":1}}],[\"基准测试工具\",{\"1\":{\"2\":1}}],[\"基于性能的考虑\",{\"1\":{\"942\":1}}],[\"基于定时消息实现如消息重投等功能\",{\"1\":{\"923\":1}}],[\"基于反射来解析和设置消息\",{\"1\":{\"742\":1,\"890\":1}}],[\"基于信用证的流控\",{\"0\":{\"619\":1}}],[\"基于vertx实现\",{\"1\":{\"374\":1}}],[\"基于轻量级的\",{\"1\":{\"372\":1}}],[\"基于javascript语言和v8引擎的开源web服务器项目\",{\"1\":{\"360\":1}}],[\"基于student原型创建一个新对象\",{\"1\":{\"339\":1}}],[\"基于套接字的分布式模型\",{\"1\":{\"237\":1}}],[\"基于\",{\"1\":{\"119\":2}}],[\"基本流程\",{\"0\":{\"979\":1}}],[\"基本的问题是\",{\"1\":{\"677\":1}}],[\"基本类型\",{\"0\":{\"506\":1}}],[\"基本类型和引用类型\",{\"1\":{\"30\":1}}],[\"基本用法\",{\"0\":{\"496\":1}}],[\"基本不是一个游戏\",{\"1\":{\"399\":1}}],[\"基本可以算新手重新上路\",{\"1\":{\"399\":1}}],[\"基本模块\",{\"0\":{\"366\":1}}],[\"基本函数从进程邮箱中提取消息\",{\"1\":{\"233\":1}}],[\"基本并发函数\",{\"0\":{\"229\":1}}],[\"基本上是\",{\"1\":{\"194\":1}}],[\"基本概念\",{\"0\":{\"170\":1,\"978\":1}}],[\"基本操作\",{\"0\":{\"91\":1}}],[\"基础信息表中的该\",{\"1\":{\"972\":1}}],[\"基础信息表\",{\"1\":{\"949\":1}}],[\"基础上实现高性能的\",{\"1\":{\"919\":1}}],[\"基础预铺大概要\",{\"1\":{\"411\":1}}],[\"基础\",{\"0\":{\"59\":1,\"75\":1}}],[\"分析\",{\"1\":{\"1439\":1}}],[\"分析反馈较弱\",{\"1\":{\"277\":1}}],[\"分层存储\",{\"1\":{\"1437\":1}}],[\"分层设计\",{\"0\":{\"1387\":1}}],[\"分级存储背后一些有挑战的技术优化\",{\"1\":{\"1437\":1}}],[\"分级存储队列文件不存在\",{\"1\":{\"1430\":1}}],[\"分级存储队列消费索引\",{\"1\":{\"1402\":1}}],[\"分级存储接入\",{\"0\":{\"1423\":1}}],[\"分级存储文件中的\",{\"1\":{\"1403\":1}}],[\"分级存储文件的\",{\"1\":{\"1403\":1}}],[\"分级存储索引文件\",{\"1\":{\"1402\":1}}],[\"分级存储索引服务\",{\"1\":{\"1402\":1}}],[\"分级存储中的索引文件也是以一组\",{\"1\":{\"1411\":1}}],[\"分级存储中的文件最小单元\",{\"1\":{\"1402\":1}}],[\"分级存储中消息文件存储的实现\",{\"1\":{\"1402\":1}}],[\"分级存储在这里的接入方法是\",{\"1\":{\"1400\":1}}],[\"分级存储调用\",{\"0\":{\"1399\":1}}],[\"分级存储初始化\",{\"0\":{\"1398\":1}}],[\"分级存储就是通过实现\",{\"1\":{\"1397\":1}}],[\"分级存储系统会读取持久化在本地的\",{\"1\":{\"1395\":1}}],[\"分级存储把读取策略抽象了出来\",{\"1\":{\"1390\":1}}],[\"分级存储消息读取入口\",{\"0\":{\"1430\":1}}],[\"分级存储消息读取器\",{\"1\":{\"1402\":1}}],[\"分级存储消息分发器\",{\"1\":{\"1402\":1}}],[\"分级存储消息分发器是一个服务线程\",{\"1\":{\"1388\":1}}],[\"分级存储消息保存时间\",{\"1\":{\"1382\":1}}],[\"分级存储引入的概念\",{\"1\":{\"1386\":1}}],[\"分级存储的元数据是专门为了恢复分级存储文件引用而设置的\",{\"1\":{\"1419\":1}}],[\"分级存储的代码位于一个单独的模块\",{\"1\":{\"1396\":1}}],[\"分级存储的索引文件分为三个状态\",{\"1\":{\"1394\":1}}],[\"分级存储的实现分为\",{\"1\":{\"1387\":1}}],[\"分级存储的\",{\"1\":{\"1386\":1,\"1403\":1}}],[\"分级存储的模型与本地存储的模型一一对应\",{\"1\":{\"1386\":1}}],[\"分级存储的方案中一个重要的选择是直写还是转写\",{\"1\":{\"1385\":1}}],[\"分级存储写文件最大同时写文件数量\",{\"1\":{\"1382\":1}}],[\"分级存储读取策略如下\",{\"1\":{\"1405\":1}}],[\"分级存储读取策略\",{\"1\":{\"1382\":1}}],[\"分级存储数据文件保存位置\",{\"1\":{\"1382\":1}}],[\"分级存储数据存储实现\",{\"1\":{\"1382\":1}}],[\"分级存储元数据存储实现\",{\"1\":{\"1382\":1,\"1402\":1}}],[\"分级存储各个配置的含义表如下\",{\"1\":{\"1382\":1}}],[\"分级存储还希望解决的问题是\",{\"1\":{\"1379\":1}}],[\"分级存储\",{\"0\":{\"1376\":1},\"1\":{\"1382\":1,\"1386\":1,\"1402\":4,\"1403\":1,\"1538\":1}}],[\"分批将定时消息请求放入\",{\"1\":{\"1372\":1}}],[\"分批将定时消息删除请求放入\",{\"1\":{\"1372\":1}}],[\"分批将消息发送到\",{\"1\":{\"1021\":1}}],[\"分开\",{\"1\":{\"1291\":1}}],[\"分为多个队列\",{\"1\":{\"1028\":1}}],[\"分别处理\",{\"1\":{\"1260\":1}}],[\"分别在\",{\"1\":{\"1129\":1}}],[\"分别消费重试\",{\"1\":{\"1095\":1}}],[\"分别用于重新加载全部文件\",{\"1\":{\"998\":1}}],[\"分别为命令行方式切换和客户端代码方式切换\",{\"1\":{\"1246\":1}}],[\"分别为全局唯一\",{\"1\":{\"899\":1}}],[\"分别为长轮询\",{\"1\":{\"804\":1}}],[\"分别替换成延迟消息对应的\",{\"1\":{\"834\":1}}],[\"分别创建索引\",{\"1\":{\"794\":1}}],[\"分别是根据消费队列过滤和根据消息详情过滤\",{\"1\":{\"1313\":1}}],[\"分别是并发消费和顺序消费的实现\",{\"1\":{\"1119\":1}}],[\"分别是并发消费和顺序消费\",{\"1\":{\"1102\":1}}],[\"分别是启动和关闭\",{\"1\":{\"961\":1}}],[\"分别是定时消息数据和定时消息索引\",{\"1\":{\"929\":1}}],[\"分别是数组\",{\"1\":{\"521\":1}}],[\"分别是\",{\"1\":{\"372\":1,\"632\":1,\"1102\":1,\"1482\":2}}],[\"分配策略\",{\"1\":{\"1143\":1}}],[\"分配给消费者进行消费的动作即重平衡\",{\"1\":{\"1126\":1}}],[\"分配完队列后\",{\"1\":{\"1104\":1}}],[\"分配新的morecreditafter\",{\"1\":{\"621\":1}}],[\"分配初始信用值initialcredit\",{\"1\":{\"621\":1}}],[\"分配的值为initialcredit\",{\"1\":{\"619\":1}}],[\"分享下我个人的技能规划\",{\"1\":{\"446\":1}}],[\"分在\",{\"1\":{\"399\":1}}],[\"分实现定下的目标\",{\"1\":{\"399\":1}}],[\"分作为我自己的一个小目标\",{\"1\":{\"399\":1}}],[\"分吧\",{\"1\":{\"399\":1}}],[\"分是我给自己定的一个小目标\",{\"1\":{\"399\":1}}],[\"分奶德倾囊相授\",{\"0\":{\"398\":1},\"1\":{\"608\":1}}],[\"分身\",{\"1\":{\"388\":2,\"716\":1}}],[\"分布的\",{\"1\":{\"950\":1,\"968\":1}}],[\"分布在不同的\",{\"1\":{\"941\":1}}],[\"分布在不同节点\",{\"1\":{\"384\":1}}],[\"分布式消息中间件\",{\"1\":{\"1057\":1}}],[\"分布式消息队列稳定性评估标准\",{\"1\":{\"286\":1}}],[\"分布式调度的mapreduce模型就是为使用者在代码开发层面屏蔽上述并行协调的逻辑\",{\"1\":{\"371\":1}}],[\"分布式系统的弹性能力不能通过编排固定频率的事件以触发检测\",{\"1\":{\"285\":1}}],[\"分布式系统共识组件的一致性等\",{\"1\":{\"278\":1}}],[\"分布式系统韧性架构压舱石openchaos\",{\"0\":{\"275\":1},\"1\":{\"608\":1}}],[\"分布式领域资深技术专家\",{\"1\":{\"277\":1}}],[\"分布式应用程序编写顺序\",{\"1\":{\"238\":1}}],[\"分布式\",{\"1\":{\"237\":1,\"372\":1}}],[\"分布式编程\",{\"0\":{\"236\":1}}],[\"分组隔离机制\",{\"0\":{\"380\":1}}],[\"分割\",{\"1\":{\"186\":2}}],[\"分号\",{\"1\":{\"180\":1}}],[\"分隔函数整体\",{\"1\":{\"180\":1}}],[\"分隔函数调用\",{\"1\":{\"180\":1}}],[\"分隔子句\",{\"1\":{\"180\":1}}],[\"分隔符拼接数组\",{\"1\":{\"29\":1}}],[\"分工合作\",{\"1\":{\"130\":1}}],[\"分离以此保障写的速度\",{\"1\":{\"1364\":1}}],[\"分离\",{\"1\":{\"124\":2}}],[\"分发消息\",{\"1\":{\"1427\":1}}],[\"分发消息到消费索引\",{\"1\":{\"1297\":1}}],[\"分发消息到多个\",{\"1\":{\"1287\":1}}],[\"分发消息到\",{\"1\":{\"1286\":1}}],[\"分发请求缓冲区\",{\"1\":{\"1403\":1}}],[\"分发请求\",{\"1\":{\"1297\":1}}],[\"分发到多个队列\",{\"1\":{\"1297\":1}}],[\"分发到\",{\"0\":{\"1294\":1}}],[\"分发到另一个\",{\"1\":{\"630\":1}}],[\"分发拉取请求到消息拉取服务\",{\"1\":{\"1134\":1}}],[\"分发给各个处理器\",{\"1\":{\"762\":1}}],[\"分发子任务\",{\"1\":{\"378\":1}}],[\"分发事件\",{\"1\":{\"122\":1}}],[\"分发\",{\"0\":{\"1297\":1},\"1\":{\"122\":1,\"1294\":1}}],[\"分而治之和事件驱动\",{\"1\":{\"119\":1}}],[\"分而治之的关键在于非阻塞\",{\"1\":{\"116\":1}}],[\"分而治之\",{\"0\":{\"116\":1}}],[\"分钟不会接收消息\",{\"1\":{\"1234\":1}}],[\"分钟不更新则过期\",{\"1\":{\"1209\":1}}],[\"分钟的超时时间是为了防止某个队列消息过多或消费过慢\",{\"1\":{\"1206\":1}}],[\"分钟的消息\",{\"1\":{\"925\":1}}],[\"分钟内\",{\"1\":{\"922\":1}}],[\"分钟后进行一次回调\",{\"1\":{\"921\":1,\"1337\":1}}],[\"分钟才会强制删除\",{\"1\":{\"866\":1}}],[\"分钟才能叠到最大层数\",{\"1\":{\"482\":1}}],[\"分钟左右一盘\",{\"1\":{\"399\":1}}],[\"分钟\",{\"1\":{\"11\":1,\"866\":1,\"1212\":1,\"1217\":1}}],[\"因而读写效率比从堆内存中读写高很多\",{\"1\":{\"904\":1}}],[\"因为前面更新了事务半消息的属性\",{\"1\":{\"1468\":1}}],[\"因为前面更新了回查次数\",{\"1\":{\"1453\":1}}],[\"因为发送时模拟了\",{\"1\":{\"1445\":1}}],[\"因为分级存储的\",{\"1\":{\"1403\":1}}],[\"因为通常情况下消息消费之后都能很快\",{\"1\":{\"1261\":1}}],[\"因为通过\",{\"1\":{\"882\":1}}],[\"因为不同的message\",{\"1\":{\"1237\":1}}],[\"因为某个\",{\"1\":{\"1234\":1}}],[\"因为如果释放\",{\"1\":{\"1215\":1}}],[\"因为只要有多个队列让多个消费者同时消费\",{\"1\":{\"1203\":1}}],[\"因为只能抛出一个异常\",{\"1\":{\"34\":1}}],[\"因为延迟重试消息依赖延迟消息能力\",{\"1\":{\"1188\":1}}],[\"因为根据tag过滤时在服务端只验证了tag的哈希码\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"因为子节点不保存消费者的offset值\",{\"1\":{\"1171\":1}}],[\"因为每个消费者都需要消费全量消息消息\",{\"1\":{\"1103\":1}}],[\"因为每次从磁盘读数据时需要先寻址\",{\"1\":{\"876\":1}}],[\"因为无法控制哪个队列的消息被先消费\",{\"1\":{\"1102\":1}}],[\"因为定时消息定时的时间不固定\",{\"1\":{\"928\":1}}],[\"因为高可靠和高性能都可以依赖\",{\"1\":{\"925\":1}}],[\"因为订单会占用商品\",{\"1\":{\"921\":1,\"1337\":1}}],[\"因为局部变量都位于栈\",{\"1\":{\"904\":1}}],[\"因为正则表达式匹配的字符编码都在\",{\"1\":{\"904\":1}}],[\"因为消息系统自身对如何更好的压缩数据和加速读取的细节更了解\",{\"1\":{\"1385\":1}}],[\"因为消息是先写入堆外内存\",{\"1\":{\"883\":1}}],[\"因为消费者每次会消费多条消息\",{\"1\":{\"1017\":1}}],[\"因为消越多柱子的时候就会吃越多的伤害\",{\"1\":{\"438\":1}}],[\"因为堆外内存中的数据未提交\",{\"1\":{\"883\":1}}],[\"因为操作系统会将一部分物理内存用作\",{\"1\":{\"879\":1}}],[\"因为比较方便\",{\"1\":{\"802\":1}}],[\"因为一个\",{\"1\":{\"1103\":1}}],[\"因为一条消息会比一个分布式定时任务轻量得多\",{\"1\":{\"921\":1,\"1337\":1}}],[\"因为一般\",{\"1\":{\"906\":1}}],[\"因为一般来说消息队列会更关心新的消息\",{\"1\":{\"787\":1}}],[\"因为一直不知道变形会解除定身\",{\"1\":{\"399\":1}}],[\"因为索引文件的\",{\"1\":{\"787\":1}}],[\"因为各种原因\",{\"1\":{\"736\":1}}],[\"因为拿不到锁的线程会让\",{\"1\":{\"733\":1}}],[\"因为写入必须被超过半数的副本接受\",{\"1\":{\"696\":1}}],[\"因为在当前的设计中\",{\"1\":{\"1297\":1}}],[\"因为在每个指标上要达到完美\",{\"1\":{\"924\":1}}],[\"因为在\",{\"1\":{\"853\":1,\"1509\":1}}],[\"因为在滚动升级时\",{\"1\":{\"693\":1}}],[\"因为在那之前没有伤害\",{\"1\":{\"451\":1}}],[\"因为重新启动的\",{\"1\":{\"678\":1}}],[\"因为队列可以跨集群迁移\",{\"1\":{\"657\":1}}],[\"因为rabbit\",{\"1\":{\"625\":1}}],[\"因为它不仅仅是类型\",{\"1\":{\"582\":1}}],[\"因为它会造成大量伤害\",{\"1\":{\"427\":1}}],[\"因为可以从等号右边推断得到\",{\"1\":{\"578\":1}}],[\"因为可以直接写if\",{\"1\":{\"333\":1}}],[\"因为数组的成员数量是不确定的\",{\"1\":{\"529\":1}}],[\"因为绝大部分使用原始类型的场合\",{\"1\":{\"509\":1}}],[\"因为没有类型检查\",{\"1\":{\"502\":1}}],[\"因为没有删除任何元素\",{\"1\":{\"298\":1}}],[\"因为减伤要留到深渊腐蚀点名的时候\",{\"1\":{\"474\":1}}],[\"因为溃烂会造成严重的\",{\"1\":{\"459\":1}}],[\"因为有后续的\",{\"1\":{\"457\":1}}],[\"因为除了老三\",{\"1\":{\"455\":1}}],[\"因为化生结束之后你会摆脱定身效果\",{\"1\":{\"427\":1}}],[\"因为距离越远躲穿刺\",{\"1\":{\"426\":1}}],[\"因为生命绽放持续时间为\",{\"1\":{\"419\":1}}],[\"因为新绿只会治疗\",{\"1\":{\"416\":1}}],[\"因为整队的单体\",{\"1\":{\"412\":1}}],[\"因为这个\",{\"1\":{\"434\":1,\"457\":1}}],[\"因为这是你性价比最高的技能\",{\"1\":{\"411\":1}}],[\"因为这套偏治疗\",{\"1\":{\"403\":1}}],[\"因为加班下班时间不固定\",{\"1\":{\"399\":1}}],[\"因为请求协议是一个标准的http请求\",{\"1\":{\"368\":1}}],[\"因为属性名是zipcode而不是zip\",{\"1\":{\"316\":1}}],[\"因为\",{\"1\":{\"188\":1,\"399\":2,\"827\":1,\"1188\":1,\"1198\":1,\"1293\":1,\"1519\":1}}],[\"因为x还没有值\",{\"1\":{\"173\":1}}],[\"因为禁用缓存后\",{\"1\":{\"95\":1}}],[\"因为把事务搞得越复杂\",{\"1\":{\"87\":1}}],[\"因为select语句既可以在事务内执行\",{\"1\":{\"87\":1}}],[\"因为应用程序在使用udp时必须指定网络接口\",{\"1\":{\"71\":1}}],[\"因为他们的ip地址前段是相同的\",{\"1\":{\"67\":1}}],[\"因为java编译器在编译时就自动把多个连续的+操作编码为stringconcatfactory的操作\",{\"1\":{\"28\":1}}],[\"因此有了事务消息的需求\",{\"1\":{\"1439\":1}}],[\"因此推荐尽可能使用集群模式\",{\"1\":{\"1090\":1}}],[\"因此业务方需要关注消费失败的情况\",{\"1\":{\"1090\":1}}],[\"因此数据还需要从内核空间拷贝到用户空间才可以被应用程序访问\",{\"1\":{\"880\":1}}],[\"因此这个参数默认值改为\",{\"1\":{\"733\":1}}],[\"因此这里就多了一次集群间的网络交互\",{\"1\":{\"668\":1}}],[\"因此触发消息流动的主要因素是\",{\"1\":{\"690\":1}}],[\"因此所有未被确认的消息都会被重新发送\",{\"1\":{\"665\":1}}],[\"因此对某些队列使用较少的镜像\",{\"1\":{\"662\":1}}],[\"因此credit\",{\"1\":{\"625\":1}}],[\"因此变熊也可以作为一个减伤来规划\",{\"1\":{\"425\":1}}],[\"因此它可以在你变猫打伤害的时候提供少量的持续治疗\",{\"1\":{\"413\":1}}],[\"因此基本上所有的列表处理函数都从提取列表头开始\",{\"1\":{\"177\":1}}],[\"因此无需担心运算溢出或无法用特定字长\",{\"1\":{\"172\":1}}],[\"因此无法引用outer\",{\"1\":{\"22\":1}}],[\"因此被称为\",{\"1\":{\"119\":1}}],[\"因此不必指定goal\",{\"1\":{\"63\":1}}],[\"因此\",{\"1\":{\"20\":1,\"87\":1,\"575\":1,\"624\":1,\"701\":1,\"702\":1,\"820\":1}}],[\"为状态机的\",{\"1\":{\"1519\":1}}],[\"为请求的轮次\",{\"1\":{\"1478\":1}}],[\"为事务消息定义了专门的生产者类型\",{\"1\":{\"1449\":1}}],[\"为当前以提交到缓冲区的\",{\"1\":{\"1427\":1}}],[\"为当前版本使用的序列化协议\",{\"1\":{\"893\":1}}],[\"为已经上传到分级存储的消息数据\",{\"1\":{\"1403\":1}}],[\"为已有的\",{\"1\":{\"1214\":1}}],[\"为异步操作\",{\"1\":{\"1403\":1}}],[\"为异步拉取方法\",{\"1\":{\"1117\":1}}],[\"为准\",{\"1\":{\"1403\":1}}],[\"为分级存储带来更多的\",{\"1\":{\"1402\":1}}],[\"为分布式系统的节点个数\",{\"1\":{\"385\":1}}],[\"为使用磁盘文件存储的默认存储实现\",{\"1\":{\"1398\":1}}],[\"为这些消息创建消费队列\",{\"1\":{\"1388\":1}}],[\"为索引文件\",{\"1\":{\"1383\":1}}],[\"为用户提供更加极致弹性的云服务\",{\"1\":{\"1378\":1}}],[\"为用户提供了主动处理这些消费多次失败的消息的可能\",{\"1\":{\"1180\":1}}],[\"为后缀名\",{\"1\":{\"1321\":1}}],[\"为它们提交消息消费进度\",{\"1\":{\"1277\":1}}],[\"为他们提交消息偏移量\",{\"1\":{\"1262\":1}}],[\"为生产者设置不同的\",{\"1\":{\"1235\":1}}],[\"为生命绽放选择正确的目标在关键时刻可以大幅提升治疗量\",{\"1\":{\"415\":1}}],[\"为重试消息恢复真正的\",{\"1\":{\"1230\":1}}],[\"为队列新建锁定标识\",{\"1\":{\"1222\":1}}],[\"为每隔队列发送持久化消费进度请求给\",{\"1\":{\"1200\":1}}],[\"为每个队列初始化分级存储消息数据文件\",{\"1\":{\"1421\":1}}],[\"为每个步骤单独定义了一个服务线程来处理\",{\"1\":{\"1348\":1}}],[\"为每个消费队列初始化消费队列锁\",{\"1\":{\"1217\":1}}],[\"为每个消费者配置固定的消息队列\",{\"1\":{\"1138\":1}}],[\"为每个消息构建消费队列时\",{\"1\":{\"1294\":1}}],[\"为每个消息队列都初始化一把锁\",{\"1\":{\"1207\":1}}],[\"为每个消息队列都向\",{\"1\":{\"1191\":1}}],[\"为每个消息创建全局唯一\",{\"1\":{\"899\":1}}],[\"为每个消息节省了1字节传输大小\",{\"1\":{\"740\":1}}],[\"为每个\",{\"1\":{\"925\":1,\"1144\":1,\"1224\":1}}],[\"为每个延迟等级创建一个deliverdelayedmessagetimertask\",{\"1\":{\"840\":1,\"844\":1}}],[\"为每个延迟等级的\",{\"1\":{\"836\":1}}],[\"为每个延迟等级都创建一个处理线程\",{\"1\":{\"834\":1}}],[\"为每个客户端连接都创建一个\",{\"1\":{\"112\":1}}],[\"为下面的失败处理逻辑使用\",{\"1\":{\"1195\":1}}],[\"为下面失败处理逻辑使用\",{\"1\":{\"1195\":1}}],[\"为广播模式和集群模式分别创建了消费进度存储类\",{\"1\":{\"1181\":1}}],[\"为推模式消费者服务\",{\"1\":{\"1169\":1}}],[\"为拉取请求设置下次拉取的偏移量\",{\"1\":{\"1165\":1}}],[\"为新增的队列新建\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"为消费索引\",{\"1\":{\"1383\":1}}],[\"为消费者分配队列消费的这一个负载过程并不是一劳永逸的\",{\"1\":{\"1098\":1}}],[\"为消息的\",{\"1\":{\"1393\":1}}],[\"为消息数据\",{\"1\":{\"1383\":1}}],[\"为消息添加多队列分发属性\",{\"1\":{\"1296\":1}}],[\"为消息分配全局唯一\",{\"1\":{\"1053\":1}}],[\"为消息扩展属性类\",{\"1\":{\"1035\":1}}],[\"为空\",{\"1\":{\"1065\":1,\"1403\":1,\"1511\":1,\"1519\":1}}],[\"为内存中存储的消息总大小\",{\"1\":{\"1065\":1}}],[\"为进程\",{\"1\":{\"1047\":1}}],[\"为不同的请求类型\",{\"1\":{\"1043\":1}}],[\"为客户端需要使用的消息类\",{\"1\":{\"1035\":1}}],[\"为所有心跳请求构造统一的请求头\",{\"1\":{\"970\":1}}],[\"为延迟消息创建了一个内部\",{\"1\":{\"925\":1}}],[\"为true\",{\"1\":{\"870\":1}}],[\"为该消费者负载的队列新建消息拉取请求\",{\"1\":{\"1219\":1}}],[\"为该\",{\"1\":{\"797\":1}}],[\"为该写满的索引文件中\",{\"1\":{\"793\":1}}],[\"为该队列应用的镜像策略\",{\"1\":{\"655\":1}}],[\"为16\",{\"1\":{\"741\":1}}],[\"为路由到该队列消息的权重\",{\"1\":{\"712\":1}}],[\"为普通队列\",{\"1\":{\"655\":1}}],[\"为镜像队列\",{\"1\":{\"655\":1}}],[\"为对象类型添加新属性\",{\"1\":{\"516\":1}}],[\"为附近最多3名受伤的盟友恢复\",{\"1\":{\"407\":1}}],[\"为附近的最多\",{\"1\":{\"401\":1}}],[\"为执行器节点分配了\",{\"1\":{\"372\":1}}],[\"为什么已经保存过的消息还要重新建一个并且保存\",{\"1\":{\"1188\":1}}],[\"为什么主流消息队列都抛弃了\",{\"1\":{\"942\":1}}],[\"为什么这里是\",{\"1\":{\"906\":1}}],[\"为什么需要预热该文件\",{\"1\":{\"882\":1}}],[\"为什么不在\",{\"1\":{\"906\":1}}],[\"为什么不实现任意时间的定时消息\",{\"0\":{\"847\":1}}],[\"为什么不直接调用\",{\"1\":{\"827\":1}}],[\"为什么所有的节点都需要缓存一份发布的消息呢\",{\"1\":{\"674\":1}}],[\"为什么要流控\",{\"0\":{\"611\":1}}],[\"为什么我的蓝经常用完\",{\"1\":{\"492\":1}}],[\"为什么我一直死\",{\"1\":{\"492\":1}}],[\"为什么选择powerjob\",{\"0\":{\"371\":1}}],[\"为什么websocket连接可以实现全双工通信而http连接不行呢\",{\"1\":{\"368\":1}}],[\"为全部\",{\"1\":{\"337\":1}}],[\"为上文描述的扩缩代价与加速比效率结果\",{\"1\":{\"285\":1}}],[\"为openchaos中度量分布式系统弹性能力的指标\",{\"1\":{\"285\":1}}],[\"为系统随机的注入故障\",{\"1\":{\"277\":1}}],[\"为避免接收语句因为消息不来而一直等待\",{\"1\":{\"232\":1}}],[\"为通常的情形编写代码并且有意忽略异常错误\",{\"1\":{\"193\":1}}],[\"为\",{\"1\":{\"191\":1,\"570\":1,\"635\":1,\"695\":1,\"711\":1,\"1065\":1,\"1195\":1,\"1197\":1,\"1198\":1,\"1267\":1,\"1278\":1,\"1288\":1,\"1293\":1,\"1297\":1,\"1318\":1,\"1325\":2,\"1367\":1,\"1382\":1,\"1403\":1,\"1424\":1,\"1427\":1,\"1453\":1,\"1463\":1,\"1519\":4}}],[\"为真\",{\"1\":{\"186\":2}}],[\"为多行执行normal命令\",{\"1\":{\"161\":1}}],[\"为有名寄存器a\",{\"1\":{\"157\":1}}],[\"为非阻塞模式\",{\"1\":{\"121\":1}}],[\"为一个友方目标恢复\",{\"1\":{\"405\":1}}],[\"为一个线程\",{\"1\":{\"120\":1}}],[\"为一个新的进程\",{\"1\":{\"4\":1}}],[\"为例\",{\"1\":{\"62\":1,\"712\":1}}],[\"为了让消费者暂时无法消费到该消息\",{\"1\":{\"1450\":1}}],[\"为了减少分级存储索引文件的\",{\"1\":{\"1411\":1}}],[\"为了减少网络请求次数\",{\"1\":{\"1044\":1}}],[\"为了加速从二级存储读取的速度和减少整体上对二级存储请求数而设置\",{\"1\":{\"1402\":1}}],[\"为了加速从二级存储读取的速度和减少整体上对二级存储的请求次数\",{\"1\":{\"1391\":1}}],[\"为了支持百万队列而引入\",{\"1\":{\"1398\":1}}],[\"为了留时间与\",{\"1\":{\"1259\":1}}],[\"为了避免瞬时保存的定时消息过多\",{\"1\":{\"1354\":1}}],[\"为了避免这个问题\",{\"1\":{\"1342\":1}}],[\"为了避免频繁检查匹配状态\",{\"1\":{\"1253\":1}}],[\"为了避免一些异常情况\",{\"1\":{\"1212\":1}}],[\"为了实现多个生产者分别发送消息到多个集群\",{\"1\":{\"1235\":1}}],[\"为了跨消费者进行消费队列负载的协调\",{\"1\":{\"1209\":1}}],[\"为了能够先后分别处理多个队列的拉取\",{\"1\":{\"1155\":1}}],[\"为了保证消费速度\",{\"1\":{\"1251\":1}}],[\"为了保证消费线程池中没有多个线程消费同一个队列\",{\"1\":{\"1217\":1}}],[\"为了保证消息消费的高可靠性\",{\"1\":{\"1180\":1}}],[\"为了保证普通消息发送的性能\",{\"1\":{\"1010\":1}}],[\"为了保证集群的安全性\",{\"1\":{\"978\":1}}],[\"为了保证可靠性\",{\"1\":{\"925\":1}}],[\"为了追求更高的性能\",{\"1\":{\"930\":1}}],[\"为了同时保证低延迟和高吞吐引入了\",{\"1\":{\"916\":1}}],[\"为了降低\",{\"1\":{\"883\":1}}],[\"为了防止定时消息在投递之前就被老化删除\",{\"1\":{\"1347\":1}}],[\"为了防止频繁进行重平衡\",{\"1\":{\"1128\":1}}],[\"为了防止缺页异常\",{\"1\":{\"882\":1}}],[\"为了防止消息存储发生混乱\",{\"1\":{\"877\":1}}],[\"为了提供差异化服务\",{\"1\":{\"847\":1}}],[\"为了提高网络性能\",{\"1\":{\"804\":1}}],[\"为了提高系统容量\",{\"1\":{\"384\":1}}],[\"为了提高性能和效率\",{\"1\":{\"54\":1}}],[\"为了方便理解\",{\"1\":{\"720\":1}}],[\"为了优化消费性能\",{\"1\":{\"687\":1}}],[\"为了解决这个问题\",{\"1\":{\"592\":1}}],[\"为了解决对象的\",{\"1\":{\"300\":1}}],[\"为了后续可以通过\",{\"1\":{\"379\":1}}],[\"为了便于模型的设计和功能的划分\",{\"1\":{\"372\":1}}],[\"为了统一集合类型\",{\"1\":{\"303\":1}}],[\"为了统一全球所有语言的编码\",{\"1\":{\"27\":1}}],[\"为了探索kafka分区的最佳使用实践\",{\"1\":{\"285\":1}}],[\"为了持久性\",{\"1\":{\"251\":1}}],[\"为了速度\",{\"1\":{\"251\":1}}],[\"中已提交的日志序号\",{\"1\":{\"1520\":1}}],[\"中已经被\",{\"1\":{\"1362\":1}}],[\"中实现\",{\"1\":{\"1508\":1}}],[\"中待分发的\",{\"1\":{\"1427\":1}}],[\"中读取\",{\"1\":{\"1415\":1}}],[\"中读取消息\",{\"1\":{\"1408\":1,\"1432\":1}}],[\"中会找到当前\",{\"1\":{\"1414\":1}}],[\"中会有耗时的业务逻辑\",{\"1\":{\"135\":1}}],[\"中真正使用的存储实现\",{\"1\":{\"1398\":1}}],[\"中处理\",{\"1\":{\"1372\":1}}],[\"中处理读请求\",{\"1\":{\"112\":1}}],[\"中还提出了另一种任意时间定时消息的实现方案\",{\"1\":{\"1364\":1}}],[\"中去查询定时消息\",{\"1\":{\"1363\":1}}],[\"中设置了\",{\"1\":{\"1362\":1}}],[\"中设置该\",{\"1\":{\"979\":1}}],[\"中取出半消息\",{\"1\":{\"1453\":1}}],[\"中取出\",{\"1\":{\"1358\":1,\"1359\":1,\"1360\":2}}],[\"中取出消息\",{\"1\":{\"1333\":1}}],[\"中新的定时消息\",{\"1\":{\"1355\":1}}],[\"中该时刻定时消息链表的最后\",{\"1\":{\"1351\":1}}],[\"中该时刻定时消息链表的第一个消息的物理偏移量\",{\"1\":{\"1351\":1}}],[\"中扫描定时消息\",{\"1\":{\"1348\":1}}],[\"中扫描新的消息\",{\"1\":{\"761\":1}}],[\"中某个元素的索引\",{\"1\":{\"1346\":1}}],[\"中就引入了这样的两个存储文件\",{\"1\":{\"1346\":1}}],[\"中就需要有相应的操作以锁定消费队列\",{\"1\":{\"1203\":1}}],[\"中终于开源了支持任意时间的定时消息\",{\"1\":{\"1338\":1}}],[\"中只支持通过设定延迟等级来支持\",{\"1\":{\"1338\":1}}],[\"中解码消息属性\",{\"1\":{\"1333\":1}}],[\"中解析出第一条和最后一条消息的\",{\"1\":{\"1408\":1,\"1432\":1}}],[\"中解析原\",{\"1\":{\"1279\":1}}],[\"中解析数据并分发请求\",{\"1\":{\"816\":1}}],[\"中拿到的\",{\"1\":{\"1321\":1}}],[\"中先后被调用\",{\"1\":{\"1318\":1}}],[\"中各个处理器处理\",{\"1\":{\"1300\":1}}],[\"中断消费\",{\"1\":{\"1278\":2}}],[\"中断而再次读取磁盘\",{\"1\":{\"879\":1}}],[\"中消息\",{\"1\":{\"1277\":1}}],[\"中消息顺序一致\",{\"1\":{\"930\":1}}],[\"中被\",{\"1\":{\"1276\":1}}],[\"中找\",{\"1\":{\"1262\":1}}],[\"中找到消息并消费\",{\"1\":{\"836\":1}}],[\"中队列数量的限制\",{\"1\":{\"1249\":1}}],[\"中引入了两个采用本地文件系统存储的文件\",{\"1\":{\"1350\":1}}],[\"中引入了的轻量化客户端就用到了\",{\"1\":{\"1249\":1}}],[\"中引入了一种新的消费模式\",{\"1\":{\"1245\":1}}],[\"中引入的一套新的\",{\"1\":{\"118\":1}}],[\"中可以注册多个生产者和消费者\",{\"1\":{\"1235\":1}}],[\"中可以使用\",{\"1\":{\"395\":1}}],[\"中准备锁定请求\",{\"1\":{\"1214\":1}}],[\"中移除\",{\"1\":{\"1277\":1}}],[\"中移除这批已经处理过的消息\",{\"1\":{\"1195\":1}}],[\"中移除该\",{\"1\":{\"954\":1,\"972\":1}}],[\"中加载整个消息体\",{\"1\":{\"1174\":1}}],[\"中拉取到的消息会先存入\",{\"1\":{\"1169\":1}}],[\"中拉取官方镜像\",{\"1\":{\"1072\":1}}],[\"中不断获取消费请求\",{\"1\":{\"1188\":1}}],[\"中不包含\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"中不会有消息被消费\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"中不是连续存储的\",{\"1\":{\"747\":1}}],[\"中重平衡策略\",{\"1\":{\"1138\":1}}],[\"中保存的消息内容进行过滤\",{\"1\":{\"1333\":1}}],[\"中保存的消息在\",{\"1\":{\"878\":1}}],[\"中保存和指定\",{\"1\":{\"1169\":1}}],[\"中保存了消费者负载的消息队列\",{\"1\":{\"1129\":1}}],[\"中弹出拉取请求\",{\"1\":{\"1104\":1}}],[\"中官方上传的镜像\",{\"1\":{\"1079\":1}}],[\"中选择了第二种方案\",{\"1\":{\"1347\":1}}],[\"中选择\",{\"1\":{\"1072\":1}}],[\"中选择一个可用的\",{\"1\":{\"1052\":1}}],[\"中删除一条消息\",{\"1\":{\"1065\":1}}],[\"中创建一个\",{\"1\":{\"1417\":1}}],[\"中创建一个进程\",{\"1\":{\"230\":1}}],[\"中创建\",{\"1\":{\"1061\":1}}],[\"中执行\",{\"1\":{\"1039\":1}}],[\"中执行的\",{\"1\":{\"1021\":1}}],[\"中默认的生产者实现\",{\"1\":{\"1036\":1}}],[\"中进行存储\",{\"1\":{\"1021\":1}}],[\"中启用消息轨迹功能\",{\"1\":{\"1005\":1}}],[\"中启动\",{\"1\":{\"983\":1}}],[\"中字段的含义\",{\"1\":{\"997\":1}}],[\"中角色\",{\"1\":{\"978\":1}}],[\"中定义了\",{\"1\":{\"978\":1}}],[\"中定义了以下几种数据类型\",{\"1\":{\"294\":1}}],[\"中支持的\",{\"1\":{\"978\":1}}],[\"中统计\",{\"1\":{\"967\":1}}],[\"中路由信息的结构\",{\"1\":{\"963\":1}}],[\"中也有定时器\",{\"1\":{\"945\":1}}],[\"中也有若干个\",{\"1\":{\"622\":2}}],[\"中存储的位置\",{\"1\":{\"1346\":1}}],[\"中存储的数据\",{\"1\":{\"1291\":1}}],[\"中存储的逻辑下标含义相同\",{\"1\":{\"787\":1}}],[\"中存储\",{\"1\":{\"944\":1}}],[\"中据说也是使用\",{\"1\":{\"942\":1}}],[\"中文件存储为内存映射文件\",{\"1\":{\"927\":1}}],[\"中将消息全部信息查出来\",{\"1\":{\"927\":1}}],[\"中将采用这种\",{\"1\":{\"773\":1}}],[\"中所说的消费速度所做的另一个改动\",{\"1\":{\"913\":1}}],[\"中所有的\",{\"1\":{\"945\":1}}],[\"中所有定时任务都是由一个工作线程单线程处理的\",{\"1\":{\"852\":1}}],[\"中所有消息的索引项\",{\"1\":{\"755\":1}}],[\"中所有\",{\"1\":{\"747\":1}}],[\"中所有代码都是单线程执行的\",{\"1\":{\"351\":1}}],[\"中直接操作\",{\"1\":{\"894\":1}}],[\"中转一下\",{\"1\":{\"894\":1}}],[\"中用的很少\",{\"1\":{\"902\":1}}],[\"中用\",{\"1\":{\"894\":1}}],[\"中多余的拷贝和对象创建\",{\"1\":{\"894\":1}}],[\"中集中记录\",{\"1\":{\"886\":1}}],[\"中继续把数据读出来\",{\"1\":{\"879\":1}}],[\"中来读取数据\",{\"1\":{\"879\":1}}],[\"中替换成了\",{\"1\":{\"840\":1}}],[\"中检查消息属性中delaylevel\",{\"1\":{\"839\":1,\"843\":1}}],[\"中是否有该半消息对应的\",{\"1\":{\"1446\":1}}],[\"中是否有到期消息\",{\"1\":{\"841\":1}}],[\"中是否有到期的消息\",{\"1\":{\"834\":1}}],[\"中是顺序的\",{\"1\":{\"733\":1}}],[\"中为了支持\",{\"1\":{\"773\":1}}],[\"中调用\",{\"1\":{\"768\":1,\"1323\":1}}],[\"中查找\",{\"1\":{\"1253\":1,\"1263\":1}}],[\"中查出原始消息\",{\"1\":{\"1359\":1}}],[\"中查出来\",{\"1\":{\"1355\":1}}],[\"中查出该消息的完整信息\",{\"1\":{\"857\":1}}],[\"中查出索引项\",{\"1\":{\"767\":2,\"1174\":1}}],[\"中查询\",{\"1\":{\"1446\":1}}],[\"中查询原始消息\",{\"1\":{\"1359\":1,\"1373\":1}}],[\"中查询完整的消息体\",{\"1\":{\"1348\":1,\"1357\":1}}],[\"中查询出\",{\"1\":{\"1358\":1}}],[\"中查询出发回的消息\",{\"1\":{\"1188\":1}}],[\"中查询出消息\",{\"1\":{\"751\":1,\"782\":1}}],[\"中查询消息完整信息\",{\"1\":{\"861\":1}}],[\"中查询消息\",{\"1\":{\"778\":1,\"786\":1,\"787\":1,\"812\":1,\"868\":1,\"878\":1,\"1164\":1}}],[\"中了\",{\"1\":{\"765\":1}}],[\"中做了交换操作\",{\"1\":{\"725\":1}}],[\"中主要有\",{\"1\":{\"1136\":1}}],[\"中主要指对\",{\"1\":{\"978\":1}}],[\"中主要存储的数据\",{\"1\":{\"944\":1}}],[\"中主要的类与我的实现中的类对应关系如下\",{\"1\":{\"135\":1}}],[\"中主从复制和同步刷盘的原理\",{\"1\":{\"723\":1}}],[\"中初始化了一个哈希环\",{\"1\":{\"716\":1}}],[\"中提出了分级存储的方案\",{\"1\":{\"1380\":1}}],[\"中提到了使用一致性哈希交换器\",{\"1\":{\"707\":1}}],[\"中提取\",{\"1\":{\"184\":1}}],[\"中发布了新的\",{\"1\":{\"675\":1}}],[\"中由工作线程消费\",{\"1\":{\"1014\":1}}],[\"中由\",{\"1\":{\"672\":1}}],[\"中添加如下配置\",{\"1\":{\"1382\":1}}],[\"中添加\",{\"1\":{\"644\":1}}],[\"中有\",{\"1\":{\"1021\":1,\"1278\":1}}],[\"中有一个码表\",{\"1\":{\"1262\":1}}],[\"中有一个客户端实例的引用\",{\"1\":{\"1118\":1}}],[\"中有一个\",{\"1\":{\"988\":1,\"994\":1}}],[\"中有一个定时任务线程\",{\"1\":{\"954\":1}}],[\"中有一个或者多个\",{\"1\":{\"622\":1}}],[\"中有数据\",{\"1\":{\"879\":1}}],[\"中有如下这些保存消息的方法\",{\"1\":{\"731\":1}}],[\"中有多个\",{\"1\":{\"131\":1}}],[\"中没有\",{\"1\":{\"1279\":1,\"1280\":1}}],[\"中没有数据\",{\"1\":{\"879\":1}}],[\"中没有一个\",{\"1\":{\"622\":1}}],[\"中没有区别\",{\"1\":{\"132\":1}}],[\"中使用多种进程来处理消息\",{\"1\":{\"614\":1}}],[\"中培植毒药的时候规划减伤\",{\"1\":{\"427\":1}}],[\"中手法不变\",{\"1\":{\"417\":1}}],[\"中间的值就是大多数节点已经确认的\",{\"1\":{\"1512\":1}}],[\"中间层是执行层\",{\"1\":{\"280\":1}}],[\"中间middle\",{\"1\":{\"145\":1}}],[\"中导入\",{\"1\":{\"191\":1}}],[\"中编译\",{\"1\":{\"180\":1}}],[\"中组件视图和运行逻辑\",{\"1\":{\"135\":1}}],[\"中流动\",{\"1\":{\"135\":1}}],[\"中包含该事务半消息的偏移量\",{\"1\":{\"1468\":1}}],[\"中包含这个消息\",{\"1\":{\"1359\":1}}],[\"中包含了分级存储所有的存储模型\",{\"1\":{\"1402\":1}}],[\"中包含了编译好的过滤表达式\",{\"1\":{\"1317\":1}}],[\"中包含了普通的\",{\"1\":{\"672\":1}}],[\"中包含两个消息\",{\"1\":{\"899\":1}}],[\"中包含重复代码的\",{\"0\":{\"731\":1}}],[\"中包含\",{\"1\":{\"125\":1,\"1342\":1}}],[\"中获取日志序号为\",{\"1\":{\"1520\":1}}],[\"中获取请求\",{\"1\":{\"1511\":3}}],[\"中获取不到消息\",{\"1\":{\"1468\":1}}],[\"中获取过滤数据\",{\"1\":{\"1324\":1}}],[\"中获取过滤信息\",{\"1\":{\"1318\":1}}],[\"中获取编译好的\",{\"1\":{\"1321\":1}}],[\"中获取顺序消息相关配置\",{\"1\":{\"973\":1}}],[\"中获取顺序消息相关的配置\",{\"1\":{\"957\":1,\"973\":1}}],[\"中获取信息\",{\"1\":{\"957\":1,\"973\":1}}],[\"中获取远端的地址\",{\"1\":{\"896\":1}}],[\"中获取的延迟等级对应的\",{\"1\":{\"845\":1}}],[\"中获取该队列消息的最大offset\",{\"1\":{\"825\":1}}],[\"中获取\",{\"1\":{\"124\":1}}],[\"中的日志序号\",{\"1\":{\"1507\":1}}],[\"中的半消息\",{\"1\":{\"1453\":1}}],[\"中的半消息进行回查\",{\"1\":{\"1446\":1}}],[\"中的最后一个索引文件\",{\"1\":{\"1412\":1}}],[\"中的最新刷盘时间\",{\"1\":{\"769\":1}}],[\"中的缓存\",{\"1\":{\"1403\":1}}],[\"中的大小\",{\"1\":{\"1371\":1}}],[\"中的定时消息放入\",{\"1\":{\"1371\":1}}],[\"中的定时消息\",{\"1\":{\"1364\":1}}],[\"中的槽位组成链表结构\",{\"1\":{\"1352\":1}}],[\"中的元素又保存它前一个元素的索引\",{\"1\":{\"1346\":1}}],[\"中的类名为\",{\"1\":{\"1300\":1}}],[\"中的拉取方法实现\",{\"1\":{\"1155\":1}}],[\"中的队列\",{\"1\":{\"1188\":1}}],[\"中的队列负载机制将一个\",{\"1\":{\"1097\":1}}],[\"中的队列如何分配给消费者的问题\",{\"1\":{\"1096\":1}}],[\"中的所有消息\",{\"1\":{\"1096\":1,\"1280\":1}}],[\"中的一个\",{\"1\":{\"1095\":1}}],[\"中的镜像地址\",{\"1\":{\"1079\":1}}],[\"中的镜像地址改为了官方镜像地址\",{\"1\":{\"1075\":1}}],[\"中的镜像\",{\"1\":{\"1079\":1}}],[\"中的概念\",{\"1\":{\"978\":1}}],[\"中的路由表\",{\"1\":{\"971\":1}}],[\"中的路由信息主要指的是前面说到的\",{\"1\":{\"949\":1}}],[\"中的几个路由信息表\",{\"1\":{\"953\":1}}],[\"中的任务拿出来放到下一\",{\"1\":{\"931\":1}}],[\"中的消息处理器处理该生产请求\",{\"1\":{\"1507\":1}}],[\"中的消息进行匹配\",{\"1\":{\"1453\":1}}],[\"中的消息写入到\",{\"1\":{\"1371\":1}}],[\"中的消息类主要有\",{\"1\":{\"1035\":1}}],[\"中的消息也遵循先生产先消费\",{\"1\":{\"1028\":1}}],[\"中的消息\",{\"1\":{\"930\":1,\"1253\":1,\"1278\":2,\"1354\":1,\"1403\":1}}],[\"中的消息都是按照消息产生的时间顺序发送的\",{\"1\":{\"836\":1}}],[\"中的对应\",{\"1\":{\"925\":1}}],[\"中的反向\",{\"0\":{\"888\":1}}],[\"中的逻辑\",{\"1\":{\"857\":1}}],[\"中的逻辑偏移量\",{\"1\":{\"751\":1,\"765\":1}}],[\"中的绝对物理偏移量\",{\"1\":{\"780\":1}}],[\"中的偏移量\",{\"1\":{\"782\":1,\"787\":1,\"836\":1,\"877\":1}}],[\"中的偏移量和消息大小\",{\"1\":{\"751\":1}}],[\"中的偏移量即可找到消息保存的位置\",{\"1\":{\"747\":1}}],[\"中的索引项\",{\"1\":{\"751\":1}}],[\"中的位置去\",{\"1\":{\"878\":1}}],[\"中的位置以便消费\",{\"1\":{\"867\":1}}],[\"中的位置\",{\"1\":{\"751\":1}}],[\"中的物理偏移量\",{\"1\":{\"749\":1,\"778\":1,\"786\":1,\"787\":1,\"868\":1,\"1367\":2,\"1368\":1,\"1371\":1,\"1372\":1,\"1386\":1}}],[\"中的每个槽位都可以保存一个指向\",{\"1\":{\"1346\":1}}],[\"中的每个消息数据都会在磁盘上存储\",{\"1\":{\"1290\":1}}],[\"中的每个\",{\"1\":{\"749\":1,\"1091\":1}}],[\"中的起始物理偏移量offset\",{\"1\":{\"747\":1}}],[\"中的属性哈希码进行过滤\",{\"1\":{\"1328\":1,\"1333\":1}}],[\"中的属性\",{\"1\":{\"742\":1}}],[\"中的过程\",{\"1\":{\"741\":1}}],[\"中的数据写入分级存储文件中\",{\"1\":{\"1428\":1}}],[\"中的数据写入\",{\"1\":{\"765\":1}}],[\"中的数据\",{\"1\":{\"730\":1}}],[\"中的下一个选中的\",{\"1\":{\"131\":1}}],[\"中的内容写到客户端\",{\"1\":{\"125\":1}}],[\"中的\",{\"0\":{\"135\":1},\"1\":{\"118\":1,\"119\":1,\"131\":1,\"135\":1,\"173\":1,\"391\":1,\"714\":1,\"737\":1,\"765\":1,\"880\":1,\"941\":1,\"949\":1,\"978\":1,\"1079\":1,\"1094\":1,\"1120\":1,\"1131\":1,\"1235\":1,\"1262\":1,\"1276\":1,\"1359\":1,\"1421\":1,\"1428\":1}}],[\"中描述了\",{\"1\":{\"108\":1}}],[\"中抛出异常\",{\"1\":{\"34\":1}}],[\"中\",{\"1\":{\"27\":1,\"118\":1,\"120\":1,\"121\":1,\"122\":2,\"127\":1,\"132\":1,\"384\":1,\"396\":1,\"613\":1,\"622\":1,\"623\":1,\"673\":1,\"727\":1,\"736\":1,\"738\":2,\"741\":1,\"747\":1,\"755\":1,\"756\":2,\"812\":1,\"815\":1,\"816\":1,\"836\":1,\"876\":1,\"879\":1,\"880\":1,\"883\":1,\"897\":1,\"915\":1,\"925\":3,\"930\":3,\"949\":1,\"950\":1,\"952\":1,\"956\":1,\"1010\":1,\"1012\":1,\"1021\":1,\"1027\":1,\"1094\":1,\"1100\":1,\"1104\":1,\"1118\":1,\"1120\":1,\"1155\":1,\"1188\":2,\"1197\":1,\"1253\":3,\"1257\":1,\"1278\":1,\"1290\":1,\"1294\":2,\"1300\":1,\"1318\":1,\"1319\":2,\"1321\":1,\"1323\":2,\"1332\":2,\"1342\":1,\"1348\":1,\"1358\":1,\"1360\":1,\"1364\":1,\"1371\":1,\"1435\":1,\"1446\":2,\"1450\":1,\"1451\":1,\"1453\":3,\"1464\":3,\"1507\":3,\"1508\":1,\"1509\":1,\"1517\":3,\"1518\":1}}],[\"汉字\",{\"1\":{\"27\":1}}],[\"最小日志序号开始同步\",{\"1\":{\"1519\":1}}],[\"最小仅依赖关系型数据库\",{\"1\":{\"371\":1}}],[\"最坏的情况下\",{\"1\":{\"1468\":1}}],[\"最理想的终态可以是两者的结合\",{\"1\":{\"1385\":1}}],[\"最新日志的\",{\"1\":{\"1502\":1}}],[\"最新\",{\"1\":{\"1351\":1,\"1367\":1}}],[\"最新的\",{\"1\":{\"1075\":1,\"1294\":1}}],[\"最佳实践\",{\"0\":{\"1231\":1},\"1\":{\"1538\":1}}],[\"最基础的操作之一\",{\"1\":{\"1024\":1}}],[\"最长延迟可达\",{\"1\":{\"937\":1}}],[\"最长保存3天\",{\"1\":{\"833\":1}}],[\"最初\",{\"1\":{\"840\":1}}],[\"最大日志序号\",{\"1\":{\"1519\":2}}],[\"最大日志条目\",{\"1\":{\"1502\":1}}],[\"最大可用的内存默认为\",{\"1\":{\"1406\":1}}],[\"最大可存储的\",{\"1\":{\"787\":1}}],[\"最大的区别在于分级存储模型的组织形式\",{\"1\":{\"1386\":1}}],[\"最大内存的一定比例\",{\"1\":{\"1382\":1}}],[\"最大预读缓存大小\",{\"1\":{\"1382\":1}}],[\"最大重试次数\",{\"1\":{\"1297\":1}}],[\"最大挂起时间\",{\"1\":{\"1173\":1}}],[\"最大拉取的消息数量\",{\"1\":{\"1149\":1}}],[\"最大拉取消息条数\",{\"1\":{\"1117\":1}}],[\"最大不超过\",{\"1\":{\"927\":1}}],[\"最大\",{\"1\":{\"922\":1,\"1497\":1}}],[\"最大返回结果数量\",{\"1\":{\"797\":1}}],[\"最大查找消息数量\",{\"1\":{\"794\":1}}],[\"最大化野性之心效果\",{\"0\":{\"417\":1}}],[\"最大化百花齐放的效果\",{\"0\":{\"416\":1}}],[\"最大化生命绽放的效果\",{\"0\":{\"415\":1}}],[\"最大化活动窗口的宽度\",{\"1\":{\"153\":1}}],[\"最大化活动窗口的高度\",{\"1\":{\"153\":1}}],[\"最晚的消息存储时间\",{\"1\":{\"787\":1}}],[\"最早的消息存储时间\",{\"1\":{\"787\":1}}],[\"最早之前\",{\"1\":{\"733\":1}}],[\"最老的从节点会被提升为新的主节点\",{\"1\":{\"659\":1}}],[\"最优先驱散熵能诅咒\",{\"1\":{\"473\":1}}],[\"最后的\",{\"1\":{\"1520\":1}}],[\"最后如果请求拉票节点的\",{\"1\":{\"1492\":1}}],[\"最后如果开启索引构建的话\",{\"1\":{\"1388\":1}}],[\"最后上传到分级存储\",{\"1\":{\"1411\":1}}],[\"最后再查询缓存\",{\"1\":{\"1409\":1}}],[\"最后将新索引文件内容上传到二级存储\",{\"1\":{\"1394\":1}}],[\"最后将消息保存到磁盘\",{\"1\":{\"834\":1}}],[\"最后从分级存储中读取消息数据并返回\",{\"1\":{\"1391\":1}}],[\"最后位置\",{\"1\":{\"1351\":1}}],[\"最后释放锁容器的锁\",{\"1\":{\"1214\":1}}],[\"最后判断一次队列是否被丢弃\",{\"1\":{\"1188\":1}}],[\"最后进行源码的解析\",{\"1\":{\"976\":1}}],[\"最后进行进行刷盘\",{\"1\":{\"883\":1}}],[\"最后启动一个消费者来消费事务消息\",{\"1\":{\"1444\":1}}],[\"最后启动定时任务\",{\"1\":{\"1421\":1}}],[\"最后启动\",{\"1\":{\"960\":1}}],[\"最后添加\",{\"1\":{\"947\":1,\"961\":1}}],[\"最后注册关闭钩子函数\",{\"1\":{\"947\":1,\"960\":1}}],[\"最后创建\",{\"1\":{\"947\":1}}],[\"最后讲解了定时消息取消的设计和实现\",{\"1\":{\"936\":1}}],[\"最后是取消的触发方式\",{\"1\":{\"935\":1}}],[\"最后配合\",{\"1\":{\"882\":1}}],[\"最后才能删除该文件\",{\"1\":{\"870\":1}}],[\"最后一次延迟\",{\"1\":{\"1180\":1}}],[\"最后一次写入后\",{\"1\":{\"866\":1}}],[\"最后一个文件格式与本地存储的\",{\"1\":{\"1386\":1}}],[\"最后一个文件需要加锁\",{\"1\":{\"794\":1}}],[\"最后一个\",{\"1\":{\"1278\":1}}],[\"最后一个是指针\",{\"1\":{\"797\":1}}],[\"最后一部分展望未来\",{\"1\":{\"275\":1}}],[\"最后更新整个队列的可用偏移量\",{\"1\":{\"759\":1,\"771\":1}}],[\"最后\",{\"1\":{\"438\":1,\"990\":1,\"1300\":1,\"1398\":1}}],[\"最好可以连续读\",{\"1\":{\"1418\":1}}],[\"最好的方式是以业务唯一标识作为幂等处理的关键依据\",{\"1\":{\"1237\":1}}],[\"最好不要一直放在自己身上\",{\"1\":{\"415\":1}}],[\"最好是\",{\"1\":{\"411\":1}}],[\"最好通过封装的inherits函数完成\",{\"1\":{\"342\":1}}],[\"最省心的是不用变猫\",{\"1\":{\"403\":1}}],[\"最多重试\",{\"1\":{\"1414\":1}}],[\"最多重试消费\",{\"1\":{\"1100\":1}}],[\"最多等待\",{\"1\":{\"1225\":1}}],[\"最多遍历\",{\"1\":{\"1164\":1}}],[\"最多只能被\",{\"1\":{\"1095\":1}}],[\"最多只能被一个消费者订阅\",{\"1\":{\"1094\":1}}],[\"最多删除\",{\"1\":{\"870\":1}}],[\"最多可以有\",{\"1\":{\"1203\":1}}],[\"最多可以保存\",{\"1\":{\"787\":1}}],[\"最多可延长至超过最大持续时间的30\",{\"1\":{\"419\":1}}],[\"最多打\",{\"1\":{\"485\":1}}],[\"最多叠加\",{\"1\":{\"401\":1}}],[\"最多支持到版本61\",{\"1\":{\"25\":1}}],[\"最快速的提升方法就是抄职业选手的作业\",{\"1\":{\"399\":1}}],[\"最简单的\",{\"1\":{\"642\":1}}],[\"最简单的哈希算法是通过将\",{\"1\":{\"385\":1}}],[\"最简单的方式是第三种\",{\"1\":{\"85\":1}}],[\"最终向主节点反馈最小的超时日志序号\",{\"1\":{\"1520\":1}}],[\"最终没有选用这种方案的考量\",{\"1\":{\"1364\":1}}],[\"最终的\",{\"1\":{\"1317\":1}}],[\"最终的存储方案就很明确了\",{\"1\":{\"929\":1}}],[\"最终投递到\",{\"1\":{\"1263\":1}}],[\"最终处理加锁逻辑\",{\"1\":{\"1214\":1}}],[\"最终调用\",{\"1\":{\"1056\":1}}],[\"最终可能导致集群不可用\",{\"1\":{\"702\":1}}],[\"最终集群中的磁盘上存储了\",{\"1\":{\"701\":1}}],[\"最终会调用\",{\"1\":{\"814\":1,\"970\":1}}],[\"最终会收到自己发送的操作命令\",{\"1\":{\"673\":1}}],[\"最终会导致它的上游\",{\"1\":{\"622\":1}}],[\"最终内存溢出并崩溃\",{\"1\":{\"611\":1}}],[\"最终\",{\"1\":{\"365\":1,\"621\":1,\"700\":1}}],[\"最终使用客户端对分布式系统执行操作\",{\"1\":{\"280\":1}}],[\"最终也是通过执行jdbc事务来实现功能的\",{\"1\":{\"87\":1}}],[\"最下层为被测组件\",{\"1\":{\"280\":1}}],[\"最上层为管理层\",{\"1\":{\"280\":1}}],[\"最常用的内置函数\",{\"1\":{\"185\":1}}],[\"最常用的注入是通过classpath以classpath\",{\"1\":{\"83\":1}}],[\"最强\",{\"0\":{\"137\":1}}],[\"最重要的是设计它的逻辑结构和文件存储结构\",{\"1\":{\"785\":1}}],[\"最重要的\",{\"1\":{\"53\":1}}],[\"最高位始终为0\",{\"1\":{\"27\":1}}],[\"数量为\",{\"1\":{\"1403\":1}}],[\"数量为自身分配负载的队列\",{\"1\":{\"1104\":1}}],[\"数量可能会非常多\",{\"1\":{\"1290\":1}}],[\"数量特别多时\",{\"1\":{\"910\":1}}],[\"数量固定的项目归组成单一的实体\",{\"1\":{\"176\":1}}],[\"数值很强的美化\",{\"1\":{\"484\":1}}],[\"数值很强的随机次要属性触发饰品\",{\"1\":{\"483\":1}}],[\"数值上增加了\",{\"1\":{\"399\":1}}],[\"数字\",{\"0\":{\"215\":1},\"1\":{\"175\":1,\"294\":1}}],[\"数字和常用符号的编码\",{\"1\":{\"27\":1}}],[\"数组生成一个签名\",{\"1\":{\"995\":1}}],[\"数组是只读数组的子类型\",{\"1\":{\"524\":1}}],[\"数组的成员类型写在方括号外面\",{\"1\":{\"527\":1}}],[\"数组的类型推断\",{\"0\":{\"523\":1}}],[\"数组的偏移量和最大填充数\",{\"1\":{\"53\":1}}],[\"数组在\",{\"1\":{\"521\":1}}],[\"数组和函数\",{\"1\":{\"512\":1}}],[\"数组\",{\"0\":{\"298\":1,\"521\":1},\"1\":{\"36\":1,\"53\":1,\"131\":1,\"294\":1,\"506\":1,\"995\":1}}],[\"数据不一致\",{\"1\":{\"1520\":1}}],[\"数据接收处理线程\",{\"1\":{\"1520\":1}}],[\"数据存在差异\",{\"1\":{\"1519\":1}}],[\"数据存储模块\",{\"1\":{\"944\":1}}],[\"数据转发线程\",{\"1\":{\"1519\":1}}],[\"数据复制线程\",{\"1\":{\"1514\":1}}],[\"数据上传完成之后被调用\",{\"1\":{\"1414\":1}}],[\"数据的\",{\"1\":{\"1395\":1}}],[\"数据组织结构\",{\"0\":{\"1383\":1}}],[\"数据量膨胀过快\",{\"1\":{\"1378\":1}}],[\"数据都放到消息体中\",{\"1\":{\"1259\":1}}],[\"数据是否为空\",{\"1\":{\"998\":1}}],[\"数据是序列化后的json\",{\"1\":{\"890\":1}}],[\"数据直接从page\",{\"1\":{\"879\":1}}],[\"数据分片\",{\"1\":{\"384\":1}}],[\"数据清理的定时线程\",{\"1\":{\"374\":1}}],[\"数据类型\",{\"0\":{\"294\":1}}],[\"数据类型和变量\",{\"0\":{\"293\":1}}],[\"数据表既可以保存在内存里\",{\"1\":{\"251\":1}}],[\"数据库如\",{\"1\":{\"928\":1}}],[\"数据库与中间件\",{\"1\":{\"277\":1}}],[\"数据库查询\",{\"0\":{\"253\":1}}],[\"数据库\",{\"0\":{\"251\":1},\"1\":{\"252\":1}}],[\"数据构造和模式中的参数\",{\"1\":{\"180\":1}}],[\"数据可以在\",{\"1\":{\"135\":1}}],[\"数据被直接写入byte\",{\"1\":{\"73\":1}}],[\"数据缓冲区大小\",{\"1\":{\"1517\":1}}],[\"数据缓冲区\",{\"1\":{\"72\":1}}],[\"数据包也是一次收发一个\",{\"1\":{\"71\":1}}],[\"数据\",{\"1\":{\"9\":1,\"247\":1,\"1420\":1}}],[\"​\",{\"1\":{\"25\":1,\"852\":1}}],[\"即投票\",{\"1\":{\"1521\":1}}],[\"即投递的时间段\",{\"1\":{\"927\":1}}],[\"即多余的数据\",{\"1\":{\"1519\":1}}],[\"即挂起的日志数量超过\",{\"1\":{\"1519\":1}}],[\"即对端未准备好\",{\"1\":{\"1497\":1}}],[\"即下一条\",{\"1\":{\"1497\":1}}],[\"即该消息已经被提交或回滚\",{\"1\":{\"1468\":1}}],[\"即该时间段内要投递的所有消息位置信息\",{\"1\":{\"927\":1}}],[\"即事务消息发送一段时间之内不进行回查\",{\"1\":{\"1453\":1,\"1468\":1}}],[\"即超过文件保存时间\",{\"1\":{\"1453\":1,\"1468\":1}}],[\"即超过最大回查次数\",{\"1\":{\"1453\":1,\"1468\":1}}],[\"即超过预读缓存最多可用内存的\",{\"1\":{\"1407\":1}}],[\"即压缩后的索引文件\",{\"1\":{\"1435\":1}}],[\"即只有在本地存储中不存在时才会读取分级存储\",{\"1\":{\"1382\":1}}],[\"即只可能处于alpha\",{\"1\":{\"690\":1}}],[\"即上图中标记为\",{\"1\":{\"1300\":1}}],[\"即进入不可见时间\",{\"1\":{\"1251\":1}}],[\"即并发消费和顺序消费\",{\"1\":{\"1203\":1}}],[\"即过滤数据\",{\"1\":{\"1173\":1}}],[\"即不流控\",{\"1\":{\"1145\":1}}],[\"即实现\",{\"1\":{\"1119\":1}}],[\"即消息到达消息队列服务端后不会马上投递\",{\"1\":{\"1337\":1}}],[\"即消息的存储时间\",{\"1\":{\"1467\":1}}],[\"即消息的\",{\"1\":{\"1006\":1}}],[\"即消费线程池同时消费多个队列的消息\",{\"1\":{\"1204\":1}}],[\"即消费者端\",{\"1\":{\"1131\":1}}],[\"即消费者接口\",{\"1\":{\"1116\":1}}],[\"即图中的红黑树\",{\"1\":{\"1104\":1}}],[\"即生产发送的消息\",{\"1\":{\"1017\":1}}],[\"即访问控制列表\",{\"1\":{\"976\":1}}],[\"即定时消息投递线程\",{\"1\":{\"930\":1}}],[\"即在消费一个队列时\",{\"1\":{\"1102\":1}}],[\"即在\",{\"1\":{\"910\":1}}],[\"即需要足够多的从节点存储了该消息后\",{\"1\":{\"853\":1}}],[\"即索引文件记录的强制刷盘时间来恢复\",{\"1\":{\"789\":1}}],[\"即使用\",{\"1\":{\"1364\":1}}],[\"即使找不到订阅关系\",{\"1\":{\"1170\":1}}],[\"即使消息端一直从mq读取消息\",{\"1\":{\"879\":1}}],[\"即使写入的数量不足flushconsumequeueleastpages\",{\"1\":{\"769\":1}}],[\"即使是保存到磁盘的消息\",{\"1\":{\"681\":1}}],[\"即每个文件大小相同的内存映射文件队列\",{\"1\":{\"746\":1}}],[\"即每个节点都在哈希环上\",{\"1\":{\"388\":1}}],[\"即一个队列同一时间只能被一个消费者的一个线程消费\",{\"1\":{\"1204\":1}}],[\"即一个应用程序用tcp占用了端口1234\",{\"1\":{\"71\":1}}],[\"即一致性哈希交换器\",{\"1\":{\"711\":1}}],[\"即某个队列的消息或流量非常大\",{\"1\":{\"707\":1}}],[\"即重启之后该队列还会存在\",{\"1\":{\"684\":1}}],[\"即保证组中活着的节点要么都收到消息要么都收不到\",{\"1\":{\"673\":1}}],[\"即接收生产者发布的消息\",{\"1\":{\"671\":1}}],[\"即编译时指定\",{\"1\":{\"597\":1}}],[\"即函数不会正常执行结束\",{\"1\":{\"542\":1}}],[\"即便没有达到\",{\"1\":{\"1409\":1}}],[\"即便消费组中有多个消费者都订阅同一\",{\"1\":{\"1090\":1}}],[\"即便有小部分的副本仍然可用\",{\"1\":{\"703\":1}}],[\"即便自己吃大红\",{\"1\":{\"448\":1}}],[\"即便主节点已经成功转移\",{\"1\":{\"284\":1}}],[\"即为完成仲裁的日志序号\",{\"1\":{\"1521\":1}}],[\"即为重新调了一次pullmessageprocessor业务处理器的processrequest\",{\"1\":{\"820\":1}}],[\"即为路由到的节点\",{\"1\":{\"395\":1}}],[\"即为按\",{\"1\":{\"391\":1}}],[\"即将需要调度执行为条件查询jobinfo表\",{\"1\":{\"374\":1}}],[\"即承担\",{\"1\":{\"372\":1}}],[\"即提供\",{\"1\":{\"372\":1}}],[\"即可在收到消息时自动消费\",{\"1\":{\"1117\":1}}],[\"即可解码出多条消息\",{\"1\":{\"1044\":1}}],[\"即可以用字面量表示的对象\",{\"1\":{\"512\":1}}],[\"即可以写入数据\",{\"1\":{\"118\":1}}],[\"即可显示\",{\"1\":{\"480\":1}}],[\"即可\",{\"1\":{\"273\":1}}],[\"即返回true或false的函数\",{\"1\":{\"184\":1}}],[\"即ssh\",{\"1\":{\"171\":1}}],[\"即sessionfactory持有连接池\",{\"1\":{\"89\":1}}],[\"即\",{\"1\":{\"121\":1,\"622\":1,\"866\":1,\"1080\":1,\"1467\":1,\"1477\":1,\"1483\":1}}],[\"即有数据可读\",{\"1\":{\"118\":1}}],[\"即认为方法签名相同\",{\"1\":{\"76\":1}}],[\"即以char为单位读取\",{\"1\":{\"57\":1}}],[\"即以byte为单位读取\",{\"1\":{\"57\":1}}],[\"即读取和写入是阻塞的\",{\"1\":{\"53\":1}}],[\"即把泛型类型t的上界限定在number了\",{\"1\":{\"49\":1}}],[\"即class版本55\",{\"1\":{\"25\":1}}],[\"即存放src和bin的父目录\",{\"1\":{\"21\":1}}],[\"就保存着\",{\"1\":{\"1317\":1}}],[\"就意味着同一条消息会保存到多个\",{\"1\":{\"1290\":1}}],[\"就必定存在并发消费\",{\"1\":{\"1203\":1}}],[\"就必须用javascript发送这个新请求\",{\"1\":{\"347\":1}}],[\"就需要在从节点也启动一个\",{\"1\":{\"930\":1}}],[\"就需要通过cglib或者javassist这些第三方库实现\",{\"1\":{\"85\":1}}],[\"就不能把这个位设为有效\",{\"1\":{\"1171\":1}}],[\"就不会进行对应消费组的重平衡主动触发\",{\"1\":{\"1128\":1}}],[\"就不可避免地变低\",{\"1\":{\"924\":1}}],[\"就不走\",{\"1\":{\"903\":1}}],[\"就不再对该值进行类型推断\",{\"1\":{\"589\":1}}],[\"就变成了一个串行化的操作\",{\"1\":{\"877\":1}}],[\"就触发请求再次执行\",{\"1\":{\"823\":1}}],[\"就唤醒该请求\",{\"1\":{\"815\":1}}],[\"就向\",{\"1\":{\"804\":1}}],[\"就完事的\",{\"1\":{\"733\":1}}],[\"就知道该操作命令都同步到了所有的\",{\"1\":{\"673\":1}}],[\"就设置套接字属性为\",{\"1\":{\"625\":1}}],[\"就看原始脚本采用什么模块格式\",{\"1\":{\"597\":1}}],[\"就拥有了指定的类型结构\",{\"1\":{\"558\":1}}],[\"就符合这个类型声明\",{\"1\":{\"553\":1}}],[\"就表示某个函数肯定不会返回值\",{\"1\":{\"542\":1}}],[\"就表示为infinity\",{\"1\":{\"294\":1}}],[\"就属于联合类型a|b\",{\"1\":{\"515\":1}}],[\"就是在同一时刻定时了超大量的消息\",{\"1\":{\"1344\":1}}],[\"就是在这里的对面的\",{\"1\":{\"1300\":1}}],[\"就是在参数列表前面加上new命令\",{\"1\":{\"548\":1}}],[\"就是它这批消息需要被尝试重试\",{\"1\":{\"1253\":1}}],[\"就是重平衡实现\",{\"1\":{\"1137\":1}}],[\"就是这样做的\",{\"1\":{\"1116\":1}}],[\"就是这么做的\",{\"1\":{\"806\":1}}],[\"就是我们实际消费中需要新建的消费者对象\",{\"1\":{\"1109\":1}}],[\"就是为了解决这些问题设计的\",{\"1\":{\"941\":1}}],[\"就是为了解决消息排序的问题\",{\"1\":{\"836\":1}}],[\"就是检查这个名称的字符是否在一些字符范围内\",{\"1\":{\"904\":1}}],[\"就是操作系统在内存中给磁盘上的文件建立的缓存\",{\"1\":{\"879\":1}}],[\"就是移动磁头\",{\"1\":{\"876\":1}}],[\"就是\",{\"1\":{\"827\":1}}],[\"就是新的消息写入后\",{\"1\":{\"806\":1}}],[\"就是用来创建\",{\"1\":{\"756\":1}}],[\"就是把锁内干的事情\",{\"1\":{\"736\":1}}],[\"就是一个全局的脚本文件\",{\"1\":{\"591\":1}}],[\"就是一个模块\",{\"1\":{\"591\":1}}],[\"就是下面这样\",{\"1\":{\"499\":1}}],[\"就是送的\",{\"1\":{\"445\":1}}],[\"就越难\",{\"1\":{\"426\":1}}],[\"就往左边走\",{\"1\":{\"425\":1}}],[\"就够了\",{\"1\":{\"380\":1}}],[\"就可以拉取消息进行消费\",{\"1\":{\"1288\":1}}],[\"就可以识别\",{\"1\":{\"1287\":1}}],[\"就可以通过偏移量查询到这条消息的完整信息\",{\"1\":{\"1188\":1}}],[\"就可以定义出相应的方法\",{\"1\":{\"1117\":1}}],[\"就可以知道整个\",{\"1\":{\"941\":1}}],[\"就可以实现高性能高可靠的定时消息\",{\"1\":{\"925\":1}}],[\"就可以达到另一个的效果\",{\"1\":{\"920\":1}}],[\"就可以随着栈帧出栈而自动销毁\",{\"1\":{\"904\":1}}],[\"就可以用该项中的偏移量从\",{\"1\":{\"836\":1}}],[\"就可以应对普通的\",{\"1\":{\"415\":1}}],[\"就可以在启动时关闭任务注册功能\",{\"1\":{\"273\":1}}],[\"就可以使用\",{\"1\":{\"191\":1}}],[\"就可以把jar包放到classpath中\",{\"1\":{\"24\":1}}],[\"就会在分发时构建\",{\"1\":{\"1293\":1}}],[\"就会造成二阶段消息丢失导致大量回查\",{\"1\":{\"734\":1}}],[\"就会导致节点间负载不均衡\",{\"1\":{\"707\":1}}],[\"就会阻塞上游进程向它发送消息\",{\"1\":{\"619\":1}}],[\"就会自动声明一个公开属性x\",{\"1\":{\"576\":1}}],[\"就会推断该参数的类型为any\",{\"1\":{\"533\":1}}],[\"就会推断该变量是值类型\",{\"1\":{\"514\":1}}],[\"就会认为该变量的类型是any\",{\"1\":{\"502\":1}}],[\"就会将数据水平切分到不同的节点来存储\",{\"1\":{\"384\":1}}],[\"就会返回如下响应\",{\"1\":{\"368\":1}}],[\"就会把它们放到包含文件里\",{\"1\":{\"211\":1}}],[\"就会被转换成一个描述此错误的\",{\"1\":{\"195\":1}}],[\"就会被广播给当前进程链接的所有进程\",{\"1\":{\"193\":1}}],[\"就会执行\",{\"1\":{\"188\":1}}],[\"就会发生异常错误\",{\"1\":{\"187\":1}}],[\"就会使用默认值throw\",{\"1\":{\"194\":1}}],[\"就会使用\",{\"1\":{\"135\":1}}],[\"就开始搜索\",{\"1\":{\"167\":1}}],[\"就绪事件以外\",{\"1\":{\"135\":1}}],[\"就绪的是客户端\",{\"1\":{\"122\":1}}],[\"就绪的是客户端连接事件\",{\"1\":{\"122\":1}}],[\"就绪的事件\",{\"1\":{\"121\":1}}],[\"就叫spring\",{\"1\":{\"93\":1}}],[\"就加入到当前事务\",{\"1\":{\"87\":1}}],[\"就相当于完成了所有业务功能\",{\"1\":{\"85\":1}}],[\"就返回一个socket实例\",{\"1\":{\"69\":1}}],[\"就直接根据完整类名查找这个class\",{\"1\":{\"20\":1}}],[\"不等于\",{\"1\":{\"1519\":1}}],[\"不等待\",{\"1\":{\"1027\":1,\"1519\":1}}],[\"不相等\",{\"1\":{\"1519\":1}}],[\"不相等则表示该文件发生过修改\",{\"1\":{\"999\":1}}],[\"不相等则更新\",{\"1\":{\"999\":1}}],[\"不保证\",{\"1\":{\"1519\":1}}],[\"不保证普通消息消费的顺序\",{\"1\":{\"1028\":1}}],[\"不增加投票轮次\",{\"1\":{\"1497\":1}}],[\"不增加\",{\"1\":{\"1491\":1}}],[\"不一致\",{\"1\":{\"1489\":1,\"1520\":1}}],[\"不一致则返回异常\",{\"1\":{\"991\":1,\"1000\":1}}],[\"不停回查\",{\"1\":{\"1468\":1}}],[\"不停地尝试从消息轨迹队列中获取一批数据\",{\"1\":{\"1021\":1}}],[\"不确定回查是否能够请求到\",{\"1\":{\"1468\":1}}],[\"不确定元组成员类型和数量\",{\"1\":{\"527\":1}}],[\"不变<\",{\"1\":{\"1435\":1}}],[\"不变\",{\"1\":{\"1418\":1}}],[\"不受\",{\"1\":{\"1347\":1}}],[\"不建议以message\",{\"1\":{\"1237\":1}}],[\"不建议开启\",{\"1\":{\"1234\":1}}],[\"不建议使用\",{\"1\":{\"333\":1}}],[\"不匹配则直接跳过该条消息\",{\"1\":{\"1174\":1}}],[\"不表示消费成功\",{\"1\":{\"1173\":1}}],[\"不本地构建了\",{\"1\":{\"1076\":1}}],[\"不启用\",{\"1\":{\"1052\":1}}],[\"不在内存中的\",{\"1\":{\"1390\":1,\"1405\":1}}],[\"不在本地存储中的\",{\"1\":{\"1390\":1,\"1405\":1}}],[\"不在对应\",{\"1\":{\"1293\":1}}],[\"不在乎消息是否成功存储在\",{\"1\":{\"1027\":1}}],[\"不在任何函数内定义的变量就具有全局作用域\",{\"1\":{\"312\":1}}],[\"不进行后续的其他权限校验\",{\"1\":{\"978\":1}}],[\"不存在\",{\"1\":{\"1520\":2}}],[\"不存在返回\",{\"1\":{\"1511\":1}}],[\"不存在则创建集群\",{\"1\":{\"971\":1}}],[\"不存在全局变量或私有变量的说法\",{\"1\":{\"173\":1}}],[\"不希望将其他第三方组件引入开源\",{\"1\":{\"928\":1}}],[\"不希望包含原始类型\",{\"1\":{\"512\":1}}],[\"不支持对重试主题的属性进行过滤\",{\"1\":{\"1173\":1}}],[\"不支持\",{\"1\":{\"925\":1}}],[\"不支持任意时间的定时消息\",{\"1\":{\"833\":1}}],[\"不换进行\",{\"1\":{\"882\":1}}],[\"不做操作\",{\"1\":{\"861\":1}}],[\"不愿意开源\",{\"1\":{\"847\":1}}],[\"不再使用非连续的链表形式\",{\"1\":{\"1393\":1}}],[\"不再将所有队列的消息数据都存在一起\",{\"1\":{\"1386\":1}}],[\"不再会发送到失败的\",{\"1\":{\"1234\":1}}],[\"不再赘述\",{\"1\":{\"843\":1}}],[\"不再直接绑定服务端\",{\"1\":{\"132\":1}}],[\"不为空\",{\"1\":{\"1428\":1}}],[\"不为\",{\"1\":{\"840\":1}}],[\"不出意外的话\",{\"1\":{\"773\":1}}],[\"不设置\",{\"1\":{\"657\":1}}],[\"不属于全局作用域\",{\"1\":{\"591\":1}}],[\"不行\",{\"1\":{\"564\":1}}],[\"不允许使用type多次定义同一个类型\",{\"1\":{\"564\":1}}],[\"不允许动态添加属性\",{\"1\":{\"556\":1}}],[\"不允许随机增删\",{\"1\":{\"495\":1}}],[\"不触发严格字面量检查\",{\"1\":{\"555\":1}}],[\"不管这个对象有多少属性\",{\"1\":{\"553\":1}}],[\"不使用包装对象\",{\"1\":{\"509\":1}}],[\"不使用大写类型object\",{\"1\":{\"512\":1}}],[\"不使用大写类型\",{\"1\":{\"509\":1}}],[\"不可写\",{\"1\":{\"1198\":1}}],[\"不可用\",{\"1\":{\"698\":1,\"1041\":1}}],[\"不可再分的值\",{\"1\":{\"508\":1}}],[\"不可变基础设施等特性\",{\"1\":{\"278\":1}}],[\"不是从节点\",{\"1\":{\"1520\":1}}],[\"不是则需要轮转\",{\"1\":{\"1371\":1}}],[\"不是元组\",{\"1\":{\"529\":1}}],[\"不是\",{\"1\":{\"506\":1,\"1519\":1,\"1521\":1}}],[\"不是一回事\",{\"1\":{\"195\":1}}],[\"不是一个变量\",{\"1\":{\"173\":1}}],[\"不报错\",{\"1\":{\"502\":3,\"504\":3}}],[\"不生成\",{\"1\":{\"498\":1}}],[\"不生成编译产物\",{\"1\":{\"498\":1}}],[\"不想自己折腾插件的玩家强烈建议直接用露露插件整合包\",{\"1\":{\"491\":1}}],[\"不占\",{\"1\":{\"485\":1}}],[\"不然打太慢可能后面黑暗之拥奶不住\",{\"1\":{\"451\":1}}],[\"不太清楚是为什么\",{\"1\":{\"443\":1}}],[\"不断根据当前\",{\"1\":{\"1521\":1}}],[\"不断循环执行该方法\",{\"1\":{\"1519\":1}}],[\"不断循环消费事务半消息进行处理\",{\"1\":{\"1453\":1}}],[\"不断扫描队列\",{\"1\":{\"1356\":1}}],[\"不断执行\",{\"1\":{\"1168\":1}}],[\"不断重试重投\",{\"1\":{\"934\":1}}],[\"不断的消费\",{\"1\":{\"881\":1}}],[\"不断启动任务去扫描该等级对应的消费队列中是否有到期的消息\",{\"1\":{\"855\":1}}],[\"不断接收消息\",{\"1\":{\"724\":1}}],[\"不断对其使用愈合\",{\"1\":{\"411\":1}}],[\"不断地将任务从waitingtasks队列推入时间轮\",{\"1\":{\"379\":1}}],[\"不比猫奶低\",{\"1\":{\"403\":1}}],[\"不追求打很多伤害而是追求稳定加治疗量\",{\"1\":{\"403\":1}}],[\"不过官方只提供了内存和本地文件两种分级存储文件段的实现\",{\"1\":{\"1380\":1}}],[\"不过每一项不需要保存消息的全量信息\",{\"1\":{\"1352\":1}}],[\"不过\",{\"1\":{\"1300\":1}}],[\"不过消费者需要在消费时指定拉取这个消费队列才可以消费\",{\"1\":{\"1291\":1}}],[\"不过这个地方单线程处理\",{\"1\":{\"733\":1}}],[\"不过本例等号左边的box<string>可以省略不写\",{\"1\":{\"578\":1}}],[\"不过还是建议开树皮\",{\"1\":{\"426\":1}}],[\"不过千丝老三确实是猫奶要好奶很多\",{\"1\":{\"401\":1}}],[\"不过原子true和false具有特殊的含义\",{\"1\":{\"206\":1}}],[\"不必在构造方法里面写任何代码\",{\"1\":{\"576\":1}}],[\"不必在每一个函数内部捕获错误\",{\"1\":{\"358\":1}}],[\"不必成为职业选手\",{\"1\":{\"399\":1}}],[\"不均衡问题和虚拟节点\",{\"0\":{\"388\":1}}],[\"不同模式下消费进度保存方式的不同\",{\"1\":{\"1103\":1}}],[\"不同\",{\"1\":{\"890\":1,\"902\":1}}],[\"不同的水位线\",{\"1\":{\"1521\":1}}],[\"不同的消费队列可以复用\",{\"1\":{\"1291\":1}}],[\"不同的消息可能得到相同的\",{\"1\":{\"786\":1}}],[\"不同的通讯请求字段不一样\",{\"1\":{\"890\":1}}],[\"不同的镜像队列形成不同的组\",{\"1\":{\"673\":1}}],[\"不同的输入大概率得到不同的输出\",{\"1\":{\"385\":1}}],[\"不同组件之间通过消息传递\",{\"1\":{\"621\":1}}],[\"不同副本里有些饰品比其他饰品更好\",{\"1\":{\"481\":1}}],[\"不同调度线程的逻辑较为类似\",{\"1\":{\"374\":1}}],[\"不提供web页面\",{\"1\":{\"371\":1}}],[\"不删除\",{\"1\":{\"298\":1}}],[\"不添加\",{\"1\":{\"298\":1}}],[\"不仅能让业务使用\",{\"1\":{\"923\":1}}],[\"不仅让仲裁队列比镜像队列更可靠\",{\"1\":{\"696\":1}}],[\"不仅如此\",{\"1\":{\"678\":1,\"693\":1}}],[\"不仅增加自己的存活概率\",{\"1\":{\"492\":1}}],[\"不仅数值弱\",{\"1\":{\"399\":1}}],[\"不仅难度上升\",{\"1\":{\"399\":1}}],[\"不仅需要模型的全面覆盖\",{\"1\":{\"277\":1}}],[\"不仅逻辑跟着复杂\",{\"1\":{\"87\":1}}],[\"不用回查需要移除\",{\"1\":{\"1468\":1}}],[\"不用模拟客户端或者泛化调用之类的\",{\"1\":{\"273\":1}}],[\"不用为每个客户端都启动一个线程\",{\"1\":{\"117\":1}}],[\"不如分布式\",{\"1\":{\"237\":1}}],[\"不带交互式\",{\"1\":{\"224\":1}}],[\"不成功\",{\"1\":{\"188\":1}}],[\"不包含任何值\",{\"1\":{\"504\":1}}],[\"不包含单词外的字符\",{\"1\":{\"155\":1}}],[\"不包括原始类型的值\",{\"1\":{\"512\":1}}],[\"不包括自我治疗\",{\"1\":{\"477\":1}}],[\"不包括父类\",{\"1\":{\"38\":2,\"39\":2}}],[\"不会存在一个客户端\",{\"1\":{\"1250\":1}}],[\"不会主动将路由信息推送给客户端\",{\"1\":{\"955\":1}}],[\"不会主动调用其他模块\",{\"1\":{\"945\":1}}],[\"不会持久化\",{\"1\":{\"950\":1}}],[\"不会被持久化\",{\"1\":{\"949\":1}}],[\"不会立即投递到它本该去的\",{\"1\":{\"925\":1}}],[\"不会超过\",{\"1\":{\"906\":1}}],[\"不会产生大量缺页\",{\"1\":{\"879\":1}}],[\"不会马上返回\",{\"1\":{\"804\":1}}],[\"不会丢数据\",{\"1\":{\"696\":1}}],[\"不会接受消息也不会处理消息\",{\"1\":{\"622\":1}}],[\"不会缺蓝\",{\"1\":{\"492\":1}}],[\"不会解除变形\",{\"1\":{\"413\":1}}],[\"不会进行重试连接其他节点\",{\"1\":{\"284\":1}}],[\"不会有垃圾收集的负担\",{\"1\":{\"247\":1}}],[\"不会阻塞\",{\"1\":{\"124\":2,\"820\":1}}],[\"不会自动重启\",{\"1\":{\"95\":1}}],[\"不会创建新的临时对象\",{\"1\":{\"28\":1}}],[\"不需要进行回查\",{\"1\":{\"1468\":1}}],[\"不需要处理了\",{\"1\":{\"1468\":1}}],[\"不需要回查\",{\"1\":{\"1468\":2}}],[\"不需要等待响应\",{\"1\":{\"1449\":1,\"1469\":1}}],[\"不需要提前创建\",{\"1\":{\"1293\":1}}],[\"不需要用\",{\"1\":{\"894\":1}}],[\"不需要手动拉取消息和更新消费进度\",{\"1\":{\"802\":1}}],[\"不需要创建索引\",{\"1\":{\"794\":1}}],[\"不需要给出实现\",{\"1\":{\"558\":1}}],[\"不需要治疗\",{\"1\":{\"416\":1}}],[\"不需要方法名称相同\",{\"1\":{\"76\":1}}],[\"不需要捕获的异常\",{\"1\":{\"33\":1}}],[\"不影响另一个应用程序用udp占用端口1234\",{\"1\":{\"71\":1}}],[\"不能用于比较大小\",{\"1\":{\"1308\":1}}],[\"不能用于比较字符串\",{\"1\":{\"1308\":3}}],[\"不能释放\",{\"1\":{\"1209\":1}}],[\"不能立即被消费者消费\",{\"1\":{\"832\":1}}],[\"不能输入正常接口\",{\"1\":{\"592\":1}}],[\"不能重新赋值\",{\"1\":{\"583\":1}}],[\"不能重复\",{\"1\":{\"302\":1}}],[\"不能通过实例对象使用\",{\"1\":{\"577\":1}}],[\"不能有冲突\",{\"1\":{\"560\":1}}],[\"不能作为构造函数使用\",{\"1\":{\"508\":1}}],[\"不能给它赋任何值\",{\"1\":{\"504\":1}}],[\"不能直接调用\",{\"1\":{\"503\":1}}],[\"不能直接赋值给其他类型的变量\",{\"1\":{\"503\":1}}],[\"不能直接由非事务方法调用\",{\"1\":{\"87\":1}}],[\"不能实例化t类型\",{\"1\":{\"48\":1}}],[\"不能判断带泛型类型的类型\",{\"1\":{\"48\":1}}],[\"不能获取带泛型类型的class\",{\"1\":{\"48\":1}}],[\"不能是基本类型\",{\"1\":{\"48\":1}}],[\"不编写实现类\",{\"1\":{\"41\":1}}],[\"不要省减伤\",{\"1\":{\"492\":1}}],[\"不要浪费任何一个清晰预兆效果\",{\"1\":{\"492\":1}}],[\"不要被点名了才开始找炸弹再跑\",{\"1\":{\"464\":1}}],[\"不要提前让变易异常触发\",{\"1\":{\"434\":1}}],[\"不要把生命绽放放在自己身上的另一个原因是\",{\"1\":{\"415\":1}}],[\"不要把任何java核心库添加到classpath中\",{\"1\":{\"23\":1}}],[\"不要让林莽卫士的\",{\"1\":{\"411\":1}}],[\"不要使用new\",{\"1\":{\"333\":1}}],[\"不要设置classpath\",{\"1\":{\"23\":1}}],[\"不推荐自己去实现\",{\"1\":{\"87\":1}}],[\"不推荐\",{\"1\":{\"23\":1}}],[\"实战与进阶\",{\"1\":{\"1105\":1}}],[\"实验体08752号的指环\",{\"1\":{\"479\":1,\"480\":1}}],[\"实验结束后\",{\"1\":{\"285\":1}}],[\"实际结果是开启布隆过滤器之后生产消费速度与开启之前差距并不明显\",{\"1\":{\"1325\":1}}],[\"实际已经保存到磁盘\",{\"1\":{\"1276\":1}}],[\"实际\",{\"1\":{\"725\":1}}],[\"实际开发中\",{\"1\":{\"514\":1}}],[\"实际添加时是添加\",{\"1\":{\"393\":1}}],[\"实际上它们可以实现相同的效果\",{\"1\":{\"1338\":1}}],[\"实际上投递方法执行后可以抽象成一个投递任务\",{\"1\":{\"933\":1}}],[\"实际上消费时是一个随机读的过程\",{\"1\":{\"878\":1}}],[\"实际上\",{\"1\":{\"803\":1}}],[\"实际上性能开销相当大\",{\"1\":{\"736\":1}}],[\"实际上就带有该修饰符\",{\"1\":{\"575\":1}}],[\"实际上就是给java命令传入\",{\"1\":{\"23\":1}}],[\"实际上http协议是建立在tcp协议之上的\",{\"1\":{\"368\":1}}],[\"实现事务消息本地执行和回查逻辑\",{\"0\":{\"1442\":1}}],[\"实现全局提交结果的一致性\",{\"1\":{\"1439\":1}}],[\"实现一个新的\",{\"1\":{\"1382\":1}}],[\"实现任务的解耦和流控\",{\"1\":{\"1353\":1}}],[\"实现任意时间的定时的要点在于知道在某一时刻需要投递哪些消息\",{\"1\":{\"1346\":1}}],[\"实现思想\",{\"0\":{\"1291\":1}}],[\"实现发送请求\",{\"1\":{\"1160\":1}}],[\"实现类\",{\"1\":{\"1514\":1}}],[\"实现类中包含了客户端实例\",{\"1\":{\"1109\":1}}],[\"实现类似水平分片的效果\",{\"1\":{\"380\":1}}],[\"实现不同请求线程池的隔离\",{\"1\":{\"1055\":1}}],[\"实现原理\",{\"0\":{\"986\":1}}],[\"实现原型继承链\",{\"1\":{\"342\":1}}],[\"实现定时消息取消的实现要点是保存一个需要取消的定时消息\",{\"1\":{\"935\":1}}],[\"实现定时消息延迟投递的主要逻辑\",{\"1\":{\"836\":1}}],[\"实现的内存映射文件\",{\"1\":{\"1386\":1}}],[\"实现的重点就是\",{\"1\":{\"1294\":1}}],[\"实现的新消费者\",{\"1\":{\"1136\":1}}],[\"实现的肩膀上\",{\"1\":{\"925\":1}}],[\"实现的序列化协议\",{\"1\":{\"893\":1}}],[\"实现其中一个\",{\"1\":{\"920\":1}}],[\"实现现高性能\",{\"0\":{\"875\":1}}],[\"实现高性能定时消息\",{\"0\":{\"918\":1},\"1\":{\"1538\":1}}],[\"实现高性能\",{\"1\":{\"874\":1}}],[\"实现有一定难度\",{\"1\":{\"847\":1}}],[\"实现amqp协议的逻辑功能\",{\"1\":{\"689\":1}}],[\"实现多个接口\",{\"0\":{\"571\":1}}],[\"实现了索引文件读写接口\",{\"1\":{\"1412\":1}}],[\"实现了一些基本的\",{\"1\":{\"1321\":1}}],[\"实现了多语言轻量化客户端\",{\"1\":{\"1249\":1}}],[\"实现了\",{\"1\":{\"1118\":1,\"1190\":1,\"1284\":1,\"1397\":1,\"1482\":1}}],[\"实现了消息读写在内存级别的读写分离\",{\"1\":{\"883\":1}}],[\"实现了无锁化调度\",{\"1\":{\"371\":1}}],[\"实现了文件流输出\",{\"1\":{\"54\":1}}],[\"实现了文件流输入\",{\"1\":{\"53\":1}}],[\"实现异步操作\",{\"1\":{\"354\":1}}],[\"实现真正的韧性架构毫无疑问是现代分布式系统的演进方向\",{\"1\":{\"278\":1}}],[\"实现真正意义上的秒级rto\",{\"1\":{\"276\":1}}],[\"实现和单线程\",{\"1\":{\"132\":1}}],[\"实现\",{\"0\":{\"107\":1,\"182\":1,\"396\":1},\"1\":{\"138\":1,\"391\":1,\"1094\":1,\"1258\":1,\"1290\":1,\"1318\":1,\"1382\":1,\"1387\":1,\"1425\":3,\"1475\":1,\"1506\":1}}],[\"实现ioc的主要机制是依赖注入\",{\"1\":{\"81\":1}}],[\"实例是\",{\"1\":{\"947\":1}}],[\"实例属性的简写形式\",{\"0\":{\"576\":1}}],[\"实例类型\",{\"0\":{\"573\":1}}],[\"实例类型被看做返回类型\",{\"1\":{\"76\":1}}],[\"实例类型被看做第一个参数类型\",{\"1\":{\"76\":1}}],[\"实例并发数\",{\"1\":{\"372\":1}}],[\"实例\",{\"1\":{\"372\":2,\"1036\":1,\"1037\":1,\"1047\":1,\"1443\":1}}],[\"实例化\",{\"1\":{\"123\":1,\"133\":1,\"369\":1}}],[\"实例化一个inner\",{\"1\":{\"22\":1}}],[\"实例化一个outer\",{\"1\":{\"22\":1}}],[\"实例分发连接事件\",{\"1\":{\"121\":1}}],[\"假设它的值为\",{\"1\":{\"187\":1}}],[\"假设classpath是\",{\"1\":{\"23\":1}}],[\"假设需要测试分别向两种列表中添加\",{\"1\":{\"9\":1}}],[\"应上报\",{\"1\":{\"1446\":1}}],[\"应当避免\",{\"1\":{\"722\":1}}],[\"应当尽量避免使用apply\",{\"1\":{\"200\":1}}],[\"应对普通\",{\"1\":{\"411\":1}}],[\"应答机制限制了全双工通信\",{\"1\":{\"368\":1}}],[\"应该立刻将客户端offset重置为0\",{\"1\":{\"1173\":1}}],[\"应该从哪里开始拉取消息\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"应该大于\",{\"1\":{\"734\":1}}],[\"应该使用type或interface\",{\"1\":{\"564\":1}}],[\"应该让他瞄准敌人释放\",{\"1\":{\"461\":1}}],[\"应该是确定的\",{\"1\":{\"384\":1}}],[\"应该到哪个或者哪些节点上获得\",{\"1\":{\"384\":1}}],[\"应该保存预处理器的输出\",{\"1\":{\"208\":1}}],[\"应该原始异常加入到原有异常中\",{\"1\":{\"34\":1}}],[\"应该去哪搜索对应的hello\",{\"1\":{\"23\":1}}],[\"应用都有自己的权限控制系统\",{\"1\":{\"976\":1}}],[\"应用范围广\",{\"1\":{\"371\":1}}],[\"应用函数在每个数组元素\",{\"1\":{\"323\":1}}],[\"应用程序的读取线程会被阻塞\",{\"1\":{\"879\":1}}],[\"应用程序在写入文件的时候\",{\"1\":{\"879\":1}}],[\"应用程序实际操作的都是\",{\"1\":{\"879\":1}}],[\"应用程序组件既可以在spring的ioc容器中运行\",{\"1\":{\"81\":1}}],[\"应用程序只需要直接使用已经创建好并配置好的组件\",{\"1\":{\"81\":1}}],[\"应用\",{\"0\":{\"93\":1},\"1\":{\"4\":1,\"285\":1,\"372\":1}}],[\"它当中有一个\",{\"1\":{\"1483\":1}}],[\"它向其他节点收发心跳和投票请求\",{\"1\":{\"1481\":1}}],[\"它根据\",{\"1\":{\"1454\":1}}],[\"它根据生产者上报的本地事务执行结果\",{\"1\":{\"1451\":1}}],[\"它指向第一个索引项的位置\",{\"1\":{\"1436\":1}}],[\"它已经实现了\",{\"1\":{\"1420\":1}}],[\"它先调用\",{\"1\":{\"1409\":1}}],[\"它先被放入内存中匹配\",{\"1\":{\"1253\":1}}],[\"它遍历当前分级存储中所有的\",{\"1\":{\"1403\":1}}],[\"它类似本地存储的\",{\"1\":{\"1402\":1}}],[\"它类似于字符串\",{\"1\":{\"531\":1}}],[\"它封装了\",{\"1\":{\"1402\":1}}],[\"它被注册到默认存储的分发器链中\",{\"1\":{\"1388\":1}}],[\"它与\",{\"1\":{\"1338\":1,\"1352\":1}}],[\"它与系统内部生成的错误差不多\",{\"1\":{\"193\":1}}],[\"它无法支持任意时间的定时\",{\"1\":{\"1338\":1}}],[\"它表示通过过滤条件的所有\",{\"1\":{\"1333\":1}}],[\"它表示该方法当前所在的对象\",{\"1\":{\"580\":1}}],[\"它存在\",{\"1\":{\"1317\":1}}],[\"它消费\",{\"1\":{\"1263\":1}}],[\"它每秒都会调用\",{\"1\":{\"1263\":1}}],[\"它每\",{\"1\":{\"1262\":1}}],[\"它允许一个队列被多个消费者\",{\"1\":{\"1255\":1}}],[\"它里面包含一批消息的句柄信息\",{\"1\":{\"1251\":1}}],[\"它有新的消息\",{\"1\":{\"1198\":1}}],[\"它有两个\",{\"1\":{\"998\":1}}],[\"它定义了两个方法\",{\"1\":{\"1313\":1}}],[\"它定义了持久化和加载的接口\",{\"1\":{\"1190\":1}}],[\"它定义了对分布式系统进行操作的基本形式\",{\"1\":{\"280\":1}}],[\"它没有把二进制位数组\",{\"1\":{\"1323\":1}}],[\"它没有订阅\",{\"1\":{\"1136\":1}}],[\"它没有包含队列的所有功能\",{\"1\":{\"694\":1}}],[\"它由\",{\"1\":{\"1041\":1}}],[\"它由瑞典电信公司爱立信开发\",{\"1\":{\"262\":1}}],[\"它调用分级存储\",{\"1\":{\"1421\":1}}],[\"它调用\",{\"1\":{\"1036\":1,\"1040\":1}}],[\"它扩展了\",{\"1\":{\"1035\":1,\"1190\":1,\"1420\":1}}],[\"它默认关闭\",{\"1\":{\"1029\":1}}],[\"它默认有\",{\"1\":{\"836\":1}}],[\"它其实是把精确过滤的逻辑提前到消息生产时来做\",{\"1\":{\"1315\":1}}],[\"它其实与上面命令行的逻辑一样\",{\"1\":{\"1248\":1}}],[\"它其实本质上就是一个\",{\"1\":{\"943\":1}}],[\"它其实才是真正干活的\",{\"1\":{\"61\":1}}],[\"它最大的优势就是\",{\"1\":{\"931\":1}}],[\"它\",{\"1\":{\"879\":1}}],[\"它保存了\",{\"1\":{\"1346\":1}}],[\"它保存的所有从队列的镜像数据都会丢失\",{\"1\":{\"693\":1}}],[\"它保留\",{\"1\":{\"879\":1}}],[\"它所有的消息数据都存放在一个无限增长的文件队列\",{\"1\":{\"876\":1}}],[\"它在在当前的互联网环境中有非常大的需求\",{\"1\":{\"1337\":1}}],[\"它在高性能和大量定时消息的情况下可能引发灾难\",{\"1\":{\"931\":1}}],[\"它在\",{\"1\":{\"765\":1,\"827\":1,\"902\":1}}],[\"它在镜像中的任何数据都将被丢弃\",{\"1\":{\"677\":1}}],[\"它将会从内存中被删除\",{\"1\":{\"1253\":1}}],[\"它将通过哈希值被映射到哈希环上\",{\"1\":{\"716\":1}}],[\"它将处理它的\",{\"1\":{\"627\":1}}],[\"它比镜像队列更安全\",{\"1\":{\"694\":1}}],[\"它比其他模型更高效\",{\"1\":{\"117\":1}}],[\"它提供队列复制的能力\",{\"1\":{\"692\":1}}],[\"它提供了按照消息\",{\"1\":{\"927\":1}}],[\"它提供了相关的接口供\",{\"1\":{\"671\":1}}],[\"它提供了实现\",{\"1\":{\"118\":1}}],[\"它需要将消息传入并调用credit\",{\"1\":{\"626\":1}}],[\"它需要迁移到新的哈希结果对应的节点\",{\"1\":{\"385\":1}}],[\"它自己的信用值会减一\",{\"1\":{\"619\":1}}],[\"它自身没有捕获\",{\"1\":{\"358\":1}}],[\"它并不能代替\",{\"1\":{\"570\":1}}],[\"它点出了平衡德相关的所有天赋\",{\"1\":{\"403\":1}}],[\"它点了不少增强生存能力的职业天赋\",{\"1\":{\"403\":1}}],[\"它底层实现是红黑树\",{\"1\":{\"395\":1}}],[\"它底层使用了操作系统的多路复用技术\",{\"1\":{\"122\":1}}],[\"它包括了以下改动\",{\"1\":{\"736\":1}}],[\"它包装了等待执行的timertask\",{\"1\":{\"379\":1}}],[\"它包含了多个同一类的消费者实例\",{\"1\":{\"1089\":1}}],[\"它包含了用户界面和控制器\",{\"1\":{\"280\":1}}],[\"它包含用户\",{\"1\":{\"976\":1}}],[\"它包含一个内存中的消费进度缓存表\",{\"1\":{\"1182\":1}}],[\"它包含一个主和多个从副本\",{\"1\":{\"695\":1}}],[\"它包含一个或多个goal\",{\"1\":{\"61\":1}}],[\"它包含一个或多个phase\",{\"1\":{\"61\":1}}],[\"它包含可靠性\",{\"1\":{\"282\":1}}],[\"它包含以下\",{\"1\":{\"62\":1}}],[\"它接受来自\",{\"1\":{\"372\":1}}],[\"它接收两个参数\",{\"1\":{\"318\":1}}],[\"它负责管理执行器节点任务的执行\",{\"1\":{\"372\":1}}],[\"它负责如map子任务的分发\",{\"1\":{\"372\":1}}],[\"它和\",{\"1\":{\"350\":1}}],[\"它和oop不同\",{\"1\":{\"85\":1}}],[\"它也仅保存在内存中\",{\"1\":{\"956\":1}}],[\"它也将哈希到这个环上\",{\"1\":{\"716\":1}}],[\"它也把每个元素依次作用于传入的函数\",{\"1\":{\"327\":1}}],[\"它也与\",{\"1\":{\"120\":1}}],[\"它可能是xiaoming继承得到的\",{\"1\":{\"299\":1}}],[\"它可以使用sql92语法作为过滤规则表达式\",{\"1\":{\"1308\":1}}],[\"它可以用来记录消息发送\",{\"1\":{\"1003\":1}}],[\"它可以用在任意位置\",{\"1\":{\"527\":1}}],[\"它可以包含多个文件\",{\"1\":{\"780\":1}}],[\"它可以实现消息在\",{\"1\":{\"633\":1}}],[\"它可以赋值给其他任何类型的变量\",{\"1\":{\"502\":1}}],[\"它可以是自部署的分布式系统集群\",{\"1\":{\"280\":1}}],[\"它可以绑定x到someexpression这个值上\",{\"1\":{\"173\":1}}],[\"它可以不断监听\",{\"1\":{\"119\":1}}],[\"它可以监听多个\",{\"1\":{\"118\":1}}],[\"它可以被捕获并处理\",{\"1\":{\"33\":1}}],[\"它可以帮助解析\",{\"1\":{\"6\":1}}],[\"它不关心发送结果\",{\"1\":{\"1027\":1}}],[\"它不会作为元数据上报到\",{\"1\":{\"1291\":1}}],[\"它不会接收消息也不会发送消息\",{\"1\":{\"621\":1}}],[\"它不会自动转换数据类型\",{\"1\":{\"295\":1}}],[\"它不但不支持事务\",{\"1\":{\"87\":1}}],[\"它主要提供了两个方法\",{\"1\":{\"1322\":1}}],[\"它主要有\",{\"1\":{\"944\":1}}],[\"它主要负责在保存消息时将原消息的\",{\"1\":{\"836\":1}}],[\"它主要关注系统面对故障所展现出的容错能力\",{\"1\":{\"277\":1}}],[\"它主要的工作\",{\"1\":{\"119\":1}}],[\"它用类似\",{\"1\":{\"927\":1}}],[\"它用来标记一条半消息的事务执行结果\",{\"1\":{\"1453\":1}}],[\"它用来在关机恢复时标明扫描开始位置\",{\"1\":{\"857\":1}}],[\"它用来指示jvm如何搜索class\",{\"1\":{\"23\":1}}],[\"它用在函数的返回值\",{\"1\":{\"542\":1}}],[\"它用于在发送消息时按照一致性哈希的方式选择\",{\"1\":{\"396\":1}}],[\"它用于设置一个跟踪模式\",{\"1\":{\"261\":1}}],[\"它会根据节点当前的状态执行对应状态的状态维维护方法\",{\"1\":{\"1483\":1}}],[\"它会把本地的数据推到从节点的\",{\"1\":{\"1481\":1}}],[\"它会把源码视为java\",{\"1\":{\"25\":1}}],[\"它会开启一个\",{\"1\":{\"990\":1,\"996\":1}}],[\"它会将请求的参数\",{\"1\":{\"989\":1,\"995\":1}}],[\"它会在处理请求的前后分别执行\",{\"1\":{\"988\":1,\"994\":1}}],[\"它会调用\",{\"1\":{\"960\":1,\"991\":1,\"1414\":1,\"1482\":1}}],[\"它会从\",{\"1\":{\"761\":1}}],[\"它会让整个队列不可用\",{\"1\":{\"693\":1}}],[\"它会先将自己的信用值\",{\"1\":{\"621\":1}}],[\"它会自动定位\",{\"1\":{\"591\":1}}],[\"它会自动转换数据类型再比较\",{\"1\":{\"295\":1}}],[\"它会创造一个值\",{\"1\":{\"564\":1}}],[\"它会启动跟踪\",{\"1\":{\"261\":1}}],[\"它以发生错误的函数名开头\",{\"1\":{\"256\":1}}],[\"它适用于实验室或模拟系统里的大型系统性能分析\",{\"1\":{\"255\":1}}],[\"它还是高度可定制的\",{\"1\":{\"251\":1}}],[\"它通过阅读一个自定义的语法标准文件\",{\"1\":{\"1321\":1}}],[\"它通过\",{\"1\":{\"186\":1}}],[\"它让程序变得更短\",{\"1\":{\"184\":1}}],[\"它就是\",{\"1\":{\"1119\":1}}],[\"它就会将其打印成字符串字面量\",{\"1\":{\"178\":1}}],[\"它就直接使用从threadlocal获取的jdbc连接以及transactionstatus\",{\"1\":{\"87\":1}}],[\"它的主要逻辑在\",{\"1\":{\"1510\":1}}],[\"它的详细逻辑如下\",{\"1\":{\"1453\":1}}],[\"它的目录也是单独的\",{\"1\":{\"1417\":1}}],[\"它的目的是在主题没有被创建时\",{\"1\":{\"1039\":1}}],[\"它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道\",{\"1\":{\"368\":1}}],[\"它的逻辑如下\",{\"1\":{\"1417\":1}}],[\"它的逻辑是\",{\"1\":{\"1405\":1}}],[\"它的写入顺序也是最靠后的\",{\"1\":{\"1414\":1}}],[\"它的组织结构近似一个\",{\"1\":{\"1393\":1}}],[\"它的每一项结构如下\",{\"1\":{\"1352\":1}}],[\"它的形式是与\",{\"1\":{\"1352\":1}}],[\"它的性能也达不到普通消息\",{\"1\":{\"1338\":1}}],[\"它的性能处于消息队列的第一梯队\",{\"1\":{\"874\":1}}],[\"它的方法\",{\"1\":{\"1323\":1}}],[\"它的两个方法先后在从\",{\"1\":{\"1318\":1}}],[\"它的背后其实是消费者在不断地\",{\"1\":{\"1245\":1}}],[\"它的存储结构类似\",{\"1\":{\"1346\":1}}],[\"它的存储位置是\",{\"1\":{\"1317\":1}}],[\"它的存储大小不会随着投递到的队列变多而线性增长\",{\"1\":{\"700\":1}}],[\"它的存在是为了解决重平衡后可能的不同消费者并行消费问题\",{\"1\":{\"1212\":1}}],[\"它的用处很多\",{\"1\":{\"1109\":1,\"1118\":1}}],[\"它的初始化方法\",{\"1\":{\"947\":1}}],[\"它的\",{\"1\":{\"815\":1,\"1188\":1,\"1509\":1,\"1520\":1}}],[\"它的结构类似于类似\",{\"1\":{\"777\":1}}],[\"它的底层结构实际是\",{\"1\":{\"741\":1}}],[\"它的实现大致为\",{\"1\":{\"673\":1}}],[\"它的类型可以是\",{\"1\":{\"582\":1}}],[\"它的类名是\",{\"1\":{\"36\":1}}],[\"它的成员有5种形式\",{\"1\":{\"558\":1}}],[\"它的操作数依然是一个值\",{\"1\":{\"518\":1}}],[\"它的乐趣点就在于实力变强带来的成就感\",{\"1\":{\"399\":1}}],[\"它的位置是随机的\",{\"1\":{\"388\":1}}],[\"它的作用是引入\",{\"1\":{\"902\":1}}],[\"它的作用是\",{\"1\":{\"385\":1}}],[\"它的所有\",{\"1\":{\"384\":1}}],[\"它的精确度为10s\",{\"1\":{\"379\":1}}],[\"它的值就为\",{\"1\":{\"186\":1}}],[\"它的头是h\",{\"1\":{\"177\":1}}],[\"它除了轮询和处理\",{\"1\":{\"135\":1}}],[\"它们会分布在文件的不同位置\",{\"1\":{\"1393\":1}}],[\"它们会被投递到\",{\"1\":{\"1253\":1}}],[\"它们都调用同一个方法\",{\"1\":{\"1258\":1}}],[\"它们都提供大型的键\",{\"1\":{\"247\":1}}],[\"它们内部都定义了一个消费线程池\",{\"1\":{\"1119\":1}}],[\"它们分别实现了消费者接口\",{\"1\":{\"1109\":1}}],[\"它们只会保存在内存中\",{\"1\":{\"949\":1}}],[\"它们仅存在于内存中\",{\"1\":{\"944\":1}}],[\"它们仅仅作为一个冗余备份\",{\"1\":{\"695\":1}}],[\"它们用于读写某个属性\",{\"1\":{\"567\":1}}],[\"它们有20\",{\"1\":{\"407\":1}}],[\"它们作为属性被绑定到\",{\"1\":{\"312\":1}}],[\"它们的重平衡触发也不太相同\",{\"1\":{\"1136\":1}}],[\"它们的\",{\"1\":{\"742\":1}}],[\"它们的写入速率时多少\",{\"1\":{\"702\":1}}],[\"它们的消费将在故障转移时被取消\",{\"1\":{\"665\":1}}],[\"它们的形式通常是\",{\"1\":{\"657\":1}}],[\"它们的区别是\",{\"1\":{\"573\":1}}],[\"它们的区别是主要在于监听的\",{\"1\":{\"132\":1}}],[\"它们的属性值要么是布尔值\",{\"1\":{\"568\":1}}],[\"它们的普遍实现是通过黑盒的故障注入来模拟一些常见的通用故障\",{\"1\":{\"282\":1}}],[\"它们由内置函数\",{\"1\":{\"218\":1}}],[\"它们被用来定义文件的某些属性\",{\"1\":{\"202\":1}}],[\"它们不会被加载进jvm\",{\"1\":{\"44\":1}}],[\"它能够极大地增强你的单目标治疗\",{\"1\":{\"405\":1}}],[\"它能够确保只发生少量的数据迁移\",{\"1\":{\"385\":1}}],[\"它能满足\",{\"1\":{\"132\":1}}],[\"它能执行的class文件版本也不同\",{\"1\":{\"25\":1}}],[\"它更多地是在用户空间的角度\",{\"1\":{\"119\":1}}],[\"它使用了上面所说的优化思想\",{\"1\":{\"119\":1}}],[\"它只被其他模块调用\",{\"1\":{\"945\":1}}],[\"它只需要寻址一次就可以连续读写下去\",{\"1\":{\"876\":1}}],[\"它只接收新消息\",{\"1\":{\"658\":1}}],[\"它只会将消息发往有空闲消费者的下游集群\",{\"1\":{\"634\":1}}],[\"它只能在阻塞模式下运行\",{\"1\":{\"118\":1}}],[\"它只是负责找到对应的compiler插件\",{\"1\":{\"64\":1}}],[\"它必须从\",{\"1\":{\"118\":1}}],[\"它基于\",{\"1\":{\"109\":1}}],[\"它总是被其他事务方法调用\",{\"1\":{\"87\":1}}],[\"它满足绝大部分的需求\",{\"1\":{\"87\":1}}],[\"它解决了以下问题\",{\"1\":{\"81\":1}}],[\"它实现了\",{\"1\":{\"78\":1,\"1036\":1}}],[\"它把char转换为byte并输出\",{\"1\":{\"58\":1}}],[\"它把世界上主要语言都纳入同一个编码\",{\"1\":{\"27\":1}}],[\"它是为消息场景量身定制的\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"它是真正查询消息的方法\",{\"1\":{\"1258\":1}}],[\"它是该消息的句柄\",{\"1\":{\"1251\":1}}],[\"它是生产者的具体实现类\",{\"1\":{\"1036\":1}}],[\"它是由多个\",{\"1\":{\"135\":1}}],[\"它是\",{\"1\":{\"118\":1,\"255\":1,\"1482\":2}}],[\"它是一个服务线程\",{\"1\":{\"1403\":1,\"1417\":1}}],[\"它是一个\",{\"1\":{\"815\":1}}],[\"它是一个函数\",{\"1\":{\"606\":1}}],[\"它是一个应用程序操作系统\",{\"1\":{\"262\":1}}],[\"它是一个轻量级的性能分析器\",{\"1\":{\"255\":1}}],[\"它是一个0～65535之间的数字\",{\"1\":{\"68\":1}}],[\"它是一个可变对象\",{\"1\":{\"28\":1}}],[\"它是带编码转换器的outputstream\",{\"1\":{\"58\":1}}],[\"它占用一个字节\",{\"1\":{\"27\":1}}],[\"而日志复制则确保各节点之间的数据一致性\",{\"1\":{\"1506\":1}}],[\"而定时消息指定确切的投递时间\",{\"1\":{\"1338\":1}}],[\"而每个队列最多只能被一个消费者消费\",{\"1\":{\"1249\":1}}],[\"而之前的\",{\"1\":{\"1245\":1}}],[\"而业务的唯一标识可以通过消息key设置\",{\"1\":{\"1237\":1}}],[\"而本片主要介绍\",{\"1\":{\"1203\":1}}],[\"而非挂起请求触发的话\",{\"1\":{\"1173\":1}}],[\"而被动触发一般是其他消费者每\",{\"1\":{\"1136\":1}}],[\"而用户真正编写的只有最终的消费逻辑\",{\"1\":{\"1119\":1}}],[\"而真正的发送逻辑则在\",{\"1\":{\"1021\":1}}],[\"而尽可能不影响正常消息发送的性能\",{\"1\":{\"1010\":1}}],[\"而在这之间的消息是正在等待副本同步的\",{\"1\":{\"1403\":1}}],[\"而在\",{\"1\":{\"1003\":1}}],[\"而rocketmq的设计理念也正是基于此\",{\"1\":{\"942\":1}}],[\"而reader是一个字符流\",{\"1\":{\"57\":1}}],[\"而对于一个简单的服务发现的场景来说\",{\"1\":{\"942\":1}}],[\"而对于长周期的方法\",{\"1\":{\"379\":1}}],[\"而zookeeper\",{\"1\":{\"942\":1}}],[\"而这对于一个注册中心来说肯定是不能接受的\",{\"1\":{\"942\":1}}],[\"而堆内存的释放由垃圾回收器负责完成\",{\"1\":{\"904\":1}}],[\"而不必在客户端实现重平衡逻辑\",{\"1\":{\"1249\":1}}],[\"而不会主动向其他模块发起请求\",{\"1\":{\"943\":1}}],[\"而不发生线程切换\",{\"1\":{\"725\":1}}],[\"而不保存到消息存储中\",{\"1\":{\"687\":1}}],[\"而不是直接计算\",{\"1\":{\"738\":1}}],[\"而不是直接存储在磁盘中\",{\"1\":{\"681\":1}}],[\"而不是类型名称\",{\"1\":{\"506\":1}}],[\"而不是\",{\"0\":{\"910\":1},\"1\":{\"482\":1}}],[\"而不是继承得到的\",{\"1\":{\"299\":1}}],[\"而不是在当前线程直接处理\",{\"1\":{\"128\":1}}],[\"而实际应用中\",{\"1\":{\"659\":1}}],[\"而信用证流控的逻辑都位于credit\",{\"1\":{\"623\":1}}],[\"而该进程进入flow状态的原因是因为它的下游进程成为了性能瓶颈\",{\"1\":{\"622\":1}}],[\"而interface只能表示对象类型\",{\"1\":{\"564\":1}}],[\"而inner类被编译为outer$inner\",{\"1\":{\"22\":1}}],[\"而结界可以省更多的\",{\"1\":{\"403\":1}}],[\"而回调函数的执行需要等到下一个满足条件的事件出现后\",{\"1\":{\"359\":1}}],[\"而flaglist规定了跟踪条件满足时要\",{\"1\":{\"261\":1}}],[\"而此函数将会返回到\",{\"1\":{\"256\":1}}],[\"而列表用于保存可变数量的元素\",{\"1\":{\"190\":1}}],[\"而表达式序列执行的结果就是\",{\"1\":{\"187\":1}}],[\"而你其实想让它打印成一列整数\",{\"1\":{\"178\":1}}],[\"而\",{\"1\":{\"109\":1,\"668\":1,\"827\":1,\"881\":1,\"942\":3,\"1024\":1,\"1284\":1,\"1300\":1,\"1318\":1,\"1519\":1}}],[\"而slow\",{\"1\":{\"379\":1}}],[\"而sessionfactory是封装了jdbc\",{\"1\":{\"89\":1}}],[\"而socket内部通过tcp\",{\"1\":{\"68\":1}}],[\"而且最大的定时时间也只有\",{\"1\":{\"1338\":1}}],[\"而且本身存储的数据应该是高度定制化的\",{\"1\":{\"942\":1}}],[\"而且可以通过增加机器的方式水平扩展\",{\"1\":{\"942\":1}}],[\"而且可以无限打挑战自己\",{\"1\":{\"399\":1}}],[\"而且只需要一个线程就可以驱动时间轮进行工作\",{\"1\":{\"931\":1}}],[\"而且这个解码方法应用广泛\",{\"1\":{\"890\":1}}],[\"而且也避免了重复数据的产生\",{\"1\":{\"880\":1}}],[\"而且也听说正式服加了大米玩法\",{\"1\":{\"399\":1}}],[\"而且都是字符串\",{\"1\":{\"518\":1}}],[\"而且\",{\"1\":{\"509\":1,\"563\":1,\"1319\":1}}],[\"而且能量还没有满\",{\"1\":{\"417\":1}}],[\"而且点了欣欣向荣的话\",{\"1\":{\"407\":1}}],[\"而且还有免费星火\",{\"1\":{\"403\":1}}],[\"而且愿意奶德的很多都是不太会选妃的钥匙主\",{\"1\":{\"399\":1}}],[\"而且在同一张表里可以存在多个相同的元组\",{\"1\":{\"248\":1}}],[\"而且在监测到当前有事务时\",{\"1\":{\"87\":1}}],[\"而且必须先编译才能运行模块里的代码\",{\"1\":{\"180\":1}}],[\"而且不需要宏定义或包含文件就能实现\",{\"1\":{\"175\":1}}],[\"而且不同于string\",{\"1\":{\"36\":1}}],[\"而且速度也会越慢\",{\"1\":{\"87\":1}}],[\"而aop是一种新的编程方式\",{\"1\":{\"85\":1}}],[\"而规范路径就是把\",{\"1\":{\"52\":1}}],[\"而java\",{\"1\":{\"25\":1}}],[\"而jar包相当于目录\",{\"1\":{\"24\":1}}],[\"而是检查挂起的请求中超时的推送请求进行重推\",{\"1\":{\"1510\":1}}],[\"而是直接调用了默认存储的消息保存\",{\"1\":{\"1400\":1}}],[\"而是直接采用断言给出的类型\",{\"1\":{\"589\":1}}],[\"而是按照队列的维度拆分存储\",{\"1\":{\"1386\":1}}],[\"而是只要将当前的时间轮直接覆盖即可\",{\"1\":{\"1346\":1}}],[\"而是只需要从上一次投递的时间和偏移量开始一个新的投递任务即可\",{\"1\":{\"932\":1}}],[\"而是无状态的\",{\"1\":{\"1323\":1}}],[\"而是用专门的\",{\"1\":{\"1263\":1}}],[\"而是用更方便的命令\",{\"1\":{\"24\":1}}],[\"而是换一个\",{\"1\":{\"1234\":1}}],[\"而是不断重用在重平衡中创建的同一个\",{\"1\":{\"1155\":1}}],[\"而是等待一段指定的时间之后才能消费到该消息\",{\"1\":{\"1028\":1}}],[\"而是等到处理完morecreditafter条消息\",{\"1\":{\"619\":1}}],[\"而是投递到延迟消息\",{\"1\":{\"925\":1}}],[\"而是到达某个时间才投递给消费者\",{\"1\":{\"920\":1,\"1337\":1}}],[\"而是延迟一定时间后投递\",{\"1\":{\"920\":1}}],[\"而是在消费者端处理消息拉取结果时进行判断\",{\"1\":{\"1314\":1}}],[\"而是在当前时间之后的某个时间投递\",{\"1\":{\"920\":1}}],[\"而是在一个任务的末尾执行下一个任务\",{\"1\":{\"857\":1}}],[\"而是挂起一段时间再重试查询\",{\"1\":{\"914\":1}}],[\"而是对于\",{\"1\":{\"894\":1}}],[\"而是尽可能地利用空闲的物理内存保存这些\",{\"1\":{\"879\":1}}],[\"而是先把\",{\"1\":{\"866\":1}}],[\"而是先标记该消息为垃圾数据\",{\"1\":{\"688\":1}}],[\"而是一个任务末尾启动一个新的任务\",{\"1\":{\"858\":1}}],[\"而是一个完全独立的类\",{\"1\":{\"22\":1}}],[\"而是提供了18个延迟等级\",{\"1\":{\"833\":1}}],[\"而是需要在指定时间进行消费\",{\"1\":{\"832\":1}}],[\"而是需要自己编写控制结构\",{\"1\":{\"182\":1}}],[\"而是会将该查询请求挂起一段时间\",{\"1\":{\"804\":1}}],[\"而是会立即返回\",{\"1\":{\"124\":2}}],[\"而是每次\",{\"1\":{\"841\":1}}],[\"而是每写满一个索引文件时就新建一个文件\",{\"1\":{\"783\":1}}],[\"而是每个方法都单独实现\",{\"1\":{\"731\":1}}],[\"而是简单粗暴的直接一个一个去\",{\"1\":{\"742\":1}}],[\"而是转化为对映射地址映射的pagecache的操作\",{\"1\":{\"728\":1}}],[\"而是该值的\",{\"1\":{\"518\":1}}],[\"而是以ws\",{\"1\":{\"368\":1}}],[\"而是利用了http协议来建立连接\",{\"1\":{\"368\":1}}],[\"而是通过原型\",{\"1\":{\"339\":1}}],[\"而是为了让变量id获得passport属性\",{\"1\":{\"316\":1}}],[\"而是为了让city和zip获得嵌套的address对象的属性\",{\"1\":{\"316\":1}}],[\"而是返回undefined\",{\"1\":{\"298\":2}}],[\"而是交给一个统一的启动类来讲服务端\",{\"1\":{\"132\":1}}],[\"而是由\",{\"1\":{\"81\":1}}],[\"而是第一次需要用到\",{\"1\":{\"37\":1}}],[\"匿名类被编译为outer$1\",{\"1\":{\"22\":1}}],[\"例如发送日志\",{\"1\":{\"1027\":1}}],[\"例如每一天需要投递的消息保存为一个文件队列\",{\"1\":{\"928\":1}}],[\"例如电商\",{\"1\":{\"921\":1,\"1337\":1}}],[\"例如两台节点a\",{\"1\":{\"659\":1}}],[\"例如一个完整的\",{\"1\":{\"262\":1}}],[\"例如list\",{\"1\":{\"185\":1}}],[\"例如函数定义\",{\"1\":{\"180\":1}}],[\"例如3\",{\"1\":{\"65\":1}}],[\"例如<k>\",{\"1\":{\"47\":1}}],[\"例如string\",{\"1\":{\"36\":1}}],[\"例如\",{\"1\":{\"21\":1,\"25\":1,\"27\":2,\"48\":4,\"62\":1,\"64\":1,\"67\":1,\"285\":1,\"622\":1,\"653\":1,\"662\":1,\"674\":1}}],[\"后过期\",{\"1\":{\"1382\":1}}],[\"后一条记录的位置\",{\"1\":{\"1352\":1}}],[\"后投递\",{\"1\":{\"1339\":2}}],[\"后分发构建索引时\",{\"1\":{\"1291\":1}}],[\"后继续执行\",{\"1\":{\"1230\":1}}],[\"后再次判断\",{\"1\":{\"1228\":1}}],[\"后再次执行拉取请求\",{\"1\":{\"1228\":1}}],[\"后再提交\",{\"1\":{\"1194\":1}}],[\"后将\",{\"1\":{\"1228\":1}}],[\"后将消费失败的消息发回\",{\"1\":{\"1188\":1}}],[\"后将拉取请求重新放入队列\",{\"1\":{\"1159\":1}}],[\"后台有线程拉取消息进行缓存\",{\"1\":{\"1136\":1}}],[\"后就执行拉取消息拉取方法\",{\"1\":{\"1119\":1}}],[\"后执行\",{\"1\":{\"932\":1}}],[\"后执行命令\",{\"1\":{\"143\":1}}],[\"后会启动一个新的定时任务进行下一次扫描\",{\"1\":{\"932\":1}}],[\"后才会被删除\",{\"1\":{\"866\":1}}],[\"后改成\",{\"1\":{\"841\":1}}],[\"后的\",{\"1\":{\"806\":1}}],[\"后\",{\"1\":{\"621\":1,\"643\":1,\"655\":1,\"668\":1,\"879\":1,\"883\":1,\"1294\":1,\"1403\":1,\"1510\":1}}],[\"后来后投递\",{\"1\":{\"925\":1}}],[\"后来\",{\"1\":{\"399\":1,\"1338\":1}}],[\"后来看了一些\",{\"1\":{\"271\":1}}],[\"后者看做数据消费者\",{\"1\":{\"724\":1}}],[\"后者是前者的子类型\",{\"1\":{\"524\":1}}],[\"后者负责处理接受worker端发来的通讯请求\",{\"1\":{\"374\":1}}],[\"后者表示系统伸缩的速率\",{\"1\":{\"285\":1}}],[\"后续收到生产者的本地事务执行结果后\",{\"1\":{\"1450\":1}}],[\"后续不会新建而是重复使用这个拉取请求\",{\"1\":{\"1152\":1}}],[\"后续有新的任务进来\",{\"1\":{\"852\":1}}],[\"后续的流控就是关联的解决方法\",{\"1\":{\"690\":1}}],[\"后续按释放横扫\",{\"1\":{\"490\":1}}],[\"后续还有的话就按上述循环\",{\"1\":{\"446\":1}}],[\"后续源码解析基于4\",{\"1\":{\"373\":1}}],[\"后续通过\",{\"1\":{\"124\":1}}],[\"后接空白\",{\"1\":{\"180\":1}}],[\"后接一串字母\",{\"1\":{\"175\":1}}],[\"后剩下的余数\",{\"1\":{\"174\":1}}],[\"后面没有操作\",{\"1\":{\"1435\":1}}],[\"后面讲解\",{\"1\":{\"1188\":1}}],[\"后面按照最大的时间间隔来重试\",{\"1\":{\"1100\":1}}],[\"后面是一个表达式\",{\"1\":{\"605\":1}}],[\"后面是当前函数完成后将会返回的各个函数清单\",{\"1\":{\"256\":1}}],[\"后面成员的值就会从这个值开始递增\",{\"1\":{\"583\":1}}],[\"后面都是机制\",{\"1\":{\"422\":1}}],[\"后面随着装等的提升\",{\"1\":{\"399\":1}}],[\"后面就佛系打本\",{\"1\":{\"399\":1}}],[\"后面的消息才能投递\",{\"1\":{\"1342\":1}}],[\"后面的消息\",{\"1\":{\"1195\":1}}],[\"后面的\",{\"1\":{\"1195\":1,\"1261\":1}}],[\"后面的表达式\",{\"1\":{\"605\":1}}],[\"后面的定义比前面的定义具有更高的优先级\",{\"1\":{\"563\":1}}],[\"后面的限定符可以是生成器\",{\"1\":{\"184\":1}}],[\"后面的参数是\",{\"1\":{\"62\":1}}],[\"后面的参数src\",{\"1\":{\"21\":1}}],[\"后面那个也是一个映射\",{\"1\":{\"167\":1}}],[\"后向匹配\",{\"1\":{\"149\":1}}],[\"后创建\",{\"1\":{\"7\":1}}],[\"$java\",{\"1\":{\"1077\":1}}],[\"$和\",{\"1\":{\"294\":1}}],[\"$a\",{\"1\":{\"215\":1}}],[\"$a实际上就是代表字符a的整数\",{\"1\":{\"178\":1}}],[\"$s\",{\"1\":{\"178\":2}}],[\"$myvimrc\",{\"1\":{\"165\":1}}],[\"$null\",{\"1\":{\"165\":1}}],[\"$env\",{\"1\":{\"165\":3}}],[\"$\",{\"1\":{\"21\":3,\"25\":2,\"145\":1,\"165\":1,\"215\":1,\"224\":2,\"252\":4,\"289\":1,\"297\":1,\"369\":4,\"499\":2,\"500\":3,\"598\":1,\"605\":2,\"1072\":1,\"1073\":2,\"1074\":3,\"1075\":9,\"1077\":5,\"1078\":2,\"1079\":4,\"1080\":10,\"1083\":2,\"1084\":2,\"1395\":1}}],[\"│browser│<──────>│web\",{\"1\":{\"78\":1}}],[\"│servlet\",{\"1\":{\"78\":1}}],[\"│my\",{\"1\":{\"78\":1}}],[\"│class││parameterizedtype││genericarraytype││wildcardtype│\",{\"1\":{\"46\":1}}],[\"│type│\",{\"1\":{\"46\":1}}],[\"│illegalargumentexception\",{\"1\":{\"33\":1}}],[\"│nullpointerexception\",{\"1\":{\"33\":1}}],[\"││ioexception│\",{\"1\":{\"33\":1}}],[\"│runtimeexception\",{\"1\":{\"33\":1}}],[\"│outofmemoryerror\",{\"1\":{\"33\":1}}],[\"│\",{\"1\":{\"21\":2,\"33\":19,\"46\":5,\"78\":2,\"749\":15}}],[\"则向客户端返回成功\",{\"1\":{\"1521\":1}}],[\"则向所有节点发送心跳\",{\"1\":{\"1485\":1}}],[\"则输出当前状态日志\",{\"1\":{\"1521\":1}}],[\"则日志转发器状态为\",{\"1\":{\"1519\":1}}],[\"则跳出循环\",{\"1\":{\"1519\":1}}],[\"则跳过\",{\"1\":{\"903\":1,\"1215\":1}}],[\"则初始化\",{\"1\":{\"1517\":1}}],[\"则初始化文件\",{\"1\":{\"1427\":1}}],[\"则磁盘满\",{\"1\":{\"1517\":1}}],[\"则立即拒绝\",{\"1\":{\"1516\":1}}],[\"则继续判断\",{\"1\":{\"1510\":1}}],[\"则认为我对端未准备好\",{\"1\":{\"1497\":1}}],[\"则认为是过期文件\",{\"1\":{\"870\":1}}],[\"则切换成\",{\"1\":{\"1495\":1}}],[\"则投票给请求拉票的节点\",{\"1\":{\"1492\":1}}],[\"则投票给它并更新当前轮次\",{\"1\":{\"1480\":1}}],[\"则当前节点用对方的\",{\"1\":{\"1492\":1}}],[\"则当前节点切换为\",{\"1\":{\"1489\":1}}],[\"则说明已经有\",{\"1\":{\"1480\":1}}],[\"则转换为\",{\"1\":{\"1479\":1}}],[\"则结束本次回查\",{\"1\":{\"1468\":1}}],[\"则表示该消息是一个事务半消息\",{\"1\":{\"1450\":1}}],[\"则表示为同步副本数\",{\"1\":{\"655\":1}}],[\"则服务端对生产者进行定期回查本地事务执行状态\",{\"1\":{\"1446\":1}}],[\"则进行判断\",{\"1\":{\"1486\":1}}],[\"则进行刷盘\",{\"1\":{\"1427\":1}}],[\"则进行一次刷盘\",{\"1\":{\"752\":1}}],[\"则滚动文件\",{\"1\":{\"1427\":1}}],[\"则销毁文件\",{\"1\":{\"1427\":1}}],[\"则创建扩展\",{\"1\":{\"1425\":1}}],[\"则创建新的索引文件后\",{\"1\":{\"1414\":1}}],[\"则创建一个文件\",{\"1\":{\"793\":1}}],[\"则创建一个新的索引文件\",{\"1\":{\"789\":1}}],[\"则缩小单次读取长度\",{\"1\":{\"1408\":1,\"1432\":1}}],[\"则截断上传\",{\"1\":{\"1403\":1}}],[\"则使用消息属性中定义的免疫回查时长\",{\"1\":{\"1468\":1}}],[\"则使用本地存储的引用调用其\",{\"1\":{\"1401\":1}}],[\"则使用短轮询\",{\"1\":{\"1173\":1}}],[\"则用一个专门的消息上传线程池异步上传已被放入缓冲区的消息\",{\"1\":{\"1388\":1}}],[\"则读消息的速度将受到较严重的影响\",{\"1\":{\"1364\":1}}],[\"则什么都不做\",{\"1\":{\"1359\":1}}],[\"则一定不需要消费\",{\"1\":{\"1333\":1}}],[\"则消费者名称的位映射\",{\"1\":{\"1332\":1}}],[\"则消费逻辑已经结束\",{\"1\":{\"1188\":1}}],[\"则为支持重试\",{\"1\":{\"1318\":1}}],[\"则为其设置延迟等级\",{\"1\":{\"1188\":1}}],[\"则根据过滤信息编译\",{\"1\":{\"1321\":1}}],[\"则根据消费组设定的过滤表达式\",{\"1\":{\"1315\":1}}],[\"则根据客户端传过来的数据构造subscriptiondata\",{\"1\":{\"1173\":1}}],[\"则可以进行压缩\",{\"1\":{\"1435\":1}}],[\"则可以看作类似文件路径的字符串\",{\"1\":{\"1290\":1}}],[\"则可以用这种方式构建自己的镜像\",{\"1\":{\"1072\":1}}],[\"则再拉取一次重试消息\",{\"1\":{\"1269\":1}}],[\"则再次执行\",{\"1\":{\"1040\":1}}],[\"则拉取所有队列\",{\"1\":{\"1269\":1}}],[\"则拉到一个任务马上进行处理\",{\"1\":{\"916\":1}}],[\"则修改它码表的对应位\",{\"1\":{\"1262\":1}}],[\"则修改消息的\",{\"1\":{\"837\":1}}],[\"则先拉取重试\",{\"1\":{\"1257\":1}}],[\"则\",{\"1\":{\"1251\":1,\"1257\":2}}],[\"则放入时间轮\",{\"1\":{\"1347\":1}}],[\"则放入slow\",{\"1\":{\"379\":1}}],[\"则放进死信队列\",{\"1\":{\"1188\":1}}],[\"则需要等待\",{\"1\":{\"1360\":1}}],[\"则需要在消息被老化前重新将其放入\",{\"1\":{\"1347\":1}}],[\"则需要将失败的消息发回\",{\"1\":{\"1179\":1}}],[\"则需要修改\",{\"1\":{\"1079\":1}}],[\"则通过服务端数据构造subscriptiondata\",{\"1\":{\"1173\":1}}],[\"则通过pullmessageprocessor的executerequestwhenwakeup\",{\"1\":{\"815\":1}}],[\"则是负责\",{\"1\":{\"1481\":1}}],[\"则是标记当前\",{\"1\":{\"1300\":1}}],[\"则是\",{\"1\":{\"1173\":1}}],[\"则是由\",{\"1\":{\"672\":1}}],[\"则丢弃processqueue\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"则抛出异常\",{\"1\":{\"1053\":1}}],[\"则会在后续调用\",{\"1\":{\"1442\":1}}],[\"则会在消息生产的构建索引阶段\",{\"1\":{\"1323\":1}}],[\"则会作为\",{\"1\":{\"1405\":1}}],[\"则会无限次重试等待\",{\"1\":{\"1355\":1}}],[\"则会将真正要投递的\",{\"1\":{\"1354\":1}}],[\"则会返回\",{\"1\":{\"1300\":2}}],[\"则会发送信息\",{\"1\":{\"1300\":1}}],[\"则会转移到磁盘中\",{\"1\":{\"1261\":1}}],[\"则会被放入死信\",{\"1\":{\"1180\":1}}],[\"则会抛出异常\",{\"1\":{\"1039\":1}}],[\"则会使用默认\",{\"1\":{\"1039\":1}}],[\"则会执行一次刷盘\",{\"1\":{\"758\":1}}],[\"则直接销毁文件\",{\"1\":{\"1427\":1}}],[\"则直接放行\",{\"1\":{\"978\":1}}],[\"则直接执行\",{\"1\":{\"379\":1}}],[\"则从等待表中删除\",{\"1\":{\"1510\":1}}],[\"则从该偏移量开始构建\",{\"1\":{\"1294\":1}}],[\"则从该\",{\"1\":{\"1065\":1}}],[\"则从nameserver上获取\",{\"1\":{\"1051\":1}}],[\"则从\",{\"1\":{\"973\":1,\"1053\":1,\"1511\":1}}],[\"则从存活\",{\"1\":{\"945\":1}}],[\"则返回给消费者消费\",{\"1\":{\"1319\":1}}],[\"则返回给消费者\",{\"1\":{\"1314\":1,\"1329\":1}}],[\"则返回\",{\"1\":{\"971\":1,\"1510\":1}}],[\"则关闭与\",{\"1\":{\"954\":1}}],[\"则无法向\",{\"1\":{\"954\":1}}],[\"则发生缺页中断\",{\"1\":{\"882\":1}}],[\"则删除一条保存最久的消息\",{\"1\":{\"1065\":1}}],[\"则删除文件\",{\"1\":{\"870\":1}}],[\"则删除check\",{\"1\":{\"793\":1}}],[\"则仍需要等待\",{\"1\":{\"866\":1}}],[\"则等待一会后重新同步投递\",{\"1\":{\"855\":1}}],[\"则更新成功心跳时间戳\",{\"1\":{\"1488\":1}}],[\"则更新消费进度\",{\"1\":{\"1163\":1,\"1173\":1,\"1179\":1}}],[\"则更新偏移量\",{\"1\":{\"1104\":1}}],[\"则更新\",{\"1\":{\"855\":1}}],[\"则把消息的\",{\"1\":{\"836\":1}}],[\"则把array的最后一个元素删除掉\",{\"1\":{\"298\":1}}],[\"则新建一个文件<br>\",{\"1\":{\"793\":1}}],[\"则新建一个文件\",{\"1\":{\"793\":1}}],[\"则有多少刷多少\",{\"1\":{\"769\":1}}],[\"则标识这次刷盘必须刷多少个page\",{\"1\":{\"769\":1}}],[\"则执行提交或回滚操作\",{\"1\":{\"1446\":1}}],[\"则执行\",{\"1\":{\"1294\":1}}],[\"则执行发送之前的钩子函数\",{\"1\":{\"1053\":1}}],[\"则执行路由删除逻辑\",{\"1\":{\"954\":1}}],[\"则执行刷盘\",{\"1\":{\"769\":1}}],[\"则执行最终任务\",{\"1\":{\"378\":1}}],[\"则指定一阶段处理线程池大小\",{\"1\":{\"734\":1}}],[\"则重启之后队列也会消失\",{\"1\":{\"684\":1}}],[\"则这些消息将丢失\",{\"1\":{\"658\":1}}],[\"则将请求中的日志数据写入\",{\"1\":{\"1511\":1}}],[\"则将缓冲区中的数据刷到二级存储\",{\"1\":{\"1427\":1}}],[\"则将实例化插件存储\",{\"1\":{\"1398\":1}}],[\"则将消息发回给\",{\"1\":{\"1180\":1}}],[\"则将该消息的\",{\"1\":{\"834\":1}}],[\"则将在声明客户机连接的节点上创建队列\",{\"1\":{\"657\":1}}],[\"则将队列镜像到所有节点\",{\"1\":{\"657\":1}}],[\"则不推送新的日志到\",{\"1\":{\"1510\":1}}],[\"则不作处理\",{\"1\":{\"1451\":1}}],[\"则不执行\",{\"1\":{\"1449\":1}}],[\"则不进行刷盘\",{\"1\":{\"1427\":1}}],[\"则不会调用\",{\"1\":{\"1442\":1}}],[\"则不会释放它的\",{\"1\":{\"1215\":1}}],[\"则不会执行\",{\"1\":{\"1047\":1}}],[\"则不等待直接进行第二个任务\",{\"1\":{\"932\":1}}],[\"则不构成错误\",{\"1\":{\"657\":1}}],[\"则不设置\",{\"1\":{\"625\":1}}],[\"则其行为取决于队列是否持久化\",{\"1\":{\"657\":1}}],[\"则该队列会自动创建为镜像队列\",{\"1\":{\"655\":1}}],[\"则调用本地存储\",{\"1\":{\"1405\":1}}],[\"则调用原来的逻辑去获取并且缓存到该\",{\"1\":{\"897\":1}}],[\"则调用\",{\"1\":{\"125\":1,\"1403\":1,\"1405\":1}}],[\"则开启一个新事务\",{\"1\":{\"87\":1}}],[\"则开启一个嵌套级别事务\",{\"1\":{\"87\":1}}],[\"则classpath为bin或者\",{\"1\":{\"21\":1}}],[\"则javac命令没有任何输出\",{\"1\":{\"21\":1}}],[\"则编译报错\",{\"1\":{\"20\":1}}],[\"则各个线程串行执行\",{\"1\":{\"4\":1}}],[\"查消息时使用\",{\"1\":{\"1414\":1}}],[\"查出消费索引后\",{\"1\":{\"1318\":1}}],[\"查出完整消息后\",{\"1\":{\"1318\":1}}],[\"查出完整消息\",{\"1\":{\"1318\":1}}],[\"查出这批消息中要重试消息对应的真实消息\",{\"1\":{\"1253\":1}}],[\"查出所有待执行的job\",{\"1\":{\"374\":1}}],[\"查\",{\"1\":{\"371\":1}}],[\"查看\",{\"1\":{\"1079\":1}}],[\"查看集群状态\",{\"1\":{\"1078\":1}}],[\"查看可选版本列表\",{\"1\":{\"1072\":1}}],[\"查看消息轨迹\",{\"0\":{\"1008\":1,\"1009\":1}}],[\"查看到构造消费索引的方法中包含了\",{\"1\":{\"914\":1}}],[\"查看其执行状态并执行对应操作\",{\"1\":{\"861\":1}}],[\"查看属性中是否有延迟等级信息\",{\"1\":{\"834\":1}}],[\"查看是否超时\",{\"1\":{\"825\":1}}],[\"查看当前节点状态\",{\"1\":{\"645\":1}}],[\"查看高手第一视角的技能顺序\",{\"1\":{\"399\":1}}],[\"查看允许的最大进程数量\",{\"1\":{\"231\":1}}],[\"查看寄存器内容\",{\"1\":{\"157\":1}}],[\"查看文档\",{\"1\":{\"153\":1,\"154\":1}}],[\"查看帮助\",{\"1\":{\"143\":1}}],[\"查看结果\",{\"0\":{\"11\":1}}],[\"查询完本地事务执行状态\",{\"1\":{\"1464\":1}}],[\"查询索引项\",{\"0\":{\"1436\":1}}],[\"查询时\",{\"1\":{\"1401\":1}}],[\"查询已提交二级存储的\",{\"1\":{\"1391\":1}}],[\"查询出该事务半消息的消息体\",{\"1\":{\"1468\":1}}],[\"查询出原始消息中要取消消息的\",{\"1\":{\"1359\":1}}],[\"查询出相应的\",{\"1\":{\"751\":1}}],[\"查询原始消息\",{\"0\":{\"1359\":1,\"1373\":1}}],[\"查询的原理是\",{\"1\":{\"1322\":1}}],[\"查询的最大消息数量\",{\"1\":{\"767\":1,\"1174\":1}}],[\"查询要分发的队列的逻辑偏移量\",{\"1\":{\"1296\":1}}],[\"查询要分发的\",{\"1\":{\"1294\":1}}],[\"查询一批\",{\"1\":{\"1278\":1,\"1453\":1}}],[\"查询对应的真正消息\",{\"1\":{\"1263\":1}}],[\"查询自己的分配结果\",{\"1\":{\"1255\":1}}],[\"查询是否加锁等操作\",{\"1\":{\"1212\":1}}],[\"查询发回的消息\",{\"1\":{\"1198\":1}}],[\"查询和持久化消费进度的方法\",{\"1\":{\"1190\":1}}],[\"查询偏移量\",{\"1\":{\"1159\":1}}],[\"查询所有注册的\",{\"1\":{\"1104\":1}}],[\"查询轨迹结果\",{\"1\":{\"1008\":1}}],[\"查询轨迹\",{\"1\":{\"1008\":1}}],[\"查询该\",{\"1\":{\"897\":1}}],[\"查询保存时间在\",{\"1\":{\"789\":1}}],[\"查询到消息在\",{\"1\":{\"778\":1,\"868\":1}}],[\"查询到消息在存储中的位置\",{\"1\":{\"687\":1}}],[\"查询\",{\"0\":{\"1296\":1},\"1\":{\"767\":1,\"1030\":1,\"1039\":1,\"1042\":1,\"1160\":1,\"1226\":1,\"1278\":1,\"1280\":1}}],[\"查询并解析消息\",{\"1\":{\"762\":1}}],[\"查询消息而创建的\",{\"1\":{\"1393\":1}}],[\"查询消息的能力\",{\"1\":{\"778\":1}}],[\"查询消息结果\",{\"1\":{\"767\":1,\"1174\":1}}],[\"查询消息\",{\"0\":{\"751\":1,\"757\":1,\"766\":1},\"1\":{\"767\":1,\"1370\":1,\"1386\":1}}],[\"查询本server负责的所有appid列表\",{\"1\":{\"374\":2}}],[\"查询语句\",{\"1\":{\"92\":1}}],[\"查询名称\",{\"1\":{\"92\":1}}],[\"查找topic配置信息\",{\"1\":{\"1173\":1}}],[\"查找路由信息\",{\"0\":{\"1051\":1}}],[\"查找主题路由信息\",{\"1\":{\"1050\":1}}],[\"查找的\",{\"1\":{\"888\":1}}],[\"查找的key\",{\"1\":{\"797\":1}}],[\"查找时是否加锁\",{\"1\":{\"797\":1}}],[\"查找时间是恒定的\",{\"1\":{\"247\":1}}],[\"查找消息的能力\",{\"1\":{\"927\":1}}],[\"查找消息的结束时间\",{\"1\":{\"797\":1}}],[\"查找消息的开始时间\",{\"1\":{\"797\":1}}],[\"查找消息最大时间\",{\"1\":{\"794\":1}}],[\"查找消息最小时间\",{\"1\":{\"794\":1}}],[\"查找索引对应的message符合时间的indexfile\",{\"1\":{\"794\":1}}],[\"查找索引对应的\",{\"1\":{\"789\":1,\"790\":1,\"797\":1}}],[\"查找所有匹配的\",{\"1\":{\"668\":1}}],[\"查找\",{\"0\":{\"888\":1,\"1039\":1},\"1\":{\"310\":1,\"764\":1,\"888\":1,\"1038\":1,\"1197\":1,\"1263\":1,\"1297\":1}}],[\"查找并且替换文本\",{\"1\":{\"150\":1}}],[\"查找java\",{\"1\":{\"20\":1}}],[\"查找import的包是否包含这个class\",{\"1\":{\"20\":1}}],[\"查找当前package是否存在这个class\",{\"1\":{\"20\":1}}],[\"按已经保存的日志序号大小降序排序\",{\"1\":{\"1521\":1}}],[\"按时间顺序找到下一个\",{\"1\":{\"1435\":1}}],[\"按时间查询\",{\"1\":{\"789\":1}}],[\"按策略分配\",{\"1\":{\"1143\":1}}],[\"按预设的策略将队列分配给消费者\",{\"1\":{\"1130\":1}}],[\"按消息轨迹存储协议进行编码\",{\"1\":{\"1021\":1}}],[\"按\",{\"1\":{\"877\":1,\"1021\":2,\"1097\":1}}],[\"按此步骤创建镜像策略\",{\"1\":{\"652\":1}}],[\"按一下变猫\",{\"1\":{\"490\":1}}],[\"按一下变熊\",{\"1\":{\"490\":1}}],[\"按两下狂暴回复\",{\"1\":{\"490\":1}}],[\"按豆豆的说法\",{\"1\":{\"421\":1,\"476\":1}}],[\"按需付费\",{\"1\":{\"276\":1}}],[\"按照\",{\"1\":{\"1517\":1}}],[\"按照重试次数来修改下一次的可见时间\",{\"1\":{\"1251\":1}}],[\"按照订阅组配置重定向\",{\"1\":{\"1173\":1}}],[\"按照相同规则对批量消息进行解码\",{\"1\":{\"1044\":1}}],[\"按照轮询的方式选择队列\",{\"1\":{\"1041\":1}}],[\"按照星际的经验\",{\"1\":{\"399\":1}}],[\"按照erlang的惯例\",{\"1\":{\"211\":1}}],[\"按照如上所示的流程进行基准测试\",{\"1\":{\"4\":1}}],[\"按下\",{\"1\":{\"167\":3}}],[\"按下面的顺序依次查找\",{\"1\":{\"20\":1}}],[\"编码工作\",{\"1\":{\"736\":1}}],[\"编码\",{\"1\":{\"111\":1,\"112\":1,\"120\":1}}],[\"编码范围从0到127\",{\"1\":{\"27\":1}}],[\"编程库与框架\",{\"0\":{\"239\":1}}],[\"编程模型\",{\"1\":{\"136\":1}}],[\"编程模型使用\",{\"1\":{\"110\":1}}],[\"编程模型的思想\",{\"1\":{\"108\":1}}],[\"编程都与它一样或是它的变体\",{\"1\":{\"108\":1}}],[\"编程\",{\"0\":{\"68\":1,\"71\":1}}],[\"编译\",{\"0\":{\"1321\":1},\"1\":{\"1321\":1}}],[\"编译成\",{\"1\":{\"593\":1}}],[\"编译设置\",{\"0\":{\"593\":1}}],[\"编译结果\",{\"1\":{\"576\":1}}],[\"编译后\",{\"1\":{\"582\":1}}],[\"编译后依然存在\",{\"1\":{\"564\":1}}],[\"编译后的模块以\",{\"1\":{\"180\":1}}],[\"编译这个模块\",{\"1\":{\"230\":1}}],[\"编译之后产生\",{\"1\":{\"180\":1}}],[\"编译期\",{\"1\":{\"85\":1}}],[\"编译时直接调用tsc命令就可以了\",{\"1\":{\"499\":1}}],[\"编译时\",{\"1\":{\"497\":1}}],[\"编译时需要用到\",{\"1\":{\"60\":1}}],[\"编译时需要用到该jar包\",{\"1\":{\"60\":1}}],[\"编译时不需要\",{\"1\":{\"60\":1}}],[\"编译test时需要用到该jar包\",{\"1\":{\"60\":1}}],[\"编译器的类型推断\",{\"1\":{\"589\":1}}],[\"编译器\",{\"0\":{\"498\":1}}],[\"编译器会根据t的类型自动为我们实行安全地强制转型\",{\"1\":{\"48\":1}}],[\"编译器内部永远把所有类型t视为object处理\",{\"1\":{\"48\":1}}],[\"编译器查找类的步骤\",{\"0\":{\"20\":1}}],[\"编译src目录下的所有java文件\",{\"1\":{\"21\":1}}],[\"编译和运行程序\",{\"0\":{\"222\":1}}],[\"编译和运行\",{\"0\":{\"21\":1}}],[\"编写自定义的过滤规则\",{\"1\":{\"1303\":1}}],[\"编写工厂方法\",{\"1\":{\"341\":1}}],[\"编写一个分布式程序\",{\"0\":{\"238\":1}}],[\"编写并发程序的三要素\",{\"1\":{\"230\":1}}],[\"编写并发程序只需要三个基本函数\",{\"1\":{\"228\":1}}],[\"编写了一个启动类\",{\"1\":{\"133\":1}}],[\"编写泛型\",{\"0\":{\"47\":1}}],[\"编写测试代码\",{\"0\":{\"9\":1}}],[\"编写的测试代码可能有缺陷\",{\"1\":{\"3\":1}}],[\"笔记\",{\"0\":{\"16\":1,\"263\":1,\"291\":1,\"493\":1},\"1\":{\"138\":1,\"608\":2}}],[\"教程\",{\"0\":{\"16\":1,\"291\":1,\"493\":1},\"1\":{\"138\":1,\"608\":1}}],[\"廖雪峰\",{\"0\":{\"16\":1,\"291\":1},\"1\":{\"138\":1,\"608\":1}}],[\"性能之道\",{\"1\":{\"1527\":1}}],[\"性能可以达到十万级别\",{\"1\":{\"1028\":1}}],[\"性能可以提升多个数量级\",{\"1\":{\"1027\":1}}],[\"性能也更好\",{\"1\":{\"930\":1}}],[\"性能高\",{\"1\":{\"928\":2}}],[\"性能和可靠性\",{\"1\":{\"924\":1}}],[\"性能等方面无法都达到完美\",{\"1\":{\"922\":1}}],[\"性能更高\",{\"1\":{\"894\":1}}],[\"性能更好\",{\"1\":{\"694\":1}}],[\"性能对比\",{\"1\":{\"893\":1}}],[\"性能\",{\"0\":{\"737\":1},\"1\":{\"922\":1}}],[\"性能最关键的一个锁\",{\"1\":{\"733\":1,\"736\":1}}],[\"性能优化\",{\"0\":{\"719\":1,\"885\":1,\"887\":1},\"1\":{\"1538\":2}}],[\"性能优化神器\",{\"0\":{\"1\":1},\"1\":{\"138\":1}}],[\"性能强劲无上限\",{\"1\":{\"380\":1}}],[\"性能会有瓶颈\",{\"1\":{\"371\":1}}],[\"性能测试\",{\"1\":{\"286\":1}}],[\"性能明显下降\",{\"1\":{\"285\":1}}],[\"性能分析\",{\"0\":{\"254\":1}}],[\"性能持续提高\",{\"1\":{\"115\":1}}],[\"性能调优必备利器之\",{\"1\":{\"15\":1}}],[\"自定义输入流\",{\"1\":{\"1428\":1}}],[\"自研了任意时间定时消息\",{\"1\":{\"1338\":1}}],[\"自研的存储的目的是为了能够长期保存定时消息\",{\"1\":{\"928\":1}}],[\"自研存储\",{\"1\":{\"928\":1}}],[\"自身的类型声明\",{\"1\":{\"570\":1}}],[\"自身放到\",{\"1\":{\"124\":1}}],[\"自然迅捷\",{\"1\":{\"490\":2}}],[\"自然之威\",{\"1\":{\"401\":1}}],[\"自如变形是变猫输出神器\",{\"1\":{\"403\":1}}],[\"自动删除输入类型的\",{\"1\":{\"593\":1}}],[\"自动实现异步调用\",{\"1\":{\"354\":1}}],[\"自动根据生命周期运行到指定的\",{\"1\":{\"62\":1}}],[\"自动装箱和自动拆箱只发生在编译阶段\",{\"1\":{\"30\":1}}],[\"自助性能测试\",{\"1\":{\"15\":1}}],[\"自己转换成\",{\"1\":{\"1480\":1}}],[\"自己来做数据转冷\",{\"1\":{\"1385\":1}}],[\"自己吃大红\",{\"1\":{\"485\":1}}],[\"自己吃越多越好\",{\"1\":{\"433\":1}}],[\"自己磕大红或者洞穴住民\",{\"1\":{\"434\":1}}],[\"自己实现基准测试代码时\",{\"1\":{\"3\":1}}],[\"自己写一个测试方法或者\",{\"1\":{\"2\":1}}],[\"与page\",{\"1\":{\"1537\":1}}],[\"与preserve相同\",{\"1\":{\"593\":1}}],[\"与状态机\",{\"1\":{\"1519\":1}}],[\"与当前\",{\"1\":{\"1521\":1}}],[\"与当前不同的挂起请求\",{\"1\":{\"1521\":1}}],[\"与当前不同\",{\"1\":{\"1512\":1,\"1521\":1}}],[\"与当前时间对比\",{\"1\":{\"954\":1}}],[\"与客户端有时间差\",{\"1\":{\"1468\":1}}],[\"与本地存储不同\",{\"1\":{\"1383\":1}}],[\"与内存中的\",{\"1\":{\"1276\":1}}],[\"与服务端交互拉取消息\",{\"1\":{\"1159\":1}}],[\"与消息队列一一对应\",{\"1\":{\"1137\":1}}],[\"与消息的\",{\"1\":{\"668\":1}}],[\"与触发点\",{\"1\":{\"1136\":1}}],[\"与集群一起用\",{\"0\":{\"1078\":1}}],[\"与普通消息公用存储\",{\"1\":{\"1010\":1}}],[\"与普通消息共用存储\",{\"1\":{\"928\":1}}],[\"与其他组件交互的示意图\",{\"1\":{\"945\":1}}],[\"与其他任何值都不相等\",{\"1\":{\"531\":1}}],[\"与镜像队列类似\",{\"1\":{\"695\":1}}],[\"与存储相关的持久化包括队列的持久化和消息的持久化\",{\"1\":{\"683\":1}}],[\"与全局流控不是一个概念\",{\"1\":{\"614\":1}}],[\"与number\",{\"1\":{\"524\":1}}],[\"与队伍站在一起\",{\"1\":{\"434\":1}}],[\"与爆裂增生非常契合\",{\"1\":{\"407\":1}}],[\"与精通相关\",{\"1\":{\"401\":1}}],[\"与下面的\",{\"1\":{\"354\":1}}],[\"与此同时\",{\"1\":{\"286\":1}}],[\"与可靠性不同\",{\"1\":{\"285\":1}}],[\"与越来越多的容器化架构应用的出现\",{\"1\":{\"276\":1}}],[\"与进程同步创建\",{\"1\":{\"229\":1}}],[\"与映射组\",{\"0\":{\"190\":1}}],[\"与方法返回类型相同\",{\"1\":{\"76\":1}}],[\"与\",{\"0\":{\"564\":1,\"942\":1,\"1081\":1,\"1261\":1,\"1274\":1,\"1524\":1},\"1\":{\"15\":1,\"116\":1,\"118\":1,\"127\":1,\"285\":1,\"298\":1,\"503\":1,\"594\":1,\"760\":1,\"789\":1,\"1036\":1,\"1095\":1,\"1249\":1,\"1253\":1,\"1258\":1,\"1278\":1,\"1290\":1,\"1291\":1,\"1351\":1,\"1352\":1,\"1453\":1,\"1517\":1,\"1519\":1,\"1520\":1}}],[\"拾遗\",{\"1\":{\"15\":1}}],[\"详解见\",{\"1\":{\"1386\":1}}],[\"详解\",{\"0\":{\"865\":1,\"939\":1,\"975\":1,\"1535\":1},\"1\":{\"1538\":2}}],[\"详解36个官方例子\",{\"1\":{\"13\":1,\"15\":1}}],[\"详情页面\",{\"1\":{\"711\":1}}],[\"详情\",{\"1\":{\"711\":1}}],[\"详情请参阅未同步的镜像部分\",{\"1\":{\"658\":1}}],[\"详细逻辑如下\",{\"1\":{\"1449\":1,\"1451\":1}}],[\"详细记录消息各个处理环节的日志\",{\"1\":{\"1003\":1}}],[\"详细的逻辑结构\",{\"1\":{\"785\":1}}],[\"详细的hql语法可以参考hibernate文档\",{\"1\":{\"92\":1}}],[\"详细流程\",{\"0\":{\"620\":1,\"807\":1,\"835\":1}}],[\"详细设计\",{\"0\":{\"389\":1,\"754\":1,\"784\":1,\"946\":1,\"1013\":1,\"1034\":1,\"1062\":1,\"1113\":1,\"1131\":1,\"1154\":1,\"1185\":1,\"1210\":1,\"1254\":1,\"1292\":1,\"1316\":1,\"1349\":1,\"1396\":1,\"1481\":1,\"1508\":1}}],[\"详细讲解了它的可靠性模型和弹性模型的工作原理\",{\"1\":{\"275\":1}}],[\"详见该项目\",{\"1\":{\"1249\":1}}],[\"详见\",{\"1\":{\"13\":1,\"1338\":1}}],[\"高水位线通过\",{\"1\":{\"1300\":1}}],[\"高水位为\",{\"1\":{\"1299\":1}}],[\"高可靠的原理\",{\"1\":{\"1024\":1}}],[\"高可靠\",{\"1\":{\"923\":1}}],[\"高可用设计\",{\"0\":{\"1031\":1}}],[\"高可用\",{\"1\":{\"371\":1}}],[\"高精度\",{\"1\":{\"923\":1}}],[\"高层\",{\"1\":{\"438\":1}}],[\"高额尖刺\",{\"1\":{\"442\":1}}],[\"高额\",{\"1\":{\"411\":2,\"475\":1}}],[\"高频率执行则使用秒级任务\",{\"1\":{\"374\":1}}],[\"高并发性\",{\"1\":{\"372\":1}}],[\"高性能优化之路\",{\"1\":{\"743\":1}}],[\"高性能最佳实践\",{\"1\":{\"707\":1}}],[\"高性能\",{\"1\":{\"371\":1,\"923\":1}}],[\"高性能程序时有没有这样的场景\",{\"1\":{\"2\":1}}],[\"高级语言通常都提供了更抽象的错误处理逻辑try\",{\"1\":{\"355\":1}}],[\"高级用法\",{\"0\":{\"13\":1,\"713\":1}}],[\"高阶函数\",{\"0\":{\"181\":1,\"321\":1,\"546\":1}}],[\"高质量的服务\",{\"1\":{\"115\":1}}],[\"高吞吐\",{\"1\":{\"115\":1}}],[\"高耦合性\",{\"1\":{\"81\":1}}],[\"注销\",{\"1\":{\"1331\":1}}],[\"注\",{\"1\":{\"285\":1}}],[\"注释\",{\"1\":{\"171\":1}}],[\"注释详解\",{\"0\":{\"12\":1}}],[\"注册过滤信息\",{\"0\":{\"1331\":1}}],[\"注册消费者时会预先编译好\",{\"1\":{\"1321\":1}}],[\"注册消费者时就会把过滤信息\",{\"1\":{\"1319\":1}}],[\"注册消费者到客户端实例\",{\"1\":{\"1122\":1}}],[\"注册消息过滤钩子函数列表\",{\"1\":{\"1120\":1,\"1122\":1}}],[\"注册消息轨迹采集钩子\",{\"0\":{\"1019\":1},\"1\":{\"1019\":1}}],[\"注册发送消息处理器\",{\"0\":{\"1055\":1}}],[\"注册服务\",{\"1\":{\"1047\":1}}],[\"注册不同的业务处理器和线程池去处理\",{\"1\":{\"1043\":1}}],[\"注册了\",{\"1\":{\"1036\":1}}],[\"注册钩子函数\",{\"1\":{\"980\":1}}],[\"注册后更新\",{\"1\":{\"970\":1}}],[\"注册后返回的选择键\",{\"1\":{\"118\":1}}],[\"注册进程\",{\"0\":{\"234\":1}}],[\"注册上去\",{\"1\":{\"135\":1}}],[\"注册到生产者或消费者实例中去\",{\"1\":{\"1014\":1}}],[\"注册到客户端\",{\"1\":{\"984\":1,\"985\":1}}],[\"注册到服务端\",{\"1\":{\"135\":1}}],[\"注册到\",{\"1\":{\"133\":1,\"1037\":1,\"1403\":1}}],[\"注册到的选择器\",{\"1\":{\"118\":1}}],[\"注册\",{\"0\":{\"988\":1,\"994\":1},\"1\":{\"131\":1,\"953\":1,\"960\":1,\"971\":1,\"988\":1,\"994\":1,\"1331\":1}}],[\"注册客户端\",{\"1\":{\"124\":1}}],[\"注册并关注一个\",{\"1\":{\"121\":1}}],[\"注入时\",{\"1\":{\"82\":1}}],[\"注入\",{\"1\":{\"81\":1}}],[\"注意需要重启\",{\"1\":{\"1005\":1}}],[\"注意该函数的入参中有一个cqoffset\",{\"1\":{\"765\":1}}],[\"注意事项\",{\"0\":{\"661\":1},\"1\":{\"1090\":1}}],[\"注意此时需要指定安装\",{\"1\":{\"644\":1}}],[\"注意如果有第三钩\",{\"1\":{\"459\":1}}],[\"注意刷好被感染点名的人的血\",{\"1\":{\"426\":1}}],[\"注意用翡翠灌注来延长\",{\"1\":{\"413\":1}}],[\"注意在变回人之后生命值上限仍然保持\",{\"1\":{\"406\":1}}],[\"注意多出的\",{\"1\":{\"332\":1}}],[\"注意这里还未强制刷盘\",{\"1\":{\"1297\":1}}],[\"注意这里有一句\",{\"1\":{\"904\":1}}],[\"注意这里会创建\",{\"1\":{\"789\":1,\"794\":1}}],[\"注意这里没有新建线程\",{\"1\":{\"123\":1}}],[\"注意这个\",{\"1\":{\"1258\":1}}],[\"注意这个值是从\",{\"1\":{\"787\":1}}],[\"注意这个clean不是lifecycle而是phase\",{\"1\":{\"62\":1}}],[\"注意这样打\",{\"1\":{\"425\":1}}],[\"注意不要引用任何循环变量\",{\"1\":{\"330\":1}}],[\"注意不要使用tostring\",{\"1\":{\"31\":1}}],[\"注意不能引用泛型类型<t>\",{\"1\":{\"47\":1}}],[\"注意\",{\"1\":{\"21\":1,\"71\":1,\"316\":2,\"506\":2,\"529\":1,\"576\":1,\"606\":1,\"624\":1,\"625\":1,\"711\":1,\"765\":1,\"786\":1,\"980\":1,\"1039\":1,\"1080\":1,\"1103\":1,\"1322\":1}}],[\"注解生命周期\",{\"1\":{\"43\":1}}],[\"注解\",{\"0\":{\"42\":1}}],[\"注解来设置启动和停止的方法\",{\"1\":{\"4\":1}}],[\"注解中可以指定执行的迭代次数和每次迭代的执行时常\",{\"1\":{\"4\":1}}],[\"注解的代码在编译之后会被编译成多个执行类以进行基准测试结果输出\",{\"1\":{\"4\":1}}],[\"ul>\",{\"1\":{\"1435\":1}}],[\"uuid\",{\"1\":{\"1021\":1}}],[\"u0001true\",{\"1\":{\"742\":1,\"890\":1}}],[\"u0001taga\",{\"1\":{\"742\":1,\"890\":1}}],[\"u0001value2\",{\"1\":{\"740\":1}}],[\"u0001value1\",{\"1\":{\"740\":1}}],[\"u0002wait\",{\"1\":{\"742\":1,\"890\":1}}],[\"u0002\",{\"1\":{\"740\":2,\"742\":1,\"890\":1}}],[\"u0002key2\",{\"1\":{\"740\":1}}],[\"ui\",{\"1\":{\"614\":1,\"622\":1}}],[\"ui可以观察到\",{\"1\":{\"613\":1}}],[\"umd\",{\"1\":{\"597\":1}}],[\"ug\",{\"1\":{\"429\":1}}],[\"u2uxquzao11nn\",{\"1\":{\"423\":1}}],[\"url的域名必须和当前页面完全一致\",{\"1\":{\"350\":1}}],[\"url\",{\"1\":{\"349\":2,\"354\":3,\"973\":1,\"1047\":1,\"1122\":1,\"1173\":1}}],[\"urgent\",{\"1\":{\"191\":2}}],[\"ubuntu\",{\"1\":{\"641\":1,\"643\":4,\"644\":3,\"1074\":26,\"1075\":3,\"1077\":1,\"1079\":6}}],[\"ubirth\",{\"1\":{\"266\":1}}],[\"ubstitute\",{\"1\":{\"150\":1}}],[\"uewell\",{\"1\":{\"266\":1}}],[\"utilall\",{\"1\":{\"738\":1,\"793\":1,\"970\":1,\"1017\":2,\"1197\":1,\"1198\":2,\"1235\":1,\"1332\":1,\"1472\":1}}],[\"util\",{\"1\":{\"267\":1,\"712\":1,\"1008\":1}}],[\"utilities\",{\"1\":{\"105\":2,\"106\":2}}],[\"ut\",{\"1\":{\"156\":1}}],[\"utf8\",{\"1\":{\"595\":1,\"737\":4}}],[\"utf\",{\"1\":{\"69\":2,\"70\":2,\"72\":2,\"125\":1,\"396\":1,\"714\":1,\"715\":1,\"1339\":1}}],[\"usually\",{\"1\":{\"1519\":3}}],[\"usr\",{\"1\":{\"224\":1}}],[\"using\",{\"1\":{\"103\":1,\"104\":1,\"171\":1,\"644\":1,\"1053\":2}}],[\"useful\",{\"1\":{\"1278\":1}}],[\"uselargepages\",{\"1\":{\"1080\":1}}],[\"used\",{\"1\":{\"396\":1,\"624\":1,\"643\":1,\"767\":1,\"1174\":1,\"1372\":1,\"1430\":1,\"1458\":1,\"1459\":1,\"1472\":1}}],[\"usebiasedlocking\",{\"1\":{\"1080\":1}}],[\"useb\",{\"1\":{\"165\":1}}],[\"usereentrantlockwhenputmessage\",{\"1\":{\"720\":1,\"732\":1,\"733\":1}}],[\"user\",{\"1\":{\"90\":1,\"91\":11,\"92\":6,\"104\":1,\"271\":1,\"551\":6,\"995\":1,\"1000\":1}}],[\"users\",{\"1\":{\"90\":1}}],[\"use\",{\"1\":{\"11\":1,\"97\":1,\"98\":2,\"101\":1,\"102\":1,\"103\":2,\"171\":1,\"296\":2,\"360\":1,\"489\":2,\"490\":3,\"886\":1,\"910\":1,\"1021\":1,\"1248\":1,\"1287\":1,\"1370\":1,\"1372\":1,\"1432\":1,\"1434\":1}}],[\"u\",{\"1\":{\"92\":7,\"141\":1}}],[\"uploaded\",{\"1\":{\"1415\":1,\"1417\":1,\"1427\":1}}],[\"upload\",{\"1\":{\"1394\":1,\"1412\":2,\"1427\":1,\"1435\":3,\"1436\":2}}],[\"upstream\",{\"0\":{\"637\":1},\"1\":{\"630\":2,\"636\":1,\"638\":2}}],[\"up\",{\"1\":{\"585\":2,\"845\":1,\"886\":1,\"913\":2,\"1075\":3,\"1077\":1,\"1079\":4}}],[\"upgraded\",{\"1\":{\"643\":2}}],[\"upgrade表示这个连接将要被转换为websocket连接\",{\"1\":{\"368\":1}}],[\"upgrade\",{\"1\":{\"368\":4,\"1171\":1}}],[\"uptime\",{\"1\":{\"171\":2}}],[\"upword\",{\"1\":{\"145\":1}}],[\"updatable\",{\"1\":{\"90\":2}}],[\"updatecommittedindex\",{\"1\":{\"1520\":3,\"1521\":2}}],[\"updateconsumeroffsetoneway\",{\"1\":{\"1200\":1}}],[\"updateconsumeroffsetrequestheader\",{\"1\":{\"1200\":2}}],[\"updateconsumeroffset\",{\"1\":{\"1191\":1,\"1200\":1}}],[\"updateconsumeoffsettobroker\",{\"1\":{\"1191\":1,\"1200\":4}}],[\"updateconsumeoffset\",{\"1\":{\"1117\":1,\"1468\":2}}],[\"updateledgerendindexandterm\",{\"1\":{\"1517\":1}}],[\"updatetimestamp\",{\"1\":{\"1420\":2}}],[\"updatetopic\",{\"1\":{\"1441\":1}}],[\"updatetopicsubscribeinfowhensubscriptionchanged\",{\"1\":{\"1122\":1}}],[\"updatetopicrouteinfofromnameserver\",{\"1\":{\"956\":1,\"1048\":2,\"1051\":2,\"1171\":1,\"1200\":1,\"1288\":1}}],[\"updatepeerwatermark\",{\"1\":{\"1518\":1,\"1519\":2,\"1521\":2}}],[\"updatepullfromwhichnode\",{\"1\":{\"1329\":1}}],[\"updateprocessqueuetableinrebalance\",{\"0\":{\"1144\":1},\"1\":{\"1134\":1,\"1137\":1,\"1143\":2,\"1144\":1,\"1213\":1,\"1224\":1}}],[\"updated\",{\"1\":{\"1200\":1}}],[\"updatesubgroup\",{\"1\":{\"1128\":1}}],[\"updatefaultitem\",{\"1\":{\"1050\":1}}],[\"updateoffset\",{\"1\":{\"845\":3,\"861\":1,\"1104\":1,\"1175\":1,\"1191\":1,\"1195\":1}}],[\"update的定义\",{\"1\":{\"624\":1}}],[\"update\",{\"1\":{\"89\":1,\"165\":2,\"192\":2,\"253\":2,\"396\":1,\"624\":3,\"625\":1,\"626\":3,\"627\":1,\"644\":1,\"737\":2,\"1145\":2,\"1200\":2,\"1201\":1,\"1212\":1,\"1266\":1,\"1270\":1}}],[\"upper\",{\"1\":{\"49\":1}}],[\"udp端口和tcp端口虽然都使用0~65535\",{\"1\":{\"71\":1}}],[\"udp没有创建连接\",{\"1\":{\"71\":1}}],[\"udp\",{\"0\":{\"71\":1},\"1\":{\"118\":1}}],[\"unknow\",{\"1\":{\"1442\":4,\"1445\":1,\"1459\":2,\"1460\":1,\"1472\":2}}],[\"unknownhostexception\",{\"1\":{\"1460\":1}}],[\"unknown\",{\"0\":{\"501\":1,\"503\":1},\"1\":{\"503\":5,\"606\":2,\"1331\":1,\"1370\":2,\"1371\":2,\"1372\":1,\"1373\":1,\"1374\":1,\"1434\":4,\"1445\":1,\"1446\":2,\"1451\":1,\"1497\":1,\"1500\":2,\"1503\":2,\"1516\":2,\"1519\":6,\"1520\":9}}],[\"unused\",{\"1\":{\"1200\":1,\"1427\":1}}],[\"unusedmq\",{\"1\":{\"1200\":4}}],[\"unmodifiablelist\",{\"1\":{\"1195\":1,\"1230\":1}}],[\"unneccessary\",{\"1\":{\"995\":1}}],[\"unnecessary\",{\"1\":{\"886\":1,\"907\":1,\"1144\":2}}],[\"unnamed\",{\"1\":{\"342\":1}}],[\"unlockdelay\",{\"1\":{\"1225\":1}}],[\"unlock\",{\"1\":{\"793\":2,\"794\":1,\"872\":1,\"971\":1,\"972\":2,\"1222\":1,\"1225\":2,\"1230\":1,\"1270\":1,\"1427\":1,\"1434\":1,\"1435\":2,\"1436\":2}}],[\"unless\",{\"1\":{\"104\":1}}],[\"unpacking\",{\"1\":{\"643\":1,\"645\":1}}],[\"unpack\",{\"1\":{\"643\":1,\"645\":1}}],[\"unsealed\",{\"1\":{\"1394\":3,\"1412\":2,\"1413\":1,\"1414\":1,\"1415\":1,\"1434\":2,\"1435\":1,\"1436\":4}}],[\"unselected\",{\"1\":{\"643\":1}}],[\"unsupportedencodingexception\",{\"1\":{\"1443\":1}}],[\"unsupported\",{\"1\":{\"1266\":1}}],[\"unsubscribe\",{\"1\":{\"1117\":1}}],[\"unshift\",{\"1\":{\"298\":2}}],[\"untitled\",{\"1\":{\"624\":1,\"724\":1,\"725\":1,\"726\":1,\"728\":1,\"730\":1,\"731\":2,\"737\":2,\"740\":1,\"741\":3,\"755\":1,\"767\":1,\"773\":1,\"786\":1,\"787\":1,\"789\":1,\"825\":1}}],[\"unblocked\",{\"1\":{\"627\":1}}],[\"unblock\",{\"1\":{\"613\":1,\"626\":1,\"627\":4}}],[\"unboxing\",{\"1\":{\"30\":1}}],[\"unexpected\",{\"1\":{\"1424\":1,\"1500\":1,\"1503\":1,\"1520\":4}}],[\"une\",{\"1\":{\"436\":1}}],[\"uncomment\",{\"1\":{\"1444\":1}}],[\"unconfigured\",{\"1\":{\"643\":1}}],[\"unchecked\",{\"1\":{\"1425\":1}}],[\"uncheck或waiting\",{\"1\":{\"375\":1}}],[\"uncaught\",{\"1\":{\"316\":2}}],[\"unregisterbroker\",{\"1\":{\"954\":1}}],[\"unregister\",{\"1\":{\"234\":1,\"1331\":2}}],[\"under\",{\"1\":{\"1462\":1}}],[\"understanding\",{\"1\":{\"15\":1}}],[\"undef\",{\"1\":{\"214\":1}}],[\"undefined\",{\"0\":{\"513\":1},\"1\":{\"191\":1,\"217\":3,\"234\":1,\"255\":1,\"294\":1,\"297\":1,\"298\":5,\"299\":1,\"301\":1,\"307\":1,\"309\":1,\"316\":1,\"332\":1,\"333\":2,\"506\":2,\"518\":2,\"551\":2,\"558\":3,\"624\":2,\"627\":1}}],[\"undo\",{\"1\":{\"141\":1}}],[\"uniqid\",{\"1\":{\"1463\":4}}],[\"uniq\",{\"1\":{\"1273\":1,\"1359\":1,\"1427\":1,\"1445\":3,\"1459\":1,\"1463\":1,\"1468\":1,\"1469\":1,\"1471\":1,\"1472\":1}}],[\"uniqkey=\",{\"1\":{\"1468\":1}}],[\"uniqkey\",{\"1\":{\"794\":3,\"1371\":1,\"1373\":7}}],[\"uniquekey\",{\"1\":{\"1472\":5}}],[\"unique\",{\"1\":{\"90\":1,\"742\":1,\"890\":1,\"899\":1,\"1053\":1,\"1287\":1,\"1445\":3}}],[\"unitname\",{\"1\":{\"1036\":1,\"1235\":4}}],[\"unit\",{\"1\":{\"765\":2,\"767\":1,\"771\":2,\"845\":3,\"860\":3,\"1174\":3,\"1328\":1,\"1333\":1,\"1370\":4,\"1371\":2,\"1432\":5,\"1517\":1}}],[\"unitmode\",{\"1\":{\"742\":1}}],[\"units\",{\"1\":{\"11\":1,\"741\":1}}],[\"union\",{\"1\":{\"515\":1}}],[\"unix\",{\"1\":{\"288\":1}}],[\"unicode\",{\"1\":{\"27\":1}}],[\"耗时进行采样形成火焰图\",{\"1\":{\"917\":1}}],[\"耗时开销很大\",{\"1\":{\"900\":1}}],[\"耗时百分比的原因\",{\"1\":{\"896\":1}}],[\"耗时都较小\",{\"1\":{\"725\":1}}],[\"耗时\",{\"1\":{\"11\":1,\"1017\":1}}],[\"所需要的字段\",{\"1\":{\"1482\":1}}],[\"所需要的副属性数值\",{\"1\":{\"421\":1}}],[\"所使用的大小的一个值\",{\"1\":{\"1300\":1}}],[\"所在的文件则重置文件末尾位置\",{\"1\":{\"1511\":1}}],[\"所在的\",{\"1\":{\"1039\":1,\"1041\":1,\"1052\":2,\"1410\":1}}],[\"所在区域\",{\"1\":{\"1017\":1}}],[\"所属类\",{\"1\":{\"1508\":1}}],[\"所属集群是否存在\",{\"1\":{\"971\":1}}],[\"所属集群名称\",{\"1\":{\"949\":1}}],[\"所属\",{\"1\":{\"964\":1}}],[\"所处的类所在的包是\",{\"1\":{\"827\":1}}],[\"所装饰对象的名字\",{\"1\":{\"606\":1}}],[\"所装饰的对象\",{\"1\":{\"606\":1}}],[\"所谓继承关系不过是把一个对象的原型指向另一个对象而已\",{\"1\":{\"339\":1}}],[\"所谓无侵入\",{\"1\":{\"81\":1}}],[\"所得到的值\",{\"1\":{\"188\":1}}],[\"所下的是一种断言\",{\"1\":{\"173\":1}}],[\"所有投票数\",{\"1\":{\"1497\":1}}],[\"所有消费者收到后唤醒重平衡线程进行重平衡\",{\"1\":{\"1136\":1}}],[\"所有消息都会保存到每个副本的磁盘中\",{\"1\":{\"704\":1}}],[\"所有消息都是持久化的\",{\"1\":{\"704\":1}}],[\"所有消息一直保存在内存中\",{\"0\":{\"702\":1}}],[\"所有acl配置文件绝对路径\",{\"1\":{\"999\":1}}],[\"所有指令当前共用了一个通用的解析方法\",{\"1\":{\"890\":1}}],[\"所有\",{\"1\":{\"852\":1,\"1290\":1,\"1390\":2,\"1405\":2,\"1499\":1}}],[\"所有问题的源头来自于节点的宕机\",{\"1\":{\"693\":1}}],[\"所有文件数据大小\",{\"1\":{\"688\":1}}],[\"所有队列的消息\",{\"1\":{\"1257\":2}}],[\"所有队列共同使用\",{\"1\":{\"687\":1}}],[\"所有队列操作首先经过主队列\",{\"1\":{\"660\":1}}],[\"所有新消息都将被复制\",{\"1\":{\"678\":1}}],[\"所有镜像队列都会自动同步\",{\"1\":{\"678\":1}}],[\"所有的\",{\"1\":{\"674\":1}}],[\"所有的组件不再由应用程序自己创建和配置\",{\"1\":{\"81\":1}}],[\"所有它的代码变成内部代码\",{\"1\":{\"591\":1}}],[\"所有可以转成对象的值\",{\"1\":{\"511\":1}}],[\"所有奶德治疗法术都可以做成鼠标指向宏\",{\"1\":{\"488\":1}}],[\"所有网络操作\",{\"1\":{\"351\":1}}],[\"所有对象都是实例\",{\"1\":{\"339\":1}}],[\"所有变更都能随时生效\",{\"1\":{\"270\":1}}],[\"所有变量名都必须以大写字母开头\",{\"1\":{\"173\":1}}],[\"所有键都是原子\",{\"1\":{\"191\":1}}],[\"所有测试执行完毕\",{\"1\":{\"11\":1}}],[\"所以此时需要\",{\"1\":{\"1510\":1}}],[\"所以重排之后的结构就呼之欲出\",{\"1\":{\"1418\":1}}],[\"所以重平衡时对每个消费者执行\",{\"1\":{\"1255\":1}}],[\"所以应该以\",{\"1\":{\"1403\":1}}],[\"所以应在函数内部先声明所有变量\",{\"1\":{\"311\":1}}],[\"所以采用了生产\",{\"1\":{\"1354\":1}}],[\"所以第一条消息会阻塞后续消息的投递\",{\"1\":{\"1342\":1}}],[\"所以先根据消费队列进行一次过滤\",{\"1\":{\"1313\":1}}],[\"所以先创建一个位图\",{\"1\":{\"904\":1}}],[\"所以一个\",{\"1\":{\"1258\":1}}],[\"所以是向\",{\"1\":{\"1252\":1}}],[\"所以真正安全的幂等处理\",{\"1\":{\"1237\":1}}],[\"所以每个消费组都有一组锁\",{\"1\":{\"1212\":1}}],[\"所以每个索引文件不应超过\",{\"1\":{\"927\":1}}],[\"所以也有可能并发消费一个队列中的多个消息\",{\"1\":{\"1203\":1}}],[\"所以即便是已经保存在\",{\"1\":{\"1188\":1}}],[\"所以定义了一个消费消息服务接口\",{\"1\":{\"1187\":1}}],[\"所以消费进度可以存在本地\",{\"1\":{\"1181\":1}}],[\"所以消息的消费进度需要统一保存\",{\"1\":{\"1103\":1}}],[\"所以消息队列\",{\"1\":{\"1090\":1}}],[\"所以如果业务对消费重复非常敏感\",{\"1\":{\"1237\":1}}],[\"所以如果是从子节点拉消息\",{\"1\":{\"1171\":1}}],[\"所以如果客户端创建时开启了消息轨迹功能\",{\"1\":{\"1014\":1}}],[\"所以并没有选择每次都创建新的\",{\"1\":{\"1155\":1}}],[\"所以整个客户端实例只需要一个共用线程就足够了\",{\"1\":{\"1155\":1}}],[\"所以整个队列不会因为新的副本加入而收到影响\",{\"1\":{\"696\":1}}],[\"所以拉取流程并不复杂\",{\"1\":{\"1151\":1}}],[\"所以按通常的想法\",{\"1\":{\"1116\":1}}],[\"所以对于已经持久化的数据影响不大\",{\"1\":{\"1362\":1}}],[\"所以对于消息是否成功发送到\",{\"1\":{\"1003\":1}}],[\"所以对象不能分步生成\",{\"1\":{\"556\":1}}],[\"所以保存在磁盘中为妙\",{\"1\":{\"935\":1}}],[\"所以异常消息的重投就十分重要\",{\"1\":{\"934\":1}}],[\"所以频率就是\",{\"1\":{\"931\":1}}],[\"所以时间跨度定为\",{\"1\":{\"927\":1}}],[\"所以本文中所实现的定时消息效果也可以用作延迟消息使用\",{\"1\":{\"920\":1}}],[\"所以本指南着重讲解猫奶\",{\"1\":{\"401\":1}}],[\"所以改成\",{\"1\":{\"909\":1}}],[\"所以改用可重入锁\",{\"1\":{\"733\":1}}],[\"所以耗时较高\",{\"1\":{\"899\":1}}],[\"所以很有优化的必要\",{\"1\":{\"890\":1}}],[\"所以该特性增大数据丢失的风险\",{\"1\":{\"883\":1}}],[\"所以只介绍推模式消费者的启动流程\",{\"1\":{\"1120\":1}}],[\"所以只会存在一个\",{\"1\":{\"1012\":1}}],[\"所以只会从\",{\"1\":{\"883\":1}}],[\"所以只要知道消息在\",{\"1\":{\"751\":1}}],[\"所以性能比随机读写好很多\",{\"1\":{\"876\":1}}],[\"所以暂时先直接跳过该条消息\",{\"1\":{\"845\":1}}],[\"所以这里直接调用\",{\"1\":{\"1510\":1}}],[\"所以这里做最坏的打算\",{\"1\":{\"1468\":1}}],[\"所以这里不会加入到内存\",{\"1\":{\"1259\":1}}],[\"所以这里只讨论\",{\"1\":{\"835\":1}}],[\"所以这些配置大多为\",{\"1\":{\"997\":1}}],[\"所以这个表会定期持久化到磁盘中\",{\"1\":{\"857\":1}}],[\"所以这个\",{\"1\":{\"7\":1}}],[\"所以可以牺牲一定的读性能来保障写入的速度\",{\"1\":{\"1363\":1}}],[\"所以可以通过批量发送的方式减少性能损耗\",{\"1\":{\"1010\":1}}],[\"所以可以通过逻辑下标计算出索引项在索引文件中的绝对偏移量\",{\"1\":{\"787\":1}}],[\"所以可以增加一个判断\",{\"1\":{\"903\":1}}],[\"所以可以直接用==比较\",{\"1\":{\"31\":1}}],[\"所以引入了\",{\"1\":{\"747\":1}}],[\"所以同一\",{\"1\":{\"747\":1}}],[\"所以优化方案就是先算好需要的长度\",{\"1\":{\"741\":1}}],[\"所以建议用尽可能新的版本部署\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"所以建议手动设置\",{\"1\":{\"1240\":1}}],[\"所以建议\",{\"1\":{\"734\":1}}],[\"所以它被保存在服务端一个专门用来保存半消息的特殊\",{\"1\":{\"1446\":1}}],[\"所以它的每一项也有一个指向该项上一项的指针\",{\"1\":{\"1352\":1}}],[\"所以它的队列\",{\"1\":{\"1293\":1}}],[\"所以它不能用普通消息的消费组维度的重试\",{\"1\":{\"1263\":1}}],[\"所以它可以批量处理这\",{\"1\":{\"724\":1}}],[\"所以它也可能被多个进程阻塞\",{\"1\":{\"625\":1}}],[\"所以需要加锁\",{\"1\":{\"1503\":1}}],[\"所以需要一个地方保存真正的\",{\"1\":{\"1188\":1}}],[\"所以需要一个桥梁\",{\"1\":{\"827\":1}}],[\"所以需要共享消费进度\",{\"1\":{\"1181\":1}}],[\"所以需要提交消费进度\",{\"1\":{\"1103\":1}}],[\"所以需要提前手动修改\",{\"1\":{\"1075\":1}}],[\"所以需要主动从\",{\"1\":{\"1039\":1}}],[\"所以需要在消息生产和消费时采集一些数据\",{\"1\":{\"1010\":1}}],[\"所以需要消费者线程从队列中消费并判断这些异步投递任务的状态\",{\"1\":{\"855\":1}}],[\"所以需要用更多地虚拟节点来让节点更均匀地分布\",{\"1\":{\"716\":1}}],[\"所以需要额外在对象外部给出函数方法的实现\",{\"1\":{\"558\":1}}],[\"所以当使用仲裁队列时\",{\"1\":{\"702\":1}}],[\"所以当有大量消息持续发往某个进程时\",{\"1\":{\"611\":1}}],[\"所以发布\",{\"1\":{\"701\":1}}],[\"所以说仲裁队列相对于可用性更看重一致性\",{\"1\":{\"695\":1}}],[\"所以说虽然理论上消息会按照q1\",{\"1\":{\"690\":1}}],[\"所以运维有时就不会选择进行消息同步\",{\"1\":{\"693\":1}}],[\"所以delta队列并不在内存中\",{\"1\":{\"690\":1}}],[\"所以镜像队列的消费需要由\",{\"1\":{\"669\":1}}],[\"所以从节点的状态与主节点应是一致的\",{\"1\":{\"649\":1}}],[\"所以官方建议谨慎使用\",{\"1\":{\"582\":1}}],[\"所以使用object时常常用空对象代替\",{\"1\":{\"511\":1}}],[\"所以除了两件美化装备\",{\"1\":{\"484\":1}}],[\"所以要在关键伤害时用它\",{\"1\":{\"482\":1}}],[\"所以要递归映射\",{\"1\":{\"167\":1}}],[\"所以不存在写竟争问题\",{\"1\":{\"793\":1}}],[\"所以不需要加锁\",{\"1\":{\"765\":1}}],[\"所以不会因为脑裂而丢数据\",{\"1\":{\"696\":1}}],[\"所以不要省减伤\",{\"1\":{\"468\":1}}],[\"所以不用太在意这条\",{\"1\":{\"417\":1}}],[\"所以把万灵留在这个时候\",{\"1\":{\"465\":1}}],[\"所以把个减留到\",{\"1\":{\"447\":1}}],[\"所以被铁钩拉过去之前要找好炸弹并且准备跑到位置\",{\"1\":{\"464\":1}}],[\"所以放绿水的时候要尽可能少动\",{\"1\":{\"453\":1}}],[\"所以错开使用你的治疗手牌\",{\"1\":{\"441\":1}}],[\"所以在多次写入失败的情况下可以放弃写入\",{\"1\":{\"1414\":1}}],[\"所以在设计上对分级存储中保存的\",{\"1\":{\"1411\":1}}],[\"所以在分级存储中面向查询进行优化\",{\"1\":{\"1393\":1}}],[\"所以在slave中在doreput\",{\"1\":{\"1297\":1}}],[\"所以在内存中就能够与\",{\"1\":{\"1253\":1}}],[\"所以在重试时会尽量避开刚刚发送失败的\",{\"1\":{\"1032\":1}}],[\"所以在重要业务中使用同步刷盘确保数据不丢失\",{\"1\":{\"765\":1}}],[\"所以在被重新投递之前\",{\"1\":{\"836\":1}}],[\"所以在这个情况下的写入放大是\",{\"1\":{\"700\":1}}],[\"所以在仲裁队列和镜像队列之间的选择不是一个容易的事情\",{\"1\":{\"694\":1}}],[\"所以在排放口之前要预铺好\",{\"1\":{\"440\":1}}],[\"所以在windows下编译必须依次列出所有\",{\"1\":{\"21\":1}}],[\"所以你的树皮肯定是能转好的\",{\"1\":{\"433\":1}}],[\"所以你需要微调一下使用连击点数的方式\",{\"1\":{\"417\":1}}],[\"所以普通\",{\"1\":{\"411\":1}}],[\"所以没有找车队\",{\"1\":{\"399\":1}}],[\"所以没有流的概念\",{\"1\":{\"71\":1}}],[\"所以\",{\"1\":{\"391\":1,\"512\":1,\"703\":1,\"1203\":1,\"1238\":1,\"1341\":1}}],[\"所以统一由indicator线程从队列中取数据\",{\"1\":{\"379\":1}}],[\"所以我们后面把它称为拉票请求方便理解\",{\"1\":{\"1477\":1}}],[\"所以我们可以得出结论\",{\"1\":{\"365\":1}}],[\"所以我认为在大部分情况下不需要开启布隆过滤器\",{\"1\":{\"1325\":1}}],[\"所以我管它叫做仲裁队列\",{\"1\":{\"695\":1}}],[\"所以我在寻找一种可以不停机的开发方法\",{\"1\":{\"270\":1}}],[\"≈\",{\"1\":{\"11\":1}}],[\"8byte\",{\"1\":{\"1435\":1}}],[\"8b\",{\"1\":{\"1351\":3,\"1352\":3}}],[\"8g\",{\"1\":{\"1079\":1}}],[\"8m\",{\"1\":{\"833\":1,\"919\":1,\"925\":1,\"1241\":1}}],[\"8nz\",{\"1\":{\"443\":1}}],[\"8jv\",{\"1\":{\"429\":1}}],[\"8r\",{\"1\":{\"423\":1}}],[\"8c\",{\"1\":{\"399\":1}}],[\"85\",{\"1\":{\"301\":1,\"864\":1,\"866\":1}}],[\"8563\",{\"1\":{\"273\":1}}],[\"8万\",{\"1\":{\"285\":1}}],[\"8次故障期间\",{\"1\":{\"284\":1}}],[\"800\",{\"1\":{\"1367\":1}}],[\"80端口\",{\"1\":{\"350\":1}}],[\"80\",{\"1\":{\"276\":1,\"515\":1,\"1404\":1,\"1407\":1}}],[\"8080就不同\",{\"1\":{\"350\":1}}],[\"8080\",{\"1\":{\"113\":1,\"126\":1,\"129\":1,\"134\":1,\"1077\":1,\"1078\":1,\"1081\":1}}],[\"8160\",{\"1\":{\"421\":2}}],[\"81\",{\"1\":{\"182\":1,\"323\":1,\"1445\":3}}],[\"8734\",{\"1\":{\"178\":1}}],[\"871\",{\"1\":{\"11\":1}}],[\"8330\",{\"1\":{\"421\":1}}],[\"83\",{\"1\":{\"178\":3}}],[\"831\",{\"1\":{\"11\":2}}],[\"8>\",{\"1\":{\"177\":1,\"181\":1,\"217\":1,\"255\":1}}],[\"82\",{\"1\":{\"176\":1,\"1445\":3}}],[\"8编码转换为string\",{\"1\":{\"72\":1}}],[\"8\",{\"0\":{\"51\":1,\"135\":1,\"300\":1,\"301\":1,\"302\":1,\"469\":1,\"470\":1,\"475\":1,\"478\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"517\":1,\"532\":1,\"533\":1,\"534\":1,\"535\":1,\"536\":1,\"537\":1,\"538\":1,\"539\":1,\"540\":2,\"541\":1,\"542\":1,\"545\":1,\"546\":1,\"547\":1,\"548\":1,\"579\":1,\"692\":1,\"736\":1,\"1175\":1},\"1\":{\"15\":1,\"54\":1,\"69\":2,\"70\":2,\"72\":2,\"125\":1,\"177\":1,\"181\":5,\"182\":1,\"184\":1,\"253\":1,\"323\":1,\"396\":2,\"399\":1,\"401\":1,\"409\":1,\"443\":2,\"455\":3,\"484\":1,\"583\":2,\"643\":4,\"648\":2,\"675\":1,\"692\":2,\"714\":1,\"715\":1,\"718\":1,\"737\":2,\"738\":3,\"797\":4,\"894\":1,\"964\":2,\"968\":2,\"1079\":1,\"1247\":1,\"1248\":2,\"1314\":1,\"1319\":1,\"1339\":1,\"1344\":1,\"1418\":1,\"1430\":1,\"1435\":1,\"1475\":1,\"1506\":1}}],[\"8994\",{\"1\":{\"11\":2}}],[\"8815\",{\"1\":{\"11\":1}}],[\"ng\",{\"1\":{\"1073\":2}}],[\"nmm5x8mrxoqowxlrg4vkmbzkwlyxdocoekshye\",{\"1\":{\"455\":1}}],[\"nmap\",{\"1\":{\"167\":3}}],[\"nynz9dwz9fy\",{\"1\":{\"423\":1}}],[\"nk42kujdhbmhz6so1yimj\",{\"1\":{\"423\":1}}],[\"npm\",{\"1\":{\"369\":1,\"498\":1,\"500\":2}}],[\"n表示\",{\"1\":{\"288\":1}}],[\"n1\",{\"1\":{\"253\":1}}],[\"nwant\",{\"1\":{\"253\":5}}],[\"nregs\",{\"1\":{\"171\":1}}],[\"nreactor>\",{\"1\":{\"125\":1}}],[\"nl\",{\"1\":{\"171\":1}}],[\"nly\",{\"1\":{\"154\":1}}],[\"nc\",{\"1\":{\"171\":1}}],[\"nvim\",{\"1\":{\"165\":1}}],[\"nil\",{\"1\":{\"188\":1}}],[\"ni\",{\"1\":{\"165\":1,\"171\":1}}],[\"niohandler\",{\"1\":{\"124\":2,\"126\":1,\"128\":1,\"134\":1,\"135\":1}}],[\"nio\",{\"0\":{\"118\":1},\"1\":{\"108\":2,\"109\":1,\"110\":1,\"116\":2,\"118\":8,\"121\":1,\"122\":1,\"124\":1,\"136\":3,\"765\":1,\"880\":1}}],[\"nnumber\",{\"1\":{\"150\":1}}],[\"nthreads\",{\"1\":{\"131\":3}}],[\"n\",{\"0\":{\"438\":1},\"1\":{\"65\":1,\"69\":3,\"125\":5,\"128\":2,\"149\":2,\"152\":1,\"153\":4,\"154\":3,\"162\":2,\"171\":4,\"174\":2,\"180\":4,\"183\":2,\"184\":5,\"193\":8,\"194\":6,\"195\":2,\"261\":3,\"330\":3,\"332\":3,\"333\":1,\"388\":1,\"446\":5,\"643\":1,\"662\":1,\"960\":2,\"984\":1,\"985\":2,\"1006\":1,\"1007\":2,\"1008\":1,\"1203\":2,\"1247\":1,\"1248\":3,\"1267\":3,\"1309\":1,\"1441\":1,\"1443\":1,\"1444\":2}}],[\"nu0uzrlwlx1xjmdjbzzw\",{\"1\":{\"469\":1}}],[\"numlegs\",{\"1\":{\"548\":1}}],[\"nums\",{\"1\":{\"539\":1,\"1198\":2}}],[\"num\",{\"1\":{\"147\":3,\"148\":2,\"797\":1,\"1174\":2,\"1247\":1,\"1351\":1,\"1367\":3,\"1371\":3,\"1464\":2}}],[\"number|boolean|string\",{\"1\":{\"558\":1}}],[\"number|string\",{\"1\":{\"520\":1,\"522\":1,\"566\":1}}],[\"number\",{\"1\":{\"143\":1,\"155\":2,\"253\":3,\"294\":2,\"333\":2,\"396\":1,\"502\":1,\"503\":2,\"504\":2,\"506\":1,\"508\":2,\"511\":1,\"512\":1,\"516\":2,\"517\":1,\"518\":4,\"519\":1,\"520\":1,\"522\":1,\"523\":1,\"524\":2,\"525\":1,\"527\":7,\"528\":2,\"535\":1,\"536\":1,\"537\":4,\"538\":3,\"539\":2,\"540\":1,\"546\":2,\"548\":1,\"550\":7,\"551\":2,\"552\":3,\"554\":1,\"555\":4,\"558\":8,\"560\":1,\"561\":1,\"562\":1,\"563\":3,\"566\":3,\"576\":4,\"582\":1,\"1021\":1,\"1296\":1,\"1468\":1}}],[\"number>的泛型定义称之为上界通配符\",{\"1\":{\"49\":1}}],[\"nu\",{\"1\":{\"143\":1}}],[\"nullpointerexception\",{\"1\":{\"101\":2,\"396\":1}}],[\"nullable\",{\"1\":{\"90\":5}}],[\"null\",{\"0\":{\"513\":1},\"1\":{\"34\":2,\"41\":1,\"91\":1,\"92\":1,\"99\":1,\"113\":1,\"122\":1,\"123\":2,\"132\":1,\"133\":1,\"294\":4,\"319\":2,\"320\":1,\"333\":1,\"337\":2,\"340\":2,\"341\":1,\"396\":4,\"506\":2,\"712\":2,\"737\":11,\"738\":2,\"742\":21,\"762\":2,\"765\":1,\"767\":6,\"793\":5,\"794\":5,\"796\":1,\"797\":6,\"819\":2,\"820\":1,\"822\":2,\"825\":5,\"827\":1,\"844\":2,\"845\":6,\"860\":4,\"861\":3,\"870\":2,\"872\":2,\"891\":4,\"894\":6,\"960\":7,\"961\":2,\"970\":2,\"971\":10,\"972\":7,\"973\":3,\"994\":1,\"995\":6,\"996\":1,\"998\":6,\"1000\":6,\"1020\":10,\"1021\":4,\"1047\":2,\"1048\":3,\"1050\":11,\"1051\":1,\"1052\":3,\"1053\":11,\"1056\":3,\"1122\":3,\"1123\":2,\"1142\":1,\"1143\":7,\"1144\":1,\"1170\":4,\"1171\":4,\"1172\":3,\"1173\":13,\"1174\":15,\"1175\":3,\"1195\":6,\"1197\":1,\"1198\":13,\"1200\":5,\"1201\":2,\"1222\":2,\"1224\":1,\"1226\":2,\"1229\":2,\"1230\":5,\"1266\":15,\"1269\":4,\"1270\":5,\"1273\":1,\"1276\":1,\"1278\":4,\"1279\":2,\"1280\":5,\"1288\":1,\"1297\":1,\"1308\":12,\"1310\":3,\"1328\":2,\"1329\":2,\"1331\":7,\"1332\":5,\"1333\":18,\"1368\":5,\"1370\":3,\"1371\":4,\"1372\":5,\"1373\":7,\"1374\":1,\"1425\":1,\"1427\":1,\"1428\":5,\"1430\":1,\"1432\":3,\"1434\":2,\"1435\":5,\"1436\":8,\"1442\":1,\"1443\":1,\"1458\":4,\"1459\":10,\"1460\":3,\"1462\":6,\"1463\":1,\"1464\":1,\"1468\":15,\"1469\":3,\"1471\":5,\"1472\":8,\"1497\":1,\"1499\":1,\"1500\":1,\"1503\":2,\"1516\":3,\"1517\":7,\"1518\":1,\"1519\":12,\"1520\":8,\"1521\":1}}],[\"native\",{\"1\":{\"1079\":1}}],[\"nativelong\",{\"1\":{\"882\":2}}],[\"national\",{\"1\":{\"27\":1}}],[\"narrowing\",{\"1\":{\"515\":1}}],[\"nan这个特殊的number与所有其他值都不相等\",{\"1\":{\"295\":1}}],[\"nan表示not\",{\"1\":{\"294\":1}}],[\"nan\",{\"1\":{\"294\":1}}],[\"napples\",{\"1\":{\"253\":2}}],[\"namesrvutil\",{\"1\":{\"973\":1}}],[\"namesrvaddr\",{\"1\":{\"970\":4,\"1443\":1,\"1444\":1}}],[\"namesrv\",{\"1\":{\"960\":3,\"971\":1,\"974\":1,\"1075\":2,\"1078\":3,\"1080\":6,\"1081\":2,\"1120\":2,\"1122\":1,\"1123\":1,\"1444\":1}}],[\"namesrvconfig\",{\"1\":{\"960\":11}}],[\"namesrvcontroller\",{\"0\":{\"961\":1},\"1\":{\"947\":4,\"960\":12,\"961\":2,\"973\":3}}],[\"namesrvstartup\",{\"1\":{\"947\":3,\"960\":3}}],[\"nameserveraddresslist\",{\"1\":{\"970\":5}}],[\"nameserver\",{\"0\":{\"939\":1,\"941\":1,\"942\":1,\"947\":1,\"949\":1,\"953\":1,\"957\":1,\"959\":1,\"963\":1,\"971\":1},\"1\":{\"939\":1,\"941\":9,\"942\":4,\"943\":1,\"944\":3,\"945\":10,\"947\":3,\"949\":2,\"950\":2,\"951\":1,\"952\":3,\"953\":1,\"954\":3,\"955\":3,\"957\":1,\"960\":3,\"963\":1,\"971\":1,\"973\":2,\"974\":1,\"1030\":5,\"1036\":1,\"1037\":1,\"1039\":3,\"1042\":1,\"1047\":1,\"1053\":1,\"1075\":1,\"1077\":1,\"1081\":1,\"1171\":1,\"1290\":1,\"1291\":1,\"1538\":1}}],[\"namespaceutil\",{\"1\":{\"1020\":3,\"1053\":2,\"1197\":1,\"1198\":1,\"1458\":1,\"1471\":1}}],[\"namespace\",{\"0\":{\"901\":1},\"1\":{\"886\":1,\"901\":1,\"902\":3,\"903\":4,\"973\":1,\"1019\":3,\"1050\":1,\"1197\":1,\"1198\":2}}],[\"names\",{\"1\":{\"712\":3,\"1075\":1,\"1077\":1,\"1079\":2}}],[\"namednums\",{\"1\":{\"527\":2}}],[\"namedqueries\",{\"1\":{\"92\":1}}],[\"namedquery\",{\"1\":{\"92\":2}}],[\"name2loadstrategy\",{\"1\":{\"1266\":1}}],[\"name2\",{\"1\":{\"203\":1}}],[\"name=\",{\"1\":{\"90\":1,\"178\":1}}],[\"name\",{\"1\":{\"38\":2,\"39\":2,\"41\":1,\"91\":1,\"92\":1,\"105\":4,\"152\":1,\"176\":2,\"180\":2,\"203\":1,\"253\":4,\"294\":2,\"297\":3,\"299\":6,\"313\":1,\"316\":6,\"338\":5,\"339\":8,\"341\":8,\"342\":3,\"344\":4,\"345\":2,\"361\":2,\"364\":2,\"515\":1,\"554\":3,\"560\":1,\"561\":1,\"564\":2,\"567\":5,\"570\":3,\"580\":2,\"605\":1,\"606\":2,\"652\":1,\"653\":1,\"712\":4,\"742\":1,\"886\":1,\"890\":1,\"894\":1,\"904\":1,\"960\":7,\"970\":4,\"973\":1,\"1047\":2,\"1048\":1,\"1073\":1,\"1075\":1,\"1077\":1,\"1078\":1,\"1080\":3,\"1081\":1,\"1120\":1,\"1122\":2,\"1123\":1,\"1160\":1,\"1173\":1,\"1195\":1,\"1198\":1,\"1230\":1,\"1247\":2,\"1266\":1,\"1269\":1,\"1287\":3,\"1288\":3,\"1427\":1,\"1445\":3}}],[\"nearby\",{\"1\":{\"974\":1}}],[\"nearest\",{\"1\":{\"396\":2}}],[\"nemesrvstartup\",{\"0\":{\"960\":1}}],[\"needincreasetermimmediately\",{\"1\":{\"1497\":4,\"1500\":1,\"1503\":1}}],[\"needdiscard\",{\"1\":{\"1468\":1}}],[\"needdelete\",{\"1\":{\"1372\":1,\"1373\":1}}],[\"needcheck\",{\"1\":{\"1521\":3}}],[\"needcheckedentry\",{\"1\":{\"1000\":3}}],[\"needcheckedpermmap\",{\"1\":{\"1000\":4}}],[\"needcheckedaccess\",{\"1\":{\"1000\":6}}],[\"needcommit\",{\"1\":{\"1428\":1}}],[\"needroll\",{\"1\":{\"1371\":2,\"1372\":1,\"1373\":1,\"1374\":3}}],[\"needretry\",{\"1\":{\"1269\":3}}],[\"neededperm\",{\"1\":{\"1000\":3}}],[\"needadminperm\",{\"1\":{\"1000\":1}}],[\"need2skip\",{\"1\":{\"861\":1}}],[\"need2blocked\",{\"1\":{\"860\":1}}],[\"need\",{\"1\":{\"643\":1,\"737\":2,\"825\":1,\"1000\":1,\"1056\":1,\"1200\":1,\"1287\":1,\"1368\":1,\"1372\":1,\"1374\":2}}],[\"needskip\",{\"1\":{\"1468\":1}}],[\"needs\",{\"1\":{\"396\":1}}],[\"nextterm\",{\"1\":{\"1497\":1}}],[\"nexttimetorequestvote\",{\"1\":{\"1497\":7}}],[\"nextopoffset\",{\"1\":{\"1468\":5}}],[\"nextoffsetcorrection\",{\"1\":{\"1174\":7}}],[\"nextoffset=\",{\"1\":{\"845\":1}}],[\"nextoffset\",{\"1\":{\"845\":10,\"860\":7,\"1144\":4,\"1169\":1,\"1224\":4}}],[\"nextindex\",{\"1\":{\"1517\":4,\"1520\":4}}],[\"nextindextoread\",{\"1\":{\"797\":4}}],[\"nextint\",{\"1\":{\"1198\":2,\"1269\":1,\"1497\":1}}],[\"nextbeginoffset\",{\"1\":{\"1174\":10,\"1175\":1,\"1275\":3}}],[\"nextlong\",{\"1\":{\"1050\":1}}],[\"nextline\",{\"1\":{\"70\":1}}],[\"nextphyfilestartoffset\",{\"1\":{\"767\":1,\"1174\":5}}],[\"next\",{\"1\":{\"118\":1,\"122\":1,\"131\":5,\"133\":1,\"253\":1,\"332\":6,\"396\":1,\"771\":1,\"787\":1,\"971\":1,\"972\":6,\"1144\":4,\"1224\":4,\"1277\":1,\"1332\":1,\"1352\":1,\"1371\":1,\"1430\":1,\"1432\":1,\"1435\":1,\"1497\":3,\"1516\":1}}],[\"net\",{\"1\":{\"625\":1,\"664\":1,\"1080\":3,\"1081\":1}}],[\"netflix最初为了搬迁基础设施上云创建了\",{\"1\":{\"276\":1}}],[\"nettyclientconfig\",{\"1\":{\"1523\":1}}],[\"nettyclientpublicexecutorthreadpool\",{\"1\":{\"1104\":1}}],[\"nettysystemconfig\",{\"1\":{\"1299\":1}}],[\"nettyserverconfig\",{\"0\":{\"1299\":1},\"1\":{\"960\":8,\"961\":2,\"1523\":1,\"1538\":1}}],[\"nettyserver\",{\"1\":{\"943\":1}}],[\"nettyrequestprocessor\",{\"1\":{\"1055\":1}}],[\"nettyremotingabstract\",{\"1\":{\"988\":1,\"994\":2}}],[\"nettyremotingclient\",{\"1\":{\"988\":1,\"994\":3,\"1042\":1,\"1155\":1,\"1165\":1,\"1214\":1}}],[\"nettyremotingserver\",{\"1\":{\"961\":2,\"988\":1,\"994\":1}}],[\"nettyencoder\",{\"1\":{\"894\":1}}],[\"netty\",{\"0\":{\"135\":1,\"1299\":1},\"1\":{\"108\":1,\"131\":2,\"133\":1,\"135\":7,\"136\":1,\"267\":2,\"894\":3,\"896\":1,\"897\":1,\"917\":1,\"947\":4,\"960\":6,\"961\":2,\"967\":1,\"1008\":1,\"1043\":1,\"1270\":1,\"1299\":4,\"1300\":13,\"1538\":1}}],[\"networked\",{\"1\":{\"171\":1}}],[\"network\",{\"1\":{\"67\":1,\"1075\":1,\"1499\":1}}],[\"never类型表示肯定不会出现的值\",{\"1\":{\"542\":1}}],[\"never\",{\"0\":{\"501\":1,\"504\":1,\"542\":1},\"1\":{\"87\":1,\"97\":1,\"504\":2,\"543\":1,\"544\":1,\"1373\":1}}],[\"nested\",{\"1\":{\"22\":1,\"87\":1}}],[\"newcompletedfuture\",{\"1\":{\"1516\":2,\"1518\":2}}],[\"newconnection\",{\"1\":{\"712\":1}}],[\"newopoffset\",{\"1\":{\"1468\":7}}],[\"newoffset=\",{\"1\":{\"1173\":1}}],[\"newoffset\",{\"1\":{\"1170\":2,\"1228\":2,\"1279\":8,\"1468\":11}}],[\"newbuffer\",{\"1\":{\"1435\":8}}],[\"newattributesbuilder\",{\"1\":{\"1427\":1,\"1464\":3}}],[\"newastate\",{\"1\":{\"624\":6}}],[\"newmq\",{\"1\":{\"1267\":2}}],[\"newmsg\",{\"1\":{\"1197\":10}}],[\"newtopic\",{\"1\":{\"1198\":8}}],[\"newtxt\",{\"1\":{\"545\":3}}],[\"newval\",{\"1\":{\"1145\":6}}],[\"newversion\",{\"1\":{\"1145\":3}}],[\"newestoffset\",{\"1\":{\"825\":4}}],[\"newlastmodifiedtime\",{\"1\":{\"999\":3}}],[\"newly\",{\"1\":{\"643\":1}}],[\"newline\",{\"1\":{\"70\":1,\"289\":1}}],[\"newslotvalue\",{\"1\":{\"1435\":3}}],[\"newspaper\",{\"1\":{\"177\":6}}],[\"newsinglethreadexecutor\",{\"1\":{\"113\":1,\"121\":1,\"132\":1}}],[\"newfixedthreadpool\",{\"1\":{\"128\":1,\"961\":1}}],[\"newinstance\",{\"1\":{\"123\":1,\"133\":1,\"742\":1,\"1425\":1}}],[\"new在少数情况下会用到\",{\"1\":{\"87\":1}}],[\"newproxyinstance\",{\"1\":{\"41\":1}}],[\"new\",{\"1\":{\"9\":2,\"22\":2,\"34\":1,\"41\":2,\"48\":1,\"69\":6,\"70\":6,\"72\":4,\"73\":5,\"81\":1,\"87\":1,\"89\":2,\"103\":1,\"112\":3,\"113\":5,\"118\":1,\"121\":2,\"122\":1,\"124\":1,\"125\":1,\"126\":1,\"128\":1,\"129\":1,\"131\":2,\"133\":3,\"134\":3,\"248\":1,\"294\":1,\"301\":2,\"302\":2,\"303\":2,\"316\":1,\"333\":5,\"341\":3,\"342\":1,\"348\":1,\"351\":2,\"352\":2,\"353\":2,\"357\":1,\"369\":2,\"396\":5,\"504\":1,\"508\":1,\"509\":2,\"543\":1,\"548\":2,\"558\":2,\"566\":1,\"573\":2,\"575\":1,\"578\":1,\"579\":2,\"580\":1,\"628\":1,\"643\":1,\"665\":1,\"712\":1,\"714\":3,\"715\":2,\"737\":4,\"738\":1,\"742\":4,\"793\":5,\"794\":2,\"815\":1,\"819\":1,\"820\":3,\"822\":1,\"825\":2,\"835\":1,\"844\":3,\"845\":5,\"860\":1,\"861\":1,\"869\":1,\"870\":1,\"872\":1,\"880\":1,\"882\":3,\"904\":1,\"950\":1,\"960\":12,\"961\":7,\"968\":1,\"970\":5,\"971\":6,\"984\":4,\"985\":6,\"994\":1,\"995\":2,\"996\":1,\"997\":6,\"998\":10,\"999\":6,\"1000\":6,\"1006\":2,\"1007\":3,\"1019\":3,\"1020\":4,\"1021\":6,\"1047\":3,\"1048\":6,\"1050\":2,\"1051\":1,\"1053\":6,\"1055\":1,\"1056\":1,\"1122\":7,\"1123\":1,\"1143\":2,\"1144\":6,\"1168\":1,\"1170\":1,\"1171\":3,\"1173\":8,\"1174\":3,\"1175\":2,\"1194\":3,\"1195\":4,\"1197\":1,\"1198\":1,\"1200\":3,\"1201\":2,\"1222\":6,\"1224\":6,\"1226\":1,\"1230\":3,\"1235\":3,\"1247\":5,\"1248\":3,\"1266\":2,\"1267\":3,\"1269\":1,\"1271\":1,\"1273\":2,\"1275\":1,\"1278\":4,\"1280\":3,\"1287\":2,\"1288\":4,\"1296\":1,\"1297\":1,\"1299\":1,\"1300\":1,\"1306\":2,\"1307\":1,\"1309\":2,\"1310\":1,\"1329\":1,\"1331\":2,\"1332\":1,\"1333\":1,\"1339\":1,\"1367\":2,\"1370\":1,\"1371\":3,\"1372\":7,\"1424\":6,\"1425\":1,\"1427\":3,\"1430\":2,\"1431\":1,\"1432\":2,\"1434\":1,\"1435\":3,\"1436\":12,\"1442\":2,\"1443\":7,\"1444\":3,\"1445\":3,\"1458\":1,\"1459\":4,\"1460\":1,\"1464\":1,\"1468\":10,\"1469\":2,\"1472\":3,\"1495\":1,\"1497\":8,\"1499\":8,\"1500\":9,\"1502\":2,\"1503\":11,\"1514\":3,\"1516\":6,\"1518\":3,\"1519\":6,\"1520\":7,\"1521\":2,\"1523\":1}}],[\"nomsgcount++\",{\"1\":{\"1278\":1}}],[\"nomsgcount\",{\"1\":{\"1278\":3}}],[\"nofityall\",{\"1\":{\"726\":1}}],[\"noform\",{\"1\":{\"490\":2}}],[\"noemit\",{\"1\":{\"498\":1}}],[\"noemitonerror\",{\"1\":{\"498\":1}}],[\"noharm\",{\"1\":{\"490\":1}}],[\"nohost\",{\"1\":{\"252\":1}}],[\"nocombat\",{\"1\":{\"490\":2}}],[\"nostance\",{\"1\":{\"490\":7}}],[\"noswimming\",{\"1\":{\"490\":3}}],[\"nosuchalgorithmexception\",{\"1\":{\"396\":1}}],[\"noshell\",{\"1\":{\"224\":2}}],[\"noresolve参数\",{\"1\":{\"603\":1}}],[\"noresolve\",{\"0\":{\"603\":1}}],[\"noranges\",{\"1\":{\"253\":3}}],[\"normallist\",{\"1\":{\"1372\":3}}],[\"normallatch\",{\"1\":{\"1372\":3}}],[\"normally\",{\"1\":{\"122\":1,\"125\":1}}],[\"normalmsgstack\",{\"1\":{\"1372\":5}}],[\"normaltopic\",{\"1\":{\"1279\":2}}],[\"normal模式赋值粘贴\",{\"1\":{\"156\":1}}],[\"normal模式下进入\",{\"1\":{\"144\":1}}],[\"normal下输入\",{\"1\":{\"143\":1}}],[\"normal普通模式\",{\"0\":{\"141\":1}}],[\"normal\",{\"1\":{\"11\":2,\"193\":1,\"194\":3,\"655\":1,\"1279\":3,\"1372\":1}}],[\"node2\",{\"1\":{\"669\":1}}],[\"node2节点是2进1出的流量\",{\"1\":{\"668\":1}}],[\"node1节点是2进3出的流量\",{\"1\":{\"668\":1}}],[\"nodehashval\",{\"1\":{\"396\":2}}],[\"node>\",{\"1\":{\"396\":2}}],[\"nodead\",{\"1\":{\"490\":2}}],[\"nodea2\",{\"1\":{\"393\":1}}],[\"nodea10\",{\"1\":{\"393\":1}}],[\"nodea1\",{\"1\":{\"393\":1}}],[\"nodea\",{\"1\":{\"393\":1}}],[\"node会依次在内置模块\",{\"1\":{\"363\":1}}],[\"node环境中\",{\"1\":{\"361\":1}}],[\"nodelist\",{\"1\":{\"252\":1}}],[\"node\",{\"0\":{\"360\":1,\"500\":1,\"600\":1},\"1\":{\"171\":1,\"237\":1,\"252\":1,\"253\":1,\"360\":1,\"396\":15,\"500\":4,\"594\":1,\"597\":2,\"600\":2,\"601\":1,\"1382\":1,\"1383\":1}}],[\"nodes\",{\"1\":{\"171\":2,\"396\":3,\"652\":2,\"657\":1}}],[\"nopaste解决\",{\"1\":{\"156\":1}}],[\"now\",{\"1\":{\"124\":1,\"125\":1,\"720\":1,\"736\":1,\"738\":1,\"819\":1,\"824\":2,\"845\":3,\"860\":3,\"1173\":3,\"1174\":2,\"1275\":3,\"1276\":5,\"1277\":4,\"1371\":1,\"1519\":1}}],[\"no\",{\"0\":{\"105\":1},\"1\":{\"165\":1,\"299\":2,\"316\":3,\"767\":1,\"819\":1,\"886\":1,\"901\":1,\"972\":1,\"973\":1,\"1000\":4,\"1008\":1,\"1050\":2,\"1056\":2,\"1079\":1,\"1173\":9,\"1174\":7,\"1175\":4,\"1198\":2,\"1208\":1,\"1266\":4,\"1269\":1,\"1270\":3,\"1276\":1,\"1332\":2,\"1333\":3,\"1372\":1,\"1373\":1,\"1430\":4,\"1432\":1,\"1435\":1,\"1462\":1,\"1468\":5}}],[\"nonatomicoperationonvolatilefield\",{\"1\":{\"1428\":1}}],[\"none\",{\"1\":{\"1173\":1}}],[\"nonode\",{\"1\":{\"252\":1}}],[\"nonu\",{\"1\":{\"143\":1}}],[\"non\",{\"0\":{\"101\":1},\"1\":{\"118\":3}}],[\"notreadynum=\",{\"1\":{\"1499\":1}}],[\"notreadynum\",{\"1\":{\"1499\":5}}],[\"notreadytermnum=\",{\"1\":{\"1497\":1}}],[\"notreadytermnum\",{\"1\":{\"1497\":5}}],[\"nothing\",{\"1\":{\"1372\":1}}],[\"notlockedmqs\",{\"1\":{\"1222\":4}}],[\"notbestbroker\",{\"1\":{\"1052\":5}}],[\"notifyconsumeridschanged\",{\"1\":{\"1331\":1}}],[\"notifyconsumeridschangedenable\",{\"1\":{\"1128\":2}}],[\"notifyme\",{\"1\":{\"824\":1,\"1170\":1,\"1201\":1,\"1228\":1}}],[\"notifymessagearrivinglistener\",{\"0\":{\"828\":1},\"1\":{\"827\":2,\"828\":1}}],[\"notifymessagearriving\",{\"0\":{\"825\":1,\"913\":1},\"1\":{\"812\":3,\"815\":1,\"823\":1,\"825\":1,\"827\":2,\"828\":1,\"886\":1,\"913\":1,\"914\":2,\"915\":1,\"1269\":1,\"1280\":1}}],[\"notify\",{\"1\":{\"812\":1,\"845\":2,\"915\":2,\"916\":1,\"1145\":2,\"1173\":2,\"1269\":1,\"1297\":2,\"1500\":2}}],[\"not\",{\"1\":{\"87\":1,\"97\":2,\"101\":1,\"104\":1,\"192\":1,\"206\":1,\"253\":1,\"316\":2,\"643\":11,\"645\":1,\"742\":1,\"764\":1,\"794\":1,\"814\":1,\"819\":3,\"825\":1,\"843\":1,\"861\":1,\"973\":1,\"996\":3,\"998\":2,\"1000\":1,\"1047\":2,\"1048\":1,\"1050\":1,\"1053\":1,\"1122\":2,\"1123\":1,\"1143\":2,\"1170\":2,\"1171\":2,\"1173\":27,\"1174\":2,\"1195\":1,\"1198\":5,\"1200\":1,\"1225\":1,\"1228\":1,\"1230\":6,\"1266\":2,\"1269\":2,\"1270\":3,\"1273\":1,\"1277\":1,\"1278\":1,\"1279\":3,\"1280\":1,\"1297\":1,\"1308\":11,\"1310\":3,\"1333\":2,\"1370\":1,\"1382\":3,\"1390\":3,\"1405\":3,\"1425\":1,\"1432\":1,\"1435\":1,\"1459\":1,\"1460\":1,\"1463\":1,\"1464\":1,\"1469\":1,\"1472\":2,\"1497\":1,\"1499\":1,\"1500\":4,\"1503\":1,\"1516\":1,\"1517\":2,\"1519\":1}}],[\"notepad\",{\"1\":{\"52\":2}}],[\"note\",{\"0\":{\"96\":1},\"1\":{\"16\":1,\"96\":1,\"98\":1,\"138\":1,\"139\":1,\"168\":1,\"263\":1,\"291\":1,\"493\":1}}],[\"6s\",{\"1\":{\"1453\":1,\"1467\":1,\"1468\":1,\"1477\":1,\"1499\":1}}],[\"65\",{\"0\":{\"1376\":1},\"1\":{\"1380\":1,\"1437\":2,\"1538\":1}}],[\"657\",{\"1\":{\"852\":1}}],[\"65746770>\",{\"1\":{\"181\":7}}],[\"6m\",{\"1\":{\"833\":1,\"919\":1,\"925\":1,\"1241\":1}}],[\"6gdxbowdawsvkbbitk2fxr08ucjpk0drqmujxcxquwfprax4nopxyjuwyqehsultnjyrsnvesg5qgjzbmmixjzmauqcgmaqklafc6cq0s827cxwpljbnjwynbk4fphtx\",{\"1\":{\"469\":1}}],[\"6gsfnsti1lpmhlia5zmf5\",{\"1\":{\"436\":1}}],[\"6yedw2r55bede4alwz2ukf8kqklkl9dr2wap9qlr\",{\"1\":{\"469\":1}}],[\"6udhpon\",{\"1\":{\"469\":1}}],[\"60m\",{\"1\":{\"1383\":4}}],[\"604\",{\"1\":{\"1367\":1}}],[\"60s\",{\"1\":{\"752\":1,\"758\":1,\"769\":1,\"869\":1,\"1230\":2,\"1453\":1,\"1468\":1}}],[\"605\",{\"1\":{\"491\":1,\"741\":1}}],[\"60\",{\"1\":{\"405\":1,\"421\":1,\"861\":1,\"869\":1,\"870\":2,\"1048\":1,\"1195\":1,\"1230\":1,\"1306\":1}}],[\"600\",{\"1\":{\"352\":1,\"353\":1,\"910\":2,\"913\":1}}],[\"63b0\",{\"1\":{\"749\":1}}],[\"639\",{\"1\":{\"484\":2}}],[\"636\",{\"1\":{\"484\":1}}],[\"630\",{\"1\":{\"399\":1}}],[\"635\",{\"1\":{\"11\":1}}],[\"6标准\",{\"1\":{\"360\":1}}],[\"6765\",{\"1\":{\"1077\":4}}],[\"67\",{\"1\":{\"301\":2}}],[\"67289768>\",{\"1\":{\"230\":1}}],[\"672\",{\"1\":{\"11\":1}}],[\"627\",{\"1\":{\"195\":1}}],[\"6844904013859651597\",{\"1\":{\"266\":1,\"274\":1}}],[\"686\",{\"1\":{\"195\":1}}],[\"689\",{\"1\":{\"195\":1}}],[\"64k\",{\"1\":{\"1299\":1}}],[\"64oovnunveau\",{\"1\":{\"436\":1}}],[\"642\",{\"1\":{\"195\":1}}],[\"64\",{\"1\":{\"182\":1,\"323\":1,\"390\":1,\"894\":1,\"1299\":1}}],[\"6>\",{\"1\":{\"171\":1,\"180\":1,\"181\":1,\"217\":1,\"255\":1}}],[\"66\",{\"1\":{\"1053\":1,\"1325\":1}}],[\"660\",{\"1\":{\"421\":3}}],[\"6666666666666667\",{\"1\":{\"174\":1}}],[\"6666\",{\"1\":{\"69\":1,\"70\":1,\"72\":1,\"73\":1}}],[\"663\",{\"1\":{\"11\":1}}],[\"6\",{\"0\":{\"45\":1,\"125\":1,\"127\":1,\"128\":1,\"129\":1,\"316\":1,\"331\":1,\"351\":1,\"352\":1,\"353\":1,\"355\":1,\"356\":1,\"357\":1,\"358\":1,\"359\":1,\"422\":1,\"423\":1,\"424\":1,\"428\":1,\"429\":1,\"430\":1,\"435\":1,\"436\":1,\"437\":1,\"442\":1,\"443\":1,\"444\":1,\"448\":1,\"449\":1,\"450\":1,\"454\":1,\"455\":2,\"456\":2,\"461\":2,\"462\":1,\"463\":1,\"468\":1,\"469\":1,\"470\":1,\"475\":1,\"498\":1,\"499\":1,\"515\":1,\"526\":1,\"527\":1,\"528\":1,\"529\":1,\"538\":1,\"577\":1,\"587\":1,\"603\":1,\"731\":1,\"883\":1,\"1044\":1,\"1103\":1,\"1173\":1,\"1202\":1,\"1280\":1,\"1392\":1,\"1393\":1,\"1394\":1,\"1419\":1,\"1420\":1,\"1421\":1},\"1\":{\"65\":1,\"106\":4,\"137\":1,\"177\":7,\"181\":4,\"182\":1,\"184\":1,\"195\":1,\"253\":2,\"284\":1,\"297\":1,\"298\":1,\"323\":1,\"325\":1,\"401\":1,\"403\":1,\"409\":1,\"411\":1,\"425\":1,\"455\":1,\"469\":1,\"485\":1,\"490\":1,\"737\":2,\"861\":1,\"964\":6,\"968\":1,\"1053\":1,\"1074\":2,\"1079\":3,\"1138\":1,\"1202\":1,\"1462\":1,\"1538\":1}}],[\"693\",{\"1\":{\"11\":2}}],[\"7~9\",{\"1\":{\"1507\":1}}],[\"7878\",{\"1\":{\"1380\":1}}],[\"780\",{\"1\":{\"421\":1}}],[\"71da5cd67513\",{\"1\":{\"1079\":2}}],[\"7w\",{\"1\":{\"910\":3}}],[\"7m\",{\"1\":{\"833\":1,\"919\":1,\"925\":1,\"1241\":1}}],[\"79\",{\"1\":{\"742\":1,\"890\":1}}],[\"7f8nf9zxfo61huhu\",{\"1\":{\"469\":1}}],[\"7v\",{\"1\":{\"443\":1}}],[\"7nf7p\",{\"1\":{\"436\":1,\"455\":1}}],[\"707m\",{\"1\":{\"1383\":4}}],[\"70\",{\"1\":{\"433\":1}}],[\"700m\",{\"1\":{\"927\":1}}],[\"700\",{\"1\":{\"421\":1}}],[\"77\",{\"1\":{\"405\":1,\"1073\":1,\"1445\":3}}],[\"771\",{\"1\":{\"11\":1}}],[\"722c5c14d3d0\",{\"1\":{\"1075\":1}}],[\"72h\",{\"1\":{\"870\":2}}],[\"72\",{\"1\":{\"866\":2,\"870\":1,\"910\":2,\"1382\":1,\"1445\":3}}],[\"72654g4\",{\"1\":{\"255\":5}}],[\"728\",{\"1\":{\"11\":1}}],[\"7>\",{\"1\":{\"177\":1,\"181\":1,\"217\":1,\"255\":1}}],[\"7\",{\"0\":{\"50\":1,\"126\":1,\"130\":1,\"131\":1,\"132\":1,\"133\":1,\"134\":1,\"332\":1,\"354\":1,\"462\":1,\"463\":1,\"468\":1,\"476\":1,\"477\":1,\"500\":1,\"516\":1,\"530\":1,\"531\":1,\"539\":1,\"555\":1,\"578\":1,\"641\":1,\"732\":1,\"1174\":1,\"1395\":1},\"1\":{\"65\":1,\"181\":3,\"182\":1,\"195\":2,\"297\":1,\"323\":1,\"324\":1,\"399\":1,\"411\":1,\"443\":1,\"455\":1,\"583\":2,\"641\":2,\"642\":1,\"645\":7,\"718\":1,\"737\":2,\"964\":3,\"968\":1,\"1079\":1,\"1243\":1,\"1367\":1,\"1475\":1,\"1506\":1}}],[\"76\",{\"1\":{\"405\":1}}],[\"765\",{\"1\":{\"11\":1}}],[\"766\",{\"1\":{\"11\":1}}],[\"75\",{\"1\":{\"301\":1,\"864\":1,\"866\":3,\"870\":1,\"1065\":1}}],[\"753\",{\"1\":{\"11\":1}}],[\"755\",{\"1\":{\"11\":2}}],[\"754\",{\"1\":{\"11\":1}}],[\"±\",{\"1\":{\"11\":4}}],[\"rqid=\",{\"1\":{\"1276\":4}}],[\"rqid\",{\"1\":{\"1273\":4}}],[\"rcv\",{\"1\":{\"1173\":3}}],[\"rwxrwxr\",{\"1\":{\"1074\":7}}],[\"rw\",{\"1\":{\"880\":1}}],[\"rw7nmnmj\",{\"1\":{\"429\":1}}],[\"rmqnamesrv\",{\"1\":{\"1075\":2,\"1079\":2,\"1080\":3,\"1081\":1}}],[\"rmqbroker1\",{\"1\":{\"1079\":1,\"1080\":1}}],[\"rmqbroker2\",{\"1\":{\"1079\":2,\"1080\":1}}],[\"rmqbroker\",{\"1\":{\"1075\":5,\"1079\":2,\"1080\":1}}],[\"rmq\",{\"1\":{\"843\":1,\"845\":2,\"860\":2,\"964\":1,\"1012\":1,\"1072\":2,\"1078\":1,\"1081\":1,\"1198\":1,\"1288\":2,\"1354\":1,\"1383\":1,\"1450\":1,\"1451\":1,\"1453\":1,\"1463\":2,\"1464\":2,\"1468\":4}}],[\"ryf\",{\"1\":{\"493\":1}}],[\"rycn\",{\"1\":{\"398\":2,\"491\":1}}],[\"rz5lnmg1tkrlu7bgzxcmr7ee3wsxdzh5znnj27nhg0tfpv7m3pye2mgg\",{\"1\":{\"469\":1}}],[\"rip28\",{\"1\":{\"1298\":1}}],[\"rip\",{\"0\":{\"1282\":1,\"1335\":1,\"1376\":2},\"1\":{\"773\":1,\"1281\":1,\"1346\":1,\"1347\":1,\"1348\":1,\"1350\":1,\"1353\":1,\"1362\":1,\"1364\":1,\"1375\":2,\"1380\":2,\"1437\":3,\"1538\":4}}],[\"ripemd\",{\"1\":{\"390\":1}}],[\"right\",{\"1\":{\"585\":2,\"1519\":1}}],[\"ring\",{\"1\":{\"396\":15,\"480\":2,\"711\":1}}],[\"r表示\",{\"1\":{\"288\":1}}],[\"ruradh\",{\"1\":{\"264\":1}}],[\"runbroker\",{\"1\":{\"1080\":2}}],[\"runbioserver\",{\"1\":{\"113\":2}}],[\"runmultireactor\",{\"1\":{\"134\":2}}],[\"runmultithreadreactor\",{\"1\":{\"129\":2}}],[\"runsinglethreadreactor\",{\"1\":{\"126\":2}}],[\"runwith\",{\"1\":{\"98\":1,\"99\":1}}],[\"runnable\",{\"1\":{\"75\":1,\"112\":1,\"113\":1,\"121\":1,\"122\":5,\"123\":1,\"124\":1,\"128\":1,\"133\":1,\"793\":1,\"820\":2,\"841\":1,\"869\":1,\"961\":2,\"970\":1,\"1021\":1,\"1048\":5,\"1175\":1,\"1201\":1,\"1469\":1,\"1472\":2}}],[\"runningflags\",{\"1\":{\"1174\":2}}],[\"running\",{\"1\":{\"69\":1,\"104\":1,\"339\":3,\"861\":1,\"1037\":1,\"1047\":3,\"1048\":1,\"1075\":1,\"1122\":2,\"1123\":1,\"1373\":1,\"1374\":1}}],[\"runtimeexception\",{\"1\":{\"133\":1,\"995\":1,\"1331\":1,\"1425\":1}}],[\"runtimeexception及其子类\",{\"1\":{\"33\":1}}],[\"runtime\",{\"1\":{\"43\":2,\"44\":1,\"60\":1,\"960\":1}}],[\"run\",{\"0\":{\"824\":1},\"1\":{\"11\":3,\"69\":1,\"112\":1,\"113\":1,\"122\":3,\"123\":1,\"124\":1,\"125\":1,\"128\":2,\"133\":1,\"339\":3,\"729\":1,\"793\":1,\"812\":1,\"815\":1,\"820\":4,\"824\":1,\"841\":2,\"844\":1,\"861\":1,\"869\":4,\"961\":2,\"970\":1,\"999\":1,\"1021\":2,\"1048\":5,\"1077\":1,\"1080\":3,\"1081\":1,\"1140\":1,\"1158\":1,\"1168\":3,\"1175\":1,\"1188\":1,\"1195\":1,\"1201\":1,\"1230\":2,\"1263\":1,\"1371\":1,\"1373\":1,\"1374\":1,\"1427\":1,\"1435\":1,\"1467\":1,\"1469\":1,\"1472\":1}}],[\"rk4eks\",{\"1\":{\"264\":1}}],[\"rolechangehandler\",{\"1\":{\"1424\":2}}],[\"role\",{\"1\":{\"1370\":1}}],[\"rolling\",{\"1\":{\"1427\":1,\"1435\":1}}],[\"rollingfile\",{\"1\":{\"1427\":1}}],[\"rollingnewfile\",{\"1\":{\"1420\":1,\"1435\":1}}],[\"roll\",{\"1\":{\"1371\":2,\"1464\":1}}],[\"rollnextfile\",{\"1\":{\"767\":1,\"1174\":2}}],[\"rollbackmessagestotal\",{\"1\":{\"1464\":1}}],[\"rollbackmessage\",{\"1\":{\"1464\":1}}],[\"rollback\",{\"1\":{\"764\":1,\"794\":1,\"1230\":1,\"1442\":2,\"1445\":2,\"1446\":3,\"1451\":1,\"1459\":1,\"1460\":2,\"1464\":2,\"1467\":1,\"1472\":3}}],[\"rolled\",{\"1\":{\"720\":1,\"722\":2,\"1468\":1}}],[\"rockemq集群中至少有两个broker节点\",{\"1\":{\"1004\":1}}],[\"rocketmq与kafka高性能设计对比\",{\"1\":{\"1527\":1}}],[\"rocketmq5源码\",{\"1\":{\"1437\":1}}],[\"rocketmq无法避免消息重复\",{\"1\":{\"1237\":1}}],[\"rocketmq消息消费源码分析\",{\"1\":{\"1105\":1}}],[\"rocketmq消息消费\",{\"1\":{\"1105\":1}}],[\"rocketmq消息轨迹\",{\"1\":{\"1022\":1}}],[\"rocketmq消费消息原理\",{\"1\":{\"1105\":1}}],[\"rocketmq消费消息\",{\"1\":{\"1105\":1}}],[\"rocketmqinc\",{\"1\":{\"1073\":1}}],[\"rocketmq按照业务逻辑区分请求处理器\",{\"1\":{\"1055\":1}}],[\"rocketmqlog\",{\"1\":{\"1008\":2}}],[\"rocketmq安装目录\",{\"1\":{\"998\":1,\"999\":1}}],[\"rocketmq2\",{\"1\":{\"983\":1}}],[\"rocketmqprotocolencode\",{\"1\":{\"893\":1,\"894\":3}}],[\"rocketmqserializable\",{\"1\":{\"886\":1,\"892\":1,\"893\":2,\"894\":3}}],[\"rocketmq存储实现分析\",{\"1\":{\"884\":1,\"1537\":1}}],[\"rocketmq存储篇\",{\"1\":{\"798\":1}}],[\"rocketmq中的定时消息支持\",{\"0\":{\"833\":1}}],[\"rocketmq的存储文件都遵循一种通用的数据存储格式定义实践\",{\"1\":{\"787\":1}}],[\"rocketmq高性能之底层存储设计\",{\"1\":{\"774\":1,\"884\":1,\"1537\":1}}],[\"rocketmq源码分析\",{\"1\":{\"774\":1}}],[\"rocketmq这样做\",{\"1\":{\"743\":1}}],[\"rocketmq4\",{\"1\":{\"733\":1}}],[\"rocketmq在保存消息时\",{\"1\":{\"733\":1}}],[\"rocketmq\",{\"0\":{\"719\":1,\"744\":1,\"773\":1,\"775\":1,\"799\":1,\"830\":1,\"849\":1,\"862\":1,\"873\":1,\"885\":1,\"889\":1,\"918\":1,\"937\":1,\"939\":1,\"975\":1,\"1002\":1,\"1009\":1,\"1023\":1,\"1058\":1,\"1068\":1,\"1072\":1,\"1074\":1,\"1075\":1,\"1076\":1,\"1077\":1,\"1079\":1,\"1082\":1,\"1083\":1,\"1084\":1,\"1085\":1,\"1106\":1,\"1124\":1,\"1146\":1,\"1176\":1,\"1202\":1,\"1231\":1,\"1243\":1,\"1282\":1,\"1299\":1,\"1301\":1,\"1303\":1,\"1335\":1,\"1376\":1,\"1438\":1,\"1474\":1,\"1505\":1,\"1523\":1,\"1524\":1,\"1528\":1,\"1538\":1},\"1\":{\"277\":1,\"286\":1,\"396\":1,\"681\":1,\"719\":2,\"720\":2,\"722\":1,\"723\":1,\"724\":2,\"725\":1,\"727\":1,\"728\":1,\"729\":1,\"733\":1,\"735\":1,\"736\":2,\"740\":1,\"742\":1,\"743\":2,\"744\":2,\"746\":1,\"756\":2,\"773\":1,\"774\":1,\"775\":2,\"777\":2,\"787\":1,\"798\":1,\"799\":2,\"800\":1,\"801\":1,\"802\":1,\"804\":2,\"805\":1,\"806\":3,\"812\":1,\"829\":1,\"830\":2,\"833\":2,\"836\":3,\"840\":1,\"849\":2,\"850\":2,\"852\":1,\"862\":2,\"863\":2,\"873\":2,\"874\":5,\"876\":1,\"877\":1,\"879\":1,\"880\":1,\"881\":1,\"882\":3,\"883\":1,\"884\":4,\"885\":2,\"886\":2,\"887\":1,\"890\":2,\"893\":3,\"894\":5,\"899\":2,\"902\":1,\"912\":1,\"915\":1,\"917\":1,\"918\":2,\"919\":2,\"922\":9,\"923\":1,\"925\":9,\"927\":2,\"928\":1,\"930\":2,\"932\":1,\"934\":1,\"936\":2,\"937\":1,\"939\":2,\"941\":3,\"942\":2,\"960\":2,\"974\":1,\"975\":2,\"976\":3,\"978\":6,\"979\":2,\"983\":2,\"984\":1,\"985\":1,\"986\":1,\"990\":1,\"996\":2,\"998\":1,\"999\":1,\"1001\":4,\"1002\":2,\"1003\":1,\"1004\":1,\"1009\":1,\"1010\":1,\"1023\":2,\"1024\":2,\"1025\":3,\"1027\":1,\"1028\":1,\"1029\":1,\"1030\":1,\"1035\":2,\"1036\":1,\"1038\":1,\"1043\":2,\"1044\":1,\"1053\":1,\"1057\":3,\"1058\":2,\"1068\":2,\"1069\":5,\"1070\":3,\"1071\":1,\"1072\":4,\"1073\":12,\"1074\":1,\"1075\":20,\"1076\":3,\"1077\":10,\"1078\":2,\"1079\":15,\"1080\":16,\"1081\":1,\"1085\":2,\"1086\":5,\"1088\":1,\"1090\":2,\"1091\":1,\"1094\":1,\"1095\":2,\"1097\":2,\"1098\":1,\"1100\":2,\"1105\":5,\"1106\":2,\"1107\":1,\"1109\":1,\"1116\":1,\"1117\":2,\"1119\":1,\"1124\":2,\"1125\":2,\"1126\":1,\"1127\":1,\"1128\":1,\"1130\":1,\"1131\":2,\"1136\":1,\"1138\":1,\"1146\":2,\"1147\":3,\"1155\":1,\"1168\":1,\"1176\":2,\"1177\":3,\"1179\":1,\"1180\":1,\"1181\":1,\"1187\":1,\"1188\":1,\"1202\":2,\"1203\":6,\"1207\":1,\"1209\":1,\"1215\":1,\"1231\":2,\"1234\":1,\"1235\":2,\"1238\":1,\"1239\":1,\"1243\":2,\"1245\":2,\"1246\":1,\"1249\":3,\"1253\":2,\"1281\":1,\"1282\":2,\"1284\":5,\"1287\":1,\"1290\":2,\"1297\":1,\"1298\":1,\"1299\":5,\"1301\":2,\"1303\":1,\"1307\":1,\"1309\":1,\"1313\":1,\"1318\":1,\"1319\":1,\"1321\":2,\"1323\":1,\"1334\":1,\"1335\":2,\"1338\":4,\"1339\":1,\"1342\":2,\"1343\":1,\"1344\":1,\"1346\":1,\"1347\":1,\"1376\":2,\"1378\":3,\"1380\":1,\"1382\":7,\"1383\":1,\"1385\":1,\"1390\":1,\"1395\":1,\"1397\":1,\"1403\":1,\"1415\":1,\"1420\":1,\"1425\":2,\"1437\":3,\"1438\":2,\"1439\":4,\"1440\":1,\"1441\":1,\"1443\":1,\"1446\":2,\"1449\":1,\"1450\":1,\"1473\":2,\"1474\":2,\"1475\":3,\"1504\":2,\"1505\":2,\"1506\":3,\"1509\":1,\"1517\":1,\"1522\":2,\"1523\":2,\"1524\":2,\"1528\":2,\"1529\":1,\"1537\":3,\"1538\":32}}],[\"rocksdbmessagestore\",{\"1\":{\"1398\":1,\"1424\":1,\"1425\":1}}],[\"rocksdb\",{\"0\":{\"1364\":1},\"1\":{\"928\":2,\"1364\":2,\"1398\":1}}],[\"routingkey\",{\"1\":{\"708\":2,\"712\":2,\"714\":1}}],[\"routing\",{\"1\":{\"668\":1,\"711\":3}}],[\"routeinfomanager\",{\"1\":{\"944\":2,\"949\":1,\"953\":3,\"954\":2,\"957\":1,\"961\":1,\"971\":3,\"972\":1,\"973\":1}}],[\"route\",{\"1\":{\"396\":1,\"973\":1,\"974\":1,\"1050\":2}}],[\"routenode\",{\"1\":{\"396\":2}}],[\"roup1dc1308enm\",{\"1\":{\"455\":1}}],[\"robot\",{\"1\":{\"339\":2}}],[\"road\",{\"1\":{\"316\":1}}],[\"rooms\",{\"1\":{\"253\":2}}],[\"rootdirs\",{\"1\":{\"601\":2}}],[\"root\",{\"1\":{\"113\":1,\"125\":1}}],[\"row\",{\"1\":{\"253\":2}}],[\"rhs\",{\"1\":{\"173\":2}}],[\"rror派生的typeerror\",{\"1\":{\"356\":1}}],[\"rr\",{\"1\":{\"171\":3,\"191\":1}}],[\"rpo\",{\"1\":{\"276\":1,\"283\":1}}],[\"rpchooks\",{\"1\":{\"988\":2,\"994\":9}}],[\"rpchook\",{\"1\":{\"979\":1,\"984\":1,\"985\":1,\"987\":1,\"988\":3,\"990\":1,\"994\":15,\"996\":1,\"1019\":4,\"1047\":1,\"1122\":1}}],[\"rpc\",{\"1\":{\"235\":1,\"1514\":1}}],[\"rp\",{\"1\":{\"171\":1}}],[\"rl\",{\"1\":{\"171\":2}}],[\"rf\",{\"1\":{\"171\":2,\"191\":1}}],[\"rfind\",{\"1\":{\"145\":1}}],[\"rdma\",{\"1\":{\"1385\":1}}],[\"rd\",{\"1\":{\"171\":1}}],[\"rarely\",{\"1\":{\"1519\":1}}],[\"rather\",{\"1\":{\"1436\":1}}],[\"rate\",{\"1\":{\"374\":1}}],[\"rabalanceimpl\",{\"1\":{\"1133\":1}}],[\"rabbit\",{\"1\":{\"618\":1,\"621\":4,\"624\":8,\"625\":3,\"626\":5,\"627\":1,\"657\":1,\"687\":2}}],[\"rabbitmqconsistenthashdemo\",{\"1\":{\"712\":1}}],[\"rabbitmqctl\",{\"1\":{\"618\":1,\"645\":2,\"653\":2}}],[\"rabbitmq<\",{\"1\":{\"712\":1}}],[\"rabbitmq数据读写过程\",{\"1\":{\"691\":1}}],[\"rabbitmq学习记录\",{\"1\":{\"691\":1}}],[\"rabbitmq先将消息的内容和索引保存在磁盘中\",{\"1\":{\"690\":1}}],[\"rabbitmq才会把消息写到磁盘上\",{\"1\":{\"690\":1}}],[\"rabbitmq会根据消息的传输速度来计算当前内存中允许保存的最大消息数量\",{\"1\":{\"690\":1}}],[\"rabbitmq中队列的存储状态\",{\"0\":{\"690\":1}}],[\"rabbitmq中的每个队列都有一个主队列\",{\"1\":{\"660\":1}}],[\"rabbitmq中有四种进程\",{\"1\":{\"619\":1}}],[\"rabbitmq流量控制机制分析\",{\"1\":{\"628\":1}}],[\"rabbitmq实战指南\",{\"1\":{\"628\":1}}],[\"rabbitmq\",{\"0\":{\"609\":1,\"612\":1,\"629\":1,\"641\":1,\"645\":1,\"646\":1,\"647\":1,\"680\":1,\"692\":1,\"705\":1,\"718\":1},\"1\":{\"609\":2,\"613\":2,\"614\":2,\"617\":1,\"628\":3,\"629\":2,\"630\":1,\"635\":3,\"640\":2,\"641\":3,\"642\":2,\"645\":12,\"646\":3,\"647\":2,\"648\":6,\"649\":1,\"654\":1,\"659\":1,\"664\":1,\"668\":3,\"675\":1,\"679\":5,\"680\":2,\"681\":5,\"687\":3,\"692\":8,\"695\":1,\"705\":2,\"707\":3,\"710\":2,\"711\":2,\"712\":3,\"717\":2,\"718\":7,\"922\":1}}],[\"raft\",{\"0\":{\"695\":1},\"1\":{\"694\":2,\"695\":1,\"696\":1,\"704\":1,\"1475\":1,\"1477\":4,\"1482\":1,\"1483\":1,\"1504\":1,\"1506\":1,\"1514\":1,\"1522\":1}}],[\"ram\",{\"1\":{\"690\":6}}],[\"radius\",{\"1\":{\"560\":1}}],[\"rainbowcolor\",{\"1\":{\"515\":1}}],[\"race\",{\"0\":{\"353\":1},\"1\":{\"353\":1}}],[\"randomq\",{\"1\":{\"1269\":5}}],[\"randomqueueid\",{\"1\":{\"1056\":1}}],[\"randomuuid\",{\"1\":{\"1021\":1}}],[\"randomaccessfile\",{\"1\":{\"880\":1}}],[\"random\",{\"1\":{\"351\":1,\"368\":2,\"1050\":1,\"1269\":1,\"1437\":1,\"1497\":1}}],[\"range\",{\"1\":{\"106\":4,\"150\":2,\"1430\":1,\"1436\":2,\"1519\":2}}],[\"raw\",{\"1\":{\"165\":1,\"756\":1,\"806\":1,\"812\":1,\"1278\":8}}],[\"r\",{\"1\":{\"125\":4,\"143\":2,\"148\":3,\"171\":7,\"230\":3,\"290\":1,\"325\":4,\"503\":1,\"742\":15,\"1173\":2,\"1198\":6,\"1436\":2,\"1443\":2}}],[\"rewind\",{\"1\":{\"1428\":2}}],[\"reentrantlock\",{\"1\":{\"1222\":1}}],[\"rebalancelockmanager\",{\"1\":{\"1212\":1,\"1214\":1,\"1222\":1}}],[\"rebalancepushimpl\",{\"1\":{\"1145\":1,\"1225\":1}}],[\"rebalanceresultset=\",{\"1\":{\"1143\":1}}],[\"rebalanceresultsize=\",{\"1\":{\"1143\":1}}],[\"rebalanced\",{\"1\":{\"1143\":1}}],[\"rebalanceimmediately\",{\"1\":{\"1122\":1,\"1136\":1}}],[\"rebalanceimpl\",{\"0\":{\"1132\":1,\"1141\":1},\"1\":{\"1120\":2,\"1122\":6,\"1129\":3,\"1132\":1,\"1137\":2,\"1170\":3,\"1175\":1,\"1224\":1,\"1226\":1,\"1228\":1}}],[\"rebalancebytopic\",{\"0\":{\"1143\":1},\"1\":{\"1104\":1,\"1134\":1,\"1137\":1,\"1142\":2,\"1143\":1}}],[\"rebalance\",{\"0\":{\"1098\":1},\"1\":{\"1048\":1,\"1124\":1,\"1145\":2,\"1281\":1}}],[\"rebalanceservice\",{\"0\":{\"1140\":1},\"1\":{\"1037\":1,\"1048\":1,\"1104\":1,\"1111\":1,\"1120\":2,\"1123\":1,\"1129\":1,\"1136\":1,\"1140\":1}}],[\"re\",{\"1\":{\"845\":1,\"860\":1}}],[\"req\",{\"1\":{\"763\":2,\"789\":1,\"794\":10,\"1371\":11}}],[\"requested\",{\"1\":{\"1519\":1}}],[\"requestsize\",{\"1\":{\"1432\":3}}],[\"requests\",{\"1\":{\"1371\":1,\"1516\":2,\"1521\":1}}],[\"requestoffset=\",{\"1\":{\"1173\":3,\"1201\":1}}],[\"requestfutureholder\",{\"1\":{\"1047\":1}}],[\"requestid\",{\"1\":{\"1017\":1}}],[\"requestbody\",{\"1\":{\"970\":4,\"1226\":5}}],[\"requestcode\",{\"1\":{\"952\":1,\"1055\":4,\"1172\":1}}],[\"requestcontent\",{\"1\":{\"113\":2,\"125\":2}}],[\"requestprocessor\",{\"1\":{\"944\":1}}],[\"requestlist\",{\"1\":{\"825\":3}}],[\"requesttask\",{\"1\":{\"820\":1}}],[\"requestheader\",{\"1\":{\"819\":3,\"970\":9,\"973\":4,\"1053\":18,\"1056\":12,\"1171\":13,\"1172\":2,\"1173\":83,\"1198\":14,\"1200\":7,\"1269\":20,\"1270\":25,\"1271\":2,\"1273\":8,\"1460\":12,\"1462\":3,\"1464\":16,\"1471\":2}}],[\"request\",{\"1\":{\"235\":2,\"348\":8,\"742\":2,\"764\":3,\"814\":2,\"819\":3,\"820\":8,\"823\":1,\"824\":1,\"825\":14,\"973\":2,\"994\":7,\"995\":8,\"996\":3,\"1000\":1,\"1021\":2,\"1048\":1,\"1056\":6,\"1170\":3,\"1172\":3,\"1173\":11,\"1174\":1,\"1175\":3,\"1198\":5,\"1228\":1,\"1269\":3,\"1273\":4,\"1297\":26,\"1332\":11,\"1427\":2,\"1435\":1,\"1462\":4,\"1464\":2,\"1471\":3,\"1472\":2,\"1500\":16,\"1503\":28,\"1516\":11,\"1519\":15,\"1520\":65}}],[\"require\",{\"1\":{\"361\":1,\"369\":1,\"595\":2}}],[\"required\",{\"1\":{\"103\":1}}],[\"required=false\",{\"1\":{\"82\":1}}],[\"requires\",{\"1\":{\"87\":1}}],[\"rename\",{\"1\":{\"742\":1,\"890\":1,\"1287\":1,\"1445\":3}}],[\"reinstall\",{\"1\":{\"646\":1}}],[\"rejectcommitorrollback\",{\"1\":{\"1464\":2}}],[\"rejectedexecutionexception\",{\"1\":{\"1194\":2}}],[\"reject\",{\"1\":{\"351\":3,\"352\":2,\"353\":2,\"1497\":8,\"1503\":10,\"1516\":1}}],[\"reducing\",{\"1\":{\"1432\":1}}],[\"reduce\",{\"0\":{\"322\":1,\"324\":1},\"1\":{\"324\":1,\"329\":1}}],[\"redirect\",{\"1\":{\"1173\":1}}],[\"redis\",{\"1\":{\"286\":1,\"1079\":3}}],[\"redelivered\",{\"1\":{\"665\":1}}],[\"red\",{\"1\":{\"582\":2,\"583\":2}}],[\"revote\",{\"1\":{\"1497\":5}}],[\"reverseorder\",{\"1\":{\"1521\":1}}],[\"reverse\",{\"1\":{\"256\":1,\"547\":5,\"886\":1,\"888\":1}}],[\"revise\",{\"1\":{\"1519\":1}}],[\"revivedelay=\",{\"1\":{\"1280\":1}}],[\"reviveretry\",{\"1\":{\"1280\":2}}],[\"revivemsgfromck\",{\"1\":{\"1279\":1,\"1280\":1}}],[\"reviveoffset\",{\"1\":{\"1278\":1}}],[\"revivequeueoffset\",{\"1\":{\"1275\":3}}],[\"revivequeueid=\",{\"1\":{\"1278\":6,\"1279\":3,\"1280\":5}}],[\"revivequeueid\",{\"1\":{\"1275\":3}}],[\"reviveqid=\",{\"1\":{\"1276\":1}}],[\"reviveqid\",{\"1\":{\"1269\":8,\"1270\":4,\"1271\":4,\"1276\":7}}],[\"revivetopic\",{\"1\":{\"1259\":1,\"1260\":1,\"1261\":2,\"1263\":4,\"1273\":1,\"1278\":3,\"1279\":3,\"1280\":1}}],[\"revivetime\",{\"1\":{\"1253\":3,\"1259\":1,\"1261\":1,\"1277\":1}}],[\"revive\",{\"1\":{\"1251\":1,\"1253\":2,\"1269\":2,\"1271\":2,\"1273\":1,\"1276\":1,\"1278\":6,\"1279\":3,\"1280\":2}}],[\"review\",{\"1\":{\"165\":1}}],[\"revious\",{\"1\":{\"154\":1}}],[\"reorder\",{\"1\":{\"253\":1}}],[\"refreshed\",{\"1\":{\"1519\":1}}],[\"refactoring\",{\"1\":{\"1437\":1}}],[\"ref\",{\"1\":{\"218\":1}}],[\"referenceerror等错误对象\",{\"1\":{\"356\":1}}],[\"referenceerror\",{\"1\":{\"316\":2}}],[\"reference\",{\"1\":{\"171\":1,\"218\":1}}],[\"relative\",{\"1\":{\"1468\":1}}],[\"reloadserversslcontext\",{\"1\":{\"961\":3}}],[\"reload\",{\"1\":{\"165\":1,\"171\":1,\"961\":3}}],[\"releasecommitlock\",{\"1\":{\"1428\":3}}],[\"releases\",{\"1\":{\"645\":1}}],[\"release\",{\"1\":{\"25\":1,\"797\":6,\"845\":1,\"860\":1,\"1173\":2,\"1174\":3,\"1370\":1,\"1372\":1,\"1427\":2,\"1436\":1,\"1462\":1}}],[\"release设置\",{\"1\":{\"25\":1}}],[\"region=defaultregion\",{\"1\":{\"1445\":3}}],[\"region\",{\"1\":{\"1020\":1}}],[\"regionname\",{\"1\":{\"1017\":1}}],[\"regionid\",{\"1\":{\"1017\":2,\"1020\":2,\"1021\":7}}],[\"registerfiltermessagehook\",{\"1\":{\"1122\":1}}],[\"registerfirst\",{\"1\":{\"971\":5}}],[\"registermessagequeuelistener\",{\"1\":{\"1117\":1}}],[\"registermessagelistener\",{\"1\":{\"985\":1,\"1007\":1,\"1117\":1,\"1248\":1,\"1444\":1}}],[\"registersendmessagehook\",{\"1\":{\"1055\":1}}],[\"registerserverrpchook\",{\"1\":{\"996\":1}}],[\"registerproducer\",{\"1\":{\"1047\":1}}],[\"registerprocessor\",{\"1\":{\"961\":1,\"1055\":5}}],[\"registerok\",{\"1\":{\"1047\":2,\"1122\":2}}],[\"registerconsumer\",{\"1\":{\"1122\":1,\"1317\":1}}],[\"registerconsumemessagehook\",{\"1\":{\"1019\":1,\"1055\":1}}],[\"registerconfig\",{\"1\":{\"960\":1}}],[\"registerrpchook\",{\"1\":{\"994\":1}}],[\"registerbrokerbody\",{\"1\":{\"970\":2}}],[\"registerbrokerresult\",{\"1\":{\"970\":1,\"971\":3}}],[\"registerbrokerresultlist\",{\"1\":{\"970\":3}}],[\"registerbrokerrequestheader\",{\"1\":{\"970\":2}}],[\"registerbroker\",{\"1\":{\"953\":1,\"970\":2,\"971\":3}}],[\"registerbrokerall\",{\"1\":{\"952\":1,\"970\":2}}],[\"registered\",{\"1\":{\"171\":2,\"234\":1,\"967\":1,\"971\":1}}],[\"register\",{\"1\":{\"118\":1,\"121\":1,\"124\":3,\"131\":2,\"133\":1,\"157\":3,\"160\":2,\"234\":1,\"952\":2,\"953\":1,\"961\":1,\"970\":1,\"1331\":4}}],[\"regex\",{\"1\":{\"886\":1,\"904\":1}}],[\"regexp\",{\"0\":{\"335\":1}}],[\"regs\",{\"1\":{\"171\":1}}],[\"reg\",{\"1\":{\"157\":1}}],[\"recallhandle=null\",{\"1\":{\"1445\":10}}],[\"recalculatepullfromwhichnode\",{\"1\":{\"1171\":2}}],[\"recvlen\",{\"1\":{\"625\":2}}],[\"recvloop\",{\"1\":{\"625\":4}}],[\"recvloop方法\",{\"1\":{\"625\":1}}],[\"recv\",{\"1\":{\"625\":3}}],[\"rectangles\",{\"1\":{\"230\":1}}],[\"rectangle\",{\"1\":{\"180\":4,\"230\":1,\"253\":1}}],[\"reconsumelater\",{\"1\":{\"1251\":1}}],[\"reconsume\",{\"1\":{\"1053\":2,\"1195\":3}}],[\"reconsumetimes=0\",{\"1\":{\"1445\":3}}],[\"reconsumetimes\",{\"1\":{\"737\":2,\"742\":1,\"1053\":3}}],[\"recoverasync\",{\"1\":{\"1421\":1}}],[\"recover\",{\"0\":{\"771\":1},\"1\":{\"771\":6,\"1053\":1,\"1421\":2}}],[\"recovery\",{\"1\":{\"283\":2}}],[\"recorddiskfallbehindsize\",{\"1\":{\"1174\":1}}],[\"records\",{\"1\":{\"191\":2}}],[\"record\",{\"0\":{\"190\":1,\"191\":1},\"1\":{\"171\":9,\"190\":1,\"191\":7,\"253\":6,\"971\":1,\"1462\":2,\"1464\":2,\"1516\":1}}],[\"recommended\",{\"1\":{\"104\":1}}],[\"received状态\",{\"1\":{\"375\":1}}],[\"received\",{\"1\":{\"235\":1,\"369\":2,\"1500\":1}}],[\"receive\",{\"1\":{\"72\":1,\"73\":1,\"229\":2,\"230\":1,\"232\":1,\"233\":1,\"235\":2,\"985\":1,\"1007\":1,\"1173\":1,\"1248\":1,\"1444\":1,\"1445\":3}}],[\"remember\",{\"1\":{\"960\":1}}],[\"remaining\",{\"1\":{\"1427\":1,\"1428\":1,\"1432\":2,\"1436\":3,\"1517\":4}}],[\"remain=\",{\"1\":{\"1427\":3}}],[\"remains\",{\"1\":{\"104\":1}}],[\"remark\",{\"1\":{\"894\":5,\"1460\":2,\"1472\":3}}],[\"removing\",{\"1\":{\"767\":1,\"1173\":1,\"1174\":1,\"1270\":1}}],[\"removewaitstorepropertystring\",{\"1\":{\"1296\":1}}],[\"removeck\",{\"1\":{\"1277\":4}}],[\"removeoffset\",{\"1\":{\"1225\":1}}],[\"removemessage\",{\"1\":{\"1195\":1}}],[\"removemap\",{\"1\":{\"722\":2,\"1453\":3,\"1468\":9}}],[\"removeall\",{\"1\":{\"1195\":1}}],[\"removeprocessqueue\",{\"1\":{\"1175\":1}}],[\"removeunnecessarymessagequeue\",{\"1\":{\"1134\":1,\"1144\":2,\"1224\":2,\"1225\":2}}],[\"removebrokername\",{\"1\":{\"972\":4}}],[\"removedirtyoffset\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"removedopoffset\",{\"1\":{\"722\":2,\"1468\":5}}],[\"removed\",{\"1\":{\"643\":1,\"972\":2}}],[\"removenode\",{\"1\":{\"396\":1}}],[\"remove\",{\"1\":{\"91\":1,\"165\":1,\"171\":2,\"253\":1,\"396\":2,\"593\":1,\"643\":1,\"646\":4,\"720\":4,\"722\":1,\"723\":2,\"731\":1,\"861\":2,\"971\":3,\"972\":14,\"1052\":1,\"1056\":2,\"1144\":4,\"1200\":2,\"1224\":2,\"1277\":2,\"1468\":3,\"1519\":2,\"1520\":2,\"1521\":3}}],[\"remotingtoomuchrequestexception\",{\"1\":{\"1053\":2}}],[\"remotingexception\",{\"1\":{\"1050\":2,\"1053\":1,\"1171\":2,\"1172\":1,\"1197\":2,\"1200\":1,\"1460\":1}}],[\"remotingexecutorthread\",{\"1\":{\"961\":1}}],[\"remotingexecutor\",{\"1\":{\"961\":2}}],[\"remotinghelper\",{\"1\":{\"984\":1,\"994\":1,\"1006\":1,\"1173\":2,\"1195\":1,\"1197\":1,\"1230\":1,\"1266\":1,\"1287\":1,\"1306\":1,\"1309\":1,\"1443\":1,\"1471\":1}}],[\"remotingclient\",{\"1\":{\"970\":1,\"1036\":1}}],[\"remotingcommand\",{\"1\":{\"742\":1,\"814\":3,\"819\":2,\"820\":2,\"890\":1,\"893\":1,\"894\":2,\"960\":1,\"973\":4,\"994\":5,\"995\":2,\"996\":3,\"1056\":2,\"1172\":2,\"1173\":4,\"1198\":3,\"1269\":2,\"1273\":4,\"1462\":3,\"1464\":7,\"1471\":2}}],[\"remotingcommandexception\",{\"1\":{\"742\":5,\"819\":2,\"820\":3,\"891\":1,\"973\":1,\"1173\":2,\"1198\":2,\"1269\":2,\"1273\":2,\"1462\":1,\"1464\":1,\"1471\":1}}],[\"remotingserver\",{\"1\":{\"961\":4,\"1055\":4}}],[\"remotingserializable\",{\"1\":{\"893\":2,\"894\":1,\"950\":1,\"968\":1}}],[\"remoting\",{\"1\":{\"947\":3,\"960\":5,\"961\":2,\"1299\":2,\"1520\":1}}],[\"remoteid=\",{\"1\":{\"1500\":2,\"1503\":2}}],[\"remotebrokeroffset\",{\"1\":{\"1190\":1}}],[\"remotebrokeroffsetstore\",{\"1\":{\"1103\":1,\"1120\":1,\"1122\":1,\"1191\":2,\"1200\":2}}],[\"remoteaddr\",{\"1\":{\"897\":1,\"972\":2,\"995\":1,\"996\":3}}],[\"remoteaddressstrategy\",{\"1\":{\"1000\":3}}],[\"remoteaddressstrategyfactory\",{\"1\":{\"997\":3,\"998\":1}}],[\"remoteaddress\",{\"1\":{\"820\":1,\"1056\":1,\"1173\":4,\"1270\":3}}],[\"remote\",{\"1\":{\"372\":1,\"897\":1,\"947\":1,\"960\":1,\"1000\":1}}],[\"remotefunc\",{\"1\":{\"210\":1}}],[\"reminder\",{\"1\":{\"191\":2}}],[\"rem\",{\"1\":{\"174\":1,\"181\":1,\"187\":1,\"189\":1}}],[\"reach\",{\"1\":{\"722\":1,\"1468\":1}}],[\"reactorgroup\",{\"0\":{\"131\":1},\"1\":{\"131\":5,\"132\":2,\"133\":6,\"134\":4,\"135\":2}}],[\"reactor>\",{\"1\":{\"123\":1,\"133\":1}}],[\"reactor\",{\"0\":{\"107\":1,\"109\":1,\"119\":1,\"121\":1,\"122\":1,\"126\":1,\"127\":1,\"129\":1,\"130\":1,\"132\":1,\"133\":1,\"134\":1,\"135\":1},\"1\":{\"107\":1,\"108\":1,\"109\":1,\"110\":2,\"118\":3,\"119\":4,\"120\":6,\"121\":6,\"122\":1,\"123\":1,\"126\":6,\"127\":7,\"128\":4,\"129\":5,\"130\":6,\"131\":16,\"132\":14,\"133\":9,\"134\":2,\"135\":9,\"136\":2,\"138\":1}}],[\"reason\",{\"1\":{\"196\":1,\"351\":4,\"613\":1,\"624\":2,\"625\":2}}],[\"realtopic\",{\"1\":{\"1371\":2}}],[\"realfilterdata\",{\"1\":{\"1333\":7}}],[\"realaclfilesnum\",{\"1\":{\"999\":9}}],[\"real\",{\"1\":{\"97\":2,\"843\":3,\"845\":2,\"860\":1,\"1352\":2,\"1371\":2,\"1445\":6,\"1462\":2,\"1463\":2,\"1464\":2,\"1468\":2,\"1469\":2}}],[\"readme\",{\"1\":{\"1437\":1}}],[\"readcommitlogfuture\",{\"1\":{\"1432\":2}}],[\"readconsumequeuefuture\",{\"1\":{\"1432\":4}}],[\"readcustomheader\",{\"1\":{\"894\":2,\"995\":1,\"1056\":1,\"1173\":1}}],[\"readasync\",{\"1\":{\"1410\":2,\"1436\":2}}],[\"readaheadcachesizethresholdrate\",{\"1\":{\"1382\":1}}],[\"readaheadcacheexpireduration\",{\"1\":{\"1382\":1}}],[\"readaheadcacheenable\",{\"1\":{\"1382\":1}}],[\"readaheadmessagesizethreshold\",{\"1\":{\"1382\":1}}],[\"readaheadmessagecountthreshold\",{\"1\":{\"1382\":1}}],[\"readable\",{\"1\":{\"1174\":1}}],[\"readgetmessageresult\",{\"1\":{\"1173\":1}}],[\"readoffsettype\",{\"1\":{\"1170\":1}}],[\"readoffset\",{\"1\":{\"1170\":1}}],[\"readonly修饰符\",{\"1\":{\"576\":1}}],[\"readonly<\",{\"1\":{\"528\":1}}],[\"readonly<number\",{\"1\":{\"524\":1}}],[\"readonlyarray<number>\",{\"1\":{\"524\":1}}],[\"readonly\",{\"0\":{\"540\":1},\"1\":{\"524\":1,\"528\":1,\"540\":1,\"552\":3,\"558\":1,\"576\":1}}],[\"readqueuenums\",{\"1\":{\"964\":10,\"968\":2,\"1173\":1}}],[\"readlock\",{\"1\":{\"793\":2,\"794\":2,\"872\":2,\"972\":2,\"1436\":4}}],[\"readline\",{\"1\":{\"69\":1,\"70\":2,\"113\":1,\"114\":1}}],[\"readwritelock\",{\"1\":{\"793\":4,\"794\":2,\"872\":2,\"1435\":2,\"1436\":2}}],[\"readsize\",{\"1\":{\"762\":2}}],[\"readfilesync\",{\"1\":{\"595\":1}}],[\"ready\",{\"1\":{\"1497\":1,\"1499\":1,\"1500\":2,\"1503\":1}}],[\"readystate\",{\"1\":{\"348\":1}}],[\"readyops\",{\"1\":{\"118\":1}}],[\"reading\",{\"1\":{\"124\":2,\"125\":4,\"643\":3,\"645\":1}}],[\"reader的进程字典\",{\"1\":{\"626\":1}}],[\"reader的进程字典中\",{\"1\":{\"624\":1}}],[\"reader来授予信用\",{\"1\":{\"626\":1}}],[\"reader更多的信用值\",{\"1\":{\"626\":1}}],[\"reader新的morecreditafter点信用值\",{\"1\":{\"626\":1}}],[\"reader进程收到bump\",{\"1\":{\"626\":1}}],[\"reader进程中被追踪\",{\"1\":{\"624\":1}}],[\"reader进程中\",{\"1\":{\"624\":1}}],[\"reader进行一次确认\",{\"1\":{\"626\":1}}],[\"reader每接收一个包\",{\"1\":{\"625\":1}}],[\"reader接收消息的入口\",{\"1\":{\"625\":1}}],[\"reader可能会将消息发送给多个进程\",{\"1\":{\"625\":1}}],[\"reader通过credit\",{\"1\":{\"624\":1}}],[\"reader处理一个有内容的命令\",{\"1\":{\"624\":1}}],[\"reader是基于inputstream构造的\",{\"1\":{\"57\":1}}],[\"reader定义了所有字符输入流的超类\",{\"1\":{\"57\":1}}],[\"reader\",{\"0\":{\"57\":1},\"1\":{\"69\":2,\"70\":3,\"113\":2,\"614\":1,\"619\":1,\"621\":6,\"622\":2,\"623\":1,\"624\":3,\"625\":1,\"626\":2}}],[\"read\",{\"1\":{\"53\":3,\"116\":2,\"118\":1,\"124\":4,\"125\":7,\"128\":4,\"130\":1,\"132\":1,\"143\":2,\"171\":3,\"191\":1,\"253\":3,\"880\":1,\"1170\":1,\"1198\":2,\"1269\":1,\"1372\":8,\"1435\":1,\"1468\":1}}],[\"res\",{\"1\":{\"1464\":6}}],[\"resentry\",{\"1\":{\"1516\":6}}],[\"resendcount++\",{\"1\":{\"861\":1}}],[\"resend\",{\"1\":{\"861\":6,\"1050\":1}}],[\"reservetime\",{\"1\":{\"1420\":1}}],[\"reserved\",{\"1\":{\"1371\":1}}],[\"resetbatchappendentryrequest\",{\"1\":{\"1519\":2}}],[\"resetbytebuffer\",{\"1\":{\"737\":4}}],[\"resettransactionvalue\",{\"1\":{\"1463\":1,\"1464\":1}}],[\"resetretryandnamespace\",{\"1\":{\"1195\":1,\"1230\":1}}],[\"resetoffset\",{\"1\":{\"860\":7}}],[\"reset\",{\"1\":{\"253\":1,\"396\":1,\"915\":1,\"960\":1,\"1050\":1,\"1053\":1}}],[\"resetsingletons\",{\"1\":{\"99\":2}}],[\"resolution\",{\"1\":{\"597\":1}}],[\"resolvehalfmsg\",{\"0\":{\"1469\":1},\"1\":{\"1468\":1,\"1469\":1}}],[\"resolvediscardmsg\",{\"1\":{\"1468\":1}}],[\"resolve\",{\"1\":{\"351\":3,\"352\":4,\"353\":4}}],[\"resources\",{\"1\":{\"62\":4,\"104\":1,\"983\":1}}],[\"resource\",{\"0\":{\"83\":1},\"1\":{\"53\":1,\"54\":1,\"57\":1,\"58\":1,\"64\":1,\"1000\":7}}],[\"restnum\",{\"1\":{\"1269\":11,\"1270\":13}}],[\"restoration\",{\"1\":{\"398\":2}}],[\"rest\",{\"0\":{\"309\":1,\"539\":1},\"1\":{\"309\":3,\"331\":2,\"539\":2}}],[\"restart\",{\"1\":{\"165\":1}}],[\"resizing\",{\"1\":{\"886\":1,\"907\":1}}],[\"resize\",{\"1\":{\"153\":1,\"886\":1,\"906\":1}}],[\"resilienceefficienty\",{\"1\":{\"285\":1}}],[\"responses\",{\"1\":{\"1499\":1,\"1502\":3,\"1521\":2}}],[\"responsefuture\",{\"1\":{\"1462\":6,\"1519\":4}}],[\"responseheader\",{\"1\":{\"1056\":2,\"1173\":13,\"1269\":7,\"1462\":2}}],[\"responsecode\",{\"1\":{\"814\":1,\"819\":2,\"973\":2,\"1056\":1,\"1173\":34,\"1198\":10,\"1269\":3,\"1273\":1,\"1462\":2,\"1464\":8,\"1519\":3}}],[\"responsetext\",{\"1\":{\"348\":1}}],[\"response\",{\"1\":{\"125\":2,\"235\":2,\"348\":2,\"349\":1,\"819\":2,\"820\":9,\"973\":8,\"994\":3,\"996\":1,\"1048\":1,\"1056\":10,\"1173\":66,\"1198\":31,\"1269\":5,\"1273\":4,\"1462\":8,\"1464\":10,\"1497\":1,\"1499\":1,\"1516\":5,\"1518\":8,\"1519\":13,\"1520\":9,\"1521\":14}}],[\"resp\",{\"1\":{\"70\":3,\"73\":1,\"349\":2,\"354\":3}}],[\"resultlist\",{\"1\":{\"1436\":3}}],[\"result=\",{\"1\":{\"1431\":1,\"1468\":2,\"1497\":1}}],[\"resultprocess\",{\"1\":{\"860\":2}}],[\"resultsize=\",{\"1\":{\"1431\":1}}],[\"results\",{\"1\":{\"171\":2,\"323\":1,\"330\":4,\"352\":2,\"1436\":1,\"1519\":1}}],[\"result\",{\"1\":{\"11\":2,\"97\":1,\"351\":4,\"353\":2,\"738\":2,\"762\":5,\"769\":3,\"861\":4,\"886\":1,\"895\":1,\"970\":3,\"971\":4,\"1143\":1,\"1145\":1,\"1175\":1,\"1195\":3,\"1266\":1,\"1280\":1,\"1296\":1,\"1297\":4,\"1332\":1,\"1333\":1,\"1339\":1,\"1424\":3,\"1427\":4,\"1428\":3,\"1430\":27,\"1431\":16,\"1432\":34,\"1434\":3,\"1435\":2,\"1436\":24,\"1464\":18,\"1497\":3,\"1503\":11}}],[\"reput\",{\"1\":{\"845\":1,\"911\":1,\"1056\":1,\"1277\":1,\"1323\":1,\"1333\":1,\"1403\":1}}],[\"reputfromoffset\",{\"1\":{\"762\":2}}],[\"reputmessageservice\",{\"0\":{\"762\":1,\"811\":1,\"816\":1,\"826\":1,\"913\":1},\"1\":{\"756\":1,\"812\":1,\"815\":1,\"886\":1,\"913\":1,\"1294\":1}}],[\"repository\",{\"1\":{\"644\":1,\"1072\":1,\"1073\":1}}],[\"report\",{\"1\":{\"43\":1}}],[\"reply\",{\"1\":{\"964\":1}}],[\"replay\",{\"1\":{\"930\":2}}],[\"replaylist\",{\"1\":{\"825\":4}}],[\"replacementvalue\",{\"1\":{\"606\":1}}],[\"replacement\",{\"1\":{\"213\":2}}],[\"replace\",{\"1\":{\"148\":1,\"1056\":1}}],[\"replication\",{\"1\":{\"695\":1,\"1505\":1}}],[\"replicas++\",{\"1\":{\"396\":1}}],[\"replicas\",{\"1\":{\"396\":2}}],[\"replicaindex\",{\"1\":{\"396\":5}}],[\"represent\",{\"1\":{\"396\":1}}],[\"represents\",{\"1\":{\"46\":3}}],[\"repeated\",{\"1\":{\"998\":1,\"1520\":2}}],[\"repeatedly\",{\"1\":{\"765\":2}}],[\"repeat\",{\"1\":{\"147\":1,\"171\":1,\"535\":2,\"1427\":2,\"1503\":1}}],[\"repeatable\",{\"1\":{\"43\":1}}],[\"ret=\",{\"1\":{\"1332\":1}}],[\"ret\",{\"1\":{\"882\":2,\"1332\":6,\"1333\":9,\"1371\":5}}],[\"retrytopicconfig\",{\"1\":{\"1269\":8}}],[\"retrytopic\",{\"1\":{\"1198\":2}}],[\"retrytimeswhensendasyncfailed\",{\"1\":{\"1040\":1}}],[\"retrytimeswhensendfailed\",{\"1\":{\"1040\":1}}],[\"retrytimes\",{\"1\":{\"769\":3,\"1017\":1}}],[\"retrygetandcreateindexfile\",{\"1\":{\"789\":1,\"794\":1}}],[\"retry\",{\"1\":{\"769\":1,\"968\":1,\"983\":1,\"1053\":1,\"1100\":1,\"1142\":1,\"1143\":1,\"1173\":6,\"1175\":1,\"1188\":1,\"1197\":1,\"1198\":4,\"1263\":1,\"1266\":1,\"1269\":1,\"1280\":4,\"1297\":2,\"1374\":2,\"1468\":1,\"1519\":1}}],[\"retentionpolicy\",{\"1\":{\"43\":1}}],[\"retention\",{\"1\":{\"43\":1,\"44\":1}}],[\"returnnull\",{\"1\":{\"1195\":1,\"1230\":1}}],[\"returntype\",{\"1\":{\"1195\":7,\"1230\":7}}],[\"returns\",{\"1\":{\"102\":1,\"1266\":1,\"1462\":1}}],[\"returned\",{\"1\":{\"97\":1}}],[\"return\",{\"0\":{\"101\":1,\"102\":1},\"1\":{\"41\":1,\"89\":1,\"91\":1,\"92\":1,\"101\":1,\"104\":1,\"113\":1,\"125\":5,\"128\":1,\"131\":2,\"261\":1,\"306\":4,\"313\":1,\"316\":1,\"320\":1,\"323\":1,\"324\":1,\"325\":2,\"329\":3,\"330\":5,\"331\":1,\"332\":1,\"338\":2,\"339\":1,\"341\":1,\"342\":1,\"348\":2,\"349\":1,\"354\":1,\"364\":1,\"365\":2,\"385\":1,\"396\":10,\"515\":2,\"537\":1,\"545\":1,\"547\":2,\"548\":1,\"558\":3,\"562\":1,\"566\":1,\"567\":1,\"568\":1,\"580\":1,\"605\":1,\"737\":5,\"738\":3,\"742\":4,\"765\":5,\"767\":1,\"793\":3,\"794\":6,\"796\":1,\"797\":2,\"819\":1,\"845\":4,\"860\":7,\"861\":2,\"870\":3,\"872\":1,\"893\":2,\"894\":1,\"915\":1,\"960\":4,\"961\":1,\"970\":2,\"971\":1,\"973\":2,\"984\":1,\"985\":2,\"995\":1,\"996\":2,\"998\":1,\"1000\":6,\"1007\":1,\"1020\":3,\"1050\":5,\"1051\":2,\"1052\":9,\"1053\":2,\"1056\":5,\"1143\":1,\"1144\":2,\"1170\":9,\"1171\":2,\"1172\":4,\"1173\":17,\"1174\":7,\"1195\":3,\"1197\":3,\"1198\":12,\"1200\":1,\"1222\":2,\"1224\":2,\"1225\":4,\"1226\":3,\"1228\":2,\"1230\":3,\"1235\":1,\"1248\":1,\"1266\":7,\"1267\":2,\"1269\":3,\"1270\":6,\"1271\":1,\"1273\":3,\"1275\":7,\"1276\":10,\"1279\":1,\"1280\":1,\"1288\":1,\"1296\":2,\"1297\":8,\"1328\":7,\"1329\":2,\"1331\":7,\"1332\":2,\"1333\":15,\"1367\":6,\"1368\":9,\"1370\":9,\"1371\":2,\"1372\":9,\"1424\":1,\"1425\":1,\"1427\":12,\"1428\":8,\"1430\":7,\"1431\":6,\"1432\":9,\"1434\":11,\"1435\":9,\"1436\":20,\"1442\":5,\"1443\":1,\"1444\":1,\"1458\":2,\"1459\":2,\"1462\":3,\"1463\":3,\"1464\":7,\"1468\":3,\"1471\":1,\"1496\":1,\"1497\":3,\"1500\":10,\"1502\":2,\"1503\":12,\"1516\":6,\"1517\":2,\"1518\":4,\"1519\":13,\"1520\":16,\"1521\":1}}],[\"rto\",{\"1\":{\"283\":1}}],[\"rtill\",{\"1\":{\"145\":1}}],[\"rt\",{\"1\":{\"23\":1}}],[\"919ce578e6db\",{\"1\":{\"1079\":1}}],[\"9101\",{\"1\":{\"11\":1}}],[\"947\",{\"1\":{\"1074\":1}}],[\"940\",{\"1\":{\"11\":3}}],[\"901\",{\"1\":{\"1074\":1}}],[\"902\",{\"1\":{\"1074\":1}}],[\"90\",{\"1\":{\"866\":1,\"1517\":1}}],[\"9000\",{\"1\":{\"285\":1}}],[\"9m\",{\"1\":{\"833\":1,\"919\":1,\"925\":1,\"1241\":1}}],[\"9e01a24a24d4\",{\"1\":{\"749\":1}}],[\"9eo\",{\"1\":{\"455\":1}}],[\"9x\",{\"1\":{\"436\":1,\"455\":1}}],[\"9tddhphteqpdsze12hyds15fnzdxinsdd7g\",{\"1\":{\"429\":1}}],[\"9c52\",{\"1\":{\"749\":1}}],[\"9c\",{\"1\":{\"399\":1}}],[\"95\",{\"1\":{\"301\":2}}],[\"950\",{\"1\":{\"11\":1}}],[\"93\",{\"1\":{\"285\":1,\"1079\":1}}],[\"938\",{\"1\":{\"11\":1}}],[\"9876\",{\"1\":{\"960\":2,\"984\":1,\"985\":1,\"1008\":1,\"1075\":5,\"1078\":1,\"1079\":5,\"1080\":3,\"1081\":1,\"1235\":2,\"1287\":2,\"1288\":2,\"1441\":1}}],[\"98\",{\"1\":{\"178\":3}}],[\"988\",{\"1\":{\"11\":2}}],[\"9795\",{\"1\":{\"255\":2}}],[\"97的简写\",{\"1\":{\"215\":1}}],[\"97\",{\"1\":{\"178\":3,\"285\":1}}],[\"9767\",{\"1\":{\"11\":1}}],[\"9>\",{\"1\":{\"177\":1,\"181\":1,\"182\":1,\"217\":1,\"255\":1}}],[\"9兼容版本\",{\"1\":{\"25\":1}}],[\"9643\",{\"1\":{\"11\":1}}],[\"9656\",{\"1\":{\"11\":1}}],[\"9\",{\"0\":{\"303\":1,\"360\":1,\"361\":1,\"362\":1,\"364\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"485\":1,\"486\":1,\"518\":1,\"541\":1,\"549\":1,\"550\":1,\"551\":1,\"552\":1,\"553\":1,\"554\":1,\"555\":1,\"556\":2,\"580\":1,\"719\":1,\"849\":1,\"885\":1},\"1\":{\"11\":4,\"25\":1,\"180\":1,\"181\":2,\"182\":2,\"323\":2,\"324\":1,\"325\":2,\"330\":1,\"399\":1,\"421\":1,\"455\":2,\"469\":1,\"583\":1,\"643\":4,\"644\":1,\"711\":1,\"719\":1,\"720\":3,\"737\":2,\"743\":1,\"849\":1,\"850\":1,\"885\":1,\"886\":6,\"889\":2,\"892\":2,\"904\":1,\"913\":1,\"917\":1,\"925\":1,\"932\":1,\"1056\":1,\"1072\":3,\"1073\":2,\"1074\":5,\"1075\":11,\"1078\":1,\"1079\":13,\"1080\":9,\"1083\":1,\"1084\":1,\"1198\":1,\"1284\":1,\"1294\":1,\"1299\":1,\"1307\":1,\"1310\":1,\"1338\":1,\"1538\":3}}],[\"99999999\",{\"1\":{\"1198\":2}}],[\"9999\",{\"1\":{\"906\":1}}],[\"99991231\",{\"1\":{\"137\":1,\"493\":1,\"1523\":1,\"1524\":1,\"1528\":1}}],[\"99\",{\"1\":{\"11\":4,\"67\":3,\"178\":2,\"294\":1,\"1257\":1,\"1445\":3}}],[\"4byte\",{\"1\":{\"1435\":1}}],[\"4b\",{\"1\":{\"1351\":1,\"1352\":5}}],[\"43\",{\"0\":{\"1335\":1},\"1\":{\"1346\":1,\"1347\":1,\"1348\":1,\"1350\":1,\"1353\":1,\"1362\":1,\"1364\":1,\"1375\":2,\"1538\":1}}],[\"433021cbeb23\",{\"1\":{\"1077\":1}}],[\"4s\",{\"1\":{\"1278\":2}}],[\"4kb\",{\"1\":{\"1042\":1,\"1053\":1}}],[\"4k\",{\"1\":{\"917\":1}}],[\"4点\",{\"1\":{\"870\":2}}],[\"4m\",{\"1\":{\"833\":1,\"919\":1,\"925\":1,\"1241\":1,\"1299\":2,\"1403\":2}}],[\"48080\",{\"1\":{\"1078\":2,\"1081\":2}}],[\"48\",{\"1\":{\"1075\":2}}],[\"48sra35t92p03fxyt\",{\"1\":{\"469\":1}}],[\"489\",{\"1\":{\"11\":2}}],[\"4juc0geru74p\",{\"1\":{\"469\":1}}],[\"4jxn6kdhye1bbcfdgmizk\",{\"1\":{\"443\":1}}],[\"4lc\",{\"1\":{\"443\":1}}],[\"47\",{\"1\":{\"436\":1,\"455\":1}}],[\"47451\",{\"1\":{\"11\":1}}],[\"46379\",{\"1\":{\"1079\":2}}],[\"46800\",{\"1\":{\"421\":2}}],[\"46200\",{\"1\":{\"421\":2}}],[\"4c\",{\"1\":{\"399\":1}}],[\"4194304\",{\"1\":{\"1299\":1}}],[\"41\",{\"1\":{\"195\":2,\"230\":1,\"446\":1}}],[\"499\",{\"1\":{\"741\":1}}],[\"49980\",{\"1\":{\"421\":1}}],[\"49000\",{\"1\":{\"421\":4}}],[\"49\",{\"1\":{\"182\":1,\"323\":1,\"1445\":1}}],[\"443\",{\"1\":{\"515\":1}}],[\"446\",{\"1\":{\"405\":1}}],[\"44\",{\"1\":{\"181\":7,\"230\":1}}],[\"449\",{\"1\":{\"11\":1}}],[\"456\",{\"1\":{\"294\":2,\"1287\":1}}],[\"45\",{\"1\":{\"176\":1,\"338\":2,\"1077\":2}}],[\"42b7\",{\"1\":{\"749\":1}}],[\"42000\",{\"1\":{\"421\":4}}],[\"420\",{\"1\":{\"253\":1}}],[\"42\",{\"1\":{\"176\":2}}],[\"4>\",{\"1\":{\"174\":1,\"181\":1,\"185\":1,\"217\":1}}],[\"40d473e300000000000104857600\",{\"1\":{\"1383\":4}}],[\"40+ms\",{\"1\":{\"915\":1}}],[\"4096\",{\"1\":{\"687\":1,\"1074\":6,\"1382\":1,\"1388\":1,\"1403\":1,\"1427\":3}}],[\"400\",{\"1\":{\"420\":1,\"618\":1,\"619\":3,\"621\":1}}],[\"400w\",{\"1\":{\"412\":1}}],[\"4000w\",{\"1\":{\"412\":1}}],[\"40w\",{\"1\":{\"403\":1}}],[\"40\",{\"1\":{\"11\":1,\"217\":4,\"285\":1,\"421\":2,\"922\":1,\"1008\":1}}],[\"4\",{\"0\":{\"35\":1,\"93\":1,\"118\":1,\"123\":1,\"298\":1,\"314\":1,\"321\":1,\"322\":1,\"325\":1,\"326\":1,\"327\":2,\"339\":1,\"340\":1,\"341\":1,\"342\":1,\"343\":1,\"344\":1,\"345\":1,\"359\":1,\"368\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1,\"395\":1,\"396\":1,\"408\":1,\"409\":1,\"410\":1,\"411\":1,\"412\":1,\"413\":1,\"418\":1,\"419\":1,\"420\":1,\"421\":1,\"443\":1,\"444\":1,\"448\":1,\"484\":1,\"505\":1,\"506\":1,\"507\":1,\"508\":1,\"509\":1,\"510\":1,\"511\":1,\"512\":1,\"513\":2,\"514\":1,\"515\":1,\"516\":1,\"517\":1,\"518\":1,\"519\":1,\"520\":1,\"525\":1,\"529\":1,\"536\":1,\"553\":1,\"564\":1,\"567\":1,\"576\":1,\"585\":1,\"594\":1,\"595\":1,\"596\":1,\"601\":1,\"607\":1,\"616\":1,\"623\":1,\"624\":1,\"625\":1,\"626\":1,\"627\":2,\"660\":1,\"661\":1,\"662\":1,\"663\":1,\"664\":1,\"665\":2,\"666\":1,\"667\":1,\"668\":1,\"669\":1,\"670\":1,\"671\":1,\"672\":1,\"673\":1,\"674\":2,\"713\":1,\"714\":1,\"715\":1,\"719\":1,\"723\":1,\"752\":1,\"758\":1,\"760\":1,\"761\":1,\"762\":1,\"763\":1,\"764\":1,\"765\":2,\"766\":1,\"767\":1,\"768\":1,\"769\":1,\"770\":2,\"771\":2,\"783\":1,\"791\":1,\"792\":1,\"793\":1,\"794\":1,\"795\":1,\"796\":2,\"797\":1,\"805\":1,\"817\":1,\"818\":1,\"819\":1,\"820\":1,\"821\":1,\"822\":1,\"823\":1,\"824\":1,\"825\":2,\"826\":1,\"827\":1,\"828\":1,\"842\":1,\"843\":1,\"844\":1,\"845\":1,\"849\":1,\"859\":1,\"860\":1,\"861\":1,\"869\":1,\"870\":1,\"871\":1,\"872\":1,\"881\":1,\"885\":1,\"954\":1,\"958\":1,\"959\":1,\"960\":1,\"961\":1,\"962\":1,\"963\":1,\"968\":1,\"969\":1,\"970\":1,\"971\":1,\"972\":2,\"973\":1,\"992\":1,\"993\":1,\"994\":1,\"995\":1,\"996\":1,\"997\":1,\"998\":1,\"999\":1,\"1000\":1,\"1008\":1,\"1013\":1,\"1014\":1,\"1015\":1,\"1031\":1,\"1032\":1,\"1033\":1,\"1038\":1,\"1039\":1,\"1040\":1,\"1041\":1,\"1042\":2,\"1045\":1,\"1046\":1,\"1047\":1,\"1048\":1,\"1049\":1,\"1050\":1,\"1051\":1,\"1052\":1,\"1053\":2,\"1054\":1,\"1055\":1,\"1056\":1,\"1099\":1,\"1100\":1,\"1101\":1,\"1118\":1,\"1121\":1,\"1122\":1,\"1123\":1,\"1139\":1,\"1140\":1,\"1141\":1,\"1142\":1,\"1143\":1,\"1144\":1,\"1145\":2,\"1146\":1,\"1161\":1,\"1166\":1,\"1167\":1,\"1168\":1,\"1169\":1,\"1170\":1,\"1171\":2,\"1172\":1,\"1173\":1,\"1174\":1,\"1175\":1,\"1192\":1,\"1193\":1,\"1194\":1,\"1195\":1,\"1196\":1,\"1197\":1,\"1198\":1,\"1199\":1,\"1200\":1,\"1201\":1,\"1215\":1,\"1220\":1,\"1221\":1,\"1222\":1,\"1223\":1,\"1224\":1,\"1225\":1,\"1226\":1,\"1227\":1,\"1228\":1,\"1229\":1,\"1230\":1,\"1261\":1,\"1262\":1,\"1263\":1,\"1264\":1,\"1265\":1,\"1266\":1,\"1267\":1,\"1268\":1,\"1269\":1,\"1270\":1,\"1271\":1,\"1272\":1,\"1273\":1,\"1274\":2,\"1275\":2,\"1276\":2,\"1277\":2,\"1278\":3,\"1279\":2,\"1280\":2,\"1295\":1,\"1296\":1,\"1297\":1,\"1320\":1,\"1321\":1,\"1322\":1,\"1323\":1,\"1324\":2,\"1325\":1,\"1326\":1,\"1327\":1,\"1328\":1,\"1329\":1,\"1330\":1,\"1331\":1,\"1332\":1,\"1333\":1,\"1365\":1,\"1366\":1,\"1367\":1,\"1368\":1,\"1369\":1,\"1370\":1,\"1371\":1,\"1372\":1,\"1373\":2,\"1374\":1,\"1388\":1,\"1396\":1,\"1397\":1,\"1398\":1,\"1399\":1,\"1402\":1,\"1403\":1,\"1404\":2,\"1405\":2,\"1406\":2,\"1407\":2,\"1410\":3,\"1411\":1,\"1412\":1,\"1413\":1,\"1416\":1,\"1417\":1,\"1418\":1,\"1419\":1,\"1420\":1,\"1421\":1,\"1433\":1,\"1434\":1,\"1435\":1,\"1436\":1,\"1444\":1,\"1447\":1,\"1448\":1,\"1449\":1,\"1450\":1,\"1451\":1,\"1452\":1,\"1453\":1,\"1454\":1,\"1480\":1,\"1487\":1,\"1493\":1,\"1494\":1,\"1495\":1,\"1496\":1,\"1497\":1,\"1498\":2,\"1499\":2,\"1500\":2,\"1501\":1,\"1502\":1,\"1503\":1,\"1512\":1,\"1513\":1,\"1514\":1,\"1515\":1,\"1516\":1,\"1517\":1,\"1518\":1,\"1519\":1,\"1520\":2,\"1521\":1,\"1534\":1,\"1536\":1},\"1\":{\"11\":4,\"98\":1,\"106\":2,\"118\":3,\"128\":1,\"134\":2,\"172\":1,\"174\":2,\"177\":4,\"180\":1,\"181\":7,\"182\":2,\"184\":3,\"187\":2,\"193\":1,\"194\":2,\"195\":2,\"253\":3,\"261\":1,\"298\":4,\"309\":2,\"316\":2,\"319\":2,\"323\":2,\"325\":1,\"329\":1,\"330\":1,\"348\":1,\"390\":1,\"396\":3,\"400\":4,\"406\":1,\"409\":1,\"411\":1,\"412\":1,\"417\":2,\"419\":2,\"438\":1,\"446\":1,\"469\":1,\"482\":1,\"548\":1,\"556\":2,\"585\":1,\"643\":4,\"644\":1,\"695\":1,\"719\":1,\"720\":1,\"733\":3,\"734\":1,\"737\":2,\"738\":3,\"742\":2,\"743\":1,\"797\":8,\"849\":1,\"850\":1,\"852\":1,\"864\":1,\"866\":4,\"870\":2,\"885\":1,\"886\":6,\"889\":3,\"890\":1,\"892\":3,\"894\":3,\"902\":1,\"906\":1,\"913\":1,\"917\":1,\"922\":1,\"925\":1,\"932\":1,\"944\":2,\"949\":2,\"976\":2,\"978\":2,\"1003\":2,\"1053\":1,\"1055\":1,\"1072\":6,\"1073\":4,\"1074\":11,\"1075\":24,\"1078\":2,\"1079\":26,\"1080\":18,\"1083\":2,\"1084\":2,\"1086\":1,\"1105\":1,\"1136\":2,\"1146\":1,\"1155\":1,\"1165\":1,\"1177\":1,\"1198\":1,\"1203\":1,\"1258\":1,\"1275\":1,\"1278\":1,\"1284\":1,\"1294\":1,\"1299\":1,\"1307\":1,\"1310\":1,\"1325\":1,\"1338\":5,\"1341\":1,\"1342\":2,\"1418\":2,\"1439\":1,\"1440\":1,\"1445\":1,\"1446\":1,\"1462\":1,\"1475\":3,\"1506\":3,\"1507\":2,\"1508\":2,\"1510\":1,\"1516\":1,\"1523\":1,\"1538\":4}}],[\"3s\",{\"1\":{\"1228\":3,\"1233\":1,\"1253\":1,\"1519\":1,\"1521\":1}}],[\"3+\",{\"1\":{\"850\":1}}],[\"3m\",{\"1\":{\"833\":1,\"919\":1,\"925\":1,\"1241\":1}}],[\"310\",{\"1\":{\"742\":1,\"890\":1}}],[\"31200\",{\"1\":{\"421\":2}}],[\"3kb88ajz0\",{\"1\":{\"469\":1}}],[\"3f9bj\",{\"1\":{\"429\":1}}],[\"3f\",{\"1\":{\"423\":1}}],[\"33000\",{\"1\":{\"421\":2}}],[\"3版本\",{\"1\":{\"373\":1}}],[\"3次\",{\"1\":{\"298\":2}}],[\"3458\",{\"1\":{\"850\":1}}],[\"342\",{\"1\":{\"741\":1}}],[\"34222\",{\"1\":{\"11\":1}}],[\"3400\",{\"1\":{\"421\":2}}],[\"34\",{\"1\":{\"272\":1}}],[\"39664283\",{\"1\":{\"646\":1}}],[\"39600\",{\"1\":{\"421\":2}}],[\"39000\",{\"1\":{\"421\":2}}],[\"39\",{\"1\":{\"272\":1}}],[\"3997\",{\"1\":{\"11\":1}}],[\"30919\",{\"1\":{\"1080\":2}}],[\"30911\",{\"1\":{\"1080\":2}}],[\"30921\",{\"1\":{\"1080\":2}}],[\"30929\",{\"1\":{\"1079\":2,\"1080\":2}}],[\"30909\",{\"1\":{\"1080\":2}}],[\"30931\",{\"1\":{\"1079\":2,\"1080\":2}}],[\"30m\",{\"1\":{\"833\":1,\"919\":1,\"925\":1,\"1241\":1}}],[\"30s\",{\"1\":{\"833\":1,\"919\":1,\"925\":1,\"945\":3,\"952\":1,\"955\":1,\"956\":1,\"1039\":1,\"1180\":1,\"1241\":1,\"1388\":1,\"1403\":1,\"1427\":1,\"1453\":1,\"1467\":1}}],[\"300\",{\"1\":{\"405\":1,\"712\":2,\"1519\":1}}],[\"30000\",{\"1\":{\"1170\":1,\"1288\":1}}],[\"3000\",{\"0\":{\"398\":1},\"1\":{\"368\":2,\"369\":2,\"399\":5,\"608\":1,\"1288\":1,\"1472\":1,\"1521\":1}}],[\"30w+\",{\"1\":{\"403\":1}}],[\"30\",{\"1\":{\"265\":1,\"399\":1,\"406\":1,\"419\":1,\"421\":2,\"1030\":2,\"1251\":1,\"1297\":2,\"1406\":1}}],[\"3确定的\",{\"1\":{\"261\":1}}],[\"3e+6\",{\"1\":{\"215\":1}}],[\"3825\",{\"1\":{\"1299\":1}}],[\"38\",{\"1\":{\"195\":1,\"1073\":1}}],[\"389\",{\"1\":{\"11\":3}}],[\"3694\",{\"1\":{\"1284\":1}}],[\"3600w\",{\"1\":{\"927\":2}}],[\"3651\",{\"1\":{\"1299\":1}}],[\"3659\",{\"1\":{\"913\":1}}],[\"3657\",{\"1\":{\"910\":1}}],[\"3619\",{\"1\":{\"907\":1}}],[\"3612\",{\"1\":{\"906\":1}}],[\"3613\",{\"1\":{\"786\":1}}],[\"36\",{\"1\":{\"182\":1,\"323\":1}}],[\"32417620\",{\"1\":{\"1420\":1}}],[\"32byte\",{\"1\":{\"1418\":1,\"1435\":1}}],[\"32k\",{\"1\":{\"1299\":1}}],[\"32条\",{\"1\":{\"1278\":1}}],[\"3201\",{\"1\":{\"1074\":1}}],[\"3286\",{\"1\":{\"852\":1}}],[\"3287\",{\"1\":{\"840\":1,\"850\":1}}],[\"32\",{\"1\":{\"181\":2,\"390\":1,\"431\":1,\"894\":1,\"1170\":1,\"1201\":1,\"1222\":1,\"1288\":1,\"1299\":1,\"1435\":1,\"1445\":6,\"1468\":1}}],[\"3>\",{\"1\":{\"174\":1,\"178\":1,\"180\":1,\"181\":1,\"217\":1}}],[\"37132\",{\"1\":{\"11\":2}}],[\"378\",{\"1\":{\"11\":1}}],[\"372\",{\"1\":{\"11\":1}}],[\"3\",{\"0\":{\"32\":1,\"86\":1,\"114\":1,\"115\":1,\"116\":1,\"117\":1,\"122\":1,\"134\":1,\"296\":1,\"297\":1,\"313\":1,\"317\":1,\"318\":1,\"320\":1,\"326\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":2,\"337\":2,\"338\":2,\"343\":1,\"344\":1,\"345\":1,\"350\":1,\"358\":1,\"365\":1,\"367\":1,\"368\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":2,\"380\":1,\"389\":1,\"390\":1,\"391\":1,\"392\":2,\"393\":2,\"394\":2,\"395\":1,\"402\":1,\"403\":1,\"404\":1,\"405\":1,\"406\":1,\"407\":2,\"413\":1,\"417\":1,\"421\":1,\"436\":1,\"437\":1,\"442\":1,\"481\":1,\"482\":1,\"483\":1,\"495\":1,\"497\":1,\"501\":1,\"502\":1,\"503\":1,\"504\":2,\"510\":1,\"511\":1,\"512\":1,\"524\":1,\"535\":1,\"552\":1,\"562\":1,\"563\":1,\"572\":1,\"573\":1,\"574\":1,\"584\":1,\"593\":1,\"600\":1,\"606\":1,\"615\":1,\"620\":1,\"621\":1,\"622\":1,\"626\":1,\"641\":1,\"646\":1,\"650\":1,\"651\":1,\"652\":1,\"653\":1,\"654\":2,\"655\":1,\"656\":2,\"657\":2,\"658\":2,\"659\":3,\"660\":2,\"661\":1,\"662\":1,\"663\":1,\"664\":2,\"665\":1,\"673\":1,\"689\":1,\"692\":1,\"712\":1,\"716\":1,\"751\":1,\"754\":1,\"755\":1,\"756\":1,\"757\":2,\"758\":1,\"759\":1,\"764\":1,\"768\":1,\"769\":1,\"782\":1,\"784\":1,\"785\":1,\"786\":1,\"787\":1,\"788\":1,\"795\":1,\"804\":1,\"807\":1,\"808\":1,\"809\":1,\"810\":1,\"811\":2,\"812\":1,\"813\":2,\"814\":2,\"815\":2,\"816\":3,\"824\":1,\"826\":1,\"827\":1,\"828\":1,\"835\":1,\"836\":1,\"837\":1,\"838\":2,\"839\":2,\"840\":2,\"841\":3,\"849\":1,\"856\":1,\"857\":1,\"858\":1,\"865\":1,\"866\":1,\"867\":1,\"868\":2,\"872\":1,\"880\":1,\"885\":1,\"946\":1,\"947\":1,\"948\":1,\"949\":1,\"950\":1,\"951\":2,\"952\":2,\"953\":2,\"954\":1,\"955\":1,\"956\":1,\"957\":1,\"969\":1,\"970\":1,\"971\":1,\"982\":1,\"983\":1,\"984\":1,\"985\":2,\"986\":1,\"987\":1,\"988\":1,\"989\":1,\"990\":1,\"991\":2,\"999\":1,\"1000\":1,\"1007\":1,\"1010\":1,\"1011\":1,\"1012\":1,\"1021\":1,\"1030\":1,\"1034\":1,\"1035\":1,\"1036\":1,\"1037\":2,\"1038\":1,\"1039\":1,\"1040\":1,\"1041\":2,\"1042\":1,\"1043\":1,\"1044\":1,\"1052\":1,\"1054\":1,\"1055\":1,\"1056\":1,\"1091\":1,\"1095\":1,\"1096\":1,\"1097\":1,\"1098\":1,\"1104\":1,\"1113\":1,\"1114\":1,\"1115\":1,\"1116\":1,\"1117\":2,\"1118\":1,\"1119\":1,\"1120\":1,\"1124\":1,\"1130\":1,\"1131\":1,\"1132\":1,\"1133\":1,\"1134\":1,\"1135\":1,\"1136\":1,\"1137\":1,\"1138\":2,\"1144\":1,\"1153\":1,\"1154\":1,\"1155\":1,\"1156\":1,\"1157\":1,\"1158\":1,\"1159\":1,\"1160\":2,\"1161\":1,\"1162\":1,\"1163\":1,\"1164\":1,\"1165\":2,\"1170\":1,\"1181\":1,\"1182\":1,\"1183\":1,\"1184\":2,\"1185\":1,\"1186\":1,\"1187\":1,\"1188\":1,\"1189\":1,\"1190\":1,\"1191\":1,\"1199\":1,\"1200\":1,\"1201\":1,\"1210\":1,\"1211\":1,\"1212\":1,\"1213\":1,\"1214\":2,\"1215\":1,\"1216\":1,\"1217\":1,\"1218\":1,\"1219\":2,\"1226\":1,\"1230\":1,\"1249\":1,\"1253\":1,\"1254\":1,\"1255\":1,\"1256\":1,\"1257\":1,\"1258\":1,\"1259\":2,\"1260\":2,\"1261\":1,\"1262\":1,\"1263\":1,\"1271\":1,\"1272\":1,\"1273\":1,\"1277\":1,\"1288\":1,\"1292\":1,\"1293\":1,\"1294\":1,\"1316\":1,\"1317\":1,\"1318\":1,\"1319\":2,\"1320\":1,\"1321\":1,\"1322\":1,\"1323\":2,\"1324\":1,\"1325\":1,\"1333\":1,\"1344\":1,\"1348\":1,\"1349\":1,\"1350\":1,\"1351\":1,\"1352\":1,\"1353\":1,\"1354\":1,\"1357\":1,\"1361\":2,\"1362\":2,\"1363\":2,\"1364\":3,\"1372\":1,\"1380\":1,\"1384\":1,\"1385\":1,\"1386\":1,\"1387\":2,\"1388\":1,\"1389\":1,\"1390\":1,\"1391\":1,\"1392\":1,\"1393\":1,\"1394\":1,\"1395\":1,\"1403\":1,\"1407\":1,\"1416\":1,\"1417\":1,\"1418\":1,\"1429\":1,\"1430\":1,\"1431\":1,\"1432\":2,\"1436\":1,\"1443\":1,\"1446\":1,\"1451\":1,\"1479\":1,\"1481\":1,\"1482\":1,\"1483\":1,\"1484\":1,\"1485\":1,\"1486\":2,\"1487\":1,\"1490\":1,\"1496\":1,\"1497\":1,\"1508\":1,\"1509\":1,\"1510\":1,\"1511\":2,\"1512\":1,\"1518\":1,\"1519\":1,\"1533\":1,\"1535\":1},\"1\":{\"11\":4,\"65\":4,\"106\":2,\"118\":1,\"125\":1,\"128\":1,\"155\":2,\"172\":1,\"174\":3,\"177\":8,\"178\":2,\"180\":2,\"181\":5,\"182\":1,\"184\":2,\"187\":1,\"192\":7,\"193\":1,\"194\":2,\"195\":3,\"215\":1,\"230\":1,\"248\":6,\"253\":4,\"261\":1,\"284\":1,\"285\":1,\"294\":3,\"298\":12,\"302\":2,\"303\":1,\"309\":2,\"319\":2,\"323\":1,\"324\":1,\"329\":1,\"330\":1,\"331\":1,\"332\":2,\"338\":2,\"372\":1,\"373\":1,\"387\":1,\"388\":1,\"400\":2,\"401\":4,\"405\":1,\"416\":1,\"417\":1,\"425\":1,\"438\":1,\"446\":1,\"490\":2,\"522\":2,\"524\":1,\"525\":1,\"529\":1,\"556\":2,\"585\":1,\"587\":1,\"593\":1,\"614\":1,\"617\":1,\"624\":1,\"628\":3,\"637\":1,\"638\":1,\"641\":2,\"642\":2,\"643\":4,\"644\":1,\"645\":6,\"648\":2,\"652\":1,\"653\":1,\"654\":1,\"662\":2,\"675\":1,\"692\":2,\"695\":1,\"703\":1,\"711\":4,\"712\":1,\"716\":1,\"718\":2,\"724\":2,\"733\":1,\"737\":2,\"771\":1,\"849\":1,\"850\":2,\"853\":1,\"854\":1,\"860\":1,\"870\":2,\"885\":1,\"886\":3,\"889\":1,\"892\":1,\"913\":1,\"917\":1,\"924\":1,\"925\":3,\"932\":1,\"942\":1,\"944\":1,\"960\":1,\"1025\":1,\"1027\":1,\"1035\":1,\"1053\":1,\"1056\":1,\"1074\":1,\"1079\":3,\"1124\":1,\"1136\":1,\"1147\":1,\"1149\":1,\"1156\":1,\"1197\":2,\"1198\":2,\"1240\":1,\"1248\":1,\"1258\":1,\"1273\":1,\"1278\":1,\"1284\":1,\"1299\":1,\"1310\":1,\"1338\":1,\"1339\":1,\"1343\":2,\"1370\":1,\"1371\":2,\"1373\":1,\"1382\":1,\"1383\":1,\"1387\":1,\"1388\":1,\"1414\":1,\"1434\":2,\"1439\":2,\"1442\":3,\"1445\":5,\"1468\":2,\"1477\":2,\"1481\":1,\"1484\":1,\"1488\":1,\"1495\":1,\"1508\":1,\"1516\":3,\"1519\":3,\"1520\":1,\"1538\":3}}],[\"3594\",{\"1\":{\"904\":1}}],[\"3591\",{\"1\":{\"901\":1}}],[\"3590\",{\"1\":{\"898\":1}}],[\"3589\",{\"1\":{\"895\":1}}],[\"3588\",{\"1\":{\"889\":1,\"892\":1}}],[\"3586\",{\"1\":{\"888\":1}}],[\"3585\",{\"1\":{\"886\":1}}],[\"35000\",{\"1\":{\"421\":4}}],[\"35<\",{\"1\":{\"8\":2}}],[\"35\",{\"1\":{\"8\":1,\"11\":1,\"401\":1}}],[\"2~4\",{\"1\":{\"1507\":1}}],[\"2取余\",{\"1\":{\"1367\":1}}],[\"2l\",{\"1\":{\"1277\":1}}],[\"2s\",{\"1\":{\"1263\":1,\"1278\":2,\"1477\":1,\"1485\":1,\"1496\":1}}],[\"2g\",{\"1\":{\"927\":2,\"1080\":1}}],[\"2h\",{\"1\":{\"833\":1,\"919\":1,\"925\":1,\"1241\":1}}],[\"2m\",{\"1\":{\"833\":1,\"919\":1,\"925\":1,\"1241\":1}}],[\"2+1\",{\"1\":{\"662\":1}}],[\"2f\",{\"1\":{\"654\":1}}],[\"2方法获取并更新进程字典的值\",{\"1\":{\"624\":1}}],[\"2方法后才会进入到rabbit\",{\"1\":{\"624\":1}}],[\"2和credit\",{\"1\":{\"624\":1}}],[\"2戒指2\",{\"1\":{\"480\":1}}],[\"2ro7pok1a5ttqz0vpuqnvbphj5vbibvh972xguqhzrj6vkct\",{\"1\":{\"436\":1}}],[\"2kuqzaszvphjbwo8gjnniodyrsjozkr4dtigprcjgvgovhnlzapkuub7wpzrkq8dyscghan1fubwupauqmaqcjgy\",{\"1\":{\"429\":1}}],[\"2v0ucbz38agvlx0c4wixfniknyixemal\",{\"1\":{\"423\":1}}],[\"2ioxwks\",{\"1\":{\"423\":1}}],[\"2^32\",{\"1\":{\"387\":1}}],[\"2d7e3458acp35v\",{\"1\":{\"381\":1}}],[\"24h\",{\"1\":{\"1427\":1}}],[\"2453\",{\"1\":{\"852\":1}}],[\"2456\",{\"1\":{\"253\":1}}],[\"24\",{\"1\":{\"525\":1,\"1074\":13,\"1382\":1}}],[\"24>\",{\"1\":{\"178\":1,\"181\":1}}],[\"26656\",{\"1\":{\"421\":1}}],[\"26400\",{\"1\":{\"421\":3,\"476\":1}}],[\"26\",{\"1\":{\"285\":1,\"773\":1,\"1074\":1}}],[\"262144\",{\"1\":{\"231\":1}}],[\"263334\",{\"1\":{\"11\":1}}],[\"27t15\",{\"1\":{\"1079\":7}}],[\"276\",{\"1\":{\"741\":1}}],[\"27\",{\"1\":{\"215\":1,\"645\":7}}],[\"278\",{\"1\":{\"11\":1}}],[\"2354\",{\"1\":{\"1074\":1}}],[\"23400\",{\"1\":{\"421\":1}}],[\"2345x1000\",{\"1\":{\"294\":1}}],[\"2345e3\",{\"1\":{\"294\":1}}],[\"23\",{\"1\":{\"195\":1,\"215\":1,\"253\":1,\"525\":1,\"1074\":11}}],[\"23>\",{\"1\":{\"178\":1,\"181\":1}}],[\"2500\",{\"1\":{\"1403\":1}}],[\"250\",{\"1\":{\"253\":4}}],[\"256\",{\"1\":{\"192\":1,\"390\":2}}],[\"25\",{\"1\":{\"182\":1,\"185\":1,\"323\":1,\"403\":1,\"525\":1,\"1073\":1,\"1074\":1}}],[\"2550\",{\"1\":{\"421\":2}}],[\"255\",{\"1\":{\"67\":5,\"1079\":3}}],[\"2>\",{\"1\":{\"173\":1,\"174\":1,\"180\":1,\"181\":1,\"184\":1,\"217\":1,\"224\":1,\"248\":1,\"252\":1}}],[\"2278↩︎\",{\"1\":{\"1504\":1,\"1522\":1}}],[\"2271\",{\"1\":{\"1074\":1}}],[\"2290\",{\"1\":{\"848\":1}}],[\"2257\",{\"1\":{\"741\":1}}],[\"221bf0008↩︎\",{\"1\":{\"286\":1}}],[\"221e\",{\"1\":{\"178\":2}}],[\"22>\",{\"1\":{\"178\":1,\"181\":1}}],[\"22\",{\"0\":{\"94\":1,\"642\":1},\"1\":{\"185\":1,\"642\":1,\"643\":5,\"644\":1,\"1073\":1}}],[\"218965349z\",{\"1\":{\"1079\":1}}],[\"218960481z\",{\"1\":{\"1079\":1}}],[\"218953791z\",{\"1\":{\"1079\":1}}],[\"218891884z\",{\"1\":{\"1079\":1}}],[\"218887204z\",{\"1\":{\"1079\":1}}],[\"218878131z\",{\"1\":{\"1079\":1}}],[\"218761998z\",{\"1\":{\"1079\":1}}],[\"21000\",{\"1\":{\"421\":2}}],[\"212d6b50\",{\"1\":{\"1383\":1}}],[\"212\",{\"1\":{\"181\":2}}],[\"21\",{\"0\":{\"79\":1,\"80\":1,\"85\":1,\"86\":1,\"93\":1},\"1\":{\"552\":1,\"642\":1}}],[\"21131\",{\"1\":{\"11\":1}}],[\"28byte<\",{\"1\":{\"1435\":1}}],[\"28byte\",{\"1\":{\"1418\":1}}],[\"2883\",{\"1\":{\"720\":1}}],[\"28\",{\"0\":{\"1282\":1},\"1\":{\"692\":1,\"720\":1,\"1325\":1,\"1538\":1}}],[\"28000\",{\"1\":{\"421\":4}}],[\"28290\",{\"1\":{\"11\":2}}],[\"28116\",{\"1\":{\"11\":1}}],[\"29749\",{\"1\":{\"11\":1}}],[\"2\",{\"0\":{\"17\":1,\"18\":1,\"26\":2,\"85\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":2,\"114\":1,\"117\":1,\"121\":1,\"129\":1,\"133\":1,\"293\":1,\"294\":1,\"295\":2,\"296\":1,\"302\":1,\"304\":1,\"305\":1,\"306\":1,\"307\":2,\"310\":2,\"311\":2,\"312\":3,\"313\":2,\"314\":2,\"315\":2,\"316\":2,\"317\":1,\"318\":1,\"320\":2,\"321\":1,\"322\":1,\"325\":2,\"326\":1,\"327\":1,\"328\":1,\"329\":1,\"330\":2,\"331\":1,\"332\":1,\"335\":1,\"338\":1,\"341\":1,\"342\":1,\"345\":1,\"349\":1,\"353\":1,\"357\":1,\"364\":1,\"366\":1,\"372\":1,\"375\":1,\"379\":1,\"386\":1,\"387\":1,\"388\":2,\"391\":1,\"394\":1,\"401\":1,\"404\":1,\"405\":1,\"406\":2,\"407\":1,\"410\":1,\"411\":1,\"412\":2,\"416\":1,\"420\":1,\"428\":1,\"429\":1,\"430\":1,\"435\":2,\"442\":1,\"448\":1,\"454\":1,\"461\":1,\"468\":1,\"475\":1,\"480\":1,\"483\":1,\"490\":1,\"496\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"503\":1,\"507\":1,\"508\":1,\"509\":2,\"512\":1,\"523\":1,\"528\":1,\"534\":1,\"551\":1,\"559\":1,\"560\":1,\"561\":2,\"562\":1,\"569\":1,\"570\":1,\"571\":2,\"574\":1,\"583\":1,\"592\":1,\"596\":1,\"599\":1,\"612\":1,\"613\":1,\"614\":2,\"615\":1,\"616\":1,\"617\":1,\"618\":1,\"619\":2,\"622\":1,\"625\":1,\"644\":1,\"645\":1,\"649\":1,\"653\":1,\"655\":1,\"658\":1,\"663\":1,\"669\":1,\"670\":1,\"671\":1,\"672\":2,\"673\":1,\"674\":1,\"678\":2,\"682\":1,\"683\":1,\"684\":1,\"685\":2,\"686\":2,\"687\":2,\"688\":3,\"689\":1,\"708\":1,\"709\":1,\"710\":1,\"711\":2,\"712\":1,\"713\":1,\"714\":1,\"715\":2,\"723\":1,\"747\":1,\"748\":1,\"749\":1,\"750\":2,\"751\":1,\"752\":1,\"753\":1,\"756\":1,\"763\":1,\"766\":1,\"767\":1,\"778\":1,\"779\":1,\"780\":1,\"781\":2,\"782\":1,\"783\":1,\"787\":1,\"788\":1,\"794\":1,\"797\":1,\"802\":1,\"803\":1,\"806\":1,\"810\":1,\"812\":1,\"815\":1,\"820\":1,\"821\":1,\"822\":1,\"823\":2,\"824\":1,\"825\":1,\"828\":1,\"833\":1,\"834\":1,\"837\":1,\"840\":1,\"844\":1,\"845\":1,\"848\":1,\"851\":1,\"852\":1,\"853\":2,\"854\":2,\"855\":3,\"858\":1,\"861\":1,\"864\":1,\"867\":1,\"871\":1,\"878\":1,\"879\":1,\"892\":1,\"916\":1,\"942\":1,\"943\":1,\"944\":1,\"945\":2,\"948\":1,\"949\":1,\"950\":2,\"953\":1,\"957\":1,\"961\":1,\"962\":1,\"963\":1,\"968\":2,\"971\":1,\"977\":1,\"978\":1,\"979\":2,\"980\":2,\"981\":3,\"982\":1,\"983\":1,\"984\":2,\"985\":1,\"989\":1,\"990\":1,\"995\":1,\"996\":1,\"997\":1,\"998\":2,\"999\":1,\"1004\":1,\"1005\":1,\"1006\":2,\"1007\":1,\"1008\":1,\"1009\":1,\"1012\":1,\"1015\":1,\"1018\":1,\"1019\":1,\"1020\":2,\"1025\":1,\"1026\":1,\"1027\":1,\"1028\":2,\"1029\":2,\"1030\":1,\"1031\":1,\"1032\":1,\"1033\":2,\"1036\":1,\"1040\":1,\"1048\":1,\"1049\":1,\"1050\":1,\"1051\":2,\"1052\":1,\"1053\":1,\"1056\":1,\"1087\":1,\"1088\":1,\"1089\":1,\"1090\":2,\"1091\":1,\"1092\":2,\"1093\":2,\"1094\":3,\"1095\":2,\"1096\":1,\"1097\":1,\"1098\":2,\"1099\":1,\"1100\":1,\"1101\":2,\"1102\":1,\"1103\":1,\"1106\":1,\"1108\":1,\"1109\":1,\"1110\":2,\"1111\":2,\"1112\":3,\"1116\":1,\"1120\":1,\"1123\":1,\"1127\":1,\"1128\":1,\"1129\":2,\"1130\":1,\"1134\":1,\"1135\":1,\"1136\":1,\"1137\":2,\"1141\":1,\"1142\":1,\"1143\":2,\"1144\":1,\"1145\":1,\"1148\":1,\"1149\":1,\"1150\":2,\"1151\":2,\"1152\":3,\"1153\":1,\"1156\":1,\"1157\":1,\"1158\":1,\"1159\":2,\"1160\":1,\"1161\":1,\"1162\":2,\"1163\":2,\"1164\":3,\"1165\":1,\"1169\":1,\"1178\":1,\"1179\":1,\"1180\":2,\"1181\":1,\"1182\":1,\"1183\":2,\"1184\":1,\"1188\":1,\"1189\":1,\"1190\":1,\"1191\":2,\"1195\":1,\"1196\":1,\"1197\":1,\"1198\":2,\"1201\":1,\"1204\":1,\"1205\":1,\"1206\":1,\"1207\":2,\"1208\":2,\"1209\":2,\"1213\":1,\"1216\":1,\"1217\":1,\"1218\":2,\"1223\":1,\"1224\":1,\"1225\":2,\"1226\":1,\"1227\":1,\"1228\":1,\"1229\":2,\"1246\":1,\"1247\":1,\"1248\":2,\"1250\":1,\"1251\":1,\"1252\":2,\"1253\":1,\"1256\":1,\"1257\":1,\"1258\":2,\"1259\":1,\"1263\":1,\"1267\":1,\"1268\":1,\"1269\":1,\"1270\":2,\"1271\":1,\"1276\":1,\"1285\":1,\"1286\":1,\"1287\":2,\"1288\":1,\"1289\":1,\"1290\":1,\"1291\":1,\"1294\":1,\"1297\":1,\"1304\":1,\"1305\":1,\"1308\":2,\"1311\":1,\"1312\":1,\"1313\":2,\"1314\":2,\"1315\":3,\"1318\":1,\"1322\":1,\"1329\":1,\"1330\":1,\"1331\":1,\"1332\":2,\"1333\":1,\"1338\":1,\"1339\":1,\"1340\":1,\"1341\":1,\"1342\":1,\"1343\":2,\"1344\":1,\"1345\":2,\"1346\":2,\"1347\":3,\"1348\":2,\"1352\":1,\"1353\":1,\"1354\":1,\"1357\":2,\"1363\":1,\"1368\":1,\"1369\":1,\"1370\":1,\"1371\":2,\"1372\":1,\"1373\":1,\"1374\":1,\"1379\":1,\"1381\":1,\"1382\":1,\"1383\":2,\"1386\":1,\"1391\":1,\"1394\":1,\"1399\":1,\"1402\":1,\"1406\":1,\"1413\":1,\"1418\":1,\"1421\":1,\"1425\":1,\"1426\":1,\"1427\":1,\"1428\":2,\"1431\":1,\"1435\":1,\"1440\":1,\"1441\":1,\"1442\":2,\"1443\":1,\"1444\":1,\"1445\":1,\"1450\":1,\"1452\":1,\"1453\":1,\"1454\":2,\"1461\":1,\"1465\":1,\"1466\":1,\"1470\":2,\"1476\":1,\"1477\":1,\"1478\":2,\"1479\":1,\"1480\":1,\"1483\":1,\"1484\":1,\"1485\":2,\"1486\":1,\"1487\":1,\"1490\":1,\"1495\":1,\"1500\":1,\"1503\":1,\"1507\":1,\"1510\":1,\"1515\":1,\"1516\":1,\"1517\":2,\"1518\":1,\"1530\":1,\"1531\":1,\"1532\":2,\"1533\":1,\"1534\":1},\"1\":{\"11\":4,\"64\":1,\"67\":2,\"92\":2,\"106\":6,\"124\":1,\"155\":2,\"167\":1,\"172\":1,\"174\":5,\"178\":2,\"181\":10,\"182\":2,\"184\":4,\"187\":3,\"189\":1,\"192\":6,\"193\":1,\"194\":2,\"195\":2,\"215\":2,\"230\":3,\"248\":6,\"253\":11,\"256\":1,\"261\":1,\"294\":3,\"298\":20,\"302\":2,\"303\":1,\"309\":2,\"323\":1,\"325\":2,\"329\":1,\"330\":2,\"332\":2,\"338\":2,\"339\":2,\"351\":1,\"381\":1,\"399\":1,\"401\":5,\"409\":1,\"411\":1,\"417\":2,\"433\":1,\"438\":2,\"446\":1,\"455\":1,\"479\":2,\"480\":1,\"484\":1,\"485\":1,\"490\":7,\"511\":1,\"512\":1,\"522\":2,\"524\":1,\"525\":1,\"527\":1,\"529\":1,\"582\":2,\"584\":2,\"593\":1,\"637\":1,\"638\":1,\"643\":1,\"655\":1,\"657\":1,\"662\":1,\"687\":1,\"693\":1,\"695\":1,\"717\":1,\"724\":2,\"725\":1,\"733\":1,\"737\":2,\"741\":7,\"769\":1,\"823\":1,\"866\":2,\"870\":1,\"881\":1,\"886\":2,\"906\":1,\"922\":1,\"947\":1,\"960\":1,\"961\":1,\"967\":1,\"978\":2,\"1032\":1,\"1040\":1,\"1048\":2,\"1053\":1,\"1056\":1,\"1074\":2,\"1075\":1,\"1079\":2,\"1106\":1,\"1136\":1,\"1147\":1,\"1180\":1,\"1203\":2,\"1233\":1,\"1235\":4,\"1246\":1,\"1255\":2,\"1325\":2,\"1338\":1,\"1346\":2,\"1347\":2,\"1360\":1,\"1367\":1,\"1371\":2,\"1372\":1,\"1374\":1,\"1383\":1,\"1420\":2,\"1442\":1,\"1443\":1,\"1445\":1,\"1464\":1,\"1468\":1,\"1475\":1,\"1495\":2,\"1506\":1,\"1516\":3,\"1517\":1,\"1519\":2,\"1520\":1,\"1521\":1,\"1538\":1}}],[\"2048\",{\"1\":{\"1021\":1}}],[\"20400\",{\"1\":{\"421\":2}}],[\"20m\",{\"1\":{\"833\":1,\"919\":1,\"925\":1,\"1241\":1,\"1519\":1}}],[\"20s\",{\"1\":{\"812\":1,\"1098\":1,\"1104\":1,\"1128\":1,\"1136\":5,\"1140\":2,\"1209\":1,\"1215\":1,\"1388\":1,\"1403\":2}}],[\"206\",{\"1\":{\"742\":1,\"890\":1}}],[\"20w\",{\"1\":{\"401\":1,\"403\":1,\"910\":2,\"913\":2,\"915\":1}}],[\"20181109221800\",{\"1\":{\"1007\":1}}],[\"2010\",{\"1\":{\"399\":1}}],[\"2017\",{\"1\":{\"316\":2}}],[\"2019\",{\"1\":{\"692\":1}}],[\"2019年随着该兴趣组并入app\",{\"1\":{\"276\":1}}],[\"20191229\",{\"1\":{\"139\":1}}],[\"20>\",{\"1\":{\"178\":1}}],[\"20行\",{\"1\":{\"150\":1}}],[\"20表示10\",{\"1\":{\"150\":1}}],[\"20250315\",{\"1\":{\"1505\":1}}],[\"20250204\",{\"1\":{\"1474\":1}}],[\"20250131\",{\"1\":{\"1438\":1}}],[\"2021\",{\"1\":{\"1008\":1}}],[\"20211209174133951\",{\"1\":{\"787\":1}}],[\"20240429\",{\"1\":{\"1376\":1}}],[\"20240828014319420\",{\"1\":{\"135\":1}}],[\"20240827\",{\"1\":{\"107\":1}}],[\"20241209220115906\",{\"1\":{\"400\":1}}],[\"20241214153644775\",{\"1\":{\"483\":1}}],[\"20241214153517135\",{\"1\":{\"483\":1}}],[\"20241214153427138\",{\"1\":{\"483\":1}}],[\"20241214153106815\",{\"1\":{\"482\":1}}],[\"20241215033648476\",{\"1\":{\"485\":1}}],[\"20241215033615401\",{\"1\":{\"485\":1}}],[\"20241215033448338\",{\"1\":{\"485\":1}}],[\"20241215033429691\",{\"1\":{\"485\":1}}],[\"20241215033513748\",{\"1\":{\"485\":1}}],[\"20241215033019166\",{\"1\":{\"485\":1}}],[\"20241215032805951\",{\"1\":{\"485\":1}}],[\"20241215032835974\",{\"1\":{\"485\":1}}],[\"20241215032910709\",{\"1\":{\"485\":1}}],[\"20241215032522331\",{\"1\":{\"485\":1}}],[\"20241215032600780\",{\"1\":{\"485\":1}}],[\"20241215024445134\",{\"1\":{\"484\":1}}],[\"20241215024207452\",{\"1\":{\"482\":1}}],[\"20241215135141478\",{\"1\":{\"485\":1}}],[\"20241215135123397\",{\"1\":{\"485\":1}}],[\"20241215135111155\",{\"1\":{\"485\":1}}],[\"20241215184719630\",{\"1\":{\"473\":1}}],[\"20241215182827848\",{\"1\":{\"471\":1}}],[\"20241215182415039\",{\"1\":{\"468\":1}}],[\"20241215181441353\",{\"1\":{\"468\":1}}],[\"20241215181344130\",{\"1\":{\"468\":1}}],[\"20241215181308589\",{\"1\":{\"468\":1}}],[\"20241215180833859\",{\"1\":{\"466\":1}}],[\"20241215180459593\",{\"1\":{\"465\":1}}],[\"20241215175539840\",{\"1\":{\"461\":1}}],[\"20241215175101355\",{\"1\":{\"461\":1}}],[\"20241215174851075\",{\"1\":{\"461\":1}}],[\"20241215174720831\",{\"1\":{\"460\":1}}],[\"20241215174529495\",{\"1\":{\"459\":1}}],[\"20241215174519187\",{\"1\":{\"459\":1}}],[\"20241215174110519\",{\"1\":{\"458\":1}}],[\"20241215173748900\",{\"1\":{\"457\":1}}],[\"20241215172150767\",{\"1\":{\"454\":1}}],[\"20241215172052368\",{\"1\":{\"454\":1}}],[\"20241215171954964\",{\"1\":{\"454\":1}}],[\"20241215171902081\",{\"1\":{\"454\":1}}],[\"20241215171822169\",{\"1\":{\"454\":1}}],[\"20241215171651887\",{\"1\":{\"454\":1}}],[\"20241215171438636\",{\"1\":{\"454\":1}}],[\"20241215171103409\",{\"1\":{\"454\":1}}],[\"20241215171153903\",{\"1\":{\"453\":1}}],[\"20241215171033646\",{\"1\":{\"454\":1}}],[\"20241215171206523\",{\"1\":{\"453\":1}}],[\"20241215151908021\",{\"1\":{\"436\":1}}],[\"20241215145423899\",{\"1\":{\"434\":1}}],[\"20241215143844442\",{\"1\":{\"429\":1}}],[\"20241215142157323\",{\"1\":{\"423\":1}}],[\"20241215191110658\",{\"1\":{\"475\":1}}],[\"20241215190934135\",{\"1\":{\"475\":1}}],[\"20241215190652972\",{\"1\":{\"475\":1}}],[\"20241215190614750\",{\"1\":{\"475\":1}}],[\"20241215190201000\",{\"1\":{\"475\":1}}],[\"20241215195222819\",{\"1\":{\"469\":1}}],[\"20241215195105012\",{\"1\":{\"462\":1}}],[\"20241215194427722\",{\"1\":{\"455\":1}}],[\"20241215194155393\",{\"1\":{\"449\":1}}],[\"20241215194805833\",{\"1\":{\"443\":1}}],[\"20241215193734907\",{\"1\":{\"455\":1}}],[\"20241215193433070\",{\"1\":{\"443\":1}}],[\"20241215193023688\",{\"1\":{\"428\":1}}],[\"20241215193008536\",{\"1\":{\"428\":1}}],[\"20241215192957117\",{\"1\":{\"428\":1}}],[\"20241215192916809\",{\"1\":{\"428\":1}}],[\"20241215192900593\",{\"1\":{\"427\":1}}],[\"20241215192830671\",{\"1\":{\"426\":1}}],[\"20241215192807338\",{\"1\":{\"425\":1}}],[\"20241215192750663\",{\"1\":{\"425\":1}}],[\"20241215205111368\",{\"1\":{\"448\":1}}],[\"20241215204933153\",{\"1\":{\"448\":1}}],[\"20241215204917425\",{\"1\":{\"448\":1}}],[\"20241215204904785\",{\"1\":{\"448\":1}}],[\"20241215204348230\",{\"1\":{\"447\":1}}],[\"20241215204245794\",{\"1\":{\"446\":1}}],[\"20241215204238526\",{\"1\":{\"446\":1}}],[\"20241215204059731\",{\"1\":{\"442\":1}}],[\"20241215204041404\",{\"1\":{\"442\":1}}],[\"20241215204022624\",{\"1\":{\"442\":1}}],[\"20241215204004565\",{\"1\":{\"442\":1}}],[\"20241215203939693\",{\"1\":{\"441\":1}}],[\"20241215203926333\",{\"1\":{\"441\":1}}],[\"20241215203859038\",{\"1\":{\"440\":1}}],[\"20241215203347297\",{\"1\":{\"439\":1}}],[\"20241215202938679\",{\"1\":{\"438\":1}}],[\"20241215202136495\",{\"1\":{\"438\":1}}],[\"20241215201912795\",{\"1\":{\"435\":1}}],[\"20241215201847343\",{\"1\":{\"435\":1}}],[\"20241215201829968\",{\"1\":{\"435\":1}}],[\"20241215201816500\",{\"1\":{\"435\":1}}],[\"20241215201726940\",{\"1\":{\"434\":1}}],[\"20241215201702659\",{\"1\":{\"433\":1}}],[\"20241215201457283\",{\"1\":{\"432\":1}}],[\"20241215201449103\",{\"1\":{\"432\":1}}],[\"20241215201426626\",{\"1\":{\"431\":1}}],[\"20241215201348939\",{\"1\":{\"431\":1}}],[\"20241215215356412\",{\"1\":{\"400\":1}}],[\"20241215225813833\",{\"1\":{\"399\":1}}],[\"20241210011543913\",{\"1\":{\"402\":1}}],[\"20241216002026405\",{\"1\":{\"455\":1}}],[\"20241216005240125\",{\"1\":{\"407\":1}}],[\"20241216230343443\",{\"1\":{\"403\":1}}],[\"20241216225919351\",{\"1\":{\"403\":1}}],[\"20241216225228495\",{\"1\":{\"403\":1}}],[\"20241216\",{\"1\":{\"398\":1}}],[\"20231012005513363\",{\"1\":{\"711\":1}}],[\"20231012005439516\",{\"1\":{\"711\":1}}],[\"20231012005239630\",{\"1\":{\"711\":1}}],[\"20231012004951406\",{\"1\":{\"711\":1}}],[\"20231012004854125\",{\"1\":{\"711\":1}}],[\"20231016\",{\"1\":{\"705\":1}}],[\"20231015\",{\"1\":{\"382\":1}}],[\"20230703004414898\",{\"1\":{\"1321\":1}}],[\"20230702220114234\",{\"1\":{\"1318\":1}}],[\"20230716\",{\"1\":{\"1301\":1}}],[\"20230808\",{\"1\":{\"1335\":1}}],[\"20230808222542658\",{\"1\":{\"375\":1}}],[\"20230820173150917\",{\"1\":{\"378\":1}}],[\"20230820172907951\",{\"1\":{\"378\":1}}],[\"20230820175906698\",{\"1\":{\"376\":1}}],[\"20230820\",{\"1\":{\"370\":1}}],[\"20230812213755060\",{\"1\":{\"380\":1}}],[\"20230812213654007\",{\"1\":{\"380\":1}}],[\"20230810222550532\",{\"1\":{\"379\":1}}],[\"20230810222518520\",{\"1\":{\"379\":1}}],[\"20230810222921012\",{\"1\":{\"379\":1}}],[\"20230810222719156\",{\"1\":{\"379\":1}}],[\"20230810215820437\",{\"1\":{\"379\":1}}],[\"20230810213003545\",{\"1\":{\"378\":1}}],[\"20230813\",{\"1\":{\"291\":1}}],[\"20230815\",{\"1\":{\"96\":1}}],[\"20230324\",{\"1\":{\"1299\":1}}],[\"20230304\",{\"1\":{\"1282\":1}}],[\"20230306\",{\"1\":{\"263\":1,\"275\":1}}],[\"20230316\",{\"1\":{\"287\":1}}],[\"20230530\",{\"1\":{\"16\":1}}],[\"20221212\",{\"1\":{\"1243\":1}}],[\"20221104\",{\"1\":{\"1231\":1}}],[\"2022\",{\"1\":{\"265\":1,\"886\":1,\"1079\":7}}],[\"20220929\",{\"1\":{\"1202\":1}}],[\"20220912\",{\"1\":{\"1176\":1}}],[\"20220904\",{\"1\":{\"1146\":1}}],[\"20220830\",{\"1\":{\"1124\":1}}],[\"20220827\",{\"1\":{\"1106\":1}}],[\"20220820\",{\"1\":{\"1085\":1}}],[\"20220724\",{\"1\":{\"1068\":1}}],[\"20220714\",{\"1\":{\"692\":1}}],[\"20220606\",{\"1\":{\"1023\":1}}],[\"20220618\",{\"1\":{\"1058\":1}}],[\"20220610\",{\"1\":{\"680\":1}}],[\"20220614\",{\"1\":{\"168\":1}}],[\"20220521\",{\"1\":{\"1002\":1}}],[\"20220515\",{\"1\":{\"975\":1}}],[\"20220502\",{\"1\":{\"939\":1}}],[\"20220328\",{\"1\":{\"862\":1}}],[\"20220320\",{\"1\":{\"849\":1}}],[\"20220301\",{\"1\":{\"744\":1,\"775\":1,\"799\":1}}],[\"20220313\",{\"1\":{\"629\":1,\"830\":1}}],[\"20220411235923338\",{\"1\":{\"912\":1}}],[\"20220411235323472\",{\"1\":{\"912\":1}}],[\"20220411235301250\",{\"1\":{\"912\":1}}],[\"20220411235759752\",{\"1\":{\"912\":1}}],[\"20220411234502755\",{\"1\":{\"909\":1}}],[\"20220411232605135\",{\"1\":{\"906\":1}}],[\"20220411231805018\",{\"1\":{\"904\":1}}],[\"20220411224424160\",{\"1\":{\"903\":1}}],[\"20220411223612434\",{\"1\":{\"902\":1}}],[\"20220411222509675\",{\"1\":{\"900\":1}}],[\"20220411222306938\",{\"1\":{\"900\":1}}],[\"20220411222721408\",{\"1\":{\"899\":1}}],[\"20220411221546009\",{\"1\":{\"900\":1}}],[\"20220411215152793\",{\"1\":{\"897\":1}}],[\"20220411213226971\",{\"1\":{\"896\":1}}],[\"20220411212011338\",{\"1\":{\"888\":1}}],[\"20220412\",{\"1\":{\"885\":1,\"918\":1}}],[\"20220410\",{\"1\":{\"873\":1}}],[\"20220409\",{\"1\":{\"647\":1}}],[\"20220408\",{\"1\":{\"641\":1}}],[\"20220427\",{\"1\":{\"1\":1}}],[\"20220131\",{\"1\":{\"609\":1,\"719\":1}}],[\"202\",{\"1\":{\"67\":3}}],[\"200表示下游进程处理200个消息后会一次性给上游进程加200信用值\",{\"1\":{\"618\":1}}],[\"2000w\",{\"1\":{\"1414\":1,\"1434\":1,\"1435\":1}}],[\"2000\",{\"1\":{\"1288\":1,\"1443\":1,\"1497\":1}}],[\"2000万个\",{\"1\":{\"787\":1}}],[\"2000万个索引项\",{\"1\":{\"787\":1}}],[\"2000+\",{\"1\":{\"485\":1}}],[\"20000\",{\"1\":{\"253\":1,\"1300\":1}}],[\"200\",{\"1\":{\"11\":2,\"253\":1,\"348\":1,\"351\":1,\"618\":2,\"621\":2,\"913\":1}}],[\"20\",{\"0\":{\"77\":1},\"1\":{\"11\":1,\"217\":4,\"230\":1,\"253\":1,\"294\":1,\"297\":1,\"316\":2,\"390\":2,\"399\":1,\"401\":3,\"407\":1,\"421\":2,\"476\":1,\"552\":1,\"644\":1,\"1104\":1,\"1179\":1,\"1187\":3,\"1203\":1,\"1217\":1,\"1427\":2,\"1519\":1}}],[\"efficient\",{\"1\":{\"1437\":1}}],[\"efylxe18dcxplaxw8n1j7ywtexyr9n9mrlurfgwnkqiktuw7icfp4epg44lb\",{\"1\":{\"443\":1}}],[\"e1\",{\"1\":{\"820\":2}}],[\"e3\",{\"1\":{\"715\":1}}],[\"e2\",{\"1\":{\"714\":1}}],[\"emptylist\",{\"1\":{\"1436\":1}}],[\"empty\",{\"1\":{\"1266\":1,\"1468\":1,\"1516\":2}}],[\"embed\",{\"1\":{\"687\":1}}],[\"email\",{\"1\":{\"92\":5}}],[\"eol\",{\"1\":{\"642\":1}}],[\"eofexception\",{\"1\":{\"125\":3,\"128\":1}}],[\"ejjenhtams0qnyykxzlyrheekqggvwso3c\",{\"1\":{\"469\":1}}],[\"eg1733bcoztd2xqk2p5gfxy\",{\"1\":{\"455\":1}}],[\"ei\",{\"1\":{\"429\":1}}],[\"either\",{\"1\":{\"46\":2}}],[\"eh3pp\",{\"1\":{\"423\":1}}],[\"epoch\",{\"1\":{\"1280\":2}}],[\"epolls\",{\"1\":{\"1173\":2}}],[\"eprof\",{\"1\":{\"255\":1}}],[\"epp\",{\"1\":{\"213\":1}}],[\"estimatedsize\",{\"1\":{\"1430\":1}}],[\"esl\",{\"1\":{\"643\":12}}],[\"esnext\",{\"1\":{\"597\":1}}],[\"es\",{\"1\":{\"594\":1}}],[\"es2015\",{\"1\":{\"498\":1,\"531\":1,\"597\":1}}],[\"es6标准引入了新的iterable类型\",{\"1\":{\"303\":1}}],[\"es6\",{\"1\":{\"300\":1,\"316\":3}}],[\"eshell\",{\"1\":{\"248\":1}}],[\"escapefailcnt\",{\"1\":{\"1468\":1}}],[\"escape\",{\"1\":{\"624\":2}}],[\"escript\",{\"1\":{\"224\":1}}],[\"esc\",{\"1\":{\"142\":1}}],[\"every\",{\"1\":{\"327\":1}}],[\"event\",{\"1\":{\"964\":1,\"1173\":8,\"1331\":5}}],[\"eventgrid等\",{\"1\":{\"276\":1}}],[\"eventmesh\",{\"1\":{\"276\":1}}],[\"eventloop\",{\"1\":{\"135\":1}}],[\"eventloopgroup\",{\"1\":{\"131\":1,\"135\":1}}],[\"evens\",{\"1\":{\"189\":9}}],[\"even\",{\"1\":{\"181\":5,\"189\":1}}],[\"evaluate\",{\"1\":{\"1332\":1,\"1333\":1}}],[\"eval\",{\"1\":{\"181\":7,\"192\":2,\"195\":4,\"230\":1,\"618\":1,\"825\":1,\"1332\":1,\"1333\":1}}],[\"eyecolour\",{\"1\":{\"176\":1}}],[\"erase\",{\"1\":{\"217\":4,\"627\":1}}],[\"err\",{\"1\":{\"369\":3}}],[\"errata\",{\"1\":{\"191\":5}}],[\"errorinfo\",{\"1\":{\"1173\":3}}],[\"errors\",{\"1\":{\"643\":1}}],[\"error表示严重的错误\",{\"1\":{\"33\":1}}],[\"error\",{\"1\":{\"11\":2,\"33\":1,\"112\":1,\"113\":1,\"192\":1,\"193\":5,\"194\":3,\"196\":9,\"255\":1,\"256\":2,\"348\":1,\"356\":3,\"357\":1,\"369\":1,\"504\":2,\"543\":1,\"558\":2,\"593\":1,\"624\":4,\"625\":1,\"643\":1,\"741\":1,\"765\":1,\"793\":1,\"794\":7,\"797\":4,\"820\":7,\"823\":1,\"825\":2,\"844\":1,\"845\":6,\"860\":6,\"861\":4,\"872\":1,\"915\":1,\"961\":1,\"971\":1,\"972\":2,\"999\":1,\"1019\":1,\"1048\":5,\"1052\":2,\"1143\":1,\"1144\":1,\"1168\":2,\"1170\":2,\"1173\":6,\"1174\":1,\"1175\":1,\"1197\":2,\"1198\":5,\"1200\":1,\"1201\":2,\"1222\":1,\"1225\":1,\"1226\":1,\"1228\":1,\"1266\":1,\"1270\":1,\"1273\":2,\"1276\":3,\"1278\":1,\"1280\":1,\"1297\":2,\"1332\":6,\"1333\":4,\"1368\":8,\"1370\":2,\"1371\":4,\"1372\":4,\"1373\":3,\"1374\":3,\"1424\":2,\"1428\":4,\"1432\":2,\"1434\":8,\"1435\":8,\"1436\":7,\"1459\":1,\"1468\":4,\"1469\":3,\"1472\":2,\"1497\":1,\"1499\":2,\"1500\":1,\"1516\":1,\"1517\":4,\"1519\":6,\"1520\":8,\"1521\":4}}],[\"erl文件中\",{\"1\":{\"623\":1}}],[\"erl文件\",{\"1\":{\"623\":1}}],[\"erlc\",{\"1\":{\"208\":1,\"224\":1}}],[\"erl\",{\"1\":{\"171\":1,\"180\":2,\"192\":4,\"195\":10,\"208\":1,\"224\":3,\"248\":1,\"252\":3,\"624\":4,\"625\":2,\"626\":3,\"627\":1}}],[\"erlang=1\",{\"1\":{\"644\":1}}],[\"erlang没有对进程邮箱的大小进行限制\",{\"1\":{\"611\":1}}],[\"erlang没有单独的布尔值类型\",{\"1\":{\"206\":1}}],[\"erlang进程之间不共享内存\",{\"1\":{\"611\":1}}],[\"erlang进程没有共享内存\",{\"1\":{\"227\":1}}],[\"erlang里的数字不是整数就是浮点数\",{\"1\":{\"215\":1}}],[\"erlang预处理器\",{\"1\":{\"213\":1}}],[\"erlang模块在编译前会自动由erlang的预处理器进行处理\",{\"1\":{\"208\":1}}],[\"erlang允许一个模块的两个版本同时运行\",{\"1\":{\"207\":1}}],[\"erlang对自己说\",{\"1\":{\"173\":1}}],[\"erlang可以用任意长度的整数执行整数运算\",{\"1\":{\"172\":1}}],[\"erlang\",{\"0\":{\"168\":1,\"171\":1,\"197\":1,\"241\":1,\"243\":1,\"246\":1,\"251\":1,\"255\":1,\"260\":1,\"642\":1},\"1\":{\"168\":1,\"171\":2,\"173\":2,\"178\":1,\"180\":1,\"181\":1,\"182\":1,\"188\":1,\"191\":2,\"193\":2,\"194\":1,\"200\":1,\"218\":1,\"224\":2,\"228\":1,\"230\":2,\"231\":1,\"237\":4,\"238\":2,\"241\":2,\"247\":2,\"252\":3,\"253\":1,\"255\":1,\"261\":4,\"608\":1,\"614\":1,\"619\":1,\"621\":1,\"623\":2,\"625\":1,\"628\":1,\"642\":6,\"643\":15,\"644\":4,\"664\":1,\"716\":1}}],[\"ea5dtnatpks9lmmyhjfvirkcvtjropibc\",{\"1\":{\"469\":1}}],[\"eason\",{\"1\":{\"370\":1}}],[\"easy\",{\"1\":{\"167\":2}}],[\"easymotion\",{\"1\":{\"167\":9}}],[\"each\",{\"1\":{\"11\":2,\"720\":3,\"741\":1,\"886\":1,\"906\":1,\"1000\":1,\"1056\":1,\"1267\":2}}],[\"edit\",{\"1\":{\"165\":1}}],[\"eq\",{\"1\":{\"165\":1}}],[\"equal\",{\"1\":{\"1519\":1}}],[\"equals\",{\"1\":{\"41\":1,\"69\":1,\"70\":1,\"396\":2,\"742\":9,\"845\":1,\"860\":1,\"961\":3,\"971\":1,\"972\":2,\"999\":1,\"1000\":1,\"1020\":1,\"1047\":1,\"1052\":1,\"1053\":1,\"1144\":1,\"1198\":1,\"1224\":1,\"1225\":1,\"1230\":3,\"1270\":7,\"1278\":2,\"1328\":1,\"1427\":2,\"1431\":1,\"1434\":3,\"1435\":1,\"1436\":3,\"1459\":1,\"1471\":1,\"1499\":1,\"1500\":3,\"1502\":1,\"1503\":2,\"1516\":2,\"1519\":3,\"1520\":3}}],[\"equivalent\",{\"1\":{\"103\":1,\"253\":4}}],[\"echo\",{\"0\":{\"398\":1},\"1\":{\"143\":2,\"398\":2,\"608\":1}}],[\"elapsed\",{\"1\":{\"1435\":3,\"1436\":1,\"1495\":2,\"1496\":1,\"1497\":1,\"1499\":2,\"1519\":2,\"1520\":1,\"1521\":4}}],[\"elapsedtime\",{\"1\":{\"1174\":2,\"1332\":3}}],[\"elasticjob\",{\"1\":{\"371\":1}}],[\"eliminate\",{\"1\":{\"720\":1,\"727\":1,\"886\":5,\"888\":1,\"901\":1,\"904\":1,\"906\":1}}],[\"eliminates\",{\"1\":{\"624\":1}}],[\"elvui\",{\"1\":{\"491\":1}}],[\"elected\",{\"1\":{\"1497\":1}}],[\"election\",{\"1\":{\"1474\":1,\"1478\":1}}],[\"element\",{\"1\":{\"303\":3,\"325\":2,\"1021\":1}}],[\"elementtype\",{\"1\":{\"43\":5}}],[\"elete\",{\"1\":{\"155\":1,\"156\":1}}],[\"else\",{\"1\":{\"125\":7,\"167\":1,\"188\":1,\"214\":1,\"306\":2,\"348\":2,\"351\":1,\"356\":2,\"504\":2,\"519\":1,\"547\":1,\"742\":5,\"767\":1,\"771\":3,\"793\":1,\"794\":1,\"797\":4,\"824\":1,\"845\":4,\"860\":4,\"870\":3,\"872\":1,\"893\":1,\"894\":2,\"971\":1,\"972\":1,\"998\":1,\"999\":1,\"1021\":2,\"1050\":1,\"1051\":1,\"1052\":2,\"1056\":2,\"1122\":2,\"1143\":1,\"1144\":3,\"1170\":2,\"1173\":9,\"1174\":9,\"1175\":2,\"1194\":2,\"1195\":5,\"1198\":1,\"1200\":3,\"1201\":1,\"1222\":1,\"1224\":3,\"1225\":1,\"1228\":2,\"1229\":2,\"1230\":6,\"1266\":1,\"1267\":2,\"1269\":5,\"1270\":2,\"1276\":1,\"1277\":2,\"1278\":4,\"1280\":2,\"1297\":3,\"1328\":1,\"1333\":1,\"1368\":1,\"1370\":2,\"1371\":4,\"1372\":1,\"1373\":4,\"1374\":1,\"1424\":1,\"1427\":3,\"1428\":2,\"1430\":4,\"1432\":3,\"1434\":1,\"1435\":1,\"1436\":2,\"1459\":1,\"1460\":1,\"1462\":4,\"1464\":1,\"1468\":6,\"1469\":2,\"1471\":3,\"1472\":2,\"1497\":7,\"1499\":5,\"1500\":5,\"1502\":1,\"1503\":6,\"1516\":2,\"1518\":2,\"1519\":9,\"1520\":4,\"1521\":3}}],[\"eugen\",{\"1\":{\"105\":2}}],[\"eugenp\",{\"1\":{\"96\":1}}],[\"ets\",{\"0\":{\"247\":1,\"249\":1},\"1\":{\"247\":4,\"248\":14,\"249\":1}}],[\"etcd等\",{\"1\":{\"286\":1}}],[\"etcd\",{\"1\":{\"284\":2}}],[\"etcd客户端视角下\",{\"1\":{\"284\":1}}],[\"etc\",{\"1\":{\"97\":1,\"644\":1}}],[\"eta\",{\"1\":{\"11\":2}}],[\"enhancement\",{\"1\":{\"1437\":1}}],[\"ensure\",{\"1\":{\"1427\":1,\"1434\":1}}],[\"enqueuing\",{\"1\":{\"1370\":2}}],[\"enqueuetime\",{\"1\":{\"1372\":3}}],[\"enqueueputqueue\",{\"1\":{\"1355\":1,\"1356\":1,\"1370\":4,\"1371\":3}}],[\"enqueue\",{\"1\":{\"1353\":1,\"1370\":5,\"1371\":3}}],[\"enablecalcfilterbitmap\",{\"1\":{\"1332\":1}}],[\"enablecalcfilterbitmap=true\",{\"1\":{\"1308\":1,\"1315\":1,\"1323\":1}}],[\"enableconsumequeueext=true\",{\"1\":{\"1308\":1,\"1315\":1,\"1323\":1}}],[\"enablepropertyfilter=true\",{\"1\":{\"1308\":2}}],[\"enablemultidispatch\",{\"1\":{\"1174\":1,\"1286\":1}}],[\"enablemsgtrace\",{\"1\":{\"1019\":2}}],[\"enablelmq\",{\"1\":{\"1174\":1,\"1286\":1}}],[\"enableasyncdeliver\",{\"1\":{\"860\":1}}],[\"enablescheduleasyncdeliver\",{\"1\":{\"850\":1}}],[\"enable\",{\"1\":{\"710\":1,\"996\":1}}],[\"enabled\",{\"1\":{\"272\":1}}],[\"entries\",{\"1\":{\"1519\":4}}],[\"entryindex=\",{\"1\":{\"1520\":1}}],[\"entrysize\",{\"1\":{\"1517\":2}}],[\"entryset\",{\"1\":{\"844\":1,\"971\":2,\"972\":5,\"1000\":1,\"1021\":1,\"1142\":1,\"1144\":1,\"1200\":1,\"1224\":1,\"1277\":1,\"1436\":1,\"1521\":1}}],[\"entrypusher\",{\"1\":{\"1516\":1}}],[\"entrypoint\",{\"1\":{\"1079\":1}}],[\"entryhandler\",{\"0\":{\"1520\":1},\"1\":{\"1508\":1,\"1511\":4,\"1514\":2,\"1520\":3}}],[\"entrydispatcher>\",{\"1\":{\"1514\":1}}],[\"entrydispatcher\",{\"0\":{\"1519\":1},\"1\":{\"1508\":2,\"1510\":8,\"1514\":1,\"1519\":5}}],[\"entry<messagequeue\",{\"1\":{\"1144\":1,\"1200\":1,\"1224\":1}}],[\"entry<string\",{\"1\":{\"971\":1,\"972\":3,\"1000\":1,\"1021\":1,\"1142\":1,\"1277\":2}}],[\"entry<long\",{\"1\":{\"971\":1,\"972\":1,\"1436\":1,\"1521\":1}}],[\"entry<integer\",{\"1\":{\"844\":1}}],[\"entry\",{\"1\":{\"598\":2,\"844\":3,\"915\":1,\"971\":2,\"972\":12,\"1021\":4,\"1142\":2,\"1200\":3,\"1277\":2,\"1436\":2,\"1516\":3,\"1517\":12,\"1518\":14,\"1519\":19,\"1520\":4}}],[\"entity\",{\"1\":{\"89\":1,\"90\":1,\"92\":1,\"1021\":2}}],[\"enum\",{\"0\":{\"581\":1,\"583\":1,\"584\":1,\"585\":1},\"1\":{\"582\":5,\"583\":2,\"584\":4,\"585\":3,\"586\":2,\"587\":1}}],[\"enum类型的每个常量在jvm中只有一个唯一实例\",{\"1\":{\"31\":1}}],[\"encountered\",{\"1\":{\"643\":1}}],[\"encodeindex\",{\"1\":{\"1517\":1}}],[\"encoderfromcontextbean\",{\"1\":{\"1021\":1}}],[\"encoderbuffer\",{\"1\":{\"737\":22}}],[\"encodeheader\",{\"1\":{\"894\":1,\"1173\":1}}],[\"encodedbuff\",{\"1\":{\"737\":1}}],[\"encode\",{\"1\":{\"111\":1,\"116\":1,\"127\":1,\"128\":1,\"737\":3,\"886\":1,\"889\":1,\"893\":1,\"894\":2,\"970\":1,\"973\":1,\"1517\":1}}],[\"encq2lqxfh6vlhujhjzmirwv14aqqalrariaylgi4vxabhww1lpbty0gyglfi4nic\",{\"1\":{\"469\":1}}],[\"enough\",{\"1\":{\"253\":1,\"1371\":1}}],[\"environment\",{\"1\":{\"960\":1,\"1075\":1,\"1078\":1}}],[\"env\",{\"1\":{\"224\":1,\"618\":1,\"960\":1}}],[\"endindex\",{\"1\":{\"1520\":12}}],[\"endif\",{\"1\":{\"167\":1,\"214\":1}}],[\"endmessagetransaction\",{\"1\":{\"1464\":1}}],[\"endphyoffset\",{\"1\":{\"787\":1,\"794\":2,\"872\":2}}],[\"endtransactiononeway\",{\"1\":{\"1460\":1,\"1472\":2}}],[\"endtransactionrequestheader\",{\"1\":{\"1460\":2,\"1464\":3,\"1472\":2}}],[\"endtransactionprocessor\",{\"0\":{\"1464\":1},\"1\":{\"1451\":1,\"1464\":1}}],[\"endtransaction\",{\"0\":{\"1460\":1,\"1464\":1},\"1\":{\"1449\":1,\"1451\":1,\"1459\":1,\"1460\":1}}],[\"endtransactionthreadpoolnums\",{\"1\":{\"720\":1,\"732\":1,\"734\":2}}],[\"endtick\",{\"1\":{\"1370\":1,\"1371\":1,\"1372\":1,\"1374\":1}}],[\"endtime\",{\"1\":{\"1278\":14,\"1279\":1,\"1436\":16}}],[\"endtimestamp\",{\"1\":{\"787\":1,\"789\":1,\"793\":1,\"1050\":3,\"1420\":2,\"1434\":3}}],[\"end\",{\"1\":{\"147\":1,\"165\":1,\"181\":8,\"182\":2,\"183\":1,\"187\":3,\"188\":2,\"189\":1,\"193\":1,\"194\":1,\"196\":2,\"205\":1,\"229\":2,\"230\":2,\"232\":1,\"235\":2,\"253\":8,\"261\":1,\"624\":6,\"625\":2,\"626\":3,\"627\":2,\"789\":3,\"790\":1,\"794\":5,\"797\":4,\"824\":1,\"845\":3,\"999\":1,\"1140\":1,\"1168\":1,\"1170\":1,\"1371\":1,\"1373\":2,\"1374\":2,\"1436\":1,\"1459\":1,\"1464\":4,\"1467\":2,\"1497\":1,\"1503\":1,\"1519\":3}}],[\"e\",{\"0\":{\"438\":1,\"901\":1},\"1\":{\"34\":6,\"69\":1,\"92\":2,\"112\":4,\"113\":4,\"122\":1,\"123\":1,\"128\":1,\"131\":1,\"133\":2,\"143\":1,\"145\":2,\"152\":1,\"171\":1,\"253\":1,\"289\":2,\"298\":2,\"356\":5,\"396\":1,\"508\":1,\"613\":2,\"742\":6,\"793\":2,\"794\":2,\"797\":8,\"820\":2,\"823\":2,\"824\":2,\"825\":4,\"844\":2,\"845\":2,\"860\":2,\"861\":6,\"870\":1,\"872\":2,\"886\":1,\"890\":1,\"915\":2,\"961\":1,\"970\":3,\"971\":2,\"972\":4,\"984\":2,\"995\":2,\"999\":4,\"1006\":2,\"1019\":1,\"1021\":1,\"1048\":10,\"1052\":2,\"1080\":7,\"1081\":1,\"1142\":2,\"1143\":2,\"1144\":1,\"1168\":4,\"1170\":6,\"1173\":3,\"1175\":4,\"1194\":2,\"1195\":3,\"1197\":4,\"1200\":2,\"1201\":2,\"1222\":2,\"1224\":1,\"1225\":2,\"1226\":2,\"1228\":2,\"1230\":3,\"1266\":2,\"1270\":2,\"1276\":2,\"1288\":1,\"1297\":4,\"1332\":4,\"1333\":4,\"1370\":5,\"1371\":2,\"1372\":2,\"1373\":4,\"1374\":2,\"1383\":1,\"1424\":2,\"1425\":2,\"1428\":1,\"1432\":4,\"1434\":2,\"1435\":5,\"1436\":4,\"1443\":2,\"1459\":7,\"1468\":2,\"1469\":2,\"1472\":5,\"1516\":3,\"1519\":3}}],[\"exhaust\",{\"1\":{\"1519\":1}}],[\"exhaustion\",{\"1\":{\"622\":2}}],[\"exhcange\",{\"1\":{\"711\":1}}],[\"examinebrokerclusterinfo\",{\"1\":{\"1248\":1}}],[\"examples\",{\"1\":{\"654\":1}}],[\"example\",{\"1\":{\"11\":4,\"103\":1,\"104\":1,\"204\":1,\"253\":2,\"350\":1,\"1025\":1}}],[\"exactly\",{\"1\":{\"283\":1,\"652\":2,\"653\":1,\"654\":1,\"657\":2,\"1237\":1}}],[\"existed\",{\"1\":{\"1520\":1}}],[\"exist\",{\"1\":{\"973\":1,\"1053\":1,\"1143\":2,\"1171\":1,\"1173\":14,\"1198\":5,\"1200\":1,\"1266\":2,\"1279\":1,\"1521\":1}}],[\"existingreplicas\",{\"1\":{\"396\":2}}],[\"exists\",{\"1\":{\"167\":1,\"490\":4,\"998\":1,\"999\":1,\"1144\":1,\"1224\":1}}],[\"exit和error其中之一\",{\"1\":{\"194\":1}}],[\"exited\",{\"1\":{\"193\":1,\"194\":2,\"1079\":3}}],[\"exit\",{\"1\":{\"193\":5,\"194\":2,\"195\":4,\"960\":4}}],[\"expiretimestamp\",{\"1\":{\"1435\":2}}],[\"expiredtime\",{\"1\":{\"870\":3}}],[\"expired\",{\"1\":{\"862\":1,\"1230\":1,\"1497\":2,\"1499\":1,\"1500\":4,\"1503\":2,\"1519\":1}}],[\"expect=\",{\"1\":{\"1432\":1}}],[\"expectlogicoffset\",{\"1\":{\"765\":15}}],[\"expressmessagefilter\",{\"1\":{\"1328\":1}}],[\"express\",{\"1\":{\"266\":3}}],[\"expressionmessagefilter\",{\"1\":{\"1173\":1,\"1270\":1,\"1318\":2,\"1319\":2,\"1324\":2,\"1333\":1}}],[\"expressionforretrymessagefilter\",{\"1\":{\"1173\":1,\"1318\":1}}],[\"expressiontype\",{\"1\":{\"1171\":6,\"1173\":3,\"1328\":1,\"1331\":1,\"1333\":2}}],[\"expressions\",{\"1\":{\"232\":1}}],[\"expressions2\",{\"1\":{\"229\":1,\"232\":1}}],[\"expressions1\",{\"1\":{\"229\":1,\"232\":1}}],[\"expression\",{\"1\":{\"171\":1,\"187\":2,\"1173\":1,\"1321\":6,\"1324\":1,\"1331\":5,\"1332\":1,\"1333\":2}}],[\"expr2\",{\"1\":{\"219\":4}}],[\"exprn\",{\"1\":{\"205\":1}}],[\"expr1\",{\"1\":{\"205\":1,\"219\":4}}],[\"exprs\",{\"1\":{\"195\":2}}],[\"expr\",{\"1\":{\"188\":3,\"192\":1,\"624\":3}}],[\"exported\",{\"1\":{\"364\":2}}],[\"exports对象\",{\"1\":{\"596\":1}}],[\"exports对象赋值\",{\"1\":{\"365\":1}}],[\"exports赋值\",{\"1\":{\"365\":1}}],[\"exports\",{\"0\":{\"365\":2},\"1\":{\"361\":1,\"364\":3,\"365\":3}}],[\"export\",{\"0\":{\"596\":1},\"1\":{\"180\":2,\"230\":1,\"235\":1,\"248\":1,\"253\":1,\"591\":5,\"596\":2,\"597\":1}}],[\"extaddr\",{\"1\":{\"1297\":3}}],[\"ext=\",{\"1\":{\"1080\":4}}],[\"externals\",{\"1\":{\"1053\":1}}],[\"extend\",{\"1\":{\"771\":1,\"845\":1,\"860\":1,\"1174\":1,\"1297\":1,\"1328\":1,\"1333\":1}}],[\"extendwith\",{\"1\":{\"98\":1}}],[\"extends\",{\"0\":{\"49\":1},\"1\":{\"49\":1,\"69\":1,\"92\":1,\"128\":1,\"345\":1,\"396\":2,\"560\":1,\"561\":1,\"562\":1,\"571\":1,\"579\":1,\"742\":1,\"950\":1,\"968\":1,\"1140\":1,\"1519\":1,\"1520\":1,\"1521\":1}}],[\"extfield\",{\"1\":{\"890\":2}}],[\"extfields\",{\"1\":{\"742\":3,\"890\":1}}],[\"extrainfo\",{\"1\":{\"1273\":8}}],[\"extrainfoutil\",{\"1\":{\"1270\":3,\"1273\":7}}],[\"extract\",{\"1\":{\"720\":5,\"736\":5}}],[\"extret\",{\"1\":{\"767\":1,\"1174\":4}}],[\"ext\",{\"1\":{\"154\":2,\"742\":1,\"845\":1,\"860\":1,\"1080\":2,\"1174\":1}}],[\"excuterequestwhenwakeup\",{\"1\":{\"820\":1}}],[\"exceed\",{\"1\":{\"1174\":1,\"1468\":2}}],[\"exceeds\",{\"1\":{\"737\":2,\"1170\":2}}],[\"exceeded\",{\"1\":{\"737\":5}}],[\"exceptionally\",{\"1\":{\"1428\":1,\"1432\":1}}],[\"exceptiontype是一个原子\",{\"1\":{\"194\":1}}],[\"exceptionsimpledesc\",{\"1\":{\"1195\":1,\"1230\":1,\"1472\":1}}],[\"exceptions\",{\"1\":{\"171\":1,\"1436\":1}}],[\"exception则是运行时的错误\",{\"1\":{\"33\":1}}],[\"exception\",{\"0\":{\"100\":1,\"103\":1},\"1\":{\"33\":2,\"34\":5,\"69\":1,\"97\":1,\"99\":4,\"103\":2,\"112\":1,\"123\":1,\"133\":1,\"171\":1,\"187\":1,\"192\":1,\"193\":10,\"194\":1,\"195\":2,\"255\":1,\"624\":2,\"793\":2,\"794\":2,\"797\":4,\"820\":1,\"824\":1,\"844\":1,\"845\":1,\"860\":1,\"861\":6,\"872\":2,\"960\":2,\"961\":2,\"970\":2,\"971\":2,\"972\":4,\"984\":1,\"995\":2,\"996\":1,\"999\":3,\"1006\":1,\"1048\":10,\"1050\":3,\"1052\":1,\"1142\":1,\"1143\":1,\"1144\":1,\"1168\":2,\"1170\":4,\"1173\":3,\"1175\":2,\"1195\":2,\"1197\":4,\"1200\":2,\"1222\":1,\"1224\":1,\"1225\":2,\"1226\":2,\"1228\":1,\"1230\":2,\"1248\":2,\"1266\":1,\"1270\":2,\"1280\":3,\"1370\":3,\"1372\":3,\"1373\":1,\"1434\":1,\"1435\":3,\"1436\":2,\"1459\":4,\"1460\":1,\"1469\":3,\"1472\":10,\"1496\":1,\"1497\":1,\"1499\":1,\"1500\":2,\"1502\":2,\"1519\":11,\"1520\":2}}],[\"exchangedeclare\",{\"1\":{\"712\":1,\"714\":1,\"715\":1}}],[\"exchange\",{\"0\":{\"633\":1,\"636\":1},\"1\":{\"630\":2,\"632\":1,\"633\":4,\"636\":1,\"637\":4,\"639\":2,\"640\":1,\"668\":1,\"700\":1,\"705\":1,\"707\":1,\"710\":1,\"711\":4,\"712\":5,\"714\":5,\"715\":5,\"717\":1,\"1290\":2}}],[\"excite\",{\"1\":{\"298\":2}}],[\"exclude\",{\"1\":{\"147\":1}}],[\"ex\",{\"1\":{\"125\":1,\"128\":2,\"1266\":1,\"1497\":3,\"1499\":3,\"1519\":2}}],[\"executelocaltransactionbranch\",{\"1\":{\"1459\":2,\"1460\":1}}],[\"executelocaltransaction\",{\"1\":{\"1442\":2,\"1459\":2}}],[\"executeconsumemessagehookafter\",{\"1\":{\"1198\":1}}],[\"executeconsumemessagehookbefore\",{\"1\":{\"1173\":1}}],[\"executehookafter\",{\"1\":{\"1195\":1,\"1230\":1}}],[\"executehookbefore\",{\"1\":{\"1195\":1,\"1230\":1}}],[\"executetasklater\",{\"1\":{\"1175\":2}}],[\"executepullrequestlater\",{\"1\":{\"1170\":9,\"1175\":2,\"1228\":2,\"1229\":1}}],[\"executepullrequestimmediately\",{\"1\":{\"1119\":3,\"1155\":1,\"1168\":2,\"1175\":3,\"1229\":2}}],[\"executesendmessagehookafter\",{\"1\":{\"1053\":1}}],[\"executesendmessagehookbefore\",{\"1\":{\"1042\":1,\"1053\":1}}],[\"executedeletefilesmanually方法被调用\",{\"1\":{\"870\":1}}],[\"executeontimeup\",{\"1\":{\"841\":1,\"845\":2,\"857\":1,\"860\":1}}],[\"executerequestwhenwakeup\",{\"0\":{\"820\":1},\"1\":{\"812\":2,\"814\":2,\"820\":1,\"825\":2}}],[\"execute\",{\"1\":{\"122\":1,\"128\":1,\"825\":2,\"845\":1,\"860\":1,\"970\":1,\"1170\":1,\"1175\":1,\"1459\":1,\"1469\":1}}],[\"executor\",{\"1\":{\"121\":2,\"122\":1,\"126\":1,\"128\":1,\"129\":1,\"132\":1,\"1458\":1}}],[\"executors\",{\"1\":{\"113\":1,\"121\":1,\"128\":1,\"132\":1,\"961\":1}}],[\"executorservice\",{\"1\":{\"113\":1,\"121\":1,\"1443\":3,\"1469\":2}}],[\"execution\",{\"1\":{\"886\":1,\"913\":1}}],[\"executions>\",{\"1\":{\"64\":1}}],[\"execution>\",{\"1\":{\"64\":1}}],[\"exe\",{\"1\":{\"52\":2}}],[\"吞吐量降到\",{\"1\":{\"285\":1}}],[\"吞吐量\",{\"1\":{\"11\":1}}],[\"wuchanming\",{\"1\":{\"774\":1}}],[\"wukqip6gns5haxs2zc\",{\"1\":{\"436\":1}}],[\"w5zd9v3oepdo30uwrm6p2zgn\",{\"1\":{\"429\":1}}],[\"wgta\",{\"1\":{\"423\":1}}],[\"wcl\",{\"1\":{\"399\":1}}],[\"wlk\",{\"1\":{\"399\":1}}],[\"wss\",{\"1\":{\"369\":2}}],[\"ws\",{\"0\":{\"369\":1},\"1\":{\"368\":2,\"369\":10}}],[\"w单词\",{\"1\":{\"155\":1}}],[\"w\",{\"1\":{\"145\":2,\"153\":17,\"154\":1,\"162\":1,\"191\":1,\"230\":2,\"297\":1}}],[\"wal\",{\"1\":{\"1453\":1,\"1475\":1,\"1506\":1}}],[\"water\",{\"0\":{\"1300\":1},\"1\":{\"1299\":6,\"1300\":4}}],[\"watermarks\",{\"1\":{\"1521\":1}}],[\"watermarks=\",{\"1\":{\"1521\":2}}],[\"watermark\",{\"1\":{\"1299\":1}}],[\"watch\",{\"0\":{\"999\":1},\"1\":{\"996\":1,\"999\":4}}],[\"was\",{\"1\":{\"767\":1,\"1053\":1,\"1170\":1,\"1173\":1,\"1174\":1,\"1270\":1,\"1468\":1}}],[\"warmmappedfile\",{\"1\":{\"882\":3}}],[\"warmup\",{\"1\":{\"4\":2,\"9\":1,\"11\":11}}],[\"warn\",{\"1\":{\"737\":4,\"765\":3,\"797\":1,\"824\":1,\"845\":2,\"860\":2,\"861\":4,\"870\":1,\"961\":1,\"970\":1,\"998\":1,\"999\":1,\"1008\":2,\"1142\":1,\"1143\":3,\"1144\":2,\"1170\":6,\"1173\":10,\"1174\":4,\"1175\":4,\"1195\":4,\"1201\":1,\"1224\":2,\"1225\":1,\"1230\":8,\"1266\":4,\"1270\":1,\"1275\":2,\"1276\":3,\"1277\":1,\"1279\":2,\"1280\":2,\"1297\":7,\"1332\":1,\"1370\":2,\"1372\":1,\"1373\":1,\"1427\":3,\"1431\":1,\"1432\":1,\"1435\":1,\"1459\":1,\"1464\":3,\"1468\":1,\"1469\":1,\"1471\":2,\"1472\":3,\"1500\":2,\"1503\":2,\"1518\":1,\"1519\":3,\"1520\":3}}],[\"wangdoc\",{\"1\":{\"493\":1}}],[\"wangji92\",{\"1\":{\"272\":2}}],[\"wangji\",{\"1\":{\"264\":1}}],[\"wants\",{\"1\":{\"253\":1}}],[\"want\",{\"1\":{\"253\":1,\"289\":1,\"643\":1}}],[\"waitack\",{\"1\":{\"1509\":1,\"1516\":2,\"1518\":2}}],[\"waiting\",{\"1\":{\"1373\":1,\"1374\":1,\"1427\":1}}],[\"waitingthreadtable\",{\"1\":{\"726\":2}}],[\"waitingtasks是一个linkedblockingqueue数据结构\",{\"1\":{\"379\":1}}],[\"waitinterval\",{\"1\":{\"1140\":1}}],[\"waitstoremsgokvalue\",{\"1\":{\"1056\":2}}],[\"waitpoint\",{\"1\":{\"915\":3}}],[\"waitforrunning\",{\"1\":{\"824\":2,\"915\":2,\"999\":1,\"1140\":1,\"1427\":1,\"1435\":1,\"1467\":1,\"1519\":2,\"1520\":2,\"1521\":3}}],[\"wait=true\",{\"1\":{\"720\":1,\"1056\":1,\"1445\":3}}],[\"waitnotifyobject\",{\"0\":{\"726\":1},\"1\":{\"720\":1,\"723\":1,\"726\":3}}],[\"wait\",{\"1\":{\"253\":1,\"726\":1,\"915\":1,\"1056\":3,\"1296\":1,\"1464\":2,\"1497\":7,\"1516\":2,\"1518\":1,\"1521\":1}}],[\"wakeupall\",{\"1\":{\"726\":1}}],[\"wakeup\",{\"1\":{\"124\":1,\"128\":1,\"825\":2,\"915\":2,\"1140\":1,\"1519\":2,\"1520\":1}}],[\"way\",{\"1\":{\"104\":1,\"1027\":1,\"1173\":1}}],[\"wower\",{\"1\":{\"399\":1}}],[\"wow\",{\"1\":{\"398\":3,\"399\":4}}],[\"would\",{\"1\":{\"103\":1,\"104\":1,\"624\":2}}],[\"word尾\",{\"1\":{\"145\":1}}],[\"word开头\",{\"1\":{\"145\":2}}],[\"word\",{\"1\":{\"101\":1,\"102\":1,\"145\":2,\"147\":3,\"155\":2,\"172\":1}}],[\"world~n\",{\"1\":{\"224\":1}}],[\"world\",{\"1\":{\"21\":4,\"224\":2,\"297\":2,\"514\":1,\"516\":1,\"535\":1,\"545\":1,\"984\":1,\"1006\":1,\"1306\":1}}],[\"worker的初始化方法中\",{\"1\":{\"380\":1}}],[\"worker全流程图如下\",{\"1\":{\"375\":1}}],[\"worker初始化流程\",{\"0\":{\"375\":1}}],[\"worker相当于会启动定期任务去执行秒级任务\",{\"1\":{\"374\":1}}],[\"worker\",{\"1\":{\"372\":3,\"375\":1,\"380\":2,\"1021\":3}}],[\"worked\",{\"1\":{\"180\":2}}],[\"working\",{\"1\":{\"171\":2,\"1267\":1}}],[\"workspace\",{\"1\":{\"1075\":3,\"1077\":1,\"1079\":3}}],[\"works\",{\"1\":{\"103\":1,\"1056\":1}}],[\"workaround\",{\"1\":{\"103\":1}}],[\"work>\",{\"1\":{\"21\":1}}],[\"work\",{\"1\":{\"21\":1,\"23\":2,\"886\":1}}],[\"were\",{\"1\":{\"643\":1}}],[\"wednesday\",{\"1\":{\"587\":2}}],[\"weekdays\",{\"1\":{\"587\":2}}],[\"weakauras\",{\"1\":{\"491\":1}}],[\"we\",{\"1\":{\"101\":1,\"102\":1,\"230\":1,\"253\":1,\"624\":4,\"627\":1,\"886\":1,\"1372\":1,\"1427\":1}}],[\"websocketserver\",{\"1\":{\"369\":2}}],[\"websocket连接建立以后\",{\"1\":{\"368\":1}}],[\"websocket连接必须由浏览器发起\",{\"1\":{\"368\":1}}],[\"websocket指定的websocket协议\",{\"1\":{\"368\":1}}],[\"websocket和connection\",{\"1\":{\"368\":1}}],[\"websocket并不是全新的协议\",{\"1\":{\"368\":1}}],[\"websocket是html5新增的协议\",{\"1\":{\"368\":1}}],[\"websocket\",{\"0\":{\"246\":1,\"368\":1},\"1\":{\"368\":7,\"369\":3}}],[\"web服务器处理tcp连接\",{\"1\":{\"78\":1}}],[\"web\",{\"0\":{\"77\":1,\"93\":1,\"367\":1},\"1\":{\"111\":1,\"262\":1,\"294\":1,\"372\":1,\"614\":1}}],[\"whqe7kbcfghuw7lgznixa\",{\"1\":{\"455\":1}}],[\"why\",{\"1\":{\"193\":4,\"196\":1,\"1278\":1}}],[\"who=w\",{\"1\":{\"191\":1}}],[\"who\",{\"1\":{\"176\":2,\"191\":4}}],[\"whose\",{\"1\":{\"46\":2}}],[\"white\",{\"1\":{\"1000\":2}}],[\"whiteremoteaddress\",{\"1\":{\"983\":3}}],[\"which\",{\"1\":{\"171\":1,\"396\":3,\"642\":1,\"720\":1,\"731\":1,\"886\":1,\"1247\":2}}],[\"while\",{\"1\":{\"112\":1,\"113\":1,\"122\":2,\"125\":1,\"332\":1,\"396\":1,\"544\":1,\"643\":1,\"722\":1,\"771\":1,\"824\":1,\"841\":1,\"845\":2,\"860\":5,\"861\":1,\"971\":1,\"972\":6,\"999\":1,\"1021\":1,\"1140\":1,\"1144\":1,\"1168\":1,\"1224\":1,\"1225\":1,\"1277\":1,\"1278\":1,\"1332\":1,\"1370\":1,\"1371\":3,\"1372\":1,\"1373\":2,\"1374\":3,\"1427\":1,\"1432\":1,\"1435\":2,\"1436\":1,\"1444\":1,\"1467\":1,\"1468\":2,\"1516\":1,\"1519\":3}}],[\"what\",{\"1\":{\"97\":1,\"180\":2,\"183\":2,\"640\":1}}],[\"wheel\",{\"1\":{\"1354\":1}}],[\"whether\",{\"1\":{\"737\":1}}],[\"whencomplete\",{\"1\":{\"1427\":1,\"1428\":1,\"1436\":2,\"1497\":1,\"1499\":1,\"1519\":1}}],[\"whenmocked\",{\"1\":{\"105\":1,\"106\":1}}],[\"whenusingdothrow\",{\"1\":{\"102\":1}}],[\"whenusingwhenthen\",{\"1\":{\"101\":1}}],[\"when\",{\"0\":{\"97\":1,\"186\":1},\"1\":{\"97\":4,\"101\":2,\"102\":1,\"104\":1,\"105\":1,\"106\":1,\"186\":5,\"187\":2,\"196\":1,\"229\":2,\"232\":2,\"625\":1,\"659\":2,\"825\":3,\"882\":2,\"886\":3,\"901\":1,\"906\":1,\"1052\":1,\"1145\":1,\"1170\":5,\"1174\":1,\"1468\":2,\"1472\":2,\"1503\":1,\"1519\":3}}],[\"whereis\",{\"1\":{\"234\":1}}],[\"where\",{\"1\":{\"92\":2,\"253\":2,\"886\":1,\"901\":1}}],[\"wrter\",{\"1\":{\"1300\":1}}],[\"wrote\",{\"1\":{\"1368\":1}}],[\"wroteoffset\",{\"1\":{\"738\":3}}],[\"wrong\",{\"1\":{\"558\":1,\"765\":1,\"1173\":1,\"1175\":1,\"1225\":1}}],[\"writabilitychanged\",{\"1\":{\"1300\":1}}],[\"writable\",{\"1\":{\"967\":1}}],[\"writing\",{\"1\":{\"886\":1}}],[\"written\",{\"1\":{\"125\":5,\"1427\":1}}],[\"writehook\",{\"1\":{\"1517\":2}}],[\"writeindex++\",{\"1\":{\"1519\":1}}],[\"writeindex=\",{\"1\":{\"1519\":2,\"1520\":1}}],[\"writeindex\",{\"1\":{\"1508\":1,\"1510\":1,\"1519\":5,\"1520\":5}}],[\"writeint\",{\"1\":{\"894\":4,\"900\":1}}],[\"writeposition\",{\"1\":{\"1435\":7}}],[\"writebeginposition\",{\"1\":{\"1435\":4}}],[\"writebufferwatermark\",{\"1\":{\"1299\":4,\"1300\":1}}],[\"writebufferlowwatermark\",{\"1\":{\"1299\":1}}],[\"writebufferhighwatermark\",{\"0\":{\"1299\":1},\"1\":{\"1299\":1,\"1538\":1}}],[\"writebytes\",{\"1\":{\"894\":1}}],[\"writebyte\",{\"1\":{\"894\":2}}],[\"writequeuenums\",{\"1\":{\"964\":10,\"968\":2,\"1052\":3}}],[\"writestr\",{\"1\":{\"894\":3}}],[\"writeshort\",{\"1\":{\"894\":2,\"900\":1}}],[\"writelong\",{\"1\":{\"894\":1}}],[\"writelock\",{\"1\":{\"793\":2,\"971\":2,\"972\":2,\"1434\":2,\"1435\":4}}],[\"writecharsequence\",{\"1\":{\"894\":1}}],[\"writemessagestore\",{\"1\":{\"845\":1,\"861\":1}}],[\"writeandflush\",{\"1\":{\"820\":1,\"1173\":1}}],[\"writerequestmap\",{\"1\":{\"1511\":3,\"1520\":9}}],[\"writerindex\",{\"1\":{\"894\":5}}],[\"writer是基于outputstream构造的\",{\"1\":{\"58\":1}}],[\"writer定义了所有字符输出流的超类\",{\"1\":{\"58\":1}}],[\"writer\",{\"0\":{\"58\":1},\"1\":{\"69\":7,\"70\":4,\"113\":6}}],[\"write\",{\"0\":{\"1300\":1},\"1\":{\"54\":1,\"69\":3,\"70\":1,\"118\":1,\"123\":1,\"125\":6,\"128\":4,\"130\":1,\"132\":1,\"133\":1,\"253\":7,\"259\":1,\"880\":1,\"910\":1,\"1198\":2,\"1297\":1,\"1299\":3,\"1300\":9,\"1435\":2}}],[\"wrapnamespace\",{\"1\":{\"1458\":1}}],[\"wrapmultidispatch\",{\"1\":{\"1294\":1}}],[\"wrap\",{\"1\":{\"123\":1,\"125\":1,\"133\":1,\"1197\":1,\"1329\":1,\"1435\":1,\"1471\":1}}],[\"wrapper\",{\"0\":{\"65\":1},\"1\":{\"65\":2,\"508\":1}}],[\"width\",{\"1\":{\"180\":4,\"563\":1}}],[\"window窗口\",{\"0\":{\"153\":1}}],[\"window\",{\"1\":{\"151\":1,\"153\":1,\"312\":1,\"320\":1,\"333\":1,\"420\":1}}],[\"windows\",{\"1\":{\"52\":2,\"253\":2,\"288\":1}}],[\"windows不支持\",{\"1\":{\"21\":1}}],[\"without\",{\"1\":{\"1195\":1}}],[\"withoutnamespace\",{\"1\":{\"1020\":3,\"1053\":2,\"1197\":1,\"1471\":1}}],[\"withnamespace\",{\"1\":{\"1050\":1,\"1197\":1}}],[\"within\",{\"1\":{\"104\":2}}],[\"with\",{\"0\":{\"106\":1},\"1\":{\"97\":3,\"98\":2,\"104\":1,\"171\":4,\"196\":2,\"248\":1,\"396\":3,\"621\":2,\"628\":1,\"886\":2,\"892\":1,\"905\":1,\"1050\":1,\"1197\":1,\"1371\":1,\"1372\":1,\"1375\":3,\"1458\":1,\"1468\":1,\"1516\":2,\"1519\":1,\"1520\":1}}],[\"wildcards\",{\"1\":{\"49\":1,\"171\":1}}],[\"willneed\",{\"1\":{\"882\":1}}],[\"willanswer\",{\"1\":{\"103\":2}}],[\"will\",{\"1\":{\"11\":1,\"97\":1,\"396\":2,\"643\":3,\"870\":1,\"1005\":1,\"1056\":1,\"1174\":1,\"1270\":1,\"1277\":1,\"1372\":1,\"1373\":1,\"1468\":2,\"1519\":2,\"1521\":3}}],[\"wikipedia\",{\"1\":{\"119\":1}}],[\"wiki\",{\"1\":{\"16\":1,\"291\":1,\"1504\":1}}],[\"www\",{\"1\":{\"16\":1,\"264\":1,\"291\":1,\"350\":1,\"381\":1,\"642\":2,\"654\":1,\"692\":1,\"1299\":1}}],[\"+message\",{\"1\":{\"1441\":1}}],[\"+oo\",{\"1\":{\"1430\":1}}],[\"+alwayspretouch\",{\"1\":{\"1080\":1}}],[\"+1\",{\"1\":{\"945\":1,\"952\":1,\"967\":1,\"1197\":1,\"1198\":1,\"1453\":1}}],[\"+$\",{\"1\":{\"904\":1}}],[\"+2\",{\"1\":{\"655\":1}}],[\"+=\",{\"1\":{\"314\":2,\"320\":1,\"330\":1,\"331\":1,\"385\":1,\"767\":1,\"771\":2,\"845\":1,\"860\":1,\"882\":1,\"1174\":1,\"1280\":1,\"1370\":1,\"1427\":1,\"1428\":1,\"1435\":1,\"1480\":1}}],[\"++ff=unix\",{\"1\":{\"289\":2}}],[\"++\",{\"0\":{\"212\":1},\"1\":{\"184\":3,\"212\":2,\"259\":1,\"332\":1}}],[\"++next\",{\"1\":{\"131\":1}}],[\"+可以将内容复制到系统剪贴板\",{\"1\":{\"158\":1}}],[\"+\",{\"1\":{\"11\":1,\"41\":1,\"69\":3,\"70\":2,\"112\":3,\"113\":2,\"153\":16,\"154\":1,\"155\":2,\"158\":1,\"162\":15,\"163\":1,\"172\":1,\"180\":1,\"181\":1,\"182\":1,\"183\":1,\"184\":7,\"230\":1,\"253\":1,\"261\":1,\"297\":4,\"303\":4,\"309\":2,\"311\":1,\"316\":10,\"324\":1,\"329\":1,\"331\":2,\"332\":1,\"338\":1,\"339\":2,\"341\":4,\"342\":2,\"344\":2,\"345\":1,\"348\":1,\"351\":8,\"356\":1,\"361\":3,\"364\":2,\"374\":3,\"396\":4,\"401\":1,\"411\":1,\"425\":1,\"428\":1,\"431\":1,\"439\":1,\"442\":2,\"443\":3,\"446\":13,\"461\":1,\"468\":2,\"492\":1,\"500\":1,\"503\":1,\"511\":1,\"512\":1,\"533\":3,\"538\":2,\"545\":1,\"566\":2,\"626\":3,\"657\":1,\"690\":1,\"712\":7,\"737\":11,\"738\":7,\"742\":4,\"762\":1,\"765\":10,\"769\":1,\"771\":15,\"786\":2,\"787\":1,\"793\":2,\"797\":25,\"824\":1,\"825\":1,\"827\":1,\"845\":14,\"857\":1,\"860\":3,\"870\":3,\"894\":3,\"906\":1,\"960\":1,\"973\":2,\"999\":9,\"1021\":2,\"1047\":5,\"1048\":2,\"1050\":3,\"1053\":2,\"1056\":2,\"1075\":1,\"1122\":5,\"1123\":2,\"1140\":2,\"1168\":2,\"1171\":7,\"1173\":8,\"1174\":10,\"1180\":1,\"1190\":1,\"1195\":4,\"1197\":7,\"1198\":13,\"1200\":3,\"1201\":2,\"1226\":1,\"1240\":1,\"1255\":1,\"1269\":3,\"1270\":9,\"1273\":2,\"1275\":5,\"1276\":9,\"1278\":15,\"1279\":1,\"1280\":4,\"1287\":1,\"1296\":2,\"1297\":16,\"1309\":1,\"1310\":1,\"1323\":2,\"1331\":3,\"1333\":8,\"1339\":3,\"1364\":2,\"1368\":2,\"1370\":3,\"1371\":5,\"1372\":1,\"1373\":3,\"1374\":3,\"1425\":2,\"1427\":6,\"1431\":2,\"1432\":8,\"1434\":4,\"1435\":6,\"1436\":7,\"1443\":2,\"1459\":2,\"1460\":1,\"1462\":2,\"1467\":1,\"1468\":4,\"1472\":1,\"1488\":1,\"1491\":1,\"1497\":9,\"1499\":3,\"1516\":1,\"1517\":2,\"1519\":8,\"1520\":6,\"1521\":3}}],[\"b959cf8b6542\",{\"1\":{\"1079\":1}}],[\"b再发送给c\",{\"1\":{\"674\":1}}],[\"b节点上的mirror提升为master\",{\"1\":{\"659\":1}}],[\"b组成集群\",{\"1\":{\"659\":1}}],[\"b表示\",{\"1\":{\"516\":1}}],[\"b3wdgz4q7n\",{\"1\":{\"443\":1}}],[\"b7qpypjjb\",{\"1\":{\"429\":1}}],[\"b2\",{\"1\":{\"206\":3}}],[\"b1\",{\"1\":{\"206\":4}}],[\"br\",{\"1\":{\"1080\":3,\"1081\":1}}],[\"broadcast\",{\"1\":{\"1173\":1}}],[\"broadcasting\",{\"0\":{\"1090\":1},\"1\":{\"1088\":1,\"1122\":1,\"1143\":1,\"1173\":1,\"1195\":2,\"1230\":1,\"1266\":1}}],[\"brokerpathconfighelper\",{\"1\":{\"1523\":1}}],[\"brokermetricsmanager\",{\"1\":{\"1462\":2,\"1464\":6}}],[\"brokerminoffset=\",{\"1\":{\"1173\":1}}],[\"broker锁并开始消费\",{\"1\":{\"1215\":1}}],[\"broker锁\",{\"0\":{\"1211\":1,\"1221\":1,\"1222\":1},\"1\":{\"1209\":6,\"1212\":2,\"1213\":2,\"1215\":4,\"1218\":1,\"1219\":2,\"1224\":1}}],[\"broker是否可读\",{\"1\":{\"1173\":1}}],[\"broker地址找到注册在broker上的filterserver地址\",{\"1\":{\"1171\":1}}],[\"brokerbusy\",{\"1\":{\"1170\":4,\"1228\":4}}],[\"broker0\",{\"1\":{\"1080\":3}}],[\"broker2\",{\"1\":{\"1075\":1,\"1080\":3}}],[\"broker1\",{\"1\":{\"1075\":2,\"1080\":3}}],[\"brokerclustername\",{\"1\":{\"1075\":2}}],[\"brokercontroller\",{\"0\":{\"1067\":1,\"1424\":1},\"1\":{\"819\":4,\"820\":1,\"823\":1,\"824\":2,\"825\":3,\"952\":1,\"970\":1,\"990\":1,\"996\":1,\"1056\":6,\"1173\":31,\"1191\":1,\"1198\":12,\"1201\":2,\"1266\":3,\"1269\":4,\"1270\":16,\"1273\":6,\"1275\":5,\"1276\":6,\"1277\":4,\"1278\":6,\"1279\":3,\"1280\":6,\"1331\":4,\"1398\":1,\"1424\":1,\"1462\":10,\"1464\":7,\"1467\":5,\"1469\":3,\"1523\":1}}],[\"brokerconfig\",{\"1\":{\"762\":1,\"827\":1,\"850\":1,\"996\":1,\"1017\":1,\"1201\":1,\"1332\":1,\"1424\":4,\"1425\":1,\"1523\":1}}],[\"brokerip1=\",{\"1\":{\"1075\":2}}],[\"brokerip\",{\"1\":{\"1075\":1}}],[\"brokerid从mqclientinstance中获取broker地址\",{\"1\":{\"1171\":1}}],[\"brokerid\",{\"1\":{\"952\":1,\"965\":1,\"970\":3,\"971\":5,\"972\":2,\"1075\":2}}],[\"brokervipchannel\",{\"1\":{\"1053\":1}}],[\"brokerstats\",{\"1\":{\"1424\":2}}],[\"brokerstatsmanager\",{\"1\":{\"1173\":4,\"1174\":1,\"1424\":3}}],[\"brokerstartup\",{\"1\":{\"1079\":4}}],[\"brokers\",{\"1\":{\"1081\":1,\"1287\":1}}],[\"brokerssent\",{\"1\":{\"1050\":2}}],[\"brokersuspendmaxtimemillis\",{\"1\":{\"805\":1,\"812\":1,\"1171\":3}}],[\"brokerouterexecutor\",{\"1\":{\"970\":1}}],[\"brokerouterapi\",{\"1\":{\"970\":2}}],[\"brokerhousekeepingservice\",{\"1\":{\"961\":1}}],[\"brokerdata\",{\"1\":{\"971\":9,\"972\":6,\"1248\":1}}],[\"brokerdatas\",{\"1\":{\"950\":1,\"968\":3}}],[\"brokerdata>>\",{\"1\":{\"972\":1}}],[\"brokerdata>\",{\"1\":{\"949\":1,\"965\":1}}],[\"brokerliveinfo\",{\"1\":{\"967\":1,\"971\":6}}],[\"brokerliveinfo>>\",{\"1\":{\"972\":1}}],[\"brokerliveinfo>\",{\"1\":{\"949\":1,\"967\":1,\"972\":1}}],[\"brokerlivetable\",{\"0\":{\"967\":1},\"1\":{\"944\":1,\"949\":1,\"953\":1,\"954\":1,\"967\":1,\"971\":3,\"972\":2}}],[\"brokername=broker\",{\"1\":{\"1445\":13}}],[\"brokernamefound\",{\"1\":{\"972\":7}}],[\"brokernames\",{\"1\":{\"971\":5,\"972\":3}}],[\"brokername\",{\"1\":{\"949\":3,\"954\":1,\"964\":11,\"965\":2,\"966\":1,\"968\":4,\"970\":2,\"971\":6,\"972\":3,\"1075\":2,\"1197\":4,\"1271\":2,\"1288\":2,\"1420\":1,\"1427\":1,\"1430\":1}}],[\"brokeraddrfound\",{\"1\":{\"972\":10}}],[\"brokeraddrsmap\",{\"1\":{\"971\":2}}],[\"brokeraddrs\",{\"1\":{\"965\":2,\"968\":2,\"1248\":2}}],[\"brokeraddr\",{\"1\":{\"949\":2,\"950\":1,\"967\":1,\"968\":1,\"970\":2,\"971\":9,\"972\":4,\"1053\":9,\"1171\":4,\"1197\":2,\"1248\":2,\"1460\":3,\"1472\":3}}],[\"brokeraddrtable\",{\"0\":{\"965\":1},\"1\":{\"944\":1,\"945\":1,\"949\":1,\"953\":1,\"954\":1,\"957\":1,\"965\":1,\"971\":4,\"972\":4,\"973\":1,\"1053\":1}}],[\"brokerallowsuspend\",{\"1\":{\"819\":3,\"1173\":5,\"1273\":2}}],[\"broker处理再到消息被消费的流程\",{\"1\":{\"834\":1}}],[\"broker端是否允许挂起\",{\"1\":{\"819\":1,\"1173\":1}}],[\"broker断电就会存在数据丢失的情况\",{\"1\":{\"765\":1}}],[\"brokerrole\",{\"1\":{\"762\":1,\"827\":1,\"1075\":2,\"1173\":2,\"1297\":1,\"1464\":1}}],[\"broker启动时\",{\"1\":{\"753\":1,\"759\":1}}],[\"broker在内部都是通过actor模式实现的\",{\"1\":{\"621\":1}}],[\"broker\",{\"0\":{\"677\":1,\"742\":1,\"952\":1,\"970\":1,\"983\":1,\"990\":1,\"991\":1,\"996\":1,\"1000\":1,\"1005\":1,\"1033\":1,\"1043\":1,\"1054\":1,\"1055\":1,\"1153\":1,\"1162\":1,\"1197\":1,\"1198\":1,\"1201\":1,\"1209\":1,\"1242\":1,\"1255\":1,\"1256\":1,\"1260\":1,\"1261\":1,\"1265\":1,\"1268\":1,\"1272\":1,\"1274\":1,\"1286\":1,\"1328\":1,\"1382\":1,\"1450\":1,\"1451\":1,\"1453\":1,\"1461\":1,\"1466\":1},\"1\":{\"611\":2,\"614\":2,\"677\":1,\"678\":1,\"687\":1,\"720\":1,\"729\":1,\"736\":1,\"747\":1,\"757\":1,\"787\":2,\"789\":1,\"801\":1,\"803\":1,\"804\":1,\"805\":1,\"806\":2,\"809\":2,\"812\":2,\"814\":1,\"816\":1,\"827\":2,\"833\":1,\"834\":4,\"835\":1,\"836\":2,\"839\":1,\"840\":2,\"866\":3,\"883\":1,\"886\":2,\"887\":2,\"899\":1,\"906\":1,\"908\":1,\"911\":1,\"941\":10,\"944\":8,\"945\":9,\"947\":2,\"949\":6,\"950\":3,\"951\":3,\"952\":9,\"953\":4,\"954\":11,\"961\":4,\"963\":1,\"964\":20,\"965\":3,\"966\":1,\"967\":3,\"968\":5,\"970\":2,\"971\":13,\"972\":11,\"978\":1,\"979\":4,\"980\":3,\"983\":2,\"986\":2,\"987\":1,\"990\":4,\"996\":3,\"998\":1,\"1000\":1,\"1003\":3,\"1004\":1,\"1005\":2,\"1010\":2,\"1011\":1,\"1012\":4,\"1015\":1,\"1017\":4,\"1021\":2,\"1024\":3,\"1027\":4,\"1028\":2,\"1029\":5,\"1030\":5,\"1032\":4,\"1033\":4,\"1035\":1,\"1036\":1,\"1037\":1,\"1039\":6,\"1041\":5,\"1042\":2,\"1043\":2,\"1052\":12,\"1053\":4,\"1056\":1,\"1061\":1,\"1075\":20,\"1079\":8,\"1080\":5,\"1081\":2,\"1086\":1,\"1093\":1,\"1094\":3,\"1095\":1,\"1097\":5,\"1098\":1,\"1100\":1,\"1101\":1,\"1102\":2,\"1103\":8,\"1104\":4,\"1109\":1,\"1112\":1,\"1117\":2,\"1118\":2,\"1119\":2,\"1120\":4,\"1122\":2,\"1123\":2,\"1125\":1,\"1128\":5,\"1130\":3,\"1136\":8,\"1137\":3,\"1138\":2,\"1143\":1,\"1145\":4,\"1147\":2,\"1149\":2,\"1152\":1,\"1153\":1,\"1155\":2,\"1156\":2,\"1160\":1,\"1163\":1,\"1169\":1,\"1170\":4,\"1171\":4,\"1173\":7,\"1174\":1,\"1177\":1,\"1179\":2,\"1180\":2,\"1181\":1,\"1183\":4,\"1187\":2,\"1188\":9,\"1190\":5,\"1191\":6,\"1195\":3,\"1197\":8,\"1198\":4,\"1200\":8,\"1203\":1,\"1209\":5,\"1212\":3,\"1214\":4,\"1218\":1,\"1219\":1,\"1224\":1,\"1225\":2,\"1226\":3,\"1228\":3,\"1234\":5,\"1245\":3,\"1248\":1,\"1249\":2,\"1250\":3,\"1251\":4,\"1252\":5,\"1253\":2,\"1255\":4,\"1257\":1,\"1266\":1,\"1286\":1,\"1287\":1,\"1288\":2,\"1297\":1,\"1308\":1,\"1312\":2,\"1313\":1,\"1314\":1,\"1317\":1,\"1318\":1,\"1319\":1,\"1321\":1,\"1331\":1,\"1338\":1,\"1362\":1,\"1370\":1,\"1379\":3,\"1382\":1,\"1383\":2,\"1395\":2,\"1397\":1,\"1398\":1,\"1405\":1,\"1420\":5,\"1432\":1,\"1449\":4,\"1450\":1,\"1451\":5,\"1453\":2,\"1454\":3,\"1459\":1,\"1460\":4,\"1462\":1,\"1468\":1,\"1471\":3,\"1472\":12,\"1507\":3,\"1509\":1}}],[\"brown\",{\"1\":{\"176\":1}}],[\"break\",{\"1\":{\"69\":1,\"70\":1,\"722\":1,\"764\":2,\"771\":3,\"794\":3,\"797\":3,\"819\":1,\"861\":4,\"870\":3,\"872\":1,\"972\":3,\"1021\":1,\"1047\":2,\"1048\":2,\"1050\":3,\"1053\":3,\"1122\":5,\"1123\":2,\"1143\":3,\"1144\":3,\"1172\":1,\"1173\":19,\"1174\":1,\"1175\":4,\"1194\":1,\"1195\":6,\"1198\":1,\"1224\":3,\"1230\":5,\"1266\":3,\"1278\":4,\"1279\":1,\"1297\":1,\"1331\":3,\"1370\":1,\"1371\":3,\"1372\":1,\"1374\":2,\"1427\":3,\"1436\":1,\"1459\":3,\"1460\":4,\"1468\":5,\"1472\":4,\"1497\":7,\"1499\":5,\"1519\":16,\"1520\":8,\"1521\":1}}],[\"bt\",{\"1\":{\"171\":1,\"399\":1}}],[\"bdd剪切当前行到寄存器b中\",{\"1\":{\"157\":1}}],[\"bddmockito\",{\"1\":{\"103\":1}}],[\"bfirst\",{\"1\":{\"152\":1}}],[\"bnext\",{\"1\":{\"152\":1}}],[\"bpre\",{\"1\":{\"152\":1}}],[\"batchpendingmap\",{\"1\":{\"1519\":2}}],[\"batchappendfuture<>\",{\"1\":{\"1518\":1}}],[\"batchappendfuture<appendentryresponse>\",{\"1\":{\"1516\":2}}],[\"batchappendfuture\",{\"1\":{\"1516\":3,\"1518\":1}}],[\"batchappendentryrequest\",{\"1\":{\"1516\":4,\"1519\":7}}],[\"batchrequest\",{\"1\":{\"1516\":5}}],[\"batchsize=\",{\"1\":{\"1432\":1}}],[\"batchsize\",{\"1\":{\"1021\":3,\"1431\":3,\"1432\":5}}],[\"batch\",{\"0\":{\"773\":1,\"905\":1,\"1044\":1},\"1\":{\"658\":1,\"720\":1,\"736\":1,\"742\":1,\"773\":2,\"870\":1,\"886\":1,\"905\":1,\"1055\":1,\"1431\":1,\"1520\":3}}],[\"basicpublish\",{\"1\":{\"712\":1,\"714\":1,\"715\":1}}],[\"basicproperties\",{\"1\":{\"685\":1,\"714\":2,\"715\":2}}],[\"basicconsume\",{\"1\":{\"665\":1}}],[\"basicqos\",{\"1\":{\"616\":1}}],[\"baseinfo\",{\"1\":{\"1519\":1,\"1520\":3}}],[\"baseoffset\",{\"1\":{\"1420\":2}}],[\"base\",{\"1\":{\"1072\":2}}],[\"based\",{\"1\":{\"621\":2,\"886\":1}}],[\"baseurl\",{\"1\":{\"601\":3}}],[\"baz\",{\"1\":{\"553\":1}}],[\"banana\",{\"1\":{\"253\":2,\"325\":1}}],[\"bag\",{\"1\":{\"248\":6}}],[\"badly\",{\"1\":{\"1173\":2,\"1174\":1,\"1175\":1,\"1270\":1,\"1430\":2,\"1431\":1,\"1432\":1}}],[\"bad\",{\"1\":{\"192\":1,\"256\":3,\"886\":1}}],[\"backtopic\",{\"1\":{\"1198\":3}}],[\"backtrace\",{\"1\":{\"171\":1}}],[\"backup\",{\"1\":{\"843\":1}}],[\"back\",{\"1\":{\"720\":1,\"722\":2,\"1055\":1,\"1197\":1,\"1464\":1,\"1468\":1}}],[\"backingqueue的设计有点类似于linux的虚拟内存swap区\",{\"1\":{\"690\":1}}],[\"backingqueue由q1\",{\"1\":{\"690\":1}}],[\"backingqueue\",{\"1\":{\"689\":1}}],[\"backing\",{\"1\":{\"671\":1,\"672\":4}}],[\"backword\",{\"1\":{\"145\":1}}],[\"bar\",{\"1\":{\"143\":1,\"516\":3,\"551\":2,\"553\":1,\"589\":2}}],[\"baeldung\",{\"1\":{\"105\":2}}],[\"bldr\",{\"1\":{\"714\":2,\"715\":2}}],[\"blue\",{\"1\":{\"582\":2,\"583\":2}}],[\"blrszjm0wizwlk5acqnu7o2fzpoaculowgczssgfvba4dcqrvain2qob4p\",{\"1\":{\"469\":1}}],[\"bloomdatavalid\",{\"1\":{\"1333\":1}}],[\"bloom\",{\"1\":{\"1332\":1,\"1333\":2}}],[\"bloomfilterdata\",{\"1\":{\"1323\":7,\"1331\":3}}],[\"bloomfilter\",{\"0\":{\"1322\":1},\"1\":{\"1323\":1,\"1331\":1,\"1333\":3}}],[\"blog\",{\"1\":{\"692\":1}}],[\"blocks\",{\"1\":{\"625\":2,\"627\":2}}],[\"blocked的列表中删除\",{\"1\":{\"627\":1}}],[\"blocked的值是一个进程id列表\",{\"1\":{\"625\":1}}],[\"blocked的值\",{\"1\":{\"625\":1}}],[\"blocked列表\",{\"1\":{\"627\":1}}],[\"blocked中\",{\"1\":{\"625\":1}}],[\"blocked\",{\"1\":{\"625\":6,\"626\":1,\"627\":4,\"860\":1}}],[\"blockedlistener\",{\"1\":{\"613\":1}}],[\"block\",{\"1\":{\"624\":2,\"625\":2,\"860\":1}}],[\"blockingqueue<pair<pushentryrequest\",{\"1\":{\"1520\":1}}],[\"blockingqueue\",{\"1\":{\"1014\":1,\"1348\":1}}],[\"blocking\",{\"1\":{\"118\":3,\"1021\":1}}],[\"blob\",{\"1\":{\"272\":1,\"1025\":1}}],[\"blank\",{\"1\":{\"765\":1,\"1368\":4}}],[\"blast\",{\"1\":{\"152\":1}}],[\"blackhole\",{\"1\":{\"11\":2}}],[\"biz\",{\"1\":{\"1280\":1}}],[\"bitnum\",{\"1\":{\"1323\":1}}],[\"bitpos\",{\"1\":{\"1323\":2}}],[\"bitmap=\",{\"1\":{\"1333\":1}}],[\"bitmap\",{\"1\":{\"904\":1,\"1262\":2,\"1333\":1}}],[\"bit\",{\"1\":{\"825\":1,\"904\":2,\"1276\":1,\"1277\":1,\"1278\":2,\"1332\":4,\"1333\":1}}],[\"bitsarray\",{\"1\":{\"1323\":5,\"1332\":2,\"1333\":7}}],[\"bits\",{\"1\":{\"390\":5,\"1323\":3}}],[\"bitstringexpr\",{\"1\":{\"184\":2}}],[\"bitstringpattern\",{\"1\":{\"184\":1}}],[\"bitstring\",{\"1\":{\"184\":1}}],[\"bigger\",{\"1\":{\"1519\":1}}],[\"biggerledgernum=\",{\"1\":{\"1497\":1}}],[\"biggerledgernum\",{\"1\":{\"1497\":4}}],[\"bigint\",{\"1\":{\"506\":1,\"508\":1,\"518\":1,\"583\":1}}],[\"bigwigs\",{\"1\":{\"491\":1}}],[\"bio>\",{\"1\":{\"113\":2}}],[\"biohandler\",{\"1\":{\"112\":1,\"113\":2}}],[\"bioserver\",{\"1\":{\"112\":2,\"113\":4}}],[\"bio\",{\"0\":{\"111\":1,\"112\":1,\"113\":1},\"1\":{\"109\":1,\"111\":1,\"116\":2}}],[\"binary\",{\"1\":{\"256\":1}}],[\"bindingkey\",{\"1\":{\"712\":1}}],[\"binding\",{\"1\":{\"171\":1}}],[\"bindings\",{\"1\":{\"171\":2}}],[\"bind\",{\"1\":{\"121\":1,\"133\":1}}],[\"bin目录用于存放编译后的class文件\",{\"1\":{\"21\":1}}],[\"bin\",{\"1\":{\"21\":7,\"23\":2,\"224\":1,\"256\":2,\"1441\":1}}],[\"behind\",{\"1\":{\"1427\":1,\"1520\":1}}],[\"behave\",{\"1\":{\"97\":1}}],[\"because\",{\"1\":{\"738\":1,\"972\":6,\"1144\":2,\"1170\":1,\"1195\":1,\"1224\":1,\"1228\":1,\"1230\":4,\"1270\":3,\"1333\":1}}],[\"become\",{\"1\":{\"625\":2}}],[\"been\",{\"1\":{\"720\":1,\"722\":2,\"1047\":1,\"1048\":1,\"1053\":1,\"1122\":1,\"1123\":1,\"1468\":1,\"1497\":1}}],[\"beta\",{\"1\":{\"690\":2}}],[\"betterblizzframes\",{\"1\":{\"491\":1}}],[\"between\",{\"0\":{\"97\":1,\"98\":1},\"1\":{\"1308\":4,\"1310\":1}}],[\"beijing\",{\"1\":{\"294\":1,\"316\":2}}],[\"beatlatch\",{\"1\":{\"1499\":4}}],[\"bear\",{\"1\":{\"181\":1}}],[\"beam\",{\"1\":{\"180\":2}}],[\"beans\",{\"1\":{\"1020\":4}}],[\"bean等条件进行装配\",{\"1\":{\"84\":1}}],[\"beanname\",{\"1\":{\"82\":2}}],[\"bean标注的方法创建bean\",{\"1\":{\"82\":1}}],[\"bean\",{\"0\":{\"82\":1},\"1\":{\"89\":1,\"371\":1,\"1020\":1}}],[\"beginning\",{\"1\":{\"1122\":1}}],[\"beginstarttime\",{\"1\":{\"1053\":3}}],[\"beginindex\",{\"1\":{\"894\":5}}],[\"beginlocktimestamp\",{\"1\":{\"824\":2}}],[\"beginphyoffset\",{\"1\":{\"787\":1}}],[\"begintimemillis\",{\"1\":{\"1462\":2}}],[\"begintimemills\",{\"1\":{\"738\":1,\"1173\":2}}],[\"begintime\",{\"1\":{\"882\":1,\"1174\":2,\"1230\":2,\"1436\":16}}],[\"begintimestampprev\",{\"1\":{\"1050\":4}}],[\"begintimestampfirst\",{\"1\":{\"1050\":4}}],[\"begintimestamp\",{\"1\":{\"787\":1,\"789\":1,\"1170\":1,\"1175\":1,\"1195\":2,\"1229\":1,\"1230\":2,\"1420\":2,\"1434\":1,\"1436\":1}}],[\"begin\",{\"1\":{\"165\":1,\"205\":1,\"624\":1,\"789\":3,\"790\":1,\"794\":6,\"797\":5,\"870\":1,\"1170\":1,\"1435\":1,\"1467\":5,\"1519\":4}}],[\"below\",{\"1\":{\"142\":1,\"687\":1}}],[\"best\",{\"1\":{\"137\":1,\"717\":1,\"1231\":1}}],[\"be\",{\"1\":{\"97\":1,\"253\":1,\"396\":4,\"624\":1,\"643\":3,\"870\":1,\"998\":1,\"1005\":1,\"1008\":1,\"1053\":1,\"1056\":1,\"1173\":1,\"1195\":1,\"1200\":1,\"1230\":4,\"1277\":2,\"1333\":1,\"1371\":1,\"1372\":1,\"1373\":1,\"1427\":2,\"1436\":1,\"1444\":1,\"1468\":5,\"1497\":1}}],[\"before\",{\"1\":{\"97\":1,\"99\":1,\"142\":1,\"870\":1,\"981\":1,\"988\":1,\"989\":1,\"994\":1,\"995\":1,\"1014\":1,\"1047\":1,\"1048\":1,\"1053\":1,\"1122\":1,\"1123\":1,\"1197\":1,\"1266\":1,\"1333\":1,\"1468\":1}}],[\"benchmarktest\",{\"1\":{\"964\":1}}],[\"benchmarks\",{\"1\":{\"10\":1}}],[\"benchmark\",{\"1\":{\"7\":2,\"9\":4,\"10\":1,\"11\":4,\"15\":1,\"741\":1,\"917\":1,\"968\":1}}],[\"benchmarkmode\",{\"1\":{\"4\":1,\"9\":1}}],[\"bysql\",{\"1\":{\"1310\":1}}],[\"by\",{\"1\":{\"624\":1,\"771\":1,\"825\":1,\"1097\":1,\"1171\":1,\"1173\":4,\"1174\":1,\"1198\":1,\"1328\":1,\"1333\":3,\"1372\":1,\"1471\":1,\"1472\":1,\"1503\":1}}],[\"byid\",{\"1\":{\"91\":2}}],[\"bye\",{\"1\":{\"69\":2,\"70\":1}}],[\"byte>\",{\"1\":{\"1000\":3}}],[\"byte2string\",{\"1\":{\"900\":1}}],[\"bytebuf\",{\"1\":{\"894\":7,\"917\":1}}],[\"bytebufferindex\",{\"1\":{\"765\":6}}],[\"bytebuffer\",{\"1\":{\"123\":1,\"124\":4,\"125\":2,\"133\":1,\"137\":1,\"729\":2,\"730\":2,\"737\":4,\"738\":5,\"765\":3,\"771\":6,\"882\":3,\"883\":1,\"894\":2,\"899\":1,\"900\":1,\"1318\":2,\"1329\":4,\"1333\":1,\"1368\":7,\"1371\":1,\"1417\":1,\"1427\":6,\"1428\":2,\"1432\":5,\"1434\":4,\"1435\":16,\"1436\":2,\"1471\":4,\"1517\":2}}],[\"bytes2string\",{\"1\":{\"738\":1}}],[\"bytes\",{\"1\":{\"125\":5,\"390\":5,\"720\":1,\"894\":1,\"1056\":1,\"1332\":1,\"1435\":1,\"1436\":6}}],[\"bytearrayoutputstream\",{\"1\":{\"54\":1}}],[\"bytearrayinputstream\",{\"1\":{\"53\":1}}],[\"byte\",{\"1\":{\"53\":2,\"72\":3,\"73\":3,\"125\":2,\"396\":1,\"687\":1,\"720\":1,\"737\":6,\"825\":1,\"828\":1,\"882\":1,\"893\":1,\"894\":3,\"970\":1,\"973\":1,\"995\":3,\"1000\":2,\"1053\":1,\"1056\":1,\"1173\":1,\"1277\":1,\"1280\":1,\"1333\":2,\"1368\":1,\"1382\":1,\"1418\":3,\"1435\":2,\"1436\":4}}],[\"bump\",{\"1\":{\"626\":4}}],[\"buflen\",{\"1\":{\"625\":9}}],[\"buf\",{\"1\":{\"625\":8}}],[\"buff\",{\"1\":{\"406\":1}}],[\"bufferfetchexecutor\",{\"1\":{\"1436\":1}}],[\"bufferfull\",{\"1\":{\"1427\":2}}],[\"bufferresult\",{\"1\":{\"1431\":2,\"1432\":7}}],[\"buffer=\",{\"1\":{\"1428\":1}}],[\"bufferlist\",{\"1\":{\"1428\":5,\"1432\":3}}],[\"buffersize\",{\"1\":{\"1427\":3,\"1428\":7}}],[\"buffercommitexecutor\",{\"1\":{\"1427\":1}}],[\"bufferconsumequeue\",{\"1\":{\"767\":6,\"1174\":7}}],[\"buffercq\",{\"1\":{\"845\":8,\"860\":7,\"1370\":7}}],[\"buffer缓冲区\",{\"0\":{\"152\":1}}],[\"buffer可视化的分割区域\",{\"1\":{\"151\":1}}],[\"buffer\",{\"0\":{\"1300\":1},\"1\":{\"72\":3,\"73\":3,\"118\":3,\"124\":4,\"125\":6,\"136\":1,\"151\":1,\"152\":1,\"267\":2,\"724\":4,\"725\":1,\"736\":1,\"738\":1,\"886\":1,\"900\":2,\"1259\":1,\"1260\":1,\"1262\":5,\"1275\":3,\"1276\":2,\"1277\":7,\"1299\":3,\"1300\":18,\"1333\":3,\"1368\":1,\"1372\":1,\"1406\":1,\"1408\":1,\"1432\":2,\"1435\":10,\"1436\":5,\"1517\":2}}],[\"bufferedinputstream\",{\"1\":{\"960\":1}}],[\"bufferedreader\",{\"1\":{\"69\":1,\"70\":1,\"113\":2}}],[\"bufferedwriter\",{\"1\":{\"69\":1,\"70\":1}}],[\"bufferedoutputstream\",{\"1\":{\"54\":2}}],[\"bug\",{\"1\":{\"473\":1,\"765\":1,\"845\":2,\"860\":2,\"1053\":1,\"1144\":1,\"1174\":1,\"1175\":1,\"1297\":4,\"1332\":2,\"1437\":1,\"1500\":3,\"1503\":2,\"1520\":1}}],[\"bus\",{\"1\":{\"266\":1}}],[\"buildresponse\",{\"1\":{\"1520\":14}}],[\"buildhalftopic\",{\"1\":{\"1463\":1}}],[\"buildmsgoffsetinfo\",{\"1\":{\"1270\":1}}],[\"buildmqclientid\",{\"1\":{\"1235\":1}}],[\"buildstartoffsetinfo\",{\"1\":{\"1270\":1}}],[\"buildsysflag\",{\"1\":{\"1170\":1,\"1198\":1}}],[\"buildordercountinfo\",{\"1\":{\"1270\":1}}],[\"buildpushrequest\",{\"1\":{\"1519\":5}}],[\"buildpopretrytopic\",{\"1\":{\"1269\":2,\"1270\":1,\"1280\":1}}],[\"buildplainaccessresource\",{\"1\":{\"998\":1}}],[\"buildconsumemessagecontext\",{\"1\":{\"1198\":1}}],[\"buildcommandlineoptions\",{\"1\":{\"960\":2}}],[\"buildindex\",{\"1\":{\"789\":1,\"794\":2}}],[\"building\",{\"1\":{\"643\":1,\"794\":1}}],[\"buildkey\",{\"1\":{\"786\":1,\"794\":3,\"822\":1,\"825\":1,\"886\":1,\"906\":2,\"1434\":1,\"1436\":2}}],[\"build\",{\"0\":{\"1425\":1},\"1\":{\"714\":1,\"715\":1,\"756\":1,\"765\":2,\"794\":1,\"1072\":3,\"1173\":2,\"1424\":1,\"1425\":1,\"1427\":1,\"1428\":1,\"1464\":3}}],[\"builder\",{\"1\":{\"714\":2,\"715\":2}}],[\"builddate\",{\"1\":{\"316\":2}}],[\"build>\",{\"1\":{\"64\":1}}],[\"built\",{\"1\":{\"185\":1}}],[\"buy\",{\"1\":{\"253\":1}}],[\"buy3\",{\"1\":{\"177\":1}}],[\"buy3|things3\",{\"1\":{\"177\":1}}],[\"buy2\",{\"1\":{\"177\":2}}],[\"buy1\",{\"1\":{\"177\":1}}],[\"buy1|things2\",{\"1\":{\"177\":1}}],[\"but\",{\"1\":{\"103\":1,\"820\":1,\"845\":1,\"870\":1,\"1000\":1,\"1143\":2,\"1170\":1,\"1174\":1,\"1228\":1,\"1372\":1,\"1459\":1,\"1472\":1,\"1500\":3,\"1503\":1}}],[\"b\",{\"0\":{\"889\":1,\"892\":1},\"1\":{\"53\":2,\"54\":1,\"145\":2,\"152\":2,\"171\":2,\"178\":2,\"184\":8,\"192\":5,\"212\":2,\"213\":2,\"248\":5,\"298\":14,\"303\":3,\"309\":5,\"332\":4,\"333\":1,\"423\":1,\"516\":2,\"518\":2,\"520\":1,\"527\":1,\"538\":3,\"553\":1,\"562\":1,\"576\":5,\"578\":1,\"579\":5,\"584\":2,\"586\":3,\"591\":1,\"627\":2,\"674\":1,\"742\":3,\"886\":2,\"889\":1,\"890\":1,\"891\":2,\"892\":1,\"894\":1,\"905\":1,\"1075\":5,\"1308\":1}}],[\"borrowbuffer\",{\"1\":{\"1428\":1}}],[\"born=\",{\"1\":{\"1468\":1}}],[\"borntime\",{\"1\":{\"1464\":2}}],[\"borntimestamp=1737222654479\",{\"1\":{\"1445\":1}}],[\"borntimestamp=1737222654439\",{\"1\":{\"1445\":1}}],[\"borntimestamp=1737222654398\",{\"1\":{\"1445\":1}}],[\"borntimestamp\",{\"1\":{\"737\":2,\"742\":1}}],[\"bornhost=\",{\"1\":{\"1445\":3}}],[\"bornhostlength\",{\"1\":{\"737\":1}}],[\"bornhostholder\",{\"1\":{\"737\":2}}],[\"bornhost\",{\"1\":{\"737\":2}}],[\"bottlenecks\",{\"1\":{\"628\":1}}],[\"both\",{\"1\":{\"97\":1,\"289\":1}}],[\"box<string>\",{\"1\":{\"578\":1}}],[\"box<type>\",{\"1\":{\"578\":1}}],[\"box\",{\"1\":{\"563\":2,\"578\":1}}],[\"boxing\",{\"1\":{\"30\":1}}],[\"boss\",{\"0\":{\"424\":1,\"430\":1,\"437\":1,\"444\":1,\"450\":1,\"456\":1,\"463\":1,\"470\":1},\"1\":{\"399\":1,\"401\":1,\"413\":1,\"422\":3,\"425\":3,\"426\":2,\"427\":1,\"428\":3,\"432\":1,\"434\":2,\"438\":2,\"439\":1,\"440\":1,\"441\":3,\"443\":1,\"445\":2,\"446\":1,\"448\":1,\"451\":1,\"452\":1,\"453\":1,\"457\":1,\"458\":2,\"459\":3,\"464\":1,\"466\":1,\"473\":1,\"491\":2,\"492\":1}}],[\"bo\",{\"1\":{\"266\":1}}],[\"bodys\",{\"1\":{\"1516\":3}}],[\"bodysize\",{\"1\":{\"894\":2}}],[\"body=\",{\"1\":{\"1445\":3}}],[\"bodycrc=988340972\",{\"1\":{\"1445\":1}}],[\"bodycrc=1401636825\",{\"1\":{\"1445\":1}}],[\"bodycrc=601994070\",{\"1\":{\"1445\":1}}],[\"bodycrc32\",{\"1\":{\"970\":2}}],[\"bodycrc\",{\"1\":{\"737\":2}}],[\"body\",{\"1\":{\"737\":4,\"787\":2,\"894\":2,\"970\":3,\"1053\":2,\"1056\":2,\"1287\":2,\"1517\":1}}],[\"bodylength\",{\"1\":{\"737\":10,\"1017\":1}}],[\"body2\",{\"1\":{\"187\":1}}],[\"body1\",{\"1\":{\"187\":1}}],[\"bool\",{\"1\":{\"591\":4}}],[\"booleancanonicalname2\",{\"1\":{\"742\":1}}],[\"booleancanonicalname1\",{\"1\":{\"742\":1}}],[\"boolean|string\",{\"1\":{\"558\":1}}],[\"boolean等在\",{\"1\":{\"506\":1}}],[\"boolean\",{\"1\":{\"125\":2,\"333\":3,\"396\":1,\"503\":1,\"504\":1,\"506\":1,\"508\":2,\"518\":1,\"527\":1,\"539\":1,\"558\":8,\"562\":1,\"568\":3,\"606\":2,\"726\":1,\"742\":5,\"762\":1,\"765\":1,\"769\":1,\"790\":1,\"793\":2,\"794\":1,\"797\":4,\"819\":1,\"825\":1,\"860\":2,\"870\":5,\"904\":3,\"960\":1,\"961\":2,\"970\":2,\"971\":1,\"972\":2,\"997\":1,\"1000\":1,\"1017\":2,\"1019\":1,\"1021\":2,\"1047\":2,\"1050\":1,\"1053\":4,\"1056\":1,\"1066\":1,\"1122\":1,\"1142\":1,\"1143\":3,\"1144\":3,\"1170\":3,\"1173\":5,\"1174\":3,\"1175\":1,\"1194\":1,\"1195\":2,\"1197\":1,\"1200\":1,\"1224\":3,\"1225\":1,\"1226\":2,\"1228\":1,\"1229\":1,\"1230\":2,\"1269\":1,\"1270\":2,\"1271\":1,\"1273\":1,\"1275\":1,\"1276\":1,\"1277\":1,\"1297\":5,\"1318\":2,\"1323\":1,\"1328\":1,\"1331\":1,\"1332\":2,\"1333\":5,\"1370\":1,\"1371\":5,\"1373\":1,\"1374\":2,\"1424\":2,\"1427\":4,\"1428\":1,\"1430\":1,\"1435\":2,\"1462\":2,\"1468\":1,\"1499\":3,\"1503\":1,\"1518\":1,\"1519\":1,\"1521\":1}}],[\"book\",{\"1\":{\"191\":5}}],[\"boots靴子\",{\"1\":{\"486\":1}}],[\"boot<\",{\"1\":{\"95\":1}}],[\"boot应用可以自动重启\",{\"1\":{\"95\":1}}],[\"boot提供了一个开发者工具\",{\"1\":{\"95\":1}}],[\"boot\",{\"0\":{\"94\":1},\"1\":{\"95\":1,\"266\":1,\"269\":1,\"272\":2}}],[\"boot在此基础上进一步提供了基于配置\",{\"1\":{\"84\":1}}],[\"bounds\",{\"1\":{\"49\":1}}],[\"bob\",{\"1\":{\"41\":1,\"294\":2,\"301\":2}}],[\"来进行仲裁\",{\"1\":{\"1521\":1}}],[\"来决定返回的结果\",{\"1\":{\"1430\":1,\"1432\":1}}],[\"来恢复对应的\",{\"1\":{\"1421\":1}}],[\"来作为插件进行接入的\",{\"1\":{\"1397\":1}}],[\"来降低成本\",{\"1\":{\"1378\":1}}],[\"来指定延迟时间或定时时间\",{\"1\":{\"1339\":1}}],[\"来指导架构提升自身的韧性能力\",{\"1\":{\"277\":1}}],[\"来\",{\"1\":{\"1263\":1}}],[\"来匹配\",{\"1\":{\"1261\":1,\"1262\":1}}],[\"来尝试匹配\",{\"1\":{\"1253\":1}}],[\"来修改单条消息的不可见时间\",{\"1\":{\"1251\":1}}],[\"来标记哪些消息成功了\",{\"1\":{\"1195\":1}}],[\"来真正发送拉取请求\",{\"1\":{\"1155\":1}}],[\"来发送命令\",{\"1\":{\"1036\":1}}],[\"来自\",{\"1\":{\"950\":1,\"968\":1}}],[\"来算\",{\"1\":{\"927\":1}}],[\"来写入\",{\"1\":{\"912\":1}}],[\"来写\",{\"1\":{\"912\":1}}],[\"来说依赖太重\",{\"1\":{\"942\":1}}],[\"来说\",{\"1\":{\"878\":2}}],[\"来判断该消息是否要投递\",{\"1\":{\"845\":1}}],[\"来配置\",{\"1\":{\"787\":2}}],[\"来配置镜像策略\",{\"1\":{\"652\":1}}],[\"来存储\",{\"1\":{\"787\":1}}],[\"来定时持久化的\",{\"1\":{\"768\":1}}],[\"来构建\",{\"1\":{\"756\":1}}],[\"来达到批量处理的目的\",{\"1\":{\"724\":1}}],[\"来让操作系统分配物理内存空间\",{\"1\":{\"882\":1}}],[\"来让消息在多个队列中负载均衡\",{\"1\":{\"707\":1}}],[\"来让人更方便地发现分布式系统可能存在的缺陷和不足\",{\"1\":{\"283\":1}}],[\"来控制每个消费者消费的队列和拉取的消息\",{\"1\":{\"1095\":1}}],[\"来控制\",{\"1\":{\"664\":1}}],[\"来替代镜像队列\",{\"1\":{\"648\":1}}],[\"来提交消费进度\",{\"1\":{\"1270\":1}}],[\"来提升写入速度\",{\"1\":{\"912\":1}}],[\"来提供高可用性\",{\"1\":{\"648\":1}}],[\"来提取该字段\",{\"1\":{\"191\":1}}],[\"来看一下进程字典中关于信用证的信息\",{\"1\":{\"624\":1}}],[\"来奶人\",{\"1\":{\"471\":1}}],[\"来补断寒冰箭雨\",{\"1\":{\"455\":1}}],[\"来在某一轮帮吃球开无敌顶掉\",{\"1\":{\"433\":1}}],[\"来打输出\",{\"1\":{\"403\":1}}],[\"来了读成长\",{\"1\":{\"399\":1}}],[\"来实现主从切换\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"来实现\",{\"1\":{\"976\":1}}],[\"来实现pull消息请求的二次处理\",{\"1\":{\"820\":1}}],[\"来实现面向对象编程\",{\"1\":{\"339\":1}}],[\"来实现静态泛型方法\",{\"1\":{\"47\":1}}],[\"来转换任意类型到string\",{\"1\":{\"333\":1}}],[\"来转换任意类型到number\",{\"1\":{\"333\":1}}],[\"来触发扩缩容动作\",{\"1\":{\"285\":1}}],[\"来观察\",{\"1\":{\"277\":1}}],[\"来执行主从切换\",{\"1\":{\"1481\":1}}],[\"来执行最终的消息消费逻辑\",{\"1\":{\"1119\":1}}],[\"来执行\",{\"1\":{\"1109\":1}}],[\"来执行定时任务\",{\"1\":{\"840\":1}}],[\"来执行与之前相同的跟踪\",{\"1\":{\"261\":1}}],[\"来执行的\",{\"1\":{\"64\":1}}],[\"来对表里的行进行定义\",{\"1\":{\"253\":1}}],[\"来表示某个整数\",{\"1\":{\"172\":1}}],[\"来管理和保存该锁\",{\"1\":{\"1209\":1}}],[\"来管理\",{\"1\":{\"131\":1}}],[\"来处理消息拉取任务拉取成功后提交的消费任务\",{\"1\":{\"1217\":1}}],[\"来处理消息拉取\",{\"1\":{\"1155\":1}}],[\"来处理\",{\"1\":{\"78\":1}}],[\"来保证没有多个消费者在重平衡后同时消费一个队列\",{\"1\":{\"1209\":1}}],[\"来保证outputstream正确关闭\",{\"1\":{\"54\":1}}],[\"来保证\",{\"1\":{\"53\":1}}],[\"来创建一个临时文件\",{\"1\":{\"52\":1}}],[\"来运行测试\",{\"1\":{\"10\":1}}],[\"来调用\",{\"1\":{\"4\":1}}],[\"v4\",{\"1\":{\"1171\":1}}],[\"vm\",{\"1\":{\"1079\":3}}],[\"vmtool\",{\"1\":{\"266\":3}}],[\"v6\",{\"1\":{\"738\":1}}],[\"voteresult\",{\"1\":{\"1503\":11}}],[\"voteresponse\",{\"1\":{\"1497\":13,\"1502\":4,\"1503\":22}}],[\"voterequest\",{\"1\":{\"1502\":11,\"1503\":1}}],[\"voted\",{\"1\":{\"1497\":1,\"1503\":1}}],[\"votelatch\",{\"1\":{\"1497\":4}}],[\"voteforquorumresponses\",{\"0\":{\"1502\":1},\"1\":{\"1491\":1,\"1497\":1,\"1502\":1}}],[\"vote\",{\"1\":{\"1480\":1,\"1497\":7,\"1502\":1,\"1503\":1}}],[\"volumes\",{\"1\":{\"1075\":1}}],[\"volatile\",{\"1\":{\"726\":1,\"1021\":3,\"1168\":1}}],[\"void\",{\"0\":{\"101\":1,\"102\":1,\"541\":1},\"1\":{\"9\":3,\"34\":1,\"41\":2,\"69\":3,\"70\":2,\"99\":5,\"101\":2,\"102\":2,\"105\":1,\"106\":1,\"112\":1,\"113\":3,\"122\":3,\"123\":1,\"125\":4,\"126\":2,\"128\":3,\"129\":2,\"133\":1,\"134\":2,\"396\":2,\"533\":2,\"535\":2,\"541\":1,\"606\":4,\"712\":1,\"762\":1,\"763\":1,\"764\":2,\"769\":1,\"771\":1,\"793\":1,\"794\":1,\"796\":1,\"797\":1,\"814\":1,\"820\":3,\"822\":1,\"823\":1,\"824\":1,\"825\":1,\"827\":1,\"828\":1,\"844\":2,\"845\":1,\"860\":1,\"861\":2,\"869\":3,\"870\":1,\"871\":1,\"872\":2,\"880\":1,\"882\":2,\"891\":1,\"894\":1,\"900\":1,\"915\":2,\"960\":1,\"961\":6,\"970\":1,\"972\":1,\"984\":1,\"985\":1,\"994\":3,\"995\":1,\"996\":3,\"998\":1,\"999\":4,\"1000\":2,\"1020\":2,\"1021\":2,\"1047\":1,\"1048\":7,\"1055\":1,\"1117\":2,\"1122\":1,\"1123\":1,\"1140\":1,\"1142\":1,\"1143\":1,\"1145\":1,\"1168\":2,\"1170\":1,\"1173\":1,\"1175\":3,\"1194\":1,\"1195\":2,\"1197\":1,\"1200\":2,\"1201\":3,\"1228\":1,\"1229\":1,\"1230\":1,\"1248\":2,\"1271\":1,\"1277\":1,\"1278\":1,\"1279\":1,\"1280\":2,\"1288\":2,\"1296\":1,\"1297\":3,\"1323\":1,\"1331\":1,\"1332\":1,\"1367\":1,\"1371\":1,\"1373\":1,\"1374\":1,\"1427\":1,\"1435\":1,\"1443\":1,\"1444\":1,\"1460\":1,\"1467\":2,\"1468\":1,\"1469\":3,\"1472\":3,\"1495\":1,\"1496\":1,\"1497\":1,\"1499\":1,\"1519\":10,\"1520\":4,\"1521\":1}}],[\"vhost\",{\"1\":{\"653\":1,\"711\":1}}],[\"v3\",{\"1\":{\"504\":1,\"645\":1,\"1198\":1}}],[\"v2\",{\"1\":{\"503\":1,\"504\":1,\"1055\":1}}],[\"v1\",{\"1\":{\"503\":1,\"504\":1,\"625\":5}}],[\"v12\",{\"1\":{\"248\":1}}],[\"veuz67d8klsguywc38p\",{\"1\":{\"443\":1}}],[\"versa\",{\"1\":{\"1269\":1}}],[\"version=$1\",{\"1\":{\"1077\":1}}],[\"version指定了websocket的协议版本\",{\"1\":{\"368\":1}}],[\"version\",{\"1\":{\"11\":1,\"203\":1,\"313\":1,\"368\":1,\"742\":1,\"890\":1,\"894\":1,\"960\":2,\"998\":1,\"1072\":2,\"1077\":1,\"1145\":2,\"1171\":2,\"1198\":1,\"1462\":1}}],[\"version>\",{\"1\":{\"8\":2,\"64\":1,\"712\":1}}],[\"vertical\",{\"1\":{\"143\":1}}],[\"verify\",{\"1\":{\"10\":1,\"62\":1}}],[\"vfm1tuvub02sx6vf\",{\"1\":{\"436\":1}}],[\"vf\",{\"1\":{\"429\":1}}],[\"vnode\",{\"1\":{\"396\":5}}],[\"vnodecount\",{\"1\":{\"396\":12}}],[\"v的作用是将现有键k的值更新为新值v\",{\"1\":{\"192\":1}}],[\"v对\",{\"1\":{\"192\":1}}],[\"v有两种用途\",{\"1\":{\"192\":1}}],[\"v\",{\"1\":{\"144\":2,\"153\":1,\"155\":1,\"156\":1,\"171\":1,\"498\":1,\"503\":3,\"519\":2,\"624\":2,\"894\":3,\"928\":1,\"1080\":9,\"1436\":1}}],[\"vice\",{\"1\":{\"1269\":1}}],[\"vickman\",{\"1\":{\"455\":1,\"476\":1}}],[\"virtual\",{\"1\":{\"396\":5,\"880\":1}}],[\"virtualnode<>\",{\"1\":{\"396\":1}}],[\"virtualnode<t>>\",{\"1\":{\"396\":1}}],[\"virtualnode<t>\",{\"1\":{\"396\":4}}],[\"virtualnode<t\",{\"1\":{\"396\":1}}],[\"virtualnode\",{\"1\":{\"396\":3}}],[\"visual可视模式\",{\"0\":{\"144\":1}}],[\"vimawesome\",{\"1\":{\"166\":1}}],[\"vim补全\",{\"0\":{\"162\":1}}],[\"vim宏\",{\"0\":{\"159\":1}}],[\"vim使用多组寄存器进行剪切\",{\"1\":{\"157\":1}}],[\"vim复制粘贴操作的是寄存器而不是系统剪贴板\",{\"1\":{\"157\":1}}],[\"vim复制粘贴与寄存器\",{\"0\":{\"156\":1}}],[\"vim寄存器\",{\"0\":{\"157\":1}}],[\"vim的text\",{\"0\":{\"155\":1}}],[\"vim的tab和其他编辑器不太一样\",{\"1\":{\"154\":1}}],[\"vim模式\",{\"0\":{\"140\":1}}],[\"vim\",{\"0\":{\"287\":1},\"1\":{\"139\":1,\"151\":1,\"165\":6,\"167\":3,\"287\":1,\"608\":1,\"1075\":4,\"1077\":1,\"1078\":1,\"1079\":1}}],[\"vim笔记\",{\"0\":{\"139\":1},\"1\":{\"608\":1}}],[\"vsn\",{\"1\":{\"203\":1}}],[\"vsc\",{\"1\":{\"167\":1}}],[\"vscode\",{\"1\":{\"167\":1}}],[\"vs\",{\"0\":{\"365\":1},\"1\":{\"137\":3,\"143\":1,\"153\":1}}],[\"varbody\",{\"1\":{\"1352\":1}}],[\"various\",{\"1\":{\"1048\":1}}],[\"variable\",{\"1\":{\"46\":2,\"171\":3,\"960\":1,\"1427\":1}}],[\"var申明的变量有作用域\",{\"1\":{\"310\":1}}],[\"var2\",{\"1\":{\"213\":1}}],[\"var1\",{\"1\":{\"213\":1}}],[\"var\",{\"1\":{\"69\":2,\"70\":2,\"89\":2,\"213\":1,\"294\":1,\"297\":6,\"298\":9,\"299\":2,\"301\":2,\"302\":2,\"303\":7,\"306\":1,\"311\":1,\"313\":1,\"314\":2,\"316\":6,\"320\":2,\"323\":2,\"324\":1,\"325\":3,\"329\":2,\"330\":8,\"331\":1,\"332\":3,\"333\":3,\"337\":1,\"338\":1,\"339\":5,\"341\":1,\"342\":1,\"348\":3,\"351\":4,\"352\":2,\"353\":2,\"361\":3,\"364\":3,\"525\":1,\"624\":4}}],[\"validnum\",{\"1\":{\"1497\":4}}],[\"validators\",{\"1\":{\"1050\":1,\"1459\":1}}],[\"validator\",{\"1\":{\"996\":6}}],[\"validatenow\",{\"1\":{\"1519\":1}}],[\"validatenameserversetting\",{\"1\":{\"1050\":1}}],[\"validate\",{\"1\":{\"62\":1,\"990\":2,\"991\":2,\"996\":1,\"1000\":2}}],[\"valid\",{\"1\":{\"904\":3}}],[\"valu\",{\"1\":{\"384\":1}}],[\"value为其最近一次修改时间\",{\"1\":{\"999\":1}}],[\"value表示该配置文件对应的dataversion\",{\"1\":{\"997\":1}}],[\"value表示acl配置文件的绝对路径\",{\"1\":{\"997\":1}}],[\"value表示相应配置文件中的权限数据\",{\"1\":{\"997\":1}}],[\"value是plainaccessresource类型\",{\"1\":{\"997\":1}}],[\"value以链表的方式存储\",{\"1\":{\"780\":1}}],[\"valueparsed\",{\"1\":{\"742\":7}}],[\"valueofcurrentminusborn\",{\"1\":{\"1468\":6}}],[\"valueof\",{\"1\":{\"712\":1,\"714\":1,\"715\":1,\"843\":1,\"897\":1,\"1020\":1,\"1021\":1,\"1053\":2,\"1195\":1,\"1197\":2,\"1273\":1,\"1280\":1,\"1309\":1,\"1463\":1,\"1499\":1,\"1519\":3}}],[\"values\",{\"1\":{\"396\":1,\"769\":2,\"871\":2,\"1248\":1,\"1436\":1,\"1520\":1,\"1521\":1}}],[\"value\",{\"1\":{\"43\":1,\"97\":1,\"171\":1,\"187\":2,\"191\":1,\"196\":1,\"204\":2,\"217\":7,\"301\":1,\"332\":6,\"338\":3,\"348\":2,\"349\":1,\"391\":1,\"396\":1,\"508\":1,\"567\":2,\"578\":2,\"589\":1,\"605\":2,\"606\":3,\"720\":1,\"732\":1,\"737\":2,\"742\":7,\"780\":4,\"786\":1,\"797\":2,\"815\":1,\"894\":1,\"897\":1,\"900\":2,\"927\":1,\"965\":1,\"995\":4,\"997\":1,\"1021\":1,\"1065\":1,\"1155\":1,\"1174\":3,\"1175\":1,\"1195\":1,\"1229\":1,\"1241\":1,\"1299\":1,\"1346\":1,\"1352\":1,\"1364\":3,\"1371\":2,\"1386\":1,\"1393\":4,\"1402\":1,\"1407\":1,\"1442\":2,\"1468\":2,\"1519\":2,\"1520\":2}}],[\"val\",{\"1\":{\"193\":2,\"194\":2,\"196\":2,\"253\":2}}],[\"pgroup=please\",{\"1\":{\"1445\":3}}],[\"pq\",{\"1\":{\"1144\":9,\"1224\":9,\"1225\":7}}],[\"pqfas4e9blspt1m8zy8snzqdchfvsao9v4s9ipfrsetp3biqzuxrywenrv3zatcdp7upcfwnvyxot9ta9fgs\",{\"1\":{\"443\":1}}],[\"ps\",{\"1\":{\"1075\":1,\"1077\":1,\"1079\":2}}],[\"pdflush\",{\"1\":{\"879\":1}}],[\"pnpm\",{\"1\":{\"498\":2}}],[\"pnodes\",{\"1\":{\"396\":6}}],[\"pnode\",{\"1\":{\"396\":13}}],[\"p7c\",{\"1\":{\"469\":1}}],[\"py1kfpff5zpgt0xs5ykebk3wpwhl72sgezfbhgshotxhbm4xgjrzwjfedlqeqgqpmqrimxrinzt4lnbctwku\",{\"1\":{\"429\":1}}],[\"python等处理器\",{\"1\":{\"371\":1}}],[\"pythag\",{\"1\":{\"184\":1}}],[\"phyoffsetread\",{\"1\":{\"797\":2}}],[\"phyoffsets\",{\"1\":{\"790\":1,\"794\":4,\"797\":5}}],[\"phyoffset\",{\"1\":{\"790\":1,\"797\":5}}],[\"phyoffset=\",{\"1\":{\"765\":1}}],[\"phy\",{\"1\":{\"738\":1}}],[\"physicsize\",{\"1\":{\"861\":1}}],[\"physicoffset\",{\"1\":{\"861\":1}}],[\"physic\",{\"1\":{\"396\":1}}],[\"physicaloffset\",{\"1\":{\"737\":2}}],[\"physical\",{\"1\":{\"396\":4,\"780\":1,\"1174\":1}}],[\"physicalnode\",{\"1\":{\"396\":7}}],[\"phase>\",{\"1\":{\"64\":1}}],[\"phase\",{\"0\":{\"62\":1},\"1\":{\"62\":4}}],[\"phase相当于java的class\",{\"1\":{\"61\":1}}],[\"phase和goal来提供标准的构建流程\",{\"1\":{\"61\":1}}],[\"p3\",{\"1\":{\"351\":1}}],[\"p2\",{\"1\":{\"351\":2,\"352\":4,\"353\":3}}],[\"p1\",{\"1\":{\"351\":2,\"352\":4,\"353\":4}}],[\"peerwatermarks\",{\"1\":{\"1521\":2}}],[\"peerwatermarksbyterm\",{\"1\":{\"1508\":1,\"1514\":1,\"1521\":7}}],[\"peerwatermark\",{\"1\":{\"1519\":6}}],[\"peer\",{\"1\":{\"1519\":1}}],[\"peerid\",{\"1\":{\"1519\":21}}],[\"peersize=\",{\"1\":{\"1499\":1}}],[\"peersize\",{\"1\":{\"1497\":2,\"1499\":2}}],[\"peek\",{\"1\":{\"860\":1,\"861\":1,\"1520\":1}}],[\"pendingappendresponsesbyterm\",{\"1\":{\"1514\":1,\"1518\":2,\"1521\":5}}],[\"pendingmap\",{\"1\":{\"1436\":3,\"1507\":2,\"1519\":9}}],[\"pendingqueue\",{\"1\":{\"861\":4}}],[\"pending\",{\"1\":{\"625\":2,\"1516\":3,\"1521\":2}}],[\"pet\",{\"1\":{\"186\":2}}],[\"pear\",{\"1\":{\"181\":3,\"253\":2,\"325\":1}}],[\"pears\",{\"1\":{\"177\":7}}],[\"perfs\",{\"1\":{\"1370\":3,\"1371\":2,\"1372\":2,\"1373\":3,\"1374\":2}}],[\"performance\",{\"1\":{\"624\":1,\"717\":1,\"719\":1,\"720\":5,\"723\":1,\"736\":3,\"742\":1,\"873\":1,\"885\":1,\"886\":5,\"889\":1,\"892\":1,\"898\":1,\"1437\":1}}],[\"permname\",{\"1\":{\"1173\":2,\"1198\":6}}],[\"permission\",{\"1\":{\"1000\":6,\"1056\":1,\"1173\":5,\"1198\":2,\"1462\":1}}],[\"perm\",{\"1\":{\"964\":10,\"968\":2,\"1000\":2,\"1198\":4}}],[\"period\",{\"1\":{\"845\":1}}],[\"persistall\",{\"1\":{\"1191\":1,\"1200\":2}}],[\"persistallconsumeroffset\",{\"1\":{\"1048\":2}}],[\"persistent\",{\"1\":{\"687\":1}}],[\"persist\",{\"1\":{\"91\":1,\"844\":1,\"1175\":1,\"1191\":1,\"1201\":2,\"1225\":1,\"1420\":1}}],[\"persion\",{\"1\":{\"21\":1}}],[\"person\",{\"1\":{\"21\":2,\"176\":4,\"294\":3,\"316\":4,\"552\":2}}],[\"per\",{\"1\":{\"11\":1,\"614\":1,\"1198\":2}}],[\"pick\",{\"1\":{\"1471\":2,\"1472\":1}}],[\"pickoneatleast\",{\"1\":{\"1052\":1}}],[\"pickuptopicroutedata\",{\"1\":{\"957\":1,\"973\":2}}],[\"pickupstoretimestamp\",{\"1\":{\"845\":1,\"860\":1}}],[\"picc\",{\"1\":{\"241\":3}}],[\"pivot\",{\"1\":{\"184\":6}}],[\"pidspec\",{\"1\":{\"261\":2}}],[\"pid2\",{\"1\":{\"229\":1}}],[\"pid1\",{\"1\":{\"229\":1,\"241\":2}}],[\"pid\",{\"1\":{\"171\":4,\"193\":1,\"229\":4,\"230\":1,\"234\":4,\"235\":3,\"241\":2,\"624\":3,\"625\":1,\"668\":1}}],[\"pipeline\",{\"1\":{\"135\":7,\"1300\":1}}],[\"p段落\",{\"1\":{\"155\":1}}],[\"p\",{\"1\":{\"143\":1,\"144\":1,\"156\":1,\"187\":5,\"208\":1,\"261\":1,\"436\":1,\"455\":1,\"552\":2,\"653\":1,\"711\":1,\"960\":2,\"1077\":1,\"1080\":6,\"1081\":1}}],[\"pub|sub\",{\"1\":{\"983\":2}}],[\"pub\",{\"1\":{\"978\":2,\"983\":2,\"1008\":1,\"1017\":1}}],[\"publish\",{\"1\":{\"624\":1}}],[\"publicexecutor\",{\"1\":{\"1155\":1}}],[\"public修饰符是默认修饰符\",{\"1\":{\"575\":1}}],[\"public和\",{\"1\":{\"95\":1}}],[\"public\",{\"1\":{\"9\":4,\"34\":2,\"41\":3,\"43\":1,\"69\":4,\"70\":2,\"89\":1,\"90\":6,\"92\":2,\"99\":4,\"112\":4,\"113\":8,\"121\":3,\"122\":2,\"123\":1,\"124\":2,\"125\":1,\"126\":4,\"128\":3,\"129\":4,\"131\":4,\"132\":1,\"133\":3,\"134\":4,\"385\":1,\"396\":16,\"575\":2,\"576\":1,\"577\":1,\"712\":2,\"737\":1,\"738\":2,\"742\":2,\"763\":1,\"764\":2,\"767\":1,\"771\":1,\"793\":3,\"794\":2,\"796\":1,\"797\":2,\"820\":3,\"822\":1,\"824\":1,\"825\":1,\"828\":2,\"843\":1,\"844\":2,\"845\":1,\"860\":1,\"861\":1,\"869\":1,\"870\":1,\"872\":1,\"882\":2,\"891\":1,\"894\":2,\"904\":1,\"915\":1,\"950\":1,\"960\":3,\"961\":6,\"968\":1,\"970\":2,\"971\":1,\"972\":1,\"973\":1,\"984\":2,\"985\":3,\"994\":2,\"995\":1,\"996\":3,\"998\":1,\"999\":3,\"1000\":1,\"1007\":1,\"1017\":2,\"1019\":1,\"1020\":2,\"1021\":3,\"1047\":1,\"1048\":6,\"1052\":2,\"1055\":1,\"1122\":1,\"1123\":1,\"1140\":2,\"1142\":1,\"1145\":1,\"1168\":2,\"1169\":1,\"1170\":1,\"1171\":1,\"1172\":1,\"1173\":1,\"1174\":2,\"1175\":3,\"1194\":1,\"1195\":2,\"1197\":2,\"1200\":2,\"1201\":2,\"1222\":2,\"1225\":1,\"1226\":1,\"1228\":1,\"1229\":1,\"1230\":1,\"1235\":1,\"1248\":4,\"1267\":1,\"1275\":1,\"1276\":1,\"1288\":2,\"1296\":2,\"1297\":1,\"1299\":3,\"1328\":1,\"1329\":1,\"1331\":2,\"1332\":1,\"1333\":2,\"1367\":7,\"1368\":3,\"1370\":1,\"1371\":2,\"1372\":1,\"1373\":1,\"1374\":1,\"1424\":1,\"1425\":1,\"1427\":3,\"1428\":1,\"1430\":1,\"1431\":1,\"1432\":1,\"1434\":2,\"1435\":3,\"1436\":2,\"1442\":3,\"1443\":1,\"1444\":2,\"1458\":1,\"1459\":1,\"1460\":1,\"1462\":1,\"1463\":2,\"1464\":1,\"1467\":1,\"1468\":1,\"1469\":3,\"1471\":1,\"1472\":2,\"1500\":1,\"1503\":1,\"1514\":1,\"1516\":1,\"1517\":1,\"1518\":1,\"1519\":2,\"1520\":3,\"1521\":2}}],[\"pulser\",{\"1\":{\"922\":1}}],[\"pullopmsg\",{\"1\":{\"1468\":1}}],[\"pulloffsetofop\",{\"1\":{\"1468\":1}}],[\"pullstatus\",{\"1\":{\"1329\":1,\"1468\":4}}],[\"pullsysflag\",{\"1\":{\"1170\":1,\"1171\":2,\"1173\":3}}],[\"pullblockifnotfound\",{\"1\":{\"1288\":1}}],[\"pullrt\",{\"1\":{\"1175\":2,\"1229\":2}}],[\"pullresultext\",{\"1\":{\"1329\":6}}],[\"pullresult\",{\"1\":{\"1117\":1,\"1170\":1,\"1171\":4,\"1172\":1,\"1175\":18,\"1228\":1,\"1229\":13,\"1288\":3,\"1329\":7,\"1468\":17}}],[\"pullrequest=\",{\"1\":{\"1170\":3}}],[\"pullrequestlist\",{\"1\":{\"1144\":3,\"1224\":3}}],[\"pullrequestqueue\",{\"1\":{\"1104\":2,\"1137\":1,\"1155\":1,\"1168\":4}}],[\"pullrequest\",{\"0\":{\"1169\":1},\"1\":{\"815\":2,\"819\":4,\"822\":4,\"825\":1,\"1104\":1,\"1119\":4,\"1120\":1,\"1137\":4,\"1144\":14,\"1155\":3,\"1168\":8,\"1169\":1,\"1170\":35,\"1173\":4,\"1175\":24,\"1224\":14,\"1228\":18,\"1229\":11}}],[\"pullrequesttable\",{\"1\":{\"815\":4,\"816\":1,\"822\":2,\"823\":1,\"825\":2}}],[\"pullrequestholdservice\",{\"0\":{\"799\":1,\"810\":1,\"815\":1,\"821\":1,\"913\":1},\"1\":{\"799\":1,\"812\":2,\"816\":1,\"825\":1,\"827\":3,\"828\":1,\"886\":2,\"906\":2,\"913\":1,\"915\":1,\"1538\":1}}],[\"pulling\",{\"1\":{\"1173\":2}}],[\"pulltimedelaymillswhenexception\",{\"1\":{\"1170\":5,\"1175\":1,\"1228\":2}}],[\"pullthresholdsizeforqueue\",{\"1\":{\"1145\":1}}],[\"pullthresholdsizefortopic\",{\"1\":{\"1145\":3}}],[\"pullthresholdforqueue\",{\"1\":{\"1145\":1}}],[\"pullthresholdfortopic\",{\"1\":{\"1145\":3}}],[\"pullapiwrapper\",{\"0\":{\"1160\":1,\"1171\":1},\"1\":{\"1120\":1,\"1122\":3,\"1159\":1,\"1170\":1,\"1175\":1,\"1229\":1,\"1319\":1,\"1329\":1}}],[\"pullcallback\",{\"0\":{\"1175\":1},\"1\":{\"1117\":1,\"1155\":1,\"1156\":1,\"1170\":4,\"1171\":4,\"1172\":3,\"1219\":1,\"1288\":1}}],[\"pullmessageresponseheader\",{\"1\":{\"1173\":3}}],[\"pullmessagerequestheader\",{\"1\":{\"1171\":2,\"1172\":1,\"1173\":3}}],[\"pullmessagesync\",{\"1\":{\"1172\":1}}],[\"pullmessageservice\",{\"0\":{\"1158\":1,\"1168\":1},\"1\":{\"1037\":1,\"1048\":1,\"1119\":3,\"1120\":2,\"1123\":1,\"1137\":1,\"1144\":1,\"1155\":1,\"1158\":1,\"1169\":1,\"1224\":1}}],[\"pullmessageasync\",{\"1\":{\"1172\":1}}],[\"pullmessage\",{\"1\":{\"1119\":1,\"1155\":1,\"1159\":1,\"1168\":1,\"1170\":2,\"1171\":1,\"1172\":1,\"1173\":1,\"1219\":1,\"1228\":1}}],[\"pullmessageexecutor\",{\"1\":{\"1043\":1}}],[\"pullmessageprocess\",{\"1\":{\"812\":1}}],[\"pullmessageprocessor\",{\"0\":{\"809\":1,\"814\":1,\"818\":1,\"1163\":1,\"1173\":1},\"1\":{\"815\":1,\"820\":1,\"1061\":1,\"1318\":1}}],[\"pullnotifyqueue\",{\"1\":{\"916\":1}}],[\"pullkernelimpl\",{\"1\":{\"812\":1,\"1159\":1,\"1170\":2,\"1171\":1}}],[\"pull模式固定20s\",{\"1\":{\"805\":1,\"1173\":1}}],[\"pull\",{\"0\":{\"1093\":1},\"1\":{\"757\":1,\"766\":1,\"801\":2,\"803\":1,\"804\":1,\"814\":1,\"819\":3,\"1048\":1,\"1073\":1,\"1094\":1,\"1095\":2,\"1117\":2,\"1136\":1,\"1144\":1,\"1146\":1,\"1168\":1,\"1170\":11,\"1172\":1,\"1173\":18,\"1175\":4,\"1228\":5,\"1245\":4,\"1246\":1,\"1247\":1,\"1277\":1,\"1284\":1,\"1297\":1,\"1333\":3,\"1431\":1,\"1468\":2}}],[\"purge\",{\"1\":{\"646\":1}}],[\"purmvqsohq2tult5tdlxeak7cxfbc7vlpsf69odi7sl5llxrn10innfuelnpvb5ttbojmjomlrqtwqfun5y9jbehotwumjolszearmiof6cfkxuq6fou\",{\"1\":{\"443\":1}}],[\"purpose\",{\"1\":{\"204\":1}}],[\"pushfastforward\",{\"1\":{\"1520\":1}}],[\"pushfallbehind\",{\"1\":{\"1520\":2}}],[\"pushed\",{\"1\":{\"1520\":2}}],[\"pushentryresponse\",{\"1\":{\"1519\":2,\"1520\":3}}],[\"pushentryrequest\",{\"1\":{\"1519\":31,\"1520\":11}}],[\"pusher\",{\"1\":{\"1516\":1}}],[\"push模式固定15s\",{\"1\":{\"1173\":1}}],[\"pushconsumer为被动消费\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"pushconsumer\",{\"1\":{\"1122\":1,\"1307\":1}}],[\"push\",{\"0\":{\"802\":1,\"803\":1,\"1094\":1},\"1\":{\"298\":2,\"330\":1,\"523\":2,\"524\":1,\"801\":2,\"802\":2,\"803\":2,\"804\":1,\"829\":1,\"914\":1,\"1048\":1,\"1094\":3,\"1095\":4,\"1104\":1,\"1122\":1,\"1245\":4,\"1246\":1,\"1249\":4,\"1251\":1,\"1252\":1,\"1255\":1,\"1516\":2,\"1518\":1,\"1519\":18,\"1520\":2}}],[\"putbackhalfmsgqueue\",{\"1\":{\"1468\":1}}],[\"puthalfmessage\",{\"1\":{\"1463\":1}}],[\"putslot\",{\"1\":{\"1367\":1,\"1371\":1}}],[\"putshort\",{\"1\":{\"737\":2}}],[\"putuserproperty\",{\"1\":{\"1287\":1,\"1309\":1,\"1459\":1}}],[\"putall\",{\"1\":{\"1280\":1}}],[\"putacktostore\",{\"1\":{\"1277\":1}}],[\"putcktostore\",{\"1\":{\"1277\":2}}],[\"putoffsetqueue\",{\"1\":{\"1275\":1}}],[\"putresultprocess\",{\"1\":{\"860\":2,\"861\":13}}],[\"putrequest\",{\"1\":{\"725\":2}}],[\"putproperty\",{\"1\":{\"843\":2,\"1056\":1,\"1197\":1,\"1198\":1,\"1296\":1,\"1459\":2,\"1463\":3}}],[\"putinqueuecount=\",{\"1\":{\"1468\":1}}],[\"putinqueuecount++\",{\"1\":{\"1468\":1}}],[\"putinqueuecount\",{\"1\":{\"1468\":2}}],[\"putint\",{\"1\":{\"737\":16,\"765\":1,\"797\":4,\"1367\":2,\"1368\":2,\"1371\":5,\"1434\":1,\"1435\":2}}],[\"putifabsent\",{\"1\":{\"822\":1,\"995\":1,\"1051\":1,\"1144\":1,\"1224\":1,\"1331\":1,\"1520\":1}}],[\"putkey\",{\"0\":{\"1434\":1},\"1\":{\"789\":1,\"790\":1,\"794\":5,\"797\":3,\"1412\":1,\"1414\":3,\"1434\":3}}],[\"putlong\",{\"1\":{\"737\":10,\"738\":1,\"765\":2,\"797\":1,\"1367\":3,\"1368\":1,\"1371\":4}}],[\"putmessagetocache\",{\"1\":{\"1431\":1}}],[\"putmessagetospecificqueue\",{\"1\":{\"1273\":1,\"1280\":1}}],[\"putmessagethreadlocal\",{\"1\":{\"737\":1}}],[\"putmessageposiitoninfo\",{\"0\":{\"765\":1}}],[\"putmessagepositioninfo只有一个线程调用\",{\"1\":{\"765\":1}}],[\"putmessagepositioninfowrapper\",{\"1\":{\"764\":1,\"1297\":1}}],[\"putmessagepositioninfo\",{\"1\":{\"756\":1,\"764\":2,\"765\":1,\"768\":1,\"1297\":2}}],[\"putmessagecontext\",{\"1\":{\"738\":2,\"1296\":2}}],[\"putmessageresult\",{\"1\":{\"737\":3,\"845\":4,\"861\":1,\"1056\":4,\"1198\":3,\"1273\":7,\"1280\":5,\"1462\":9,\"1463\":1}}],[\"putmessagestatus\",{\"1\":{\"737\":2,\"845\":1,\"861\":1,\"1273\":4,\"1462\":1}}],[\"putmessages\",{\"0\":{\"731\":1},\"1\":{\"720\":1,\"731\":3}}],[\"putmessage\",{\"0\":{\"731\":1,\"736\":1},\"1\":{\"720\":3,\"731\":3,\"736\":2,\"737\":2,\"837\":1,\"839\":1,\"845\":1,\"861\":1,\"1065\":1,\"1175\":1,\"1222\":1,\"1229\":1,\"1462\":1,\"1463\":1}}],[\"put\",{\"1\":{\"125\":1,\"217\":3,\"396\":1,\"624\":4,\"625\":1,\"654\":1,\"665\":1,\"714\":2,\"715\":1,\"737\":10,\"738\":1,\"845\":1,\"861\":1,\"882\":1,\"894\":2,\"916\":1,\"971\":5,\"995\":3,\"996\":1,\"998\":5,\"999\":2,\"1021\":1,\"1047\":1,\"1056\":1,\"1168\":2,\"1195\":1,\"1198\":1,\"1201\":3,\"1222\":2,\"1230\":1,\"1273\":3,\"1275\":1,\"1277\":1,\"1278\":1,\"1280\":2,\"1297\":3,\"1322\":1,\"1323\":1,\"1371\":3,\"1372\":2,\"1374\":4,\"1427\":3,\"1430\":1,\"1431\":1,\"1434\":4,\"1435\":2,\"1436\":1,\"1442\":1,\"1462\":2,\"1464\":3,\"1499\":3,\"1518\":1,\"1519\":1,\"1520\":2}}],[\"ppt\",{\"1\":{\"108\":1}}],[\"please\",{\"1\":{\"742\":1,\"890\":1,\"960\":1,\"1008\":1,\"1047\":1,\"1122\":1,\"1173\":1,\"1287\":1}}],[\"plus\",{\"1\":{\"398\":1}}],[\"plugclean\",{\"1\":{\"165\":1}}],[\"plugdiff\",{\"1\":{\"165\":1}}],[\"plugupdate\",{\"1\":{\"165\":1}}],[\"plug\",{\"1\":{\"165\":7,\"167\":2}}],[\"pluginmessagestore\",{\"1\":{\"1425\":2}}],[\"pluginclass\",{\"1\":{\"1425\":3}}],[\"pluginclasses\",{\"1\":{\"1425\":3}}],[\"plugin>\",{\"1\":{\"64\":1}}],[\"pluginstall\",{\"1\":{\"165\":1}}],[\"plugins>\",{\"1\":{\"64\":1}}],[\"plugins\",{\"1\":{\"64\":1,\"165\":4,\"710\":1}}],[\"plugins<\",{\"1\":{\"64\":1}}],[\"plugin<\",{\"1\":{\"64\":1}}],[\"plugin可以创建一个可执行的jar\",{\"1\":{\"64\":1}}],[\"plugin\",{\"0\":{\"264\":1},\"1\":{\"64\":1,\"272\":3,\"629\":1,\"640\":2,\"707\":1,\"1424\":1,\"1425\":5}}],[\"play\",{\"1\":{\"1074\":7,\"1075\":1,\"1079\":5,\"1080\":1,\"1081\":2,\"1083\":1,\"1084\":1}}],[\"player\",{\"1\":{\"490\":1}}],[\"plater\",{\"1\":{\"491\":1}}],[\"platformdependent0\",{\"1\":{\"1008\":1}}],[\"platformdependent\",{\"1\":{\"267\":1}}],[\"platform\",{\"1\":{\"262\":1}}],[\"planid\",{\"1\":{\"253\":2}}],[\"plans\",{\"1\":{\"253\":1}}],[\"plan\",{\"1\":{\"253\":5}}],[\"plainaclconfdata\",{\"1\":{\"998\":7}}],[\"plainaccessconfig\",{\"1\":{\"998\":4}}],[\"plainaccessconfiglist\",{\"1\":{\"998\":2}}],[\"plainaccessresource\",{\"1\":{\"998\":7,\"1000\":21}}],[\"plainaccessresourcemap\",{\"1\":{\"998\":4}}],[\"plainaccessresource>\",{\"1\":{\"998\":1}}],[\"plainaccessresource>>\",{\"1\":{\"997\":1,\"998\":1}}],[\"plainaccessvalidator\",{\"1\":{\"980\":1,\"990\":3,\"991\":1,\"996\":2}}],[\"plainpermissonmanager\",{\"0\":{\"997\":1,\"998\":1,\"999\":1},\"1\":{\"997\":1}}],[\"plainpermissionmanager\",{\"1\":{\"990\":2,\"991\":1,\"996\":3,\"997\":1,\"999\":1,\"1000\":1}}],[\"plain\",{\"1\":{\"103\":1,\"979\":1,\"983\":1,\"990\":1,\"996\":1,\"998\":2,\"999\":1}}],[\"pwd\",{\"1\":{\"92\":2,\"171\":1,\"1075\":3,\"1077\":1}}],[\"poll\",{\"1\":{\"915\":1,\"1021\":1,\"1371\":2,\"1373\":1,\"1374\":1,\"1520\":1}}],[\"pollingresult\",{\"1\":{\"1269\":3}}],[\"pollingtimemills\",{\"1\":{\"819\":3,\"1173\":3}}],[\"polling\",{\"1\":{\"806\":1,\"812\":1,\"1269\":5}}],[\"policies\",{\"1\":{\"654\":1}}],[\"policy的设置命令为\",{\"1\":{\"653\":1}}],[\"policy的优先级\",{\"1\":{\"652\":1}}],[\"policy的名称\",{\"1\":{\"652\":1}}],[\"policy\",{\"1\":{\"636\":1,\"638\":2,\"652\":1,\"653\":2,\"655\":3,\"698\":1}}],[\"pogfcjk8p14un4sd0rodsdlfzwwbaecphgbse1d0xa8lducpwmdc9ymatngmuynevw59zouanrxbn46b0bumcnyxuaa84vid5skvcfxvuinocioamccujgiasmmpctqlxmgxahejf1oewyhfgpqqkdbmzlunmc5mewg7ki7vi3zoqh2xfeyk6xjbgrcatiehl\",{\"1\":{\"423\":1}}],[\"powerjob的特性上有一个比较有趣的点\",{\"1\":{\"380\":1}}],[\"powerjob从架构和技术选型上较大程度参考了schedulerx\",{\"1\":{\"371\":1}}],[\"powerjob是新一代分布式任务调度与计算框架\",{\"1\":{\"370\":1}}],[\"powerjob\",{\"0\":{\"370\":1},\"1\":{\"370\":1,\"372\":6,\"380\":1,\"381\":2,\"608\":1}}],[\"pow\",{\"1\":{\"323\":2}}],[\"popcheckpoint>\",{\"1\":{\"1278\":1}}],[\"popcheckpointwrapper>\",{\"1\":{\"1277\":1}}],[\"popcheckpointwrapper>>\",{\"1\":{\"1277\":1}}],[\"popcheckpointwrapper\",{\"1\":{\"1275\":2,\"1276\":1,\"1277\":1}}],[\"popcheckpoint\",{\"1\":{\"1271\":3,\"1275\":1,\"1276\":1,\"1277\":1,\"1278\":3,\"1279\":12,\"1280\":26}}],[\"popbuffer\",{\"1\":{\"1270\":1,\"1275\":3,\"1276\":5,\"1277\":2}}],[\"popbuffermergeservice\",{\"0\":{\"1275\":1,\"1276\":1,\"1277\":1},\"1\":{\"1262\":1,\"1270\":1,\"1271\":2}}],[\"popackconstants\",{\"1\":{\"1270\":2,\"1273\":1,\"1278\":7,\"1279\":4}}],[\"poptime\",{\"1\":{\"1269\":6,\"1270\":4,\"1271\":2}}],[\"popworkgroupsize\",{\"1\":{\"1267\":1}}],[\"popreviveservice\",{\"0\":{\"1278\":1,\"1279\":1,\"1280\":1},\"1\":{\"1263\":2}}],[\"popmessagerequestheader\",{\"1\":{\"1270\":1,\"1271\":1}}],[\"popmessageprocessor\",{\"0\":{\"1269\":1,\"1270\":1,\"1271\":1},\"1\":{\"1257\":1,\"1273\":1}}],[\"popmsgfromqueue\",{\"0\":{\"1270\":1},\"1\":{\"1258\":1,\"1269\":4,\"1270\":2}}],[\"poppushconsumer\",{\"1\":{\"1248\":2}}],[\"popsharequeuenum\",{\"1\":{\"1247\":2,\"1255\":4,\"1267\":6}}],[\"population\",{\"1\":{\"561\":1}}],[\"pop\",{\"0\":{\"1095\":1,\"1243\":1,\"1245\":1,\"1246\":1,\"1249\":1,\"1251\":1,\"1256\":1,\"1258\":1,\"1268\":1},\"1\":{\"298\":7,\"1095\":4,\"1105\":1,\"1131\":1,\"1243\":1,\"1245\":5,\"1246\":2,\"1247\":4,\"1248\":3,\"1249\":4,\"1250\":2,\"1251\":7,\"1252\":4,\"1253\":3,\"1255\":4,\"1257\":9,\"1258\":4,\"1259\":1,\"1261\":2,\"1262\":1,\"1263\":4,\"1266\":2,\"1267\":5,\"1269\":4,\"1270\":10,\"1271\":6,\"1273\":2,\"1275\":5,\"1276\":5,\"1277\":2,\"1278\":8,\"1279\":3,\"1280\":7,\"1281\":1,\"1538\":1}}],[\"potato\",{\"1\":{\"253\":2}}],[\"pointwrapper\",{\"1\":{\"1275\":6,\"1276\":7,\"1277\":22}}],[\"pointer\",{\"1\":{\"882\":5}}],[\"point之后的所有索引文件\",{\"1\":{\"793\":1}}],[\"point\",{\"1\":{\"176\":5,\"283\":1,\"552\":2,\"555\":2,\"558\":1,\"566\":6,\"1271\":1,\"1275\":11,\"1276\":5,\"1277\":5,\"1278\":22}}],[\"pooledbytebufallocator\",{\"1\":{\"267\":1}}],[\"pool\",{\"1\":{\"128\":2}}],[\"pos=\",{\"1\":{\"1519\":1,\"1520\":1}}],[\"posix\",{\"1\":{\"1382\":1}}],[\"posixfilesegment\",{\"1\":{\"1382\":3}}],[\"posixparser\",{\"1\":{\"960\":1}}],[\"positions\",{\"1\":{\"1516\":4}}],[\"position\",{\"1\":{\"690\":1,\"737\":1,\"738\":1,\"1297\":2,\"1367\":2,\"1368\":1,\"1372\":3,\"1428\":1,\"1430\":1,\"1432\":4,\"1434\":1,\"1435\":2,\"1436\":1}}],[\"pos\",{\"1\":{\"900\":2,\"1052\":8,\"1351\":4,\"1352\":2,\"1368\":3,\"1371\":1}}],[\"possible\",{\"1\":{\"104\":1,\"1436\":1}}],[\"postgresql\",{\"1\":{\"371\":1}}],[\"postconstruct和\",{\"1\":{\"82\":1}}],[\"post\",{\"1\":{\"62\":2,\"266\":1,\"274\":1,\"624\":3}}],[\"ports\",{\"1\":{\"1075\":2,\"1077\":1,\"1078\":1,\"1079\":2}}],[\"port>\",{\"1\":{\"971\":2}}],[\"portname\",{\"1\":{\"241\":1}}],[\"port\",{\"1\":{\"73\":1,\"112\":7,\"113\":2,\"121\":2,\"126\":2,\"129\":2,\"133\":2,\"134\":2,\"241\":5,\"369\":1,\"971\":1,\"1075\":2}}],[\"pt\",{\"1\":{\"48\":2,\"556\":4}}],[\"pair\",{\"1\":{\"1520\":33}}],[\"pair<>\",{\"1\":{\"1520\":3}}],[\"pair<pushentryrequest\",{\"1\":{\"1520\":6}}],[\"pair<long\",{\"1\":{\"1519\":1}}],[\"pair<string>\",{\"1\":{\"48\":2}}],[\"payloadbuffer\",{\"1\":{\"1435\":2}}],[\"payload\",{\"1\":{\"1435\":4}}],[\"pagecache\",{\"0\":{\"1363\":1},\"1\":{\"1173\":2,\"1364\":1,\"1517\":2}}],[\"pages\",{\"1\":{\"882\":2}}],[\"page\",{\"0\":{\"879\":1},\"1\":{\"879\":19,\"880\":1,\"882\":7,\"883\":10,\"931\":1,\"1382\":1,\"1390\":1}}],[\"paused\",{\"1\":{\"1170\":1}}],[\"pause\",{\"1\":{\"255\":1,\"1144\":1}}],[\"patch\",{\"1\":{\"731\":1,\"740\":1}}],[\"pattern2等模式进行匹配\",{\"1\":{\"194\":1}}],[\"pattern2\",{\"1\":{\"187\":2,\"229\":1,\"232\":1}}],[\"pattern1\",{\"1\":{\"187\":2,\"229\":1,\"232\":1}}],[\"pattern\",{\"1\":{\"150\":2,\"184\":1,\"261\":2,\"652\":1,\"653\":1,\"654\":1,\"904\":1}}],[\"paths\",{\"1\":{\"601\":2}}],[\"pathname\",{\"1\":{\"316\":1}}],[\"pathz\",{\"1\":{\"223\":1}}],[\"patha\",{\"1\":{\"223\":1}}],[\"path\",{\"1\":{\"83\":1,\"223\":1,\"252\":1,\"316\":1,\"368\":1,\"961\":4,\"999\":1,\"1420\":2}}],[\"path对象和file对象类似\",{\"1\":{\"52\":1}}],[\"passed\",{\"1\":{\"1497\":2}}],[\"passively\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"passport不是变量\",{\"1\":{\"316\":1}}],[\"passport\",{\"1\":{\"316\":5}}],[\"password\",{\"1\":{\"92\":5}}],[\"paste\",{\"1\":{\"144\":1,\"156\":1}}],[\"packet\",{\"1\":{\"72\":8,\"73\":7}}],[\"packageconflictdetect\",{\"1\":{\"960\":1}}],[\"packages\",{\"1\":{\"643\":3,\"644\":1}}],[\"package\",{\"1\":{\"62\":3,\"64\":1,\"369\":1,\"643\":12,\"645\":1}}],[\"parent\",{\"1\":{\"342\":2}}],[\"parsehalfmessageinner\",{\"0\":{\"1463\":1},\"1\":{\"1463\":3}}],[\"parsenormaltopic\",{\"1\":{\"1279\":1,\"1280\":1}}],[\"parseobject\",{\"1\":{\"1278\":2}}],[\"parsesocketaddressaddr\",{\"1\":{\"1197\":1}}],[\"parsecmdline\",{\"1\":{\"960\":1}}],[\"parsechannelremoteaddr\",{\"0\":{\"895\":1},\"1\":{\"886\":1,\"895\":1,\"896\":1,\"994\":1,\"1173\":2,\"1266\":1,\"1471\":1}}],[\"parsedouble\",{\"1\":{\"742\":1}}],[\"parseboolean\",{\"1\":{\"742\":3,\"1053\":1,\"1056\":1,\"1462\":1}}],[\"parselong\",{\"1\":{\"742\":2,\"1297\":1,\"1370\":1}}],[\"parse\",{\"1\":{\"338\":5,\"720\":1,\"742\":1,\"996\":1,\"1173\":3,\"1321\":1,\"1497\":1,\"1499\":1}}],[\"parseresult\",{\"1\":{\"1497\":22}}],[\"parserequestcontent\",{\"1\":{\"995\":3}}],[\"parser\",{\"1\":{\"171\":1}}],[\"parseint\",{\"1\":{\"34\":1,\"320\":2,\"518\":1,\"742\":7,\"823\":1,\"891\":1,\"1299\":2,\"1469\":1}}],[\"partb\",{\"1\":{\"889\":1}}],[\"partition\",{\"1\":{\"659\":2}}],[\"part\",{\"1\":{\"137\":1,\"717\":1,\"886\":12,\"889\":1,\"892\":1,\"905\":1,\"913\":2}}],[\"params指定\",{\"1\":{\"652\":2}}],[\"params\",{\"1\":{\"652\":2,\"653\":1,\"654\":1,\"657\":1}}],[\"param\",{\"1\":{\"125\":1,\"396\":7,\"764\":1,\"765\":4,\"767\":6,\"793\":1,\"794\":6,\"796\":1,\"797\":6,\"819\":3,\"820\":2,\"822\":3,\"825\":3,\"870\":4,\"872\":1,\"1000\":2,\"1020\":2,\"1021\":1,\"1050\":4,\"1052\":3,\"1053\":6,\"1056\":4,\"1143\":1,\"1144\":3,\"1145\":3,\"1168\":1,\"1170\":1,\"1171\":12,\"1173\":3,\"1174\":6,\"1194\":4,\"1195\":3,\"1197\":5,\"1198\":2,\"1200\":1,\"1201\":9,\"1222\":3,\"1224\":3,\"1225\":2,\"1226\":1,\"1228\":1,\"1266\":5,\"1267\":6,\"1269\":2,\"1270\":12,\"1271\":8,\"1273\":3,\"1275\":4,\"1276\":2,\"1278\":1,\"1280\":2,\"1296\":3,\"1297\":8,\"1328\":2,\"1329\":3,\"1331\":5,\"1333\":4,\"1367\":7,\"1368\":4,\"1370\":1,\"1371\":4,\"1425\":1,\"1427\":2,\"1430\":6,\"1432\":1,\"1436\":5,\"1458\":2,\"1459\":3,\"1460\":3,\"1468\":5,\"1469\":2,\"1472\":3,\"1500\":1,\"1502\":3,\"1503\":2,\"1516\":1,\"1517\":1,\"1518\":2,\"1519\":6,\"1520\":15}}],[\"parameters\",{\"1\":{\"558\":1,\"720\":1,\"732\":1}}],[\"parameterized\",{\"1\":{\"46\":3}}],[\"parameterizedtype\",{\"1\":{\"46\":1,\"48\":3}}],[\"parameter\",{\"1\":{\"43\":1,\"1459\":1}}],[\"pr\",{\"1\":{\"720\":1,\"840\":1,\"848\":1,\"850\":2,\"905\":1,\"1375\":1}}],[\"practice\",{\"1\":{\"717\":1,\"1231\":1}}],[\"prromote\",{\"1\":{\"659\":1}}],[\"preappend\",{\"1\":{\"1517\":1}}],[\"prepos\",{\"1\":{\"1517\":5}}],[\"preparing\",{\"1\":{\"643\":1,\"645\":1}}],[\"preparemessage\",{\"1\":{\"1462\":1}}],[\"preparedtransactionoffset=69962470552\",{\"1\":{\"1445\":1}}],[\"preparedtransactionoffset=69962467966\",{\"1\":{\"1445\":1}}],[\"preparedtransactionoffset=69962469259\",{\"1\":{\"1445\":1}}],[\"prepared\",{\"1\":{\"737\":2,\"764\":1,\"794\":1,\"1053\":4,\"1056\":1,\"1197\":1,\"1459\":1,\"1462\":1,\"1464\":1}}],[\"prepare\",{\"1\":{\"62\":1,\"882\":1,\"1467\":2}}],[\"preconditions\",{\"1\":{\"1516\":4,\"1517\":8,\"1519\":10,\"1520\":16}}],[\"precisionms\",{\"1\":{\"1367\":6,\"1371\":5,\"1373\":1,\"1374\":1}}],[\"presend\",{\"1\":{\"1056\":1}}],[\"preserve\",{\"1\":{\"593\":1}}],[\"prefix\",{\"1\":{\"1053\":1,\"1142\":1,\"1143\":1,\"1175\":1,\"1266\":1,\"1280\":1,\"1287\":1}}],[\"prefetch\",{\"1\":{\"1431\":1}}],[\"prefetchcount\",{\"1\":{\"616\":1}}],[\"preferred\",{\"1\":{\"267\":1}}],[\"prevterm\",{\"1\":{\"1497\":2}}],[\"prevpos\",{\"1\":{\"1372\":3}}],[\"prevrequestoffset\",{\"1\":{\"1175\":5,\"1229\":1}}],[\"prevbody\",{\"1\":{\"1053\":4}}],[\"prevbrokerliveinfo\",{\"1\":{\"971\":2}}],[\"prev\",{\"1\":{\"822\":3,\"1331\":3,\"1352\":1,\"1371\":1}}],[\"previndexread\",{\"1\":{\"797\":5}}],[\"previndexfile\",{\"1\":{\"793\":3}}],[\"previously\",{\"1\":{\"643\":1}}],[\"previous\",{\"1\":{\"171\":2,\"1427\":1,\"1434\":1}}],[\"prevent\",{\"1\":{\"643\":1,\"645\":1,\"720\":1,\"882\":1,\"960\":1,\"1432\":2}}],[\"predestroy对bean进行初始化和清理\",{\"1\":{\"82\":1}}],[\"pre\",{\"1\":{\"62\":2,\"765\":1,\"1144\":2,\"1224\":2}}],[\"priority\",{\"1\":{\"652\":1,\"653\":3}}],[\"primitive\",{\"1\":{\"508\":1}}],[\"primarystudent\",{\"1\":{\"342\":3,\"345\":1}}],[\"primary\",{\"1\":{\"82\":1}}],[\"price\",{\"1\":{\"253\":3,\"554\":3}}],[\"printstr\",{\"1\":{\"1000\":2}}],[\"printstacktrace\",{\"1\":{\"128\":1,\"613\":1,\"861\":1,\"984\":1,\"1006\":1,\"1443\":1}}],[\"printallperiodically\",{\"1\":{\"961\":1}}],[\"printobjectproperties\",{\"1\":{\"960\":4}}],[\"printf\",{\"1\":{\"960\":2,\"984\":1,\"985\":2,\"1006\":1,\"1007\":2,\"1248\":2,\"1309\":1,\"1443\":1,\"1444\":2}}],[\"printx\",{\"1\":{\"577\":2}}],[\"printwriter\",{\"1\":{\"113\":2}}],[\"print\",{\"1\":{\"70\":1,\"113\":2,\"171\":3}}],[\"println\",{\"1\":{\"34\":1,\"41\":2,\"48\":1,\"69\":3,\"70\":3,\"112\":3,\"113\":4,\"712\":2,\"1288\":1}}],[\"private和protected\",{\"1\":{\"575\":1}}],[\"private\",{\"1\":{\"9\":2,\"69\":1,\"70\":1,\"99\":2,\"113\":1,\"122\":1,\"124\":2,\"133\":5,\"396\":2,\"576\":1,\"577\":1,\"606\":2,\"712\":3,\"737\":1,\"742\":13,\"762\":1,\"765\":1,\"769\":1,\"789\":1,\"815\":1,\"819\":1,\"823\":1,\"827\":1,\"860\":1,\"861\":1,\"869\":2,\"870\":1,\"871\":1,\"872\":1,\"880\":1,\"893\":2,\"897\":1,\"950\":4,\"961\":2,\"968\":4,\"984\":2,\"985\":2,\"996\":1,\"997\":7,\"999\":1,\"1017\":25,\"1021\":21,\"1048\":1,\"1050\":1,\"1051\":1,\"1053\":1,\"1056\":1,\"1143\":1,\"1144\":1,\"1168\":1,\"1169\":4,\"1173\":1,\"1198\":1,\"1201\":1,\"1222\":2,\"1224\":1,\"1241\":1,\"1248\":1,\"1266\":1,\"1269\":1,\"1270\":1,\"1271\":1,\"1273\":1,\"1277\":1,\"1280\":2,\"1297\":3,\"1299\":2,\"1323\":2,\"1442\":2,\"1463\":1,\"1468\":1,\"1472\":5,\"1495\":1,\"1496\":1,\"1497\":1,\"1499\":1,\"1502\":1,\"1514\":10,\"1519\":26,\"1520\":9,\"1521\":4}}],[\"provider\",{\"1\":{\"1382\":3}}],[\"provided\",{\"1\":{\"60\":1}}],[\"problem\",{\"1\":{\"720\":1,\"736\":1,\"1371\":1}}],[\"problems\",{\"1\":{\"643\":2,\"645\":1}}],[\"promote\",{\"1\":{\"659\":5}}],[\"promot\",{\"1\":{\"657\":1}}],[\"promise\",{\"0\":{\"351\":1,\"352\":1,\"353\":1},\"1\":{\"351\":3,\"352\":3,\"353\":3,\"354\":3}}],[\"producer2\",{\"1\":{\"1235\":1}}],[\"producer1\",{\"1\":{\"1235\":1}}],[\"producertable\",{\"1\":{\"1036\":1,\"1047\":1}}],[\"producer\",{\"0\":{\"1470\":1},\"1\":{\"835\":2,\"886\":1,\"894\":1,\"941\":1,\"944\":1,\"945\":1,\"984\":5,\"994\":1,\"1006\":4,\"1047\":4,\"1074\":1,\"1233\":3,\"1235\":8,\"1287\":4,\"1306\":1,\"1309\":1,\"1339\":1,\"1443\":7,\"1459\":1,\"1464\":2,\"1469\":1,\"1471\":6}}],[\"producergroup=\",{\"1\":{\"1472\":1}}],[\"producergroupname\",{\"1\":{\"984\":1,\"1006\":1}}],[\"producergroup\",{\"1\":{\"742\":1,\"1008\":1,\"1047\":1,\"1472\":2}}],[\"produce\",{\"1\":{\"720\":1,\"723\":1,\"736\":1}}],[\"product\",{\"1\":{\"554\":2,\"1077\":1}}],[\"prodetail\",{\"1\":{\"286\":1}}],[\"protocols\",{\"1\":{\"368\":1}}],[\"proto\",{\"1\":{\"339\":2}}],[\"prototype\",{\"1\":{\"339\":1,\"340\":5,\"341\":4,\"342\":6}}],[\"protected\",{\"1\":{\"125\":5,\"128\":1,\"576\":2,\"577\":1,\"737\":1,\"915\":1,\"994\":3,\"995\":1,\"1278\":1,\"1279\":1,\"1431\":1,\"1435\":1,\"1436\":2,\"1467\":1}}],[\"properly\",{\"1\":{\"1008\":1}}],[\"property\",{\"1\":{\"553\":1,\"715\":2,\"720\":1,\"843\":2,\"894\":1,\"995\":1,\"1020\":2,\"1053\":5,\"1056\":5,\"1197\":2,\"1198\":3,\"1273\":1,\"1280\":2,\"1287\":1,\"1296\":2,\"1297\":4,\"1371\":1,\"1373\":2,\"1427\":2,\"1459\":4,\"1462\":3,\"1463\":3,\"1464\":3,\"1468\":3,\"1469\":4,\"1471\":2,\"1472\":1}}],[\"properties=\",{\"1\":{\"1445\":3}}],[\"propertiesstring\",{\"1\":{\"1056\":1}}],[\"properties2object\",{\"1\":{\"960\":3}}],[\"properties属性中\",{\"1\":{\"839\":1,\"843\":1}}],[\"propertieslength\",{\"1\":{\"737\":10}}],[\"propertiesdata\",{\"1\":{\"737\":10}}],[\"properties\",{\"1\":{\"89\":1,\"737\":6,\"742\":1,\"825\":4,\"828\":2,\"834\":1,\"960\":7,\"995\":1,\"1056\":1,\"1318\":2,\"1333\":4,\"1427\":3}}],[\"prop\",{\"1\":{\"558\":1,\"1297\":8}}],[\"props=\",{\"1\":{\"1332\":1}}],[\"props\",{\"1\":{\"89\":5,\"341\":2,\"342\":5,\"1020\":3}}],[\"profile配置不同的bean\",{\"1\":{\"84\":1}}],[\"project>\",{\"1\":{\"64\":1}}],[\"project1\",{\"1\":{\"23\":2}}],[\"processtransactionstate\",{\"1\":{\"1472\":2}}],[\"processed\",{\"1\":{\"1373\":1}}],[\"processesqueue\",{\"1\":{\"860\":4}}],[\"processes\",{\"1\":{\"171\":2,\"628\":1}}],[\"processconsumeresult\",{\"1\":{\"1187\":1,\"1188\":1,\"1195\":2,\"1230\":1}}],[\"processpullresult\",{\"1\":{\"1175\":1,\"1229\":1,\"1319\":1,\"1329\":1}}],[\"processqueue>\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"processqueue>>\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"processqueuetable\",{\"1\":{\"1133\":1,\"1144\":3,\"1145\":1,\"1224\":3,\"1226\":1}}],[\"processqueue\",{\"1\":{\"1104\":1,\"1137\":1,\"1144\":9,\"1155\":1,\"1159\":1,\"1169\":3,\"1170\":14,\"1175\":2,\"1194\":5,\"1195\":5,\"1224\":9,\"1225\":1,\"1226\":5,\"1228\":3,\"1229\":2,\"1230\":15}}],[\"processstatus\",{\"1\":{\"861\":3}}],[\"processrequest方法拉取消息\",{\"1\":{\"825\":1}}],[\"processrequestwrapper\",{\"1\":{\"820\":2}}],[\"processrequest\",{\"0\":{\"819\":1,\"1269\":1,\"1273\":1,\"1462\":1,\"1464\":1},\"1\":{\"809\":1,\"812\":1,\"814\":2,\"815\":1,\"819\":1,\"820\":1,\"1055\":1,\"1056\":1,\"1163\":1,\"1173\":1,\"1257\":1,\"1260\":1,\"1269\":1,\"1273\":1,\"1318\":1,\"1450\":1,\"1451\":1,\"1464\":1}}],[\"processoffset\",{\"1\":{\"771\":7}}],[\"processortracker\",{\"1\":{\"372\":4}}],[\"processor\",{\"1\":{\"128\":2,\"372\":3,\"720\":1,\"736\":1}}],[\"processlimit\",{\"1\":{\"231\":1}}],[\"process3\",{\"1\":{\"196\":1}}],[\"processandhandoff\",{\"1\":{\"128\":2}}],[\"processing\",{\"1\":{\"128\":2,\"643\":2,\"1020\":1}}],[\"process\",{\"1\":{\"62\":6,\"113\":2,\"125\":5,\"127\":1,\"128\":2,\"171\":1,\"196\":3,\"217\":1,\"230\":1,\"614\":1,\"619\":1,\"621\":1,\"624\":8,\"627\":1,\"671\":2,\"672\":2,\"722\":3,\"820\":1,\"1053\":1,\"1195\":1,\"1277\":1,\"1372\":1,\"1468\":3}}],[\"proxy\",{\"1\":{\"41\":2}}],[\"progress\",{\"1\":{\"11\":2,\"886\":1}}],[\"c0a80109803418b4aac25d18020f0007\",{\"1\":{\"1445\":1}}],[\"c0a80109803418b4aac25d1801be0001\",{\"1\":{\"1445\":1}}],[\"c0a80109803418b4aac25d1801e70004\",{\"1\":{\"1445\":1}}],[\"cfcd208400000000000000000000\",{\"1\":{\"1383\":9}}],[\"cfnullable\",{\"1\":{\"742\":4}}],[\"cfnotnull\",{\"1\":{\"742\":8}}],[\"ck=\",{\"1\":{\"1280\":1}}],[\"ckmessagenumber\",{\"1\":{\"1269\":1}}],[\"ck\",{\"1\":{\"1251\":1,\"1263\":3,\"1271\":4,\"1275\":3,\"1276\":1,\"1277\":4,\"1278\":10,\"1279\":4,\"1280\":6}}],[\"ckgaaaaaaaaaaaaaaaaaaaaaasxmzyjzmzmfz2amllstmmbaaaaaaaaaaawyamzajmhzmxmmzmg2aaaaaayaamdaaaaambzs1smzmnmzmbzy\",{\"1\":{\"455\":1}}],[\"ckgaaaaaaaaaaaaaaaaaaaaaasxmzyjzmzmfz2amlbstmmbaaaaaaaaaaawyghzgy0mmzmmhzmb0gaaaaaadagzaaqaaaz2mbnlzszdzmdmxa\",{\"1\":{\"402\":1}}],[\"ckgaaaaaaaaaaaaaaaaaaaaaasxmzyjzmzmfzyamlybzmdaaaaaaaaaaaglbymbgndjzmdzmdmtxaaaaaagaazmgllxcmmzwgaaaalmzmwmg\",{\"1\":{\"443\":1}}],[\"ckgavcqzxenqpqxqed372hg2kuxmzyhzmzmfz2mdyzjttxmaaaaaaaaaaaawmmmzmdjmdymzmzmbm2aaaaaayaamdwyyybtzmldbaz2mbnlzszhxygmxa\",{\"1\":{\"403\":1}}],[\"ckgavcqzxenqpqxqed372hg2kuxmzyjzmzmfz2mdyzjttxmaaaaaaaaaaaawgmygykhzmxmmzmxcadaaaaagbwambyzzsgpzmlhagzbmtmlz2shzgygd\",{\"1\":{\"403\":1,\"449\":1}}],[\"centos\",{\"1\":{\"1072\":1}}],[\"certificate\",{\"1\":{\"961\":3}}],[\"certchanged\",{\"1\":{\"961\":4}}],[\"certain\",{\"1\":{\"396\":1}}],[\"cmq\",{\"1\":{\"922\":1}}],[\"cmdnum\",{\"1\":{\"147\":1}}],[\"cmd\",{\"1\":{\"143\":1,\"147\":1,\"243\":1,\"894\":10}}],[\"cqbuffer\",{\"1\":{\"1432\":17}}],[\"cqunit\",{\"1\":{\"1427\":11}}],[\"cqmaxoffset=\",{\"1\":{\"860\":1}}],[\"cqminoffset=\",{\"1\":{\"845\":1,\"860\":1}}],[\"cqminoffset\",{\"1\":{\"845\":4}}],[\"cqextunit\",{\"1\":{\"767\":1,\"825\":1,\"845\":5,\"860\":5,\"1174\":6,\"1297\":8,\"1318\":4,\"1328\":3,\"1333\":8}}],[\"cqoffset\",{\"1\":{\"765\":5}}],[\"cq\",{\"1\":{\"764\":2,\"765\":2,\"767\":1,\"769\":2,\"771\":2,\"845\":12,\"860\":14,\"1174\":3,\"1270\":1,\"1297\":2,\"1370\":11,\"1432\":1}}],[\"customizedtracetopic\",{\"1\":{\"1019\":2}}],[\"customheader\",{\"1\":{\"894\":2}}],[\"custom\",{\"1\":{\"742\":10}}],[\"curr\",{\"1\":{\"1520\":1}}],[\"currvotefor\",{\"1\":{\"1503\":2}}],[\"currterm\",{\"1\":{\"1495\":1,\"1496\":1,\"1497\":2,\"1500\":10,\"1503\":12,\"1516\":4,\"1517\":4,\"1519\":2,\"1521\":18}}],[\"curroffsetpy\",{\"1\":{\"1372\":6}}],[\"currreadtimems\",{\"1\":{\"1372\":5}}],[\"currwritetime\",{\"1\":{\"1371\":1}}],[\"currwritetimems\",{\"1\":{\"1371\":3,\"1372\":1}}],[\"currqueueoffset\",{\"1\":{\"1370\":7,\"1371\":1}}],[\"currposition\",{\"1\":{\"1368\":2}}],[\"current=\",{\"1\":{\"1427\":6}}],[\"currentoffset\",{\"1\":{\"1427\":21}}],[\"currentwritefile\",{\"1\":{\"1412\":1,\"1434\":1}}],[\"currentqueuecount\",{\"1\":{\"1145\":4}}],[\"currentthread\",{\"1\":{\"985\":1,\"1007\":1,\"1248\":1,\"1444\":1}}],[\"currenttimemillis\",{\"1\":{\"722\":1,\"769\":4,\"793\":1,\"825\":1,\"845\":1,\"860\":1,\"870\":1,\"882\":1,\"971\":1,\"1017\":1,\"1020\":2,\"1050\":3,\"1053\":4,\"1145\":1,\"1170\":2,\"1175\":1,\"1195\":3,\"1222\":2,\"1226\":1,\"1229\":1,\"1230\":4,\"1240\":1,\"1269\":1,\"1273\":1,\"1275\":1,\"1276\":1,\"1277\":2,\"1278\":4,\"1280\":1,\"1332\":1,\"1339\":1,\"1370\":2,\"1373\":3,\"1427\":2,\"1434\":1,\"1435\":1,\"1464\":3,\"1467\":2,\"1468\":5,\"1496\":1,\"1497\":2,\"1499\":2,\"1500\":2,\"1519\":7,\"1520\":2,\"1521\":5}}],[\"currentpendingnum=\",{\"1\":{\"860\":1}}],[\"currentpendingnum\",{\"1\":{\"860\":3}}],[\"currentlogicoffset\",{\"1\":{\"765\":9}}],[\"currently\",{\"1\":{\"643\":1,\"645\":1}}],[\"current\",{\"1\":{\"104\":1,\"171\":1,\"396\":1,\"771\":2,\"960\":1,\"1198\":2,\"1230\":3,\"1427\":2,\"1430\":1,\"1434\":1,\"1435\":1,\"1517\":3,\"1520\":2}}],[\"cursor\",{\"1\":{\"489\":2}}],[\"c节点中新增了e节点\",{\"1\":{\"674\":1}}],[\"c2\",{\"1\":{\"573\":1}}],[\"cjq\",{\"1\":{\"433\":1}}],[\"cwcozycelucxsijlzh6jicwuaesfoiocrtvgp6ho7tkt7ymslksf1ivsy8lr3vksfjrlcs8gpa9drfqyvy40dzvn4bogfz18gmibr4by3n5owcqmduwlivdoz1jfdqcrqlje8sxismwe1kyzbrmilme2qxhu3mlsckym5peardb14i4mhimvz7jwjier5mxilxyp8vxwbhtiqbb0ydwsdpwmy4jsfdjtguxfrrjgr4u2xaj3an8tgchyzdouervfxurmtn5xgcodvpyyhojli\",{\"1\":{\"429\":1}}],[\"c7dsaj\",{\"1\":{\"429\":1}}],[\"c1\",{\"1\":{\"330\":4,\"573\":1}}],[\"cst\",{\"1\":{\"316\":1}}],[\"cn1dn1exqhujo46ws9mphhnjd3e6fujlrtzyeqb4r8aqvy69enqdypfa8u9zfswak9jcoh\",{\"1\":{\"455\":1}}],[\"cndxj\",{\"1\":{\"423\":1}}],[\"cncf成立了专门的兴趣小组\",{\"1\":{\"276\":1}}],[\"cn\",{\"1\":{\"266\":1,\"274\":1,\"286\":1,\"1025\":1}}],[\"cnt\",{\"1\":{\"11\":1,\"741\":1}}],[\"c=>xx\",{\"1\":{\"192\":1}}],[\"c小于等于n并且a\",{\"1\":{\"184\":1}}],[\"crc32\",{\"1\":{\"970\":1}}],[\"creation\",{\"1\":{\"624\":1}}],[\"createflatfileforconsumequeue\",{\"1\":{\"1421\":1}}],[\"createflatfileforcommitlog\",{\"1\":{\"1421\":1}}],[\"createtimestamp\",{\"1\":{\"1420\":2}}],[\"createtopicinsendmessagebackmethod\",{\"1\":{\"1198\":2}}],[\"createtempfile\",{\"1\":{\"52\":1}}],[\"createrequestcommand\",{\"1\":{\"1172\":1}}],[\"createresponsecommand\",{\"1\":{\"973\":1,\"1173\":1,\"1198\":1,\"1273\":1,\"1464\":1}}],[\"createbrokercontroller\",{\"1\":{\"1079\":1}}],[\"createbook\",{\"1\":{\"85\":1}}],[\"createandupdatequeuedata\",{\"1\":{\"971\":1}}],[\"createuniqid\",{\"0\":{\"898\":1},\"1\":{\"886\":1,\"898\":1,\"899\":1,\"1017\":1}}],[\"createchannel\",{\"1\":{\"712\":1}}],[\"createpoint\",{\"1\":{\"537\":2}}],[\"create\",{\"1\":{\"252\":2,\"253\":4,\"330\":2,\"339\":2,\"548\":2,\"624\":1,\"1037\":1,\"1039\":1,\"1047\":4,\"1048\":1,\"1122\":2,\"1123\":1,\"1247\":1,\"1267\":1,\"1287\":1,\"1332\":1,\"1333\":1,\"1368\":2}}],[\"created\",{\"1\":{\"98\":1,\"961\":1,\"1047\":1,\"1048\":1,\"1072\":1,\"1075\":2,\"1077\":1,\"1079\":2,\"1122\":1,\"1123\":1}}],[\"createstarted\",{\"1\":{\"1435\":2,\"1436\":1}}],[\"createstudent\",{\"1\":{\"339\":2,\"341\":1}}],[\"creates\",{\"1\":{\"98\":2}}],[\"createsessionfactory\",{\"1\":{\"89\":1}}],[\"createnewindexfile\",{\"1\":{\"1434\":1}}],[\"createnewfile\",{\"1\":{\"52\":1}}],[\"createnamesrvcontroller\",{\"1\":{\"947\":1,\"960\":2}}],[\"createnamedquery\",{\"1\":{\"92\":1}}],[\"createquery\",{\"1\":{\"92\":1}}],[\"credit消息给列表中的进程\",{\"1\":{\"627\":1}}],[\"credit消息后\",{\"1\":{\"626\":1}}],[\"credits\",{\"1\":{\"627\":2}}],[\"credit\",{\"1\":{\"618\":2,\"621\":2,\"622\":2,\"624\":5,\"625\":4,\"626\":11,\"627\":7,\"628\":2}}],[\"crz1eaqz\",{\"1\":{\"429\":1}}],[\"cron\",{\"1\":{\"374\":1}}],[\"cross\",{\"1\":{\"171\":1}}],[\"crashed\",{\"1\":{\"1519\":1}}],[\"crash\",{\"1\":{\"372\":1}}],[\"cr用符号\",{\"1\":{\"288\":1}}],[\"cr\",{\"0\":{\"290\":1},\"1\":{\"288\":2,\"289\":1}}],[\"cd\",{\"1\":{\"171\":1,\"401\":1,\"403\":3,\"405\":2,\"406\":1,\"411\":1,\"413\":2,\"425\":1,\"443\":3,\"482\":1,\"485\":2,\"491\":1,\"1070\":1,\"1072\":1,\"1074\":1,\"1078\":1,\"1079\":1,\"1083\":1,\"1084\":1}}],[\"cb\",{\"1\":{\"171\":2}}],[\"ctx\",{\"1\":{\"814\":1,\"973\":1,\"1056\":5,\"1198\":2,\"1266\":2,\"1462\":4,\"1464\":1,\"1471\":2}}],[\"cto甚至包括ceo开始重视并投入到混沌工程实践中\",{\"1\":{\"276\":1}}],[\"ctemplate\",{\"1\":{\"235\":1}}],[\"ctrl\",{\"1\":{\"153\":16,\"154\":1,\"162\":15}}],[\"ctrl+f\",{\"1\":{\"145\":1}}],[\"ctrl+o\",{\"1\":{\"145\":1}}],[\"ctrl+v\",{\"1\":{\"144\":1}}],[\"ctrl+u\",{\"1\":{\"142\":1,\"145\":1}}],[\"ctrl+w\",{\"1\":{\"142\":1}}],[\"ctrl+h\",{\"1\":{\"142\":1}}],[\"ctrl+\",{\"1\":{\"142\":1}}],[\"ctrl+c\",{\"1\":{\"125\":2,\"142\":1}}],[\"ct\",{\"1\":{\"148\":1}}],[\"cg\",{\"1\":{\"117\":1}}],[\"caffeine\",{\"1\":{\"1406\":1}}],[\"cache的爱恨情仇\",{\"1\":{\"1537\":1}}],[\"cache的热点范围内\",{\"1\":{\"878\":1}}],[\"cache关系及演化历史\",{\"1\":{\"1527\":1}}],[\"cache和buffer\",{\"1\":{\"1527\":1}}],[\"cachebusy\",{\"1\":{\"1430\":2}}],[\"cached\",{\"1\":{\"1170\":2}}],[\"cachedmessagesizeinmib\",{\"1\":{\"1170\":4}}],[\"cachedmessagecount\",{\"1\":{\"1170\":4}}],[\"cache经由socket发送给了consumer\",{\"1\":{\"879\":1}}],[\"cache\",{\"0\":{\"879\":1},\"1\":{\"878\":1,\"879\":19,\"880\":1,\"882\":3,\"883\":10,\"886\":1,\"895\":1,\"931\":1,\"1267\":1,\"1382\":1,\"1390\":1,\"1427\":1,\"1431\":4}}],[\"caculate\",{\"1\":{\"230\":1}}],[\"caculateaera\",{\"1\":{\"230\":4}}],[\"caculategeometry\",{\"1\":{\"230\":3}}],[\"cause\",{\"1\":{\"820\":1,\"1173\":1,\"1270\":1,\"1370\":1}}],[\"caught\",{\"1\":{\"193\":3,\"194\":6}}],[\"cap\",{\"1\":{\"942\":1}}],[\"capacity\",{\"1\":{\"797\":1,\"1435\":1}}],[\"capacity属性\",{\"1\":{\"741\":1}}],[\"capital\",{\"1\":{\"561\":1,\"564\":2,\"570\":3}}],[\"car\",{\"1\":{\"571\":2,\"573\":4}}],[\"cameradistancemaxzoomfactor\",{\"1\":{\"490\":1}}],[\"cas\",{\"1\":{\"725\":1,\"915\":1}}],[\"cast\",{\"1\":{\"489\":8,\"490\":9,\"624\":2}}],[\"cases\",{\"1\":{\"1056\":1}}],[\"case\",{\"0\":{\"187\":1},\"1\":{\"97\":1,\"187\":3,\"189\":1,\"194\":1,\"196\":1,\"271\":1,\"515\":2,\"624\":5,\"625\":2,\"626\":1,\"627\":2,\"720\":1,\"764\":4,\"794\":4,\"819\":1,\"861\":4,\"1047\":4,\"1048\":2,\"1050\":3,\"1053\":3,\"1056\":1,\"1122\":6,\"1123\":2,\"1143\":2,\"1144\":2,\"1172\":3,\"1173\":20,\"1175\":4,\"1195\":4,\"1198\":1,\"1224\":2,\"1229\":1,\"1266\":2,\"1267\":1,\"1331\":3,\"1432\":2,\"1436\":4,\"1442\":3,\"1459\":4,\"1460\":3,\"1472\":3,\"1497\":9,\"1499\":4,\"1500\":1,\"1519\":6,\"1520\":7}}],[\"calsignature\",{\"1\":{\"995\":1,\"1000\":1}}],[\"calsignature方法会根据客户端的\",{\"1\":{\"995\":1}}],[\"calmsglength\",{\"1\":{\"737\":2}}],[\"calculateopoffset\",{\"1\":{\"1468\":1}}],[\"calculate\",{\"1\":{\"1020\":1,\"1432\":1}}],[\"calc\",{\"1\":{\"360\":1,\"1332\":4}}],[\"caller\",{\"1\":{\"1521\":3}}],[\"called\",{\"1\":{\"97\":1,\"192\":1,\"886\":1,\"906\":1}}],[\"calltimeout\",{\"1\":{\"1050\":2}}],[\"callback\",{\"1\":{\"171\":2}}],[\"callbacks\",{\"1\":{\"171\":1}}],[\"call\",{\"0\":{\"319\":1},\"1\":{\"97\":2,\"165\":2,\"192\":2,\"253\":1,\"319\":2,\"342\":1,\"351\":2,\"886\":1,\"901\":1,\"960\":1,\"1053\":2,\"1287\":1,\"1427\":1,\"1472\":1}}],[\"calls\",{\"1\":{\"97\":1}}],[\"callable<void>\",{\"1\":{\"960\":1}}],[\"callable\",{\"1\":{\"75\":1}}],[\"categories\",{\"1\":{\"348\":1,\"349\":1}}],[\"cat\",{\"1\":{\"181\":1,\"185\":2,\"186\":4,\"563\":4}}],[\"catcher2\",{\"1\":{\"195\":3}}],[\"catcher\",{\"1\":{\"193\":2,\"194\":2}}],[\"catch`表达式中\",{\"1\":{\"193\":1,\"194\":1}}],[\"catch和receive表达式\",{\"1\":{\"180\":1}}],[\"catch\",{\"0\":{\"194\":1,\"195\":1},\"1\":{\"34\":2,\"69\":2,\"112\":2,\"113\":2,\"122\":1,\"123\":1,\"125\":2,\"128\":2,\"131\":1,\"133\":1,\"171\":1,\"193\":3,\"194\":5,\"195\":5,\"196\":1,\"351\":2,\"355\":1,\"356\":1,\"396\":1,\"613\":1,\"742\":3,\"793\":2,\"794\":1,\"797\":4,\"820\":2,\"823\":1,\"824\":1,\"825\":2,\"844\":1,\"845\":1,\"860\":1,\"861\":3,\"870\":1,\"871\":1,\"872\":1,\"915\":1,\"961\":1,\"970\":2,\"971\":1,\"972\":2,\"984\":1,\"995\":1,\"996\":1,\"999\":2,\"1006\":1,\"1019\":1,\"1021\":1,\"1048\":5,\"1050\":1,\"1052\":1,\"1053\":1,\"1142\":1,\"1143\":1,\"1144\":1,\"1168\":3,\"1170\":3,\"1173\":2,\"1175\":1,\"1194\":2,\"1195\":1,\"1197\":2,\"1200\":1,\"1201\":1,\"1222\":1,\"1224\":1,\"1225\":1,\"1226\":1,\"1228\":1,\"1230\":1,\"1266\":1,\"1270\":1,\"1276\":1,\"1278\":1,\"1297\":2,\"1332\":2,\"1333\":2,\"1370\":2,\"1371\":2,\"1372\":2,\"1373\":2,\"1374\":2,\"1424\":1,\"1425\":1,\"1432\":1,\"1434\":1,\"1435\":3,\"1436\":2,\"1443\":1,\"1459\":3,\"1468\":2,\"1469\":1,\"1472\":2,\"1497\":2,\"1499\":1,\"1516\":1,\"1519\":3,\"1520\":6,\"1521\":2}}],[\"candidate\",{\"0\":{\"1480\":1,\"1486\":1},\"1\":{\"1477\":2,\"1478\":2,\"1479\":1,\"1480\":4,\"1482\":1,\"1484\":1,\"1486\":1,\"1488\":3,\"1489\":2,\"1491\":2,\"1492\":1,\"1495\":1,\"1497\":5,\"1499\":3,\"1500\":3,\"1503\":2}}],[\"canwrite\",{\"1\":{\"1297\":4}}],[\"cancel\",{\"1\":{\"665\":2}}],[\"cancelaura\",{\"1\":{\"490\":2}}],[\"can\",{\"1\":{\"101\":1,\"165\":1,\"230\":1,\"646\":1,\"845\":2,\"860\":2,\"961\":1,\"995\":1,\"998\":1,\"1019\":1,\"1173\":1,\"1174\":2,\"1225\":1,\"1269\":1,\"1278\":1,\"1279\":2,\"1280\":1,\"1297\":1,\"1468\":1,\"1503\":1}}],[\"chl\",{\"1\":{\"1331\":2}}],[\"choose\",{\"1\":{\"995\":1,\"1080\":1}}],[\"chpid\",{\"1\":{\"624\":9}}],[\"chkey\",{\"1\":{\"624\":5}}],[\"child\",{\"1\":{\"342\":4}}],[\"children\",{\"1\":{\"131\":5}}],[\"ch\",{\"1\":{\"125\":5,\"714\":2,\"715\":2}}],[\"chat\",{\"1\":{\"368\":1}}],[\"chaos\",{\"1\":{\"276\":1}}],[\"chanel\",{\"1\":{\"1300\":2}}],[\"changeroletofollower\",{\"1\":{\"1500\":1}}],[\"changeroletoleader\",{\"1\":{\"1497\":1}}],[\"changeroletocandidate\",{\"1\":{\"1495\":1,\"1497\":1,\"1499\":3,\"1500\":1,\"1503\":1}}],[\"changeinvisibletime\",{\"1\":{\"1251\":3}}],[\"changeinstancenametopid\",{\"1\":{\"1047\":1,\"1122\":1}}],[\"changed\",{\"1\":{\"961\":2,\"1143\":5,\"1144\":5,\"1145\":4,\"1224\":5,\"1521\":4}}],[\"changestate\",{\"1\":{\"1519\":8}}],[\"changes\",{\"1\":{\"165\":1,\"1370\":1}}],[\"change\",{\"1\":{\"148\":2,\"171\":1,\"720\":2,\"722\":1,\"732\":1,\"1267\":1,\"1331\":1,\"1435\":1,\"1500\":2,\"1519\":2}}],[\"channels\",{\"1\":{\"1331\":3}}],[\"channeloutboundbuffer\",{\"1\":{\"1300\":1}}],[\"channeloutboundhandler\",{\"1\":{\"135\":1}}],[\"channeloption\",{\"1\":{\"1300\":1}}],[\"channelfuture\",{\"1\":{\"820\":1,\"1173\":1}}],[\"channelfuturelistener\",{\"1\":{\"820\":1,\"1173\":1}}],[\"channelhandlercontext\",{\"1\":{\"814\":1,\"973\":1,\"1056\":1,\"1198\":1,\"1266\":1,\"1462\":1,\"1464\":1,\"1471\":1}}],[\"channel将会发送一条\",{\"1\":{\"626\":1}}],[\"channel累计处理的消息数达到morecreditafter值时\",{\"1\":{\"626\":1}}],[\"channel每处理一条消息\",{\"1\":{\"626\":1}}],[\"channel模块中调用credit\",{\"1\":{\"624\":1}}],[\"channel进程的id将从credit\",{\"1\":{\"627\":1}}],[\"channel进程的内存空间\",{\"1\":{\"624\":1}}],[\"channel进程会记录它向特定的发送者\",{\"1\":{\"626\":1}}],[\"channel进程发送的消息数\",{\"1\":{\"624\":1}}],[\"channel进程为例\",{\"1\":{\"623\":1}}],[\"channel中会调用credit\",{\"1\":{\"624\":1}}],[\"channelinboundhandler\",{\"1\":{\"135\":1}}],[\"channel\",{\"1\":{\"118\":18,\"121\":1,\"125\":3,\"128\":1,\"135\":4,\"136\":1,\"614\":1,\"619\":1,\"621\":7,\"622\":12,\"624\":13,\"625\":1,\"626\":1,\"665\":3,\"668\":5,\"712\":7,\"814\":2,\"819\":4,\"820\":7,\"896\":2,\"897\":2,\"967\":3,\"971\":3,\"972\":13,\"994\":1,\"1048\":1,\"1056\":1,\"1173\":11,\"1266\":1,\"1269\":8,\"1270\":7,\"1273\":3,\"1299\":4,\"1300\":4,\"1331\":2,\"1469\":5,\"1471\":1}}],[\"charsequence\",{\"1\":{\"894\":1}}],[\"charset\",{\"1\":{\"737\":4,\"894\":2,\"984\":1,\"1006\":1,\"1273\":1,\"1278\":2,\"1287\":1,\"1306\":1,\"1309\":1,\"1443\":1}}],[\"charat\",{\"1\":{\"508\":1}}],[\"chararraywriter和stringwriter在内存中模拟一个字符流输出\",{\"1\":{\"58\":1}}],[\"chararrayreader和stringreader可以在内存中模拟一个字符流输入\",{\"1\":{\"57\":1}}],[\"char\",{\"1\":{\"125\":1,\"145\":2,\"148\":1,\"385\":1,\"741\":1,\"900\":5,\"904\":2}}],[\"checkresponsefuturestimeout\",{\"1\":{\"1521\":1}}],[\"checkresponsefutureselapsed\",{\"1\":{\"1521\":2}}],[\"checkrequestheader\",{\"1\":{\"1472\":6}}],[\"checkquotaandwait\",{\"1\":{\"1519\":2}}],[\"checkqueueok\",{\"1\":{\"1275\":1}}],[\"checkappendfuture\",{\"1\":{\"1520\":2}}],[\"checkandfreshstate\",{\"1\":{\"1519\":4}}],[\"checkabnormalfuture\",{\"1\":{\"1511\":1,\"1520\":3}}],[\"checktermforwatermark\",{\"1\":{\"1521\":1}}],[\"checktermforpendingmap\",{\"1\":{\"1518\":1,\"1521\":1}}],[\"checktransactionstate\",{\"0\":{\"1471\":1,\"1472\":1},\"1\":{\"1471\":5,\"1472\":3}}],[\"checktransactionstaterequestheader\",{\"1\":{\"1469\":12,\"1471\":3,\"1472\":2}}],[\"checklistener\",{\"1\":{\"1472\":1}}],[\"checklocaltransactionstate\",{\"1\":{\"1472\":3}}],[\"checklocaltransaction\",{\"1\":{\"1442\":4,\"1454\":1,\"1472\":1}}],[\"check=\",{\"1\":{\"1468\":2}}],[\"checkimmunity=\",{\"1\":{\"1468\":1}}],[\"checkimmunitytimestr\",{\"1\":{\"1468\":7}}],[\"checkimmunitytime\",{\"1\":{\"1464\":2,\"1468\":12}}],[\"checkinterval\",{\"1\":{\"1467\":2}}],[\"checkindiskbycommitoffset\",{\"1\":{\"1174\":1}}],[\"checkdequeuelatch\",{\"1\":{\"1371\":1,\"1372\":2}}],[\"checkmax\",{\"1\":{\"1467\":2}}],[\"checkmultidispatchqueue\",{\"1\":{\"1297\":2}}],[\"checkmessage\",{\"1\":{\"1050\":2,\"1459\":1}}],[\"checkmessageandreturnsize\",{\"1\":{\"762\":1}}],[\"checkblock\",{\"1\":{\"1270\":1}}],[\"checkclientinbroker\",{\"1\":{\"1122\":1}}],[\"checkconfig\",{\"1\":{\"1047\":1,\"1122\":1}}],[\"checkforbiddenhook\",{\"1\":{\"1053\":1}}],[\"checkfields\",{\"1\":{\"742\":1}}],[\"checkproducertransactionstate\",{\"1\":{\"1469\":1}}],[\"checkpreparequeueoffset\",{\"1\":{\"1468\":1}}],[\"checkpreparemessage\",{\"1\":{\"1464\":2}}],[\"checkpermission\",{\"1\":{\"1000\":2}}],[\"checkperm\",{\"1\":{\"1000\":3}}],[\"checkpoint会先被保存在内存中\",{\"1\":{\"1253\":1}}],[\"checkpoint文件刷盘\",{\"1\":{\"789\":1,\"796\":1}}],[\"checkpoint\",{\"0\":{\"1259\":1,\"1261\":1,\"1274\":1},\"1\":{\"789\":2,\"1251\":1,\"1253\":10,\"1258\":5,\"1259\":4,\"1261\":3,\"1262\":10,\"1263\":3,\"1270\":2,\"1271\":1,\"1275\":3,\"1276\":5,\"1277\":10,\"1278\":4,\"1279\":1,\"1280\":1,\"1362\":2,\"1521\":1}}],[\"checkholdrequest\",{\"0\":{\"823\":1},\"1\":{\"812\":1,\"815\":3,\"823\":1,\"824\":1}}],[\"checknotnull\",{\"1\":{\"742\":8}}],[\"checkexecutor\",{\"1\":{\"1472\":1}}],[\"checker组件会对实验中的业务和非业务数据进行自动化分析\",{\"1\":{\"280\":1}}],[\"checked\",{\"0\":{\"103\":1},\"1\":{\"103\":1,\"1468\":4}}],[\"check\",{\"0\":{\"1468\":1},\"1\":{\"171\":1,\"823\":1,\"824\":1,\"886\":1,\"904\":1,\"1000\":6,\"1171\":1,\"1271\":1,\"1277\":1,\"1279\":1,\"1371\":1,\"1443\":1,\"1445\":3,\"1453\":1,\"1464\":2,\"1467\":5,\"1468\":10,\"1469\":2,\"1472\":3,\"1516\":4,\"1517\":8,\"1519\":10,\"1520\":16,\"1521\":2}}],[\"cheatsheet\",{\"1\":{\"15\":1}}],[\"cprof\",{\"1\":{\"255\":4}}],[\"cpu总体利用率达到\",{\"1\":{\"285\":1}}],[\"cpu\",{\"1\":{\"116\":1,\"130\":2,\"372\":1,\"379\":1,\"622\":2,\"648\":1,\"722\":1,\"733\":2,\"886\":1,\"894\":1,\"896\":1,\"900\":1,\"904\":2,\"914\":1,\"917\":1,\"1325\":2,\"1364\":1,\"1521\":1}}],[\"cp参数\",{\"1\":{\"23\":1}}],[\"cp\",{\"1\":{\"21\":1,\"942\":1,\"1080\":1}}],[\"c\",{\"0\":{\"242\":1,\"895\":1},\"1\":{\"21\":1,\"23\":4,\"52\":2,\"148\":2,\"150\":1,\"155\":1,\"171\":2,\"180\":2,\"181\":6,\"184\":7,\"192\":6,\"224\":1,\"230\":1,\"248\":1,\"261\":1,\"266\":3,\"267\":2,\"298\":8,\"303\":3,\"385\":2,\"538\":3,\"548\":2,\"553\":1,\"567\":1,\"576\":5,\"582\":4,\"584\":2,\"624\":3,\"626\":8,\"627\":3,\"742\":3,\"886\":1,\"890\":1,\"891\":2,\"960\":3,\"1075\":3,\"1077\":1,\"1079\":8,\"1080\":3,\"1247\":2,\"1248\":1,\"1441\":1}}],[\"cidallsize=\",{\"1\":{\"1143\":1}}],[\"cidall\",{\"1\":{\"1143\":6,\"1266\":6,\"1267\":10}}],[\"cid\",{\"1\":{\"1007\":1,\"1248\":1,\"1267\":2,\"1279\":1,\"1288\":2,\"1445\":3,\"1468\":2}}],[\"city\",{\"1\":{\"294\":1,\"316\":3}}],[\"circles\",{\"1\":{\"230\":1}}],[\"circle\",{\"1\":{\"230\":2,\"253\":1,\"560\":1,\"1097\":1}}],[\"ci\",{\"1\":{\"11\":2,\"155\":1}}],[\"cobbliu\",{\"1\":{\"1527\":1}}],[\"coffeemaker\",{\"1\":{\"1290\":1}}],[\"copybaseinfo\",{\"1\":{\"1516\":1}}],[\"copysubscription\",{\"1\":{\"1122\":1}}],[\"copyonwritearraylist<>\",{\"1\":{\"970\":1}}],[\"copymappedfiles\",{\"1\":{\"870\":1}}],[\"copy\",{\"1\":{\"720\":1,\"727\":1,\"886\":1,\"892\":1,\"894\":1,\"1371\":1,\"1524\":1,\"1527\":1}}],[\"coordinator\",{\"1\":{\"672\":1}}],[\"could\",{\"1\":{\"983\":1,\"1008\":1,\"1267\":1}}],[\"coutry\",{\"1\":{\"564\":1}}],[\"countofminute1\",{\"1\":{\"1277\":1}}],[\"count++\",{\"1\":{\"1277\":1}}],[\"countck++\",{\"1\":{\"1277\":2}}],[\"countck\",{\"1\":{\"1277\":1}}],[\"count=\",{\"1\":{\"1170\":2}}],[\"count时\",{\"1\":{\"690\":1}}],[\"count值为2表示两个副本\",{\"1\":{\"657\":1}}],[\"count值为1表示一个副本\",{\"1\":{\"657\":1}}],[\"countdownlatch\",{\"1\":{\"970\":5,\"1371\":3,\"1372\":4,\"1373\":2,\"1497\":2,\"1499\":2}}],[\"countdown秒之后执行\",{\"1\":{\"845\":1,\"860\":1}}],[\"countdown\",{\"1\":{\"613\":1,\"845\":4,\"860\":2,\"915\":1,\"970\":1,\"1497\":2,\"1499\":2}}],[\"countrywithpop\",{\"1\":{\"561\":1}}],[\"country\",{\"1\":{\"561\":2,\"564\":1,\"570\":3}}],[\"counts\",{\"1\":{\"396\":1}}],[\"counter\",{\"1\":{\"330\":2,\"967\":1,\"1275\":3,\"1277\":3}}],[\"count\",{\"1\":{\"320\":2,\"330\":2,\"657\":1,\"690\":1,\"712\":5,\"767\":1,\"797\":1,\"1170\":1,\"1174\":1,\"1270\":2,\"1277\":1,\"1430\":1,\"1436\":1,\"1443\":1,\"1468\":1}}],[\"course\",{\"1\":{\"97\":1}}],[\"corresponding\",{\"1\":{\"1021\":1}}],[\"correctposition\",{\"1\":{\"1428\":1}}],[\"correct\",{\"1\":{\"1270\":3,\"1428\":1,\"1430\":1,\"1435\":1}}],[\"correcttopic\",{\"1\":{\"1198\":3}}],[\"correcttagsoffset\",{\"1\":{\"1175\":1}}],[\"correction\",{\"1\":{\"1173\":2}}],[\"correcting\",{\"1\":{\"643\":1}}],[\"correctdelivertimestamp\",{\"1\":{\"845\":1,\"860\":1}}],[\"correlation\",{\"1\":{\"715\":1}}],[\"corbaorb\",{\"1\":{\"262\":1}}],[\"corescheduletaskmanager类负责管理所有调度的任务\",{\"1\":{\"374\":1}}],[\"core\",{\"1\":{\"96\":1,\"104\":1,\"598\":1}}],[\"core<\",{\"1\":{\"8\":1}}],[\"cost=\",{\"1\":{\"1497\":1,\"1499\":1}}],[\"cost=cost\",{\"1\":{\"253\":1}}],[\"costtimeasync\",{\"1\":{\"1053\":3}}],[\"costtimesync\",{\"1\":{\"1053\":3}}],[\"costtimes\",{\"1\":{\"1008\":1}}],[\"costtime\",{\"1\":{\"824\":3,\"1017\":1,\"1020\":2,\"1050\":3,\"1436\":3}}],[\"cost\",{\"1\":{\"177\":1,\"180\":1,\"183\":1,\"253\":19,\"824\":1,\"1020\":1,\"1435\":3,\"1436\":2}}],[\"code=\",{\"1\":{\"1000\":1}}],[\"code\",{\"1\":{\"171\":1,\"223\":3,\"348\":3,\"595\":1,\"720\":4,\"731\":1,\"736\":3,\"737\":2,\"742\":1,\"845\":1,\"860\":1,\"890\":1,\"894\":1,\"1328\":1,\"1333\":1,\"1352\":1,\"1368\":1,\"1370\":1,\"1500\":6,\"1519\":1,\"1520\":2}}],[\"collectors\",{\"1\":{\"1248\":1,\"1436\":1,\"1521\":1}}],[\"collect\",{\"1\":{\"1248\":1,\"1371\":1,\"1436\":1,\"1521\":1}}],[\"collectionutils\",{\"1\":{\"1371\":1}}],[\"collections\",{\"1\":{\"396\":1,\"1143\":2,\"1195\":1,\"1230\":1,\"1266\":2,\"1436\":1}}],[\"collection<consumerfilterdata>\",{\"1\":{\"1332\":1}}],[\"collection<subscriptiondata>\",{\"1\":{\"1331\":2}}],[\"collection<string>\",{\"1\":{\"46\":1}}],[\"collection<t>\",{\"1\":{\"396\":2}}],[\"color\",{\"1\":{\"582\":8,\"583\":2}}],[\"colorscheme\",{\"1\":{\"163\":3}}],[\"column\",{\"1\":{\"90\":5}}],[\"conumser\",{\"1\":{\"941\":1}}],[\"conf\",{\"1\":{\"866\":1,\"960\":1,\"979\":1,\"983\":1,\"998\":2,\"999\":1,\"1005\":1,\"1075\":14,\"1079\":5,\"1080\":12,\"1128\":1,\"1286\":1,\"1382\":1}}],[\"conflict\",{\"1\":{\"624\":1}}],[\"config目录下\",{\"1\":{\"983\":1}}],[\"configs\",{\"1\":{\"960\":1}}],[\"configtable\",{\"1\":{\"944\":1}}],[\"config\",{\"1\":{\"944\":1,\"960\":1,\"973\":1,\"998\":2,\"1000\":1,\"1174\":2,\"1395\":1,\"1420\":1,\"1523\":1}}],[\"configmanager\",{\"1\":{\"840\":2,\"1190\":2,\"1420\":2}}],[\"configured\",{\"1\":{\"1000\":1}}],[\"configureblocking\",{\"1\":{\"118\":1,\"121\":1,\"124\":1,\"133\":1}}],[\"configurator\",{\"1\":{\"960\":3}}],[\"configuration\",{\"1\":{\"643\":1,\"645\":1,\"1424\":1,\"1523\":2}}],[\"configuration>\",{\"1\":{\"64\":1}}],[\"confirm消息等\",{\"1\":{\"689\":1}}],[\"confirm\",{\"1\":{\"150\":1,\"671\":1}}],[\"considered\",{\"1\":{\"1468\":1}}],[\"consistenthashrouter<t\",{\"1\":{\"396\":1}}],[\"consistenthashrouter\",{\"1\":{\"396\":3}}],[\"consistent\",{\"1\":{\"382\":1,\"396\":1,\"705\":1,\"707\":1,\"710\":1,\"711\":2,\"712\":2,\"714\":1,\"715\":1,\"717\":1,\"1503\":1}}],[\"consuming\",{\"1\":{\"1225\":1}}],[\"consumsergroup\",{\"1\":{\"978\":1}}],[\"consumed\",{\"1\":{\"1467\":1}}],[\"consumethreadmax\",{\"1\":{\"1238\":2}}],[\"consumethreadmin\",{\"1\":{\"1238\":1}}],[\"consumetype\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"consumebatchsize\",{\"1\":{\"1194\":4,\"1230\":2}}],[\"consumeorderlystatus\",{\"1\":{\"1230\":8}}],[\"consumeorderlycontext\",{\"1\":{\"1230\":2}}],[\"consumeorderly\",{\"1\":{\"1122\":2,\"1170\":1,\"1228\":1}}],[\"consumeexecutor\",{\"1\":{\"1119\":2,\"1187\":1,\"1194\":2}}],[\"consumeconcurrentlycontext\",{\"1\":{\"985\":1,\"1007\":1,\"1195\":3,\"1197\":1,\"1444\":1}}],[\"consumeconcurrentlystatus\",{\"1\":{\"985\":2,\"1007\":2,\"1195\":6,\"1248\":1,\"1444\":2}}],[\"consumemessagedirectly\",{\"1\":{\"1187\":1}}],[\"consumemessagethread\",{\"1\":{\"1445\":3}}],[\"consumemessagethreadpool\",{\"1\":{\"1104\":1}}],[\"consumemessagetracehookimpl\",{\"1\":{\"1014\":1,\"1019\":1,\"1020\":1}}],[\"consumemessageservice\",{\"1\":{\"1104\":1,\"1119\":2,\"1122\":4,\"1175\":1,\"1187\":1,\"1229\":1}}],[\"consumemessageorderlyservice\",{\"1\":{\"1102\":1,\"1119\":1,\"1122\":1,\"1230\":20}}],[\"consumemessageconcurrentlyservice\",{\"1\":{\"1102\":1,\"1119\":1,\"1122\":1,\"1188\":1,\"1194\":1,\"1195\":14,\"1197\":1}}],[\"consumemessagecontext\",{\"1\":{\"1020\":2,\"1173\":2,\"1195\":15,\"1198\":1,\"1230\":15}}],[\"consumemessagehooklist\",{\"1\":{\"1055\":1}}],[\"consumemessageafter\",{\"1\":{\"1020\":1}}],[\"consumemessagebefore\",{\"1\":{\"1020\":1}}],[\"consumemessage\",{\"1\":{\"985\":1,\"1007\":1,\"1104\":1,\"1119\":2,\"1195\":3,\"1230\":4,\"1444\":1}}],[\"consumefromwhere\",{\"1\":{\"985\":1,\"1007\":1,\"1248\":1,\"1444\":1}}],[\"consumequque\",{\"1\":{\"857\":1}}],[\"consumequeuefilesegmenttable\",{\"1\":{\"1420\":1}}],[\"consumequeuefilesegment\",{\"1\":{\"1402\":1}}],[\"consumequeueinterface\",{\"1\":{\"1294\":1,\"1297\":1,\"1427\":1}}],[\"consumequeue里面的tagscode实际是一个时间点\",{\"1\":{\"845\":1,\"860\":1}}],[\"consumequeue>\",{\"1\":{\"769\":1,\"871\":1}}],[\"consumequeue>>\",{\"1\":{\"769\":1,\"871\":1}}],[\"consumequeuetable\",{\"1\":{\"769\":1,\"871\":1}}],[\"consumequeueext\",{\"1\":{\"760\":1,\"771\":2,\"825\":1,\"845\":2,\"860\":2,\"1174\":2,\"1297\":3,\"1318\":1,\"1323\":1,\"1328\":1,\"1332\":1,\"1333\":2}}],[\"consumequeue\",{\"0\":{\"744\":1,\"746\":1,\"747\":1,\"765\":1,\"771\":1,\"867\":1,\"871\":1,\"910\":1},\"1\":{\"744\":1,\"746\":3,\"747\":4,\"749\":4,\"750\":1,\"751\":4,\"755\":2,\"756\":5,\"757\":1,\"760\":3,\"761\":2,\"764\":5,\"765\":7,\"767\":8,\"769\":3,\"773\":3,\"781\":1,\"811\":1,\"812\":2,\"816\":1,\"834\":2,\"836\":2,\"839\":2,\"845\":6,\"857\":1,\"860\":4,\"863\":1,\"864\":2,\"867\":3,\"869\":2,\"871\":3,\"872\":1,\"877\":2,\"878\":3,\"879\":1,\"880\":1,\"912\":3,\"930\":3,\"1080\":1,\"1174\":17,\"1291\":2,\"1294\":3,\"1297\":3,\"1319\":2,\"1328\":1,\"1333\":1,\"1370\":6,\"1383\":2,\"1386\":2,\"1400\":1,\"1402\":2,\"1403\":10,\"1408\":3,\"1414\":1,\"1421\":1,\"1427\":11,\"1432\":2,\"1538\":1}}],[\"consume\",{\"0\":{\"773\":1},\"1\":{\"755\":2,\"756\":1,\"765\":2,\"771\":5,\"806\":1,\"812\":1,\"845\":1,\"860\":1,\"886\":2,\"910\":1,\"913\":1,\"985\":2,\"1007\":2,\"1019\":1,\"1020\":1,\"1144\":2,\"1170\":1,\"1173\":3,\"1174\":1,\"1176\":1,\"1195\":7,\"1202\":1,\"1224\":2,\"1228\":1,\"1230\":9,\"1243\":1,\"1247\":1,\"1248\":2,\"1297\":2,\"1328\":1,\"1333\":1,\"1383\":4,\"1432\":5,\"1444\":2,\"1445\":3}}],[\"consumernum=\",{\"1\":{\"1332\":1}}],[\"consumer=\",{\"1\":{\"1332\":1}}],[\"consumermanager\",{\"1\":{\"1317\":2,\"1318\":1,\"1319\":1}}],[\"consumermanagerprocess\",{\"1\":{\"1191\":1}}],[\"consumeroffset\",{\"1\":{\"1201\":1}}],[\"consumeroffsetmanager\",{\"1\":{\"1190\":2,\"1191\":2,\"1201\":1}}],[\"consumersendmsgbackrequestheader\",{\"1\":{\"1198\":3}}],[\"consumersendmessageback\",{\"1\":{\"1197\":1}}],[\"consumertable\",{\"1\":{\"1317\":1}}],[\"consumert\",{\"1\":{\"1195\":3,\"1230\":3}}],[\"consumereviveobj\",{\"1\":{\"1278\":6,\"1279\":7}}],[\"consumerevivemessage\",{\"0\":{\"1278\":1},\"1\":{\"1263\":2,\"1278\":1}}],[\"consumerequest\",{\"1\":{\"1188\":1,\"1194\":10,\"1195\":23,\"1230\":1}}],[\"consumerequestqueue\",{\"1\":{\"1187\":1,\"1188\":1}}],[\"consumereturntype\",{\"1\":{\"1020\":1,\"1195\":7,\"1230\":7}}],[\"consumeretrytimes\",{\"1\":{\"742\":1}}],[\"consumerfiltermanager\",{\"1\":{\"1173\":1,\"1317\":1,\"1321\":2,\"1324\":1,\"1331\":2,\"1332\":3,\"1333\":1,\"1424\":1}}],[\"consumerfilterdata\",{\"1\":{\"1173\":11,\"1317\":1,\"1332\":1,\"1333\":12}}],[\"consumergroupevent\",{\"1\":{\"1331\":1}}],[\"consumergroupinfo>\",{\"1\":{\"1317\":1}}],[\"consumergroupinfo\",{\"1\":{\"1173\":5,\"1266\":4}}],[\"consumergroup\",{\"1\":{\"978\":1,\"1019\":4,\"1143\":7,\"1144\":8,\"1169\":1,\"1171\":1,\"1195\":7,\"1197\":1,\"1224\":6,\"1226\":2,\"1230\":3,\"1266\":9,\"1267\":5,\"1323\":1,\"1331\":4}}],[\"consumer拉取请求\",{\"1\":{\"820\":1}}],[\"consumer\",{\"1\":{\"665\":3,\"767\":1,\"806\":1,\"809\":2,\"814\":4,\"815\":1,\"894\":1,\"944\":1,\"945\":1,\"968\":1,\"985\":7,\"1007\":7,\"1055\":1,\"1074\":1,\"1085\":1,\"1105\":1,\"1106\":1,\"1122\":3,\"1124\":1,\"1143\":1,\"1145\":1,\"1146\":1,\"1170\":4,\"1173\":17,\"1174\":2,\"1176\":1,\"1200\":2,\"1201\":1,\"1202\":1,\"1240\":1,\"1243\":1,\"1247\":1,\"1248\":11,\"1266\":1,\"1267\":2,\"1281\":1,\"1307\":1,\"1310\":1,\"1332\":2,\"1333\":1,\"1430\":1,\"1444\":8,\"1445\":1}}],[\"console\",{\"1\":{\"303\":4,\"309\":3,\"332\":1,\"338\":1,\"339\":2,\"351\":4,\"352\":1,\"353\":1,\"361\":1,\"364\":1,\"369\":5,\"490\":1,\"529\":1,\"533\":3,\"538\":1,\"541\":1,\"544\":1,\"575\":1,\"577\":1,\"587\":1,\"605\":1,\"960\":4,\"1073\":2}}],[\"const命令声明的数组变量是可以改变成员\",{\"1\":{\"524\":1}}],[\"const\",{\"0\":{\"524\":1},\"1\":{\"369\":3,\"500\":1,\"508\":1,\"509\":4,\"514\":2,\"518\":1,\"523\":1,\"524\":3,\"527\":2,\"529\":1,\"533\":3,\"535\":1,\"544\":1,\"545\":1,\"548\":1,\"550\":1,\"551\":1,\"552\":2,\"553\":1,\"554\":2,\"555\":3,\"556\":2,\"558\":1,\"573\":2,\"575\":1,\"578\":1,\"579\":2,\"580\":1,\"595\":1}}],[\"const与let都具有块级作用域\",{\"1\":{\"315\":1}}],[\"const定义常量\",{\"1\":{\"315\":1}}],[\"constants\",{\"1\":{\"598\":1}}],[\"constant\",{\"1\":{\"213\":1}}],[\"constructindexfile\",{\"1\":{\"1403\":1,\"1414\":1,\"1427\":1}}],[\"construct\",{\"1\":{\"104\":1,\"1425\":2}}],[\"constructor<abstractpluginmessagestore>\",{\"1\":{\"1425\":1}}],[\"constructor<\",{\"1\":{\"123\":1,\"133\":1}}],[\"constructor\",{\"1\":{\"43\":1,\"44\":1,\"123\":2,\"133\":2,\"342\":1,\"344\":1,\"345\":1,\"566\":3,\"576\":2,\"578\":1,\"1523\":1}}],[\"concurrentnavigablemap<long\",{\"1\":{\"1436\":1}}],[\"concurrentskiplistset<>\",{\"1\":{\"1372\":1}}],[\"concurrentmap<long\",{\"1\":{\"1514\":1,\"1519\":2,\"1520\":1,\"1521\":1}}],[\"concurrentmap<integer\",{\"1\":{\"769\":2,\"840\":1,\"871\":2,\"1201\":1}}],[\"concurrentmap<string\",{\"1\":{\"769\":1,\"815\":1,\"871\":1,\"950\":1,\"968\":1,\"971\":1,\"1212\":1,\"1222\":1,\"1317\":1,\"1514\":1}}],[\"concurrenthashmap<messagequeue\",{\"1\":{\"1212\":1,\"1222\":3}}],[\"concurrenthashmap<integer\",{\"1\":{\"1201\":1}}],[\"concurrenthashmap<string\",{\"1\":{\"950\":1,\"968\":1,\"1222\":1,\"1436\":1,\"1442\":1}}],[\"concurrenthashmap<>\",{\"1\":{\"815\":1,\"1222\":1,\"1436\":1,\"1442\":1,\"1514\":2,\"1519\":2,\"1520\":1}}],[\"concurrenthashmap\",{\"1\":{\"726\":1,\"815\":1}}],[\"concurrent\",{\"1\":{\"712\":1,\"1371\":1}}],[\"concurrently\",{\"1\":{\"104\":1}}],[\"concepts\",{\"1\":{\"628\":1}}],[\"concat\",{\"1\":{\"298\":2}}],[\"convert\",{\"1\":{\"171\":1,\"983\":1,\"1374\":1}}],[\"continuously\",{\"1\":{\"1230\":1}}],[\"continueconsume\",{\"1\":{\"1230\":4}}],[\"continue\",{\"1\":{\"125\":1,\"643\":1,\"742\":1,\"767\":2,\"793\":1,\"825\":2,\"845\":2,\"860\":2,\"1000\":1,\"1020\":2,\"1021\":1,\"1050\":1,\"1144\":2,\"1174\":4,\"1222\":2,\"1224\":2,\"1277\":5,\"1278\":3,\"1279\":4,\"1280\":4,\"1332\":2,\"1371\":1,\"1373\":1,\"1374\":1,\"1435\":1,\"1468\":9,\"1499\":1,\"1520\":2,\"1521\":2}}],[\"container\",{\"1\":{\"1075\":5,\"1077\":2,\"1078\":1,\"1079\":2}}],[\"contains\",{\"1\":{\"994\":1,\"998\":1,\"999\":1,\"1144\":1,\"1200\":1,\"1224\":1,\"1226\":1,\"1322\":1,\"1323\":1,\"1328\":1,\"1329\":1,\"1373\":1}}],[\"containskey\",{\"1\":{\"722\":1,\"998\":1,\"1000\":2,\"1056\":1,\"1144\":1,\"1224\":1,\"1468\":1}}],[\"containsexactly\",{\"1\":{\"106\":3}}],[\"contrib\",{\"1\":{\"644\":1}}],[\"controller\",{\"1\":{\"960\":10}}],[\"control\",{\"0\":{\"609\":1},\"1\":{\"280\":1,\"609\":1,\"614\":1,\"621\":2,\"624\":1,\"628\":2,\"718\":1,\"860\":2,\"976\":1,\"1170\":6}}],[\"content\",{\"1\":{\"624\":4,\"845\":2,\"860\":2,\"973\":2,\"1021\":3,\"1174\":2,\"1434\":1}}],[\"contents\",{\"1\":{\"381\":1,\"578\":2}}],[\"contextlist\",{\"1\":{\"1021\":3}}],[\"contexts\",{\"1\":{\"1021\":4}}],[\"contexttype\",{\"1\":{\"1020\":3}}],[\"contextcode\",{\"1\":{\"1017\":1}}],[\"context\",{\"1\":{\"266\":3,\"272\":1,\"273\":1,\"605\":3,\"606\":2,\"961\":2,\"985\":1,\"1007\":1,\"1017\":1,\"1020\":18,\"1021\":9,\"1053\":17,\"1173\":15,\"1195\":9,\"1197\":4,\"1198\":2,\"1230\":5,\"1248\":1,\"1332\":2,\"1333\":2,\"1424\":2,\"1425\":3,\"1444\":1}}],[\"conditional来进行条件装配\",{\"1\":{\"84\":1}}],[\"connecton\",{\"1\":{\"668\":1}}],[\"connectionfactory\",{\"1\":{\"712\":2}}],[\"connection\",{\"1\":{\"368\":2,\"369\":2,\"613\":3,\"614\":1,\"621\":1,\"622\":8,\"623\":1,\"625\":2,\"668\":1,\"712\":3}}],[\"connection的实例\",{\"1\":{\"89\":1}}],[\"connect\",{\"1\":{\"73\":2,\"118\":1,\"241\":1}}],[\"connected\",{\"1\":{\"69\":1,\"113\":1}}],[\"combinerequestcontent\",{\"1\":{\"995\":2}}],[\"combat\",{\"1\":{\"490\":6}}],[\"combo\",{\"1\":{\"422\":1,\"432\":1,\"443\":1,\"448\":2,\"461\":1,\"464\":1,\"468\":2,\"492\":2}}],[\"com不同\",{\"1\":{\"350\":1}}],[\"com和example\",{\"1\":{\"350\":1}}],[\"commercialsizepermsg\",{\"1\":{\"1269\":2}}],[\"commercialbasecount\",{\"1\":{\"1173\":2}}],[\"commercial\",{\"1\":{\"1173\":1}}],[\"commpressed\",{\"1\":{\"1053\":1}}],[\"communicationmode\",{\"1\":{\"1050\":7,\"1053\":7,\"1170\":1,\"1171\":4,\"1172\":3}}],[\"commitindex\",{\"1\":{\"1519\":2}}],[\"commitorrollback\",{\"1\":{\"1472\":1}}],[\"commitoffset\",{\"1\":{\"1170\":1,\"1171\":3,\"1173\":1,\"1191\":1,\"1201\":3,\"1270\":3,\"1279\":1,\"1427\":2}}],[\"commitoffsetvalue\",{\"1\":{\"1170\":4}}],[\"commitoffsetenable\",{\"1\":{\"1170\":3}}],[\"commitlatency\",{\"1\":{\"1464\":2}}],[\"commitlock\",{\"1\":{\"1428\":1}}],[\"commitlogfilesegmenttable\",{\"1\":{\"1402\":1,\"1420\":1}}],[\"commitlogrollinginterval\",{\"1\":{\"1382\":1}}],[\"commitlogoffset=69962472685\",{\"1\":{\"1445\":1}}],[\"commitlogoffset=69962472265\",{\"1\":{\"1445\":1}}],[\"commitlogoffset=69962471845\",{\"1\":{\"1445\":1}}],[\"commitlogoffset=\",{\"1\":{\"1332\":1,\"1464\":2,\"1468\":1}}],[\"commitlogdelay\",{\"1\":{\"1278\":2}}],[\"commitlogdispatchercalcbitmap\",{\"1\":{\"1323\":2,\"1332\":1,\"1424\":1}}],[\"commitlogdispatcher\",{\"1\":{\"762\":1,\"763\":1}}],[\"commitlogdispatcherbuildconsumequeue\",{\"0\":{\"764\":1},\"1\":{\"756\":1}}],[\"commitlog偏移量\",{\"1\":{\"872\":1}}],[\"commitlog可用则一直进行循环扫描\",{\"1\":{\"762\":1}}],[\"commitlog\",{\"0\":{\"731\":1,\"839\":1,\"843\":1,\"866\":1,\"870\":1,\"910\":1,\"1294\":1},\"1\":{\"720\":3,\"727\":1,\"728\":1,\"729\":2,\"730\":1,\"731\":2,\"733\":4,\"736\":5,\"737\":7,\"738\":2,\"746\":1,\"747\":5,\"749\":1,\"750\":2,\"751\":2,\"755\":1,\"756\":3,\"761\":1,\"762\":3,\"765\":8,\"767\":5,\"778\":2,\"780\":1,\"781\":2,\"782\":2,\"786\":2,\"787\":4,\"794\":2,\"806\":1,\"811\":1,\"814\":1,\"816\":1,\"833\":2,\"836\":4,\"837\":2,\"841\":1,\"847\":4,\"848\":1,\"850\":1,\"857\":1,\"861\":1,\"863\":1,\"864\":3,\"866\":6,\"867\":1,\"868\":3,\"869\":2,\"870\":4,\"871\":2,\"872\":3,\"876\":2,\"877\":5,\"878\":3,\"879\":1,\"880\":1,\"881\":1,\"910\":1,\"912\":2,\"927\":1,\"930\":6,\"1080\":1,\"1163\":1,\"1164\":1,\"1174\":5,\"1188\":6,\"1198\":2,\"1291\":3,\"1294\":4,\"1296\":1,\"1318\":1,\"1333\":1,\"1346\":1,\"1347\":3,\"1348\":2,\"1352\":2,\"1354\":1,\"1355\":1,\"1356\":1,\"1357\":2,\"1359\":3,\"1360\":2,\"1363\":1,\"1364\":1,\"1370\":1,\"1371\":2,\"1373\":2,\"1374\":1,\"1382\":1,\"1383\":3,\"1386\":4,\"1400\":1,\"1402\":5,\"1403\":9,\"1408\":3,\"1421\":1,\"1427\":3,\"1432\":2,\"1453\":1,\"1464\":1,\"1509\":1}}],[\"commitmessagestotal\",{\"1\":{\"1464\":1}}],[\"commitmessage\",{\"1\":{\"1464\":1}}],[\"commit0\",{\"1\":{\"1428\":2}}],[\"commitposition\",{\"1\":{\"1428\":3}}],[\"commit=\",{\"1\":{\"1428\":1}}],[\"commitasync\",{\"0\":{\"1428\":1},\"1\":{\"1427\":4,\"1428\":1,\"1435\":1}}],[\"commitqueueoffset\",{\"1\":{\"1371\":4}}],[\"commits\",{\"1\":{\"886\":1}}],[\"committed=\",{\"1\":{\"1521\":2}}],[\"committedindex=\",{\"1\":{\"1520\":1}}],[\"committedindex\",{\"1\":{\"1508\":2,\"1510\":3,\"1511\":2,\"1520\":4,\"1521\":2}}],[\"committed\",{\"1\":{\"720\":1,\"722\":2,\"1270\":1,\"1427\":1,\"1464\":1,\"1468\":1}}],[\"commit\",{\"1\":{\"663\":1,\"720\":2,\"736\":1,\"764\":1,\"787\":1,\"794\":1,\"843\":1,\"886\":1,\"913\":1,\"1230\":1,\"1270\":1,\"1279\":1,\"1297\":2,\"1333\":1,\"1383\":4,\"1403\":8,\"1427\":3,\"1428\":2,\"1442\":3,\"1445\":1,\"1446\":3,\"1451\":1,\"1459\":1,\"1460\":2,\"1464\":3,\"1472\":2,\"1510\":4,\"1511\":2,\"1519\":3,\"1520\":8}}],[\"commonexecutor\",{\"1\":{\"1427\":1}}],[\"commonjs\",{\"0\":{\"362\":1,\"594\":1},\"1\":{\"594\":1,\"595\":2,\"596\":2,\"597\":2}}],[\"common\",{\"1\":{\"272\":1,\"624\":1}}],[\"commons\",{\"1\":{\"60\":1}}],[\"commandline2properties\",{\"1\":{\"960\":1}}],[\"commandline\",{\"1\":{\"960\":6}}],[\"commandcustomheader>\",{\"1\":{\"742\":1}}],[\"commandcustomheader\",{\"1\":{\"742\":3,\"995\":1}}],[\"commands\",{\"1\":{\"171\":4}}],[\"command\",{\"1\":{\"155\":1,\"171\":1,\"241\":1,\"624\":1,\"1075\":2,\"1077\":1,\"1079\":2,\"1173\":1}}],[\"command模式命令\",{\"1\":{\"154\":1}}],[\"command命令模式\",{\"0\":{\"143\":1}}],[\"compose\",{\"0\":{\"1068\":1,\"1075\":1,\"1078\":1},\"1\":{\"1068\":1,\"1069\":1,\"1074\":2,\"1075\":11,\"1078\":3,\"1538\":1}}],[\"components\",{\"1\":{\"598\":1}}],[\"component\",{\"1\":{\"46\":2,\"598\":1}}],[\"compressed\",{\"1\":{\"970\":3,\"1053\":2}}],[\"comprehension\",{\"1\":{\"184\":1}}],[\"completablefuture\",{\"1\":{\"1056\":3,\"1198\":7,\"1427\":10,\"1428\":5,\"1430\":5,\"1431\":1,\"1432\":5,\"1436\":9,\"1500\":9,\"1503\":11}}],[\"completablefuture<pushentryresponse>>\",{\"1\":{\"1520\":5}}],[\"completablefuture<pushentryresponse>>>\",{\"1\":{\"1520\":3}}],[\"completablefuture<pushentryresponse>\",{\"1\":{\"1519\":2,\"1520\":9}}],[\"completablefuture<putmessageresult>\",{\"1\":{\"843\":1,\"1056\":1,\"1198\":1,\"1296\":1,\"1462\":1,\"1463\":1}}],[\"completablefuture<appendentryresponse>\",{\"1\":{\"1516\":1,\"1518\":2,\"1521\":1}}],[\"completablefuture<heartbeatresponse>\",{\"1\":{\"1499\":1,\"1500\":1}}],[\"completablefuture<voteresponse>\",{\"1\":{\"1497\":1,\"1502\":1,\"1503\":1}}],[\"completablefuture<void>\",{\"1\":{\"1427\":1,\"1436\":1}}],[\"completablefuture<>\",{\"1\":{\"1436\":1}}],[\"completablefuture<list<indexitem>>\",{\"1\":{\"1436\":6}}],[\"completablefuture<long>\",{\"1\":{\"1431\":1}}],[\"completablefuture<bytebuffer>\",{\"1\":{\"1432\":2}}],[\"completablefuture<boolean>\",{\"1\":{\"1427\":1,\"1428\":1}}],[\"completablefuture<getmessageresultext>\",{\"1\":{\"1431\":1,\"1432\":1}}],[\"completablefuture<getmessageresult>\",{\"1\":{\"1430\":1}}],[\"completablefuture<remotingcommand>\",{\"1\":{\"1056\":1,\"1198\":1}}],[\"completeexceptionally\",{\"1\":{\"1436\":2}}],[\"completedfuture\",{\"1\":{\"1056\":3,\"1198\":7,\"1427\":10,\"1428\":5,\"1430\":5,\"1431\":1,\"1432\":5,\"1436\":4,\"1500\":9,\"1503\":11}}],[\"complete\",{\"1\":{\"11\":3,\"1436\":1,\"1520\":13,\"1521\":3}}],[\"compact\",{\"1\":{\"1435\":5,\"1436\":4}}],[\"compacttonewfile\",{\"1\":{\"1435\":2}}],[\"compacted\",{\"1\":{\"1435\":2}}],[\"compactmappedfile\",{\"1\":{\"1412\":1,\"1435\":2}}],[\"compacting\",{\"1\":{\"1394\":2,\"1412\":1,\"1417\":1}}],[\"compaction\",{\"1\":{\"1364\":2,\"1435\":5}}],[\"comparison\",{\"1\":{\"1519\":1}}],[\"compared\",{\"1\":{\"1519\":6}}],[\"compareindex=\",{\"1\":{\"1519\":6,\"1520\":1}}],[\"compareindex\",{\"1\":{\"1519\":39,\"1520\":6}}],[\"compareortruncaterequests\",{\"1\":{\"1511\":3,\"1520\":6}}],[\"compare\",{\"1\":{\"1510\":6,\"1511\":3,\"1519\":26,\"1520\":10}}],[\"compareandset\",{\"1\":{\"844\":1,\"915\":2,\"1497\":1,\"1499\":1,\"1519\":1}}],[\"comparable<tracecontext>\",{\"1\":{\"1017\":1}}],[\"comparator\",{\"1\":{\"75\":1,\"1521\":1}}],[\"company\",{\"1\":{\"252\":1}}],[\"computeifabsent\",{\"1\":{\"1421\":1,\"1427\":1}}],[\"computeelapsedtimemilliseconds\",{\"1\":{\"1332\":1}}],[\"computepullfromwhichfilterserver\",{\"1\":{\"1171\":1}}],[\"computepullfromwherewithexception\",{\"1\":{\"1137\":1,\"1144\":1,\"1170\":1,\"1224\":1,\"1228\":1}}],[\"computedelivertimestamp\",{\"1\":{\"845\":1,\"860\":1}}],[\"compute\",{\"1\":{\"111\":1,\"116\":1,\"127\":1,\"845\":1,\"860\":1,\"1144\":1,\"1170\":1,\"1224\":1,\"1228\":1}}],[\"compiled\",{\"1\":{\"1332\":1}}],[\"compile这个goal来完成编译\",{\"1\":{\"64\":1}}],[\"compileroptions\",{\"1\":{\"499\":1,\"601\":3}}],[\"compiler\",{\"1\":{\"63\":2,\"64\":1,\"1321\":2}}],[\"compile\",{\"1\":{\"60\":1,\"62\":2,\"63\":2,\"64\":1,\"171\":3,\"203\":1,\"230\":1,\"235\":1,\"253\":1,\"1321\":1}}],[\"com\",{\"1\":{\"16\":1,\"21\":5,\"89\":1,\"96\":1,\"110\":1,\"165\":2,\"166\":1,\"264\":1,\"266\":1,\"268\":1,\"272\":4,\"274\":1,\"291\":1,\"381\":3,\"493\":1,\"642\":2,\"644\":1,\"645\":2,\"646\":1,\"654\":1,\"692\":1,\"712\":1,\"756\":1,\"774\":1,\"806\":1,\"812\":1,\"852\":1,\"1025\":1,\"1053\":1,\"1070\":1,\"1284\":1,\"1297\":1,\"1299\":3,\"1504\":1,\"1522\":1}}],[\"cluster=defaultcluster\",{\"1\":{\"1445\":3}}],[\"clusterinfo\",{\"1\":{\"1248\":3}}],[\"clustering\",{\"0\":{\"1091\":1},\"1\":{\"1088\":1,\"1122\":2,\"1143\":1,\"1170\":1,\"1195\":1,\"1225\":1,\"1230\":2,\"1266\":1}}],[\"cluster2\",{\"1\":{\"1235\":1}}],[\"cluster1\",{\"1\":{\"1235\":1}}],[\"clustername\",{\"1\":{\"949\":1,\"966\":1,\"970\":2,\"971\":4,\"972\":5,\"1056\":2,\"1247\":1}}],[\"cluster信息\",{\"1\":{\"944\":1}}],[\"clusteraddrtable\",{\"0\":{\"966\":1},\"1\":{\"944\":1,\"949\":1,\"953\":1,\"954\":1,\"966\":1,\"971\":3,\"972\":4}}],[\"clustertestrequestprocessor\",{\"1\":{\"944\":1}}],[\"cluster\",{\"1\":{\"645\":1,\"657\":1,\"965\":1,\"968\":2,\"972\":1,\"1056\":1,\"1247\":2,\"1248\":1}}],[\"club\",{\"1\":{\"265\":1}}],[\"clonemessage\",{\"1\":{\"1053\":2}}],[\"clonelistandclear\",{\"1\":{\"825\":1}}],[\"clone\",{\"1\":{\"563\":8,\"1053\":1,\"1070\":1}}],[\"cloner\",{\"1\":{\"563\":4}}],[\"closure\",{\"1\":{\"329\":1,\"624\":1}}],[\"closedchannelexception\",{\"1\":{\"131\":1}}],[\"closed\",{\"1\":{\"124\":1,\"125\":1,\"1428\":1}}],[\"close\",{\"1\":{\"69\":1,\"70\":1,\"113\":2,\"125\":2,\"128\":1,\"241\":1,\"259\":1,\"960\":1}}],[\"cloudamqp\",{\"1\":{\"692\":1,\"707\":1}}],[\"cloud\",{\"1\":{\"274\":1}}],[\"clipboard+=unnamed\",{\"1\":{\"158\":1}}],[\"clipboard=unnamedset\",{\"1\":{\"158\":1}}],[\"clientremotingprocessor\",{\"0\":{\"1471\":1},\"1\":{\"1471\":1}}],[\"clients\",{\"1\":{\"1249\":1}}],[\"clientversion\",{\"1\":{\"1331\":3}}],[\"clientv\",{\"1\":{\"1173\":1}}],[\"clienterrorcode\",{\"1\":{\"1050\":1}}],[\"clientip=\",{\"1\":{\"1173\":1}}],[\"clientip\",{\"1\":{\"1036\":1,\"1240\":3}}],[\"clientid=\",{\"1\":{\"1143\":1}}],[\"clientid\",{\"0\":{\"1240\":1},\"1\":{\"1036\":3,\"1037\":1,\"1048\":1,\"1123\":1,\"1200\":1,\"1222\":6,\"1235\":4,\"1240\":4,\"1266\":4,\"1267\":5}}],[\"clienthost=\",{\"1\":{\"1201\":1}}],[\"clienthost\",{\"1\":{\"1008\":1,\"1017\":1,\"1201\":6}}],[\"clientconfig\",{\"1\":{\"903\":1,\"1048\":5,\"1123\":1}}],[\"client<\",{\"1\":{\"712\":1}}],[\"client\",{\"1\":{\"69\":1,\"70\":1,\"112\":1,\"113\":1,\"280\":1,\"368\":1,\"369\":2,\"613\":1,\"614\":1,\"660\":1,\"712\":2,\"945\":1,\"1047\":2,\"1048\":1,\"1122\":1,\"1123\":1,\"1156\":1,\"1174\":1,\"1212\":1,\"1266\":3,\"1267\":1,\"1273\":1,\"1281\":1,\"1300\":1,\"1415\":1,\"1427\":1,\"1443\":1,\"1459\":1,\"1462\":1,\"1463\":1,\"1468\":1,\"1469\":1,\"1471\":1,\"1472\":3}}],[\"clearcommitoffsetflag\",{\"1\":{\"1171\":1}}],[\"clearproperty\",{\"1\":{\"1053\":2,\"1197\":1,\"1459\":1,\"1464\":1}}],[\"clearfocus\",{\"1\":{\"490\":1}}],[\"clear\",{\"1\":{\"122\":1,\"125\":2,\"128\":1,\"253\":2,\"738\":1,\"999\":1,\"1266\":1,\"1371\":1,\"1372\":1,\"1373\":1,\"1519\":3,\"1520\":1,\"1521\":2}}],[\"cleanofflinebroker\",{\"1\":{\"1048\":1}}],[\"cleanimmediately\",{\"1\":{\"870\":4}}],[\"cleanatonce\",{\"1\":{\"870\":4}}],[\"cleanfilesperiodically\",{\"1\":{\"869\":2}}],[\"cleanconsumequeueservice\",{\"1\":{\"869\":2,\"871\":1,\"872\":1}}],[\"cleancommitlogservice\",{\"1\":{\"869\":2}}],[\"clean\",{\"1\":{\"10\":1,\"62\":5,\"64\":2,\"972\":1}}],[\"clazz\",{\"1\":{\"48\":2,\"1425\":2}}],[\"classfilter模式详解\",{\"1\":{\"1334\":1}}],[\"classfilter\",{\"1\":{\"1170\":3}}],[\"classheader\",{\"1\":{\"742\":3}}],[\"classic\",{\"0\":{\"599\":1},\"1\":{\"597\":2,\"621\":2,\"648\":1,\"679\":1}}],[\"class命令也有类似作用\",{\"1\":{\"564\":1}}],[\"class的作用就是让javascript引擎去实现原来需要我们自己编写的原型链代码\",{\"1\":{\"343\":1}}],[\"class的实例不能单独存在\",{\"1\":{\"22\":1}}],[\"classname\",{\"1\":{\"266\":3}}],[\"classloader\",{\"1\":{\"266\":1}}],[\"classes\",{\"1\":{\"62\":2}}],[\"class对象的getresourceasstream\",{\"1\":{\"56\":1}}],[\"class<abstractpluginmessagestore>\",{\"1\":{\"1425\":2}}],[\"class<\",{\"1\":{\"48\":2,\"121\":2,\"133\":2,\"742\":1}}],[\"class<intpair>\",{\"1\":{\"48\":1}}],[\"class访问\",{\"1\":{\"36\":1}}],[\"class类的构造方法是private\",{\"1\":{\"36\":1}}],[\"class实例在jvm中是唯一的\",{\"1\":{\"36\":1}}],[\"class是由jvm在执行过程中动态加载的\",{\"1\":{\"36\":1}}],[\"class和其它信息\",{\"1\":{\"24\":1}}],[\"class文件\",{\"1\":{\"23\":1}}],[\"class文件只使用完整类名\",{\"1\":{\"20\":1}}],[\"classpath或\",{\"1\":{\"23\":1}}],[\"classpath的设定方法有两种\",{\"1\":{\"23\":1}}],[\"classpath是jvm用到的一个环境变量\",{\"1\":{\"23\":1}}],[\"classpath\",{\"0\":{\"23\":1,\"56\":1},\"1\":{\"1080\":1}}],[\"class\",{\"0\":{\"25\":1,\"36\":1,\"343\":1,\"344\":1,\"345\":1,\"562\":1,\"572\":1},\"1\":{\"9\":1,\"21\":2,\"22\":4,\"23\":3,\"24\":1,\"34\":1,\"36\":2,\"37\":2,\"39\":2,\"40\":2,\"41\":4,\"43\":2,\"44\":7,\"48\":2,\"69\":2,\"70\":1,\"84\":1,\"89\":2,\"90\":1,\"91\":2,\"92\":3,\"98\":3,\"99\":4,\"101\":3,\"102\":3,\"105\":1,\"106\":1,\"112\":1,\"113\":2,\"121\":1,\"123\":3,\"124\":1,\"126\":2,\"128\":2,\"129\":2,\"131\":1,\"133\":4,\"134\":2,\"339\":1,\"344\":1,\"345\":1,\"396\":3,\"398\":1,\"548\":1,\"562\":1,\"566\":1,\"567\":1,\"568\":1,\"570\":3,\"571\":2,\"573\":1,\"575\":1,\"576\":2,\"577\":1,\"578\":1,\"579\":3,\"580\":1,\"605\":2,\"606\":1,\"712\":1,\"742\":1,\"828\":1,\"950\":1,\"968\":1,\"973\":1,\"984\":1,\"985\":1,\"996\":1,\"998\":3,\"1017\":2,\"1021\":2,\"1140\":1,\"1169\":1,\"1170\":1,\"1173\":2,\"1198\":1,\"1222\":1,\"1230\":1,\"1248\":1,\"1273\":1,\"1278\":2,\"1323\":1,\"1367\":1,\"1368\":1,\"1425\":4,\"1442\":1,\"1464\":1,\"1468\":1,\"1471\":1,\"1514\":2,\"1519\":1,\"1520\":1,\"1521\":1}}],[\"o那些事\",{\"1\":{\"1527\":1}}],[\"occurs\",{\"1\":{\"1424\":1}}],[\"occurred\",{\"1\":{\"1052\":1,\"1373\":1,\"1374\":1}}],[\"oo\",{\"1\":{\"1430\":1}}],[\"oom\",{\"1\":{\"1404\":2,\"1432\":1}}],[\"oops\",{\"1\":{\"253\":1}}],[\"oop把系统看作多个对象的交互\",{\"1\":{\"85\":1}}],[\"o线程准备好处理队列中的写请求\",{\"1\":{\"1299\":1}}],[\"o线程将立即执行所请求的写操作时返回\",{\"1\":{\"1299\":1}}],[\"owner\",{\"1\":{\"1173\":5}}],[\"ownedperm\",{\"1\":{\"1000\":2}}],[\"ownedpermmap\",{\"1\":{\"1000\":6}}],[\"ownedaccess\",{\"1\":{\"1000\":13}}],[\"omitstacktraceinfastthrow\",{\"1\":{\"1080\":1}}],[\"omnicd\",{\"1\":{\"491\":1}}],[\"omni\",{\"1\":{\"162\":1}}],[\"o和磁盘空间的使用\",{\"1\":{\"657\":1}}],[\"overflow\",{\"1\":{\"819\":1,\"1173\":2,\"1174\":2,\"1175\":2,\"1270\":1,\"1430\":4,\"1431\":2,\"1432\":2}}],[\"over\",{\"1\":{\"645\":1,\"769\":1,\"771\":3,\"797\":1,\"820\":1,\"1173\":1}}],[\"override\",{\"1\":{\"41\":1,\"69\":1,\"112\":1,\"113\":1,\"122\":1,\"123\":1,\"125\":1,\"128\":2,\"133\":1,\"396\":2,\"793\":1,\"820\":2,\"824\":1,\"828\":1,\"844\":1,\"869\":1,\"891\":1,\"960\":1,\"961\":3,\"970\":1,\"985\":1,\"994\":2,\"995\":1,\"996\":2,\"999\":3,\"1007\":1,\"1020\":2,\"1021\":1,\"1048\":5,\"1140\":1,\"1145\":1,\"1173\":1,\"1175\":3,\"1194\":1,\"1195\":1,\"1200\":2,\"1201\":1,\"1225\":1,\"1288\":2,\"1296\":1,\"1297\":1,\"1328\":1,\"1331\":1,\"1332\":1,\"1333\":2,\"1371\":1,\"1373\":1,\"1374\":1,\"1427\":2,\"1430\":1,\"1434\":1,\"1435\":2,\"1436\":1,\"1442\":2,\"1444\":1,\"1458\":1,\"1464\":1,\"1467\":2,\"1468\":1,\"1469\":1,\"1472\":2,\"1516\":1,\"1517\":1,\"1519\":1,\"1520\":1,\"1521\":1}}],[\"o7w0w0zdxfv003z8mmpehqxrtgdhgbhhggjutxdmlfuyykejazznhpiec\",{\"1\":{\"469\":1}}],[\"oldoffset\",{\"1\":{\"1278\":5,\"1279\":2}}],[\"oldclientid\",{\"1\":{\"1222\":1}}],[\"oldaddr\",{\"1\":{\"971\":2}}],[\"old\",{\"1\":{\"741\":2,\"1278\":4,\"1518\":3,\"1520\":3}}],[\"oldparseint\",{\"1\":{\"320\":2}}],[\"oldvalue\",{\"1\":{\"217\":1}}],[\"ognl\",{\"0\":{\"274\":1},\"1\":{\"267\":2}}],[\"obtuseralivestatus\",{\"1\":{\"266\":1}}],[\"obtglobalstatistics\",{\"1\":{\"266\":1}}],[\"objlock\",{\"1\":{\"1230\":2}}],[\"obj\",{\"1\":{\"148\":1,\"338\":2,\"511\":7,\"512\":7,\"516\":2,\"550\":1,\"551\":1,\"553\":1,\"596\":2}}],[\"objectheader\",{\"1\":{\"742\":5}}],[\"object>\",{\"1\":{\"665\":2,\"714\":2,\"715\":1}}],[\"objectkey\",{\"1\":{\"396\":3}}],[\"objective\",{\"1\":{\"283\":2}}],[\"objects\",{\"1\":{\"97\":2,\"396\":1}}],[\"object\",{\"0\":{\"155\":1,\"510\":2,\"511\":1,\"512\":1},\"1\":{\"33\":1,\"41\":3,\"97\":1,\"155\":2,\"338\":1,\"339\":2,\"340\":3,\"341\":1,\"396\":2,\"506\":1,\"508\":2,\"512\":1,\"518\":1,\"742\":1,\"870\":1,\"872\":1,\"995\":1,\"1048\":1,\"1123\":1,\"1230\":1,\"1331\":1,\"1332\":1,\"1333\":1,\"1442\":1,\"1458\":1,\"1459\":1}}],[\"otp\",{\"0\":{\"262\":1},\"1\":{\"262\":1,\"643\":1}}],[\"other\",{\"0\":{\"608\":1},\"1\":{\"139\":1,\"168\":1,\"196\":1,\"263\":1,\"275\":1,\"287\":1,\"291\":1,\"370\":1,\"382\":1,\"398\":1,\"493\":1,\"624\":2}}],[\"oid\",{\"1\":{\"253\":2}}],[\"ospp\",{\"1\":{\"286\":1}}],[\"os\",{\"1\":{\"243\":1,\"288\":1,\"882\":4}}],[\"odds\",{\"1\":{\"189\":10}}],[\"o操作完成时会被阻塞\",{\"1\":{\"114\":1}}],[\"o\",{\"0\":{\"125\":1},\"1\":{\"114\":1,\"118\":6,\"124\":1,\"125\":1,\"127\":1,\"130\":3,\"137\":1,\"142\":2,\"151\":1,\"162\":1,\"171\":1,\"443\":1,\"622\":2,\"657\":1,\"662\":2,\"879\":1,\"917\":1,\"924\":1,\"931\":1,\"1077\":1,\"1300\":1,\"1453\":1,\"1527\":2}}],[\"on=true\",{\"1\":{\"1445\":3}}],[\"onsuccess\",{\"1\":{\"1175\":1,\"1229\":1,\"1288\":1}}],[\"onfilenumchanged\",{\"1\":{\"999\":2}}],[\"onfilechanged\",{\"1\":{\"999\":2}}],[\"oncommitted\",{\"1\":{\"1521\":1}}],[\"oncomplete\",{\"1\":{\"1462\":2}}],[\"onchanged\",{\"1\":{\"961\":1}}],[\"onchanneldestroy\",{\"1\":{\"954\":1,\"972\":3}}],[\"once\",{\"1\":{\"253\":1,\"283\":2,\"625\":3,\"972\":1,\"1047\":1,\"1122\":1,\"1200\":1,\"1237\":1}}],[\"onwaitend\",{\"0\":{\"1467\":1},\"1\":{\"915\":2,\"1467\":1}}],[\"oneway\",{\"1\":{\"970\":2,\"1050\":1,\"1053\":2,\"1172\":1}}],[\"onexceptionimpl\",{\"1\":{\"1040\":1}}],[\"onexception\",{\"1\":{\"861\":3,\"1175\":1,\"1288\":1}}],[\"one\",{\"1\":{\"515\":1,\"585\":2,\"819\":1,\"971\":1,\"995\":1,\"1027\":1,\"1173\":1,\"1174\":1,\"1175\":1,\"1287\":1,\"1372\":2,\"1430\":2,\"1431\":1,\"1432\":2,\"1468\":1}}],[\"onreadystatechange\",{\"1\":{\"348\":1}}],[\"only\",{\"1\":{\"230\":1,\"720\":1,\"736\":1,\"971\":1,\"1346\":1,\"1352\":1,\"1468\":1,\"1503\":1,\"1516\":1}}],[\"on\",{\"1\":{\"112\":1,\"143\":1,\"171\":2,\"369\":4,\"627\":1,\"628\":1,\"643\":4,\"645\":1,\"657\":1,\"659\":6,\"665\":2,\"714\":4,\"886\":1,\"1078\":1}}],[\"our\",{\"1\":{\"101\":1,\"102\":1,\"913\":1}}],[\"outdir\",{\"1\":{\"498\":1}}],[\"outdoors\",{\"1\":{\"490\":1}}],[\"outfile\",{\"1\":{\"498\":1,\"499\":2}}],[\"outputshutdown\",{\"1\":{\"967\":1}}],[\"outputstreamwriter\",{\"1\":{\"69\":1,\"70\":1}}],[\"outputstream定义了所有输出流的超类\",{\"1\":{\"54\":1}}],[\"outputstream\",{\"0\":{\"54\":1},\"1\":{\"69\":2,\"70\":2}}],[\"outputiscomplete\",{\"1\":{\"125\":2}}],[\"output\",{\"1\":{\"69\":4,\"70\":4,\"113\":2,\"118\":1,\"124\":3,\"125\":9}}],[\"outputtimeunit\",{\"1\":{\"9\":1}}],[\"out\",{\"1\":{\"34\":1,\"41\":2,\"48\":1,\"69\":3,\"70\":4,\"112\":3,\"113\":3,\"259\":3,\"712\":2,\"720\":5,\"736\":5,\"894\":24,\"960\":2,\"984\":1,\"985\":2,\"1006\":1,\"1007\":2,\"1195\":1,\"1230\":1,\"1248\":2,\"1288\":1,\"1309\":1,\"1370\":1,\"1443\":1,\"1444\":2,\"1519\":1}}],[\"outer$3\",{\"1\":{\"22\":1}}],[\"outer$2\",{\"1\":{\"22\":1}}],[\"outer类被编译为outer\",{\"1\":{\"22\":1}}],[\"outer\",{\"1\":{\"22\":5}}],[\"ok\",{\"1\":{\"69\":1,\"180\":2,\"196\":2,\"224\":2,\"248\":2,\"252\":2,\"256\":1,\"259\":1,\"351\":1,\"536\":2,\"624\":5,\"625\":2,\"627\":3,\"663\":1,\"738\":1,\"845\":1,\"861\":1,\"960\":1,\"970\":1,\"1047\":3,\"1048\":1,\"1050\":2,\"1051\":2,\"1056\":3,\"1122\":3,\"1123\":1,\"1170\":1,\"1173\":1,\"1195\":3,\"1198\":1,\"1226\":1,\"1230\":1,\"1273\":1,\"1280\":1,\"1445\":10,\"1459\":1,\"1462\":1,\"1516\":1}}],[\"oriprops\",{\"1\":{\"1462\":1}}],[\"origprops\",{\"1\":{\"1056\":6}}],[\"originmsgid\",{\"1\":{\"1197\":3,\"1198\":3}}],[\"original\",{\"1\":{\"1021\":2}}],[\"origin\",{\"1\":{\"34\":4,\"368\":1,\"1053\":1}}],[\"ordinal\",{\"1\":{\"1020\":1,\"1171\":1,\"1198\":1}}],[\"ordercountinfo\",{\"1\":{\"1269\":6,\"1270\":3}}],[\"orderly\",{\"1\":{\"1202\":1,\"1230\":1}}],[\"orderid188\",{\"1\":{\"984\":1,\"1006\":2}}],[\"ordertopicconf\",{\"1\":{\"950\":1,\"968\":1,\"973\":2}}],[\"order\",{\"1\":{\"546\":1,\"765\":1,\"793\":1,\"973\":1,\"1269\":1,\"1273\":1,\"1434\":1}}],[\"ordered\",{\"1\":{\"248\":3,\"249\":1}}],[\"oracle\",{\"1\":{\"298\":4,\"371\":1}}],[\"orange1\",{\"1\":{\"253\":2}}],[\"orange\",{\"1\":{\"181\":4,\"253\":6,\"325\":2}}],[\"oranges\",{\"1\":{\"177\":4,\"253\":4}}],[\"orelse\",{\"1\":{\"219\":1,\"1436\":1}}],[\"or\",{\"1\":{\"15\":1,\"46\":2,\"97\":1,\"98\":2,\"165\":2,\"171\":2,\"186\":1,\"206\":1,\"230\":1,\"396\":1,\"643\":1,\"1079\":1,\"1248\":1,\"1277\":1,\"1308\":4,\"1333\":1,\"1468\":1}}],[\"org\",{\"1\":{\"11\":4,\"64\":1,\"89\":1,\"96\":2,\"104\":2,\"266\":4,\"286\":1,\"882\":2,\"990\":1,\"996\":2,\"1079\":2,\"1382\":2,\"1425\":2}}],[\"ofnullable\",{\"1\":{\"1436\":1}}],[\"ofseconds\",{\"1\":{\"1427\":1}}],[\"of循环来遍历\",{\"1\":{\"303\":1}}],[\"offer\",{\"1\":{\"1370\":1,\"1373\":1}}],[\"official\",{\"1\":{\"1073\":1}}],[\"offsetlist\",{\"1\":{\"1431\":4}}],[\"offset++\",{\"1\":{\"1427\":1}}],[\"offsetbuffersize\",{\"1\":{\"1277\":1}}],[\"offsetmovedevent\",{\"1\":{\"1173\":2}}],[\"offsetmsgid=null\",{\"1\":{\"1445\":10}}],[\"offsetmsgid\",{\"1\":{\"899\":1,\"1017\":1}}],[\"offsetstore\",{\"1\":{\"1122\":5,\"1170\":1,\"1175\":2,\"1190\":1,\"1191\":3}}],[\"offsets结果列表\",{\"1\":{\"797\":1}}],[\"offset=1\",{\"1\":{\"1445\":3}}],[\"offset=0\",{\"1\":{\"1445\":3}}],[\"offset=\",{\"1\":{\"845\":1,\"860\":2,\"1332\":2,\"1427\":6,\"1431\":3,\"1432\":4,\"1468\":5}}],[\"offsettable\",{\"1\":{\"840\":1,\"844\":1,\"845\":1,\"1104\":1,\"1190\":1,\"1200\":2,\"1201\":2}}],[\"offset未找到任何数据\",{\"1\":{\"819\":1}}],[\"offsetpy=\",{\"1\":{\"845\":2,\"860\":1,\"1174\":1}}],[\"offsetpy\",{\"1\":{\"767\":4,\"845\":5,\"860\":8,\"1174\":7,\"1368\":3,\"1370\":3,\"1371\":3,\"1372\":2}}],[\"offset\",{\"1\":{\"720\":1,\"722\":2,\"737\":2,\"738\":2,\"757\":1,\"765\":8,\"767\":5,\"771\":4,\"780\":1,\"787\":2,\"789\":1,\"790\":1,\"795\":1,\"797\":1,\"812\":1,\"819\":4,\"823\":2,\"840\":2,\"844\":4,\"845\":9,\"855\":5,\"857\":5,\"858\":2,\"860\":17,\"868\":2,\"871\":2,\"872\":9,\"964\":1,\"985\":1,\"1007\":1,\"1095\":2,\"1117\":1,\"1144\":1,\"1170\":10,\"1171\":3,\"1173\":18,\"1174\":26,\"1175\":7,\"1195\":3,\"1198\":1,\"1200\":8,\"1201\":10,\"1224\":1,\"1228\":10,\"1248\":1,\"1270\":26,\"1271\":5,\"1275\":1,\"1276\":1,\"1277\":2,\"1278\":11,\"1280\":2,\"1288\":2,\"1296\":2,\"1297\":3,\"1318\":1,\"1352\":1,\"1362\":1,\"1370\":7,\"1371\":1,\"1390\":2,\"1391\":1,\"1403\":9,\"1405\":2,\"1407\":1,\"1408\":1,\"1410\":2,\"1427\":16,\"1428\":1,\"1430\":11,\"1431\":2,\"1432\":10,\"1434\":6,\"1436\":1,\"1444\":1,\"1468\":6,\"1517\":1}}],[\"off\",{\"1\":{\"53\":1,\"1200\":1}}],[\"of\",{\"1\":{\"11\":2,\"97\":3,\"98\":1,\"147\":2,\"171\":4,\"187\":2,\"189\":1,\"193\":1,\"194\":1,\"196\":1,\"204\":1,\"230\":1,\"253\":3,\"303\":4,\"332\":1,\"396\":5,\"614\":2,\"621\":2,\"624\":4,\"625\":2,\"626\":1,\"627\":2,\"643\":3,\"645\":1,\"720\":12,\"732\":1,\"736\":10,\"737\":2,\"767\":1,\"845\":4,\"860\":1,\"886\":3,\"895\":1,\"898\":1,\"910\":1,\"913\":1,\"960\":1,\"1000\":1,\"1017\":1,\"1021\":1,\"1050\":1,\"1174\":1,\"1247\":1,\"1267\":1,\"1276\":1,\"1287\":1,\"1328\":1,\"1332\":1,\"1333\":1,\"1371\":1,\"1430\":1,\"1432\":1,\"1434\":1,\"1436\":3,\"1464\":2,\"1468\":4,\"1504\":1,\"1519\":3,\"1522\":1}}],[\"opmsg\",{\"1\":{\"1468\":6}}],[\"opmsgmap\",{\"1\":{\"1468\":7}}],[\"opoffsetdiff=\",{\"1\":{\"1468\":1}}],[\"opoffset=\",{\"1\":{\"1468\":3}}],[\"opoffset\",{\"1\":{\"1468\":8}}],[\"opqueue\",{\"1\":{\"1468\":6}}],[\"opaque\",{\"1\":{\"742\":1,\"890\":1,\"894\":1}}],[\"operationresult\",{\"1\":{\"1464\":2}}],[\"operationcomplete\",{\"1\":{\"820\":1,\"1173\":1}}],[\"operation\",{\"1\":{\"643\":1,\"1464\":2}}],[\"operating\",{\"1\":{\"627\":1}}],[\"open0\",{\"1\":{\"1079\":1}}],[\"openmessaging最初的创始人冯嘉曾表示\",{\"1\":{\"277\":1}}],[\"openchaos已支持接入大多数分布式系统\",{\"1\":{\"286\":1}}],[\"openchaos可以根据用户设置的操作系统指标或业务指标阈值来触发扩缩容\",{\"1\":{\"285\":1}}],[\"openchaos支持对系统扩缩容能力的度量与评测\",{\"1\":{\"285\":1}}],[\"openchaos执行的一个实验结果示例\",{\"1\":{\"284\":1}}],[\"openchaos不仅支持普遍的黑盒故障注入\",{\"1\":{\"282\":1}}],[\"openchaos中的检测模型关注更高维度的属性\",{\"1\":{\"282\":1}}],[\"openchaos的整体架构可以分为管理层\",{\"1\":{\"280\":1}}],[\"openchaos的工作原理是这样的\",{\"1\":{\"280\":1}}],[\"openchaos借助混沌工程思想\",{\"1\":{\"278\":1}}],[\"openchaos创始团队早期也和这些社区的先行者进行过多轮交流\",{\"1\":{\"276\":1}}],[\"openchaos\",{\"0\":{\"278\":1},\"1\":{\"275\":1,\"278\":1}}],[\"open\",{\"1\":{\"121\":2,\"132\":1,\"133\":1,\"142\":1,\"241\":1,\"256\":1,\"259\":1,\"262\":1,\"348\":1,\"369\":2,\"967\":1,\"1005\":1,\"1079\":1}}],[\"openjdk\",{\"1\":{\"2\":1,\"7\":1,\"8\":2}}],[\"oprc84tpgev\",{\"1\":{\"429\":1}}],[\"opt=\",{\"1\":{\"1080\":8}}],[\"optimization\",{\"1\":{\"1437\":1}}],[\"optimized\",{\"1\":{\"1200\":1}}],[\"optimise\",{\"1\":{\"720\":4,\"723\":1,\"736\":2,\"742\":1}}],[\"optional<statemachinecaller>\",{\"1\":{\"1521\":1}}],[\"optional\",{\"1\":{\"1436\":1}}],[\"optionally\",{\"1\":{\"124\":1}}],[\"option\",{\"1\":{\"1247\":5,\"1300\":1}}],[\"options\",{\"1\":{\"171\":1,\"203\":2,\"266\":1,\"960\":4,\"1080\":1}}],[\"opt\",{\"1\":{\"241\":1,\"1075\":4,\"1079\":1,\"1080\":20,\"1247\":5}}],[\"op\",{\"1\":{\"118\":4,\"121\":1,\"122\":1,\"124\":2,\"125\":3,\"128\":3,\"130\":3,\"132\":4,\"133\":1,\"741\":1,\"1446\":11,\"1451\":2,\"1453\":7,\"1464\":2,\"1468\":3}}],[\"ops\",{\"1\":{\"11\":25,\"118\":1,\"741\":4}}],[\"用重排后新索引文件的\",{\"1\":{\"1417\":1}}],[\"用高可用的存储或分布式文件系统直接替换本地块存储\",{\"1\":{\"1385\":1}}],[\"用生产\",{\"1\":{\"1353\":1}}],[\"用单独的文件存储\",{\"1\":{\"1347\":1}}],[\"用单独的一个拉取消息线程\",{\"1\":{\"1155\":1}}],[\"用编译好的\",{\"1\":{\"1324\":1,\"1333\":1}}],[\"用它们构造成一个新的消息\",{\"1\":{\"1360\":1}}],[\"用它能够将消费者端指定的\",{\"1\":{\"1321\":1}}],[\"用它来判断这个消费者是否可能匹配过滤规则\",{\"1\":{\"1315\":1}}],[\"用它来解析权限配置文件\",{\"1\":{\"990\":1,\"996\":1}}],[\"用布隆过滤器计算匹配过滤条件的消费组\",{\"1\":{\"1308\":1,\"1315\":1,\"1323\":1}}],[\"用消费队列来表示轻量级队列\",{\"1\":{\"1291\":1}}],[\"用消费队列表示的好处还在于\",{\"1\":{\"1291\":1}}],[\"用消息的序号作为\",{\"1\":{\"712\":1}}],[\"用请求头中的信息构造\",{\"1\":{\"1273\":1}}],[\"用如下命令\",{\"1\":{\"1247\":1}}],[\"用该偏移量更新消费进度\",{\"1\":{\"1188\":1}}],[\"用该消息重新消费的次数计算延迟等级\",{\"1\":{\"1180\":1}}],[\"用该函数的参数绑定循环变量当前的值\",{\"1\":{\"330\":1}}],[\"用阻塞队列\",{\"1\":{\"1155\":1}}],[\"用物理偏移量从消息存储中查找消息\",{\"1\":{\"1153\":1}}],[\"用同一个网络\",{\"1\":{\"1081\":1}}],[\"用本地构建的镜像和\",{\"1\":{\"1079\":1}}],[\"用到的是\",{\"1\":{\"1035\":1}}],[\"用原\",{\"1\":{\"1021\":1}}],[\"用分层时间轮或者哈希时间轮就好了\",{\"1\":{\"931\":1}}],[\"用代码复杂度换性能\",{\"1\":{\"917\":1}}],[\"用作后续匹配\",{\"1\":{\"1453\":1}}],[\"用作示例\",{\"1\":{\"1442\":1}}],[\"用作事务消息接收\",{\"1\":{\"1441\":1}}],[\"用作返回值\",{\"1\":{\"1258\":1}}],[\"用作请求处理前的权限校验\",{\"1\":{\"980\":1}}],[\"用作保存消息在\",{\"1\":{\"867\":1}}],[\"用作消息过滤\",{\"1\":{\"755\":1}}],[\"用图展示一下消息投递线程和任务更新线程的工作流程\",{\"1\":{\"856\":1}}],[\"用以执行基本的\",{\"1\":{\"1321\":1}}],[\"用以解析\",{\"1\":{\"1321\":1}}],[\"用以被scheduledexecutorservice定时调用\",{\"1\":{\"841\":1}}],[\"用以被\",{\"1\":{\"841\":1}}],[\"用以提高定时消息重投递的性能\",{\"1\":{\"840\":1}}],[\"用以生成\",{\"1\":{\"811\":1}}],[\"用以在客户端应对可能的阻塞情况\",{\"1\":{\"613\":1}}],[\"用法类似\",{\"1\":{\"726\":1}}],[\"用整数字符串表示\",{\"1\":{\"712\":1}}],[\"用整数组成的列表或一个二进制型表示字符串\",{\"1\":{\"178\":1}}],[\"用type命令为函数类型定义一个别名\",{\"1\":{\"533\":1}}],[\"用大括号表示\",{\"1\":{\"519\":1}}],[\"用处不大\",{\"1\":{\"514\":1}}],[\"用狂奔怒吼来躲避轨道上的龙喷\",{\"1\":{\"471\":1}}],[\"用狂奔怒吼帮小队躲避海潮涌动\",{\"1\":{\"466\":1}}],[\"用狂奔怒吼帮助被上钩了点名的队友跑路\",{\"1\":{\"464\":1}}],[\"用狂奔怒吼去找黑洞移除虚空腐蚀\",{\"1\":{\"441\":1}}],[\"用尽一切手段来最大化你的输出\",{\"1\":{\"457\":1}}],[\"用夺魂咆哮来控制召出来的小虫子\",{\"1\":{\"457\":1}}],[\"用治疗手牌快速把吸奶盾奶爆\",{\"1\":{\"445\":1}}],[\"用野性成长\",{\"1\":{\"439\":1}}],[\"用猫奶天赋\",{\"1\":{\"433\":1}}],[\"用了\",{\"1\":{\"433\":1}}],[\"用在最危险的时候\",{\"1\":{\"413\":1}}],[\"用横扫来泄能\",{\"1\":{\"412\":1}}],[\"用撕碎来泄能\",{\"1\":{\"412\":1}}],[\"用哈希算法将字符串转换为\",{\"1\":{\"390\":1}}],[\"用某种方式转换成数字\",{\"1\":{\"386\":1}}],[\"用一个有界的\",{\"1\":{\"1348\":1}}],[\"用一个周期性任务去扫描\",{\"1\":{\"1342\":1}}],[\"用一个线程从拉取请求队列\",{\"1\":{\"1104\":1}}],[\"用一个线程处理多个客户端连接\",{\"1\":{\"122\":1}}],[\"用一个单独的线程异步调用\",{\"1\":{\"915\":1}}],[\"用一根矛\",{\"1\":{\"458\":1,\"460\":1}}],[\"用一张流程图归纳\",{\"1\":{\"380\":1}}],[\"用相对路径\",{\"1\":{\"361\":1}}],[\"用await调用另一个异步函数\",{\"1\":{\"354\":1}}],[\"用关键字async配合await调用promise\",{\"1\":{\"354\":1}}],[\"用class的好处就是极大地简化了原型链代码\",{\"1\":{\"343\":1}}],[\"用parseint\",{\"1\":{\"333\":1}}],[\"用自定义函数替换原函数\",{\"1\":{\"320\":1}}],[\"用平衡二叉树表示\",{\"1\":{\"249\":1}}],[\"用端口建立外部\",{\"0\":{\"242\":1}}],[\"用模式匹配的方式提取元组的值\",{\"1\":{\"176\":1}}],[\"用途\",{\"1\":{\"154\":1}}],[\"用来将元素加入到集合中\",{\"1\":{\"1322\":1}}],[\"用来为\",{\"1\":{\"1319\":1}}],[\"用来标记消费成功失败的位置\",{\"1\":{\"1195\":1}}],[\"用来快速更新和查询\",{\"1\":{\"1190\":1}}],[\"用来快速查找某一时刻需要投递的消息\",{\"1\":{\"927\":1}}],[\"用来让消费者实时上报消费进度\",{\"1\":{\"1183\":1}}],[\"用来实时更新\",{\"1\":{\"1182\":1}}],[\"用来临时存放拉取到待消费的消息\",{\"1\":{\"1137\":1}}],[\"用来保证在有消息正在被顺序消费时\",{\"1\":{\"1209\":1}}],[\"用来保证每个消费者执行同样的重平衡流程得到的结果一致\",{\"1\":{\"1137\":1}}],[\"用来保存拉取到的消息\",{\"1\":{\"1104\":1}}],[\"用来保存返回结果\",{\"1\":{\"741\":1}}],[\"用来保存信用值信息的\",{\"1\":{\"624\":1}}],[\"用来与\",{\"1\":{\"1118\":1}}],[\"用来注册消费监听器\",{\"1\":{\"1117\":1}}],[\"用来缓存acl配置文件和全局白名单的映射关系\",{\"1\":{\"997\":1}}],[\"用来缓存accesskey和acl配置文件的映射关系\",{\"1\":{\"997\":1}}],[\"用来缓存所有acl配置文件的dataversion\",{\"1\":{\"997\":1}}],[\"用来缓存所有acl配置文件的权限数据\",{\"1\":{\"997\":2}}],[\"用来缓存所有\",{\"1\":{\"997\":1}}],[\"用来缓存\",{\"1\":{\"997\":1}}],[\"用来配置用户和用户权限\",{\"1\":{\"983\":1}}],[\"用来拼接数据统计字典的\",{\"1\":{\"908\":1}}],[\"用来表示它里面的每个条消息是否被\",{\"1\":{\"1262\":1}}],[\"用来表示\",{\"1\":{\"903\":1}}],[\"用来表示元组是什么\",{\"1\":{\"176\":1}}],[\"用来存储状态\",{\"1\":{\"897\":1}}],[\"用来存放任意数量的事物\",{\"1\":{\"177\":1}}],[\"用来根据投递时间查询该时间需要投递的消息\",{\"1\":{\"848\":1}}],[\"用来添加类的初始化逻辑\",{\"1\":{\"606\":1}}],[\"用来描述函数内部的this关键字的类型\",{\"1\":{\"580\":1}}],[\"用来高效存储海量的\",{\"1\":{\"247\":1}}],[\"用来选择下一个\",{\"1\":{\"131\":1}}],[\"用来和刚连接的客户端通信\",{\"1\":{\"69\":1}}],[\"用线程池去处理\",{\"1\":{\"130\":1}}],[\"用户态线程和内核态线程有什么区别\",{\"1\":{\"1527\":1}}],[\"用户态和内核态\",{\"0\":{\"1526\":1},\"1\":{\"1527\":1}}],[\"用户业务代码返回\",{\"1\":{\"1251\":1}}],[\"用户主动发起拉取\",{\"1\":{\"1151\":1}}],[\"用户往往难以快速部署\",{\"1\":{\"1069\":1}}],[\"用户也可以自己实现其他验证器\",{\"1\":{\"990\":1,\"996\":1}}],[\"用户ip白名单\",{\"1\":{\"983\":1}}],[\"用户需手动配置一个\",{\"1\":{\"980\":1}}],[\"用户需在消息属性中设置延迟等级\",{\"1\":{\"834\":1}}],[\"用户手动修改和配置\",{\"1\":{\"980\":1}}],[\"用户权限的集合\",{\"1\":{\"978\":1}}],[\"用户\",{\"1\":{\"978\":2}}],[\"用户组\",{\"1\":{\"976\":1}}],[\"用户的应用程序在使用完某块\",{\"1\":{\"879\":1}}],[\"用户自己进行消息的拉取和消费进度的更新\",{\"1\":{\"801\":1}}],[\"用户自定义\",{\"1\":{\"652\":1}}],[\"用户名和密码进行签名\",{\"1\":{\"981\":1}}],[\"用户名和密码\",{\"1\":{\"712\":1}}],[\"用户就感觉自己仍然停留在当前页面\",{\"1\":{\"347\":1}}],[\"用户定义的模块属性\",{\"0\":{\"204\":1}}],[\"用户只敲了个回车\",{\"1\":{\"125\":1}}],[\"用户输入\",{\"1\":{\"125\":1}}],[\"用户输入完成\",{\"1\":{\"125\":1}}],[\"用于日志打印\",{\"1\":{\"1521\":1}}],[\"用于仲裁\",{\"1\":{\"1519\":1}}],[\"用于判断已提交条目序号\",{\"1\":{\"1514\":1}}],[\"用于判断日志是否被大多数节点写入\",{\"1\":{\"1507\":1}}],[\"用于集群内网络通信\",{\"1\":{\"1514\":1}}],[\"用于下次检查后的遍历\",{\"1\":{\"1512\":1}}],[\"用于操作当前节点的日志存储\",{\"1\":{\"1482\":1}}],[\"用于保存当前节点的角色\",{\"1\":{\"1482\":1}}],[\"用于持久化到本地文件和从本地文件读取\",{\"1\":{\"1420\":1}}],[\"用于扫描和重排已经写满的索引文件\",{\"1\":{\"1412\":1}}],[\"用于存储\",{\"1\":{\"1402\":1}}],[\"用于存放\",{\"1\":{\"1263\":1}}],[\"用于存放所有的\",{\"1\":{\"988\":1,\"994\":1}}],[\"用于根据\",{\"1\":{\"1386\":1}}],[\"用于根据时间范围查询消息\",{\"1\":{\"787\":1}}],[\"用于消费每个队列的时候查询消息\",{\"1\":{\"1386\":1}}],[\"用于消费者消费消息\",{\"1\":{\"836\":1}}],[\"用于定时消息到时\",{\"1\":{\"1367\":1}}],[\"用于比较数字\",{\"1\":{\"1308\":3}}],[\"用于设置写缓冲区的低水位线和高水位线\",{\"1\":{\"1299\":1}}],[\"用于等待异步请求结果\",{\"1\":{\"1499\":1}}],[\"用于等待\",{\"1\":{\"1270\":1}}],[\"用于获取客户端\",{\"1\":{\"1270\":1}}],[\"用于匹配\",{\"0\":{\"1259\":1}}],[\"用于快速更新和查询\",{\"1\":{\"1191\":1}}],[\"用于响应和请求的匹配\",{\"1\":{\"1173\":1}}],[\"用于暂存解析出来的\",{\"1\":{\"998\":1}}],[\"用于解析白名单\",{\"1\":{\"997\":1}}],[\"用于每\",{\"1\":{\"990\":1,\"996\":1}}],[\"用于配置全局客户端\",{\"1\":{\"983\":1}}],[\"用于类模式的消息过滤\",{\"1\":{\"949\":1}}],[\"用于类模式消息过滤\",{\"1\":{\"944\":1}}],[\"用于路由发现的场景非常合适\",{\"1\":{\"942\":1}}],[\"用于写入字符串数组\",{\"1\":{\"900\":1}}],[\"用于将本地存储的消息提交到分级存储中\",{\"1\":{\"1403\":1}}],[\"用于将消费失败的消息重新生产到\",{\"1\":{\"1120\":1,\"1123\":1}}],[\"用于将\",{\"1\":{\"897\":1}}],[\"用于加速文件\",{\"1\":{\"879\":1}}],[\"用于周期性扫描延迟等级的消息\",{\"1\":{\"840\":1,\"844\":1}}],[\"用于管理和控制所有索引文件\",{\"1\":{\"789\":1}}],[\"用于搜索时间范围内的消息\",{\"1\":{\"786\":1}}],[\"用于到\",{\"1\":{\"786\":1,\"787\":1}}],[\"用于往consumequeue中写入索引项\",{\"1\":{\"765\":1}}],[\"用于直接从对象中提取属性\",{\"1\":{\"554\":1}}],[\"用于执行时间轮到期的任务\",{\"1\":{\"379\":1}}],[\"用于扩展一个原型\",{\"1\":{\"342\":1}}],[\"用于以下情形\",{\"1\":{\"205\":1}}],[\"用于监听客户端连接事件\",{\"1\":{\"135\":1}}],[\"用于监听某个端口进来的请求\",{\"1\":{\"118\":1}}],[\"用于处理客户端连接\",{\"1\":{\"135\":1}}],[\"用于处理新的客户端连接\",{\"1\":{\"133\":1}}],[\"用于处理连接接收事件\",{\"1\":{\"130\":1}}],[\"用于处理并发传递给服务处理程序的服务请求\",{\"1\":{\"119\":1}}],[\"用于在发送请求前将该账号的用户名和密码信息放入请求中\",{\"1\":{\"987\":1}}],[\"用于在发送请求前在请求中加入验证信息\",{\"1\":{\"980\":1}}],[\"用于在\",{\"1\":{\"124\":1}}],[\"用于在客户端连接事件发生时取出\",{\"1\":{\"121\":1}}],[\"用于注册和执行消息消费的真正逻辑\",{\"1\":{\"1187\":1}}],[\"用于注册\",{\"1\":{\"118\":1}}],[\"用于向\",{\"1\":{\"118\":1}}],[\"用于\",{\"1\":{\"118\":1,\"1278\":1}}],[\"用于文件的读和写\",{\"1\":{\"118\":1}}],[\"用于测试\",{\"1\":{\"2\":1}}],[\"用注解\",{\"1\":{\"75\":1}}],[\"用\",{\"0\":{\"194\":1,\"195\":1,\"246\":1,\"247\":1,\"1075\":1,\"1077\":1},\"1\":{\"52\":1,\"174\":1,\"176\":1,\"186\":1,\"234\":1,\"237\":1,\"273\":1,\"341\":1,\"522\":1,\"574\":1,\"932\":1,\"1079\":1,\"1155\":1,\"1258\":1,\"1262\":1,\"1307\":1,\"1428\":1,\"1510\":1}}],[\"用string\",{\"1\":{\"29\":1,\"333\":1}}],[\"用参数\",{\"1\":{\"25\":2}}],[\"用例计时和输出的时间单位\",{\"1\":{\"9\":1}}],[\"tctable\",{\"1\":{\"971\":3}}],[\"tcp协议本身就实现了全双工通信\",{\"1\":{\"368\":1}}],[\"tcp\",{\"0\":{\"68\":1},\"1\":{\"118\":3,\"121\":1,\"124\":1,\"237\":1,\"621\":1,\"1075\":16,\"1077\":2,\"1079\":17,\"1300\":7}}],[\"tls\",{\"0\":{\"1084\":1},\"1\":{\"1074\":1,\"1084\":1}}],[\"tlsservertrustcertpath\",{\"1\":{\"961\":2}}],[\"tlsserverkeypath\",{\"1\":{\"961\":2}}],[\"tlsservercertpath\",{\"1\":{\"961\":2}}],[\"tlssystemconfig\",{\"1\":{\"961\":7}}],[\"tlsmode\",{\"1\":{\"961\":2}}],[\"tls协议\",{\"1\":{\"368\":1}}],[\"tbw102\",{\"1\":{\"742\":1,\"890\":1,\"964\":1,\"968\":1}}],[\"tbc\",{\"1\":{\"399\":2}}],[\"ttl\",{\"1\":{\"698\":1,\"1385\":1}}],[\"tx\",{\"1\":{\"663\":1}}],[\"txt\",{\"1\":{\"191\":1,\"533\":8,\"545\":2}}],[\"t1\",{\"1\":{\"518\":1}}],[\"t0\",{\"1\":{\"518\":1}}],[\"two\",{\"1\":{\"515\":1,\"585\":2,\"654\":1}}],[\"twice\",{\"1\":{\"500\":2,\"886\":1,\"906\":1}}],[\"tsconfig\",{\"0\":{\"499\":1}}],[\"tsc\",{\"0\":{\"498\":1,\"602\":1,\"603\":1},\"1\":{\"498\":9,\"499\":2,\"602\":1}}],[\"ts\",{\"0\":{\"500\":1},\"1\":{\"493\":1,\"498\":6,\"499\":4,\"500\":5,\"591\":3,\"595\":1}}],[\"tvvtuxnpm0r0qjl\",{\"1\":{\"469\":1}}],[\"tv1yuvnmq0fp7kenhbpwiujtsgqinw6\",{\"1\":{\"436\":1}}],[\"tdfzm7xc4scfzqvtqmhaolzmophk7sxkbhlbgpp\",{\"1\":{\"443\":1}}],[\"tfge4rj\",{\"1\":{\"429\":1}}],[\"tpinfo\",{\"1\":{\"1052\":11}}],[\"tps\",{\"0\":{\"910\":1},\"1\":{\"284\":1,\"285\":1,\"720\":1,\"741\":1,\"852\":2,\"854\":1,\"886\":2,\"910\":1,\"913\":2,\"915\":1,\"916\":3,\"924\":1,\"927\":1,\"935\":1}}],[\"tpl\",{\"1\":{\"261\":1}}],[\"tpope\",{\"1\":{\"165\":1}}],[\"tmpdequeuechangeflag\",{\"1\":{\"1374\":4}}],[\"tmpbuffer\",{\"1\":{\"1371\":12}}],[\"tmpwritetimems\",{\"1\":{\"1371\":7}}],[\"tmpreq\",{\"1\":{\"1371\":3}}],[\"tmpcommitqueueoffset\",{\"1\":{\"1371\":2}}],[\"tmpmessage\",{\"1\":{\"1053\":4}}],[\"tmp\",{\"1\":{\"259\":1,\"793\":6,\"995\":3,\"1267\":2}}],[\"tuesday\",{\"1\":{\"587\":1}}],[\"tuple\",{\"1\":{\"185\":2,\"521\":1,\"527\":3}}],[\"tutorial\",{\"1\":{\"137\":1}}],[\"tutorials\",{\"1\":{\"96\":1}}],[\"tieredbackendserviceprovider\",{\"1\":{\"1382\":1}}],[\"tieredbackendserviceprovider=org\",{\"1\":{\"1382\":1}}],[\"tieredmetadataserviceprovider\",{\"1\":{\"1382\":1}}],[\"tieredmessagestore\",{\"0\":{\"1405\":1},\"1\":{\"1382\":2,\"1396\":1,\"1400\":1,\"1401\":1,\"1402\":1,\"1405\":1,\"1421\":1}}],[\"tieredstoragelevel\",{\"1\":{\"1382\":1}}],[\"tieredstoragelevel=force\",{\"1\":{\"1382\":1}}],[\"tieredstoreexception\",{\"1\":{\"1432\":1}}],[\"tieredstoremetricsconstant\",{\"1\":{\"1427\":3}}],[\"tieredstoremetricsmanager\",{\"1\":{\"1427\":2}}],[\"tieredstoremetadata\",{\"1\":{\"1395\":1,\"1420\":1}}],[\"tieredstoremaxpendinglimit\",{\"1\":{\"1382\":1}}],[\"tieredstorefilereservedtime\",{\"1\":{\"1382\":1}}],[\"tieredstorefilepath\",{\"1\":{\"1382\":1}}],[\"tieredstorefilepath=e\",{\"1\":{\"1382\":1}}],[\"tieredstore\",{\"0\":{\"1376\":1},\"1\":{\"1376\":1,\"1382\":6,\"1383\":1,\"1396\":1,\"1538\":1}}],[\"tiered\",{\"1\":{\"1382\":1,\"1383\":1,\"1394\":2,\"1412\":2,\"1417\":2,\"1420\":8,\"1436\":2,\"1437\":5}}],[\"timing\",{\"1\":{\"1375\":3}}],[\"time=1737222710178\",{\"1\":{\"1445\":3}}],[\"timewheel\",{\"1\":{\"1348\":1}}],[\"timeup\",{\"1\":{\"870\":4}}],[\"timeunit\",{\"1\":{\"9\":1,\"861\":1,\"869\":1,\"915\":1,\"961\":2,\"970\":1,\"1021\":1,\"1048\":5,\"1201\":1,\"1225\":1,\"1370\":1,\"1371\":2,\"1373\":2,\"1374\":1,\"1427\":2,\"1435\":5,\"1436\":1,\"1443\":1,\"1497\":1,\"1499\":1,\"1519\":2}}],[\"timedelay\",{\"1\":{\"844\":2}}],[\"timediff\",{\"1\":{\"797\":13,\"1434\":2}}],[\"timems\",{\"1\":{\"1367\":14,\"1372\":1}}],[\"timematched\",{\"1\":{\"797\":2}}],[\"timemillistohumanstring\",{\"1\":{\"793\":1}}],[\"timerrollwindowslots\",{\"1\":{\"1371\":5}}],[\"timerrequst\",{\"1\":{\"1359\":1}}],[\"timerrequest\",{\"1\":{\"1355\":1,\"1356\":1,\"1358\":1,\"1359\":4,\"1360\":1,\"1370\":5,\"1371\":9,\"1372\":9,\"1373\":7,\"1374\":1}}],[\"timermessagestore\",{\"1\":{\"1371\":3,\"1373\":3,\"1374\":3}}],[\"timerdequeueputmessageservice\",{\"0\":{\"1360\":1,\"1374\":1}}],[\"timerdequeuegetmessageservice\",{\"0\":{\"1359\":1,\"1373\":1}}],[\"timerdequeuegetservice\",{\"0\":{\"1358\":1,\"1372\":1}}],[\"timerdelay\",{\"1\":{\"1278\":2}}],[\"timerenqueueputservice\",{\"0\":{\"1356\":1,\"1371\":1},\"1\":{\"1371\":1}}],[\"timerenqueuegetservice\",{\"0\":{\"1355\":1,\"1370\":1}}],[\"timeread\",{\"1\":{\"797\":4}}],[\"timerlogfilesize\",{\"1\":{\"1372\":1}}],[\"timerlogbuffer\",{\"1\":{\"1371\":1}}],[\"timerlog\",{\"0\":{\"1352\":1,\"1356\":1,\"1368\":1},\"1\":{\"1346\":5,\"1348\":1,\"1350\":1,\"1351\":4,\"1352\":1,\"1356\":2,\"1358\":2,\"1362\":4,\"1363\":1,\"1367\":3,\"1368\":5,\"1371\":12,\"1372\":12}}],[\"timerwheel\",{\"0\":{\"1351\":1,\"1367\":1},\"1\":{\"1346\":4,\"1350\":1,\"1352\":2,\"1362\":3,\"1367\":1,\"1371\":2,\"1372\":1}}],[\"timertask\",{\"1\":{\"841\":1,\"844\":1}}],[\"timer\",{\"1\":{\"840\":4,\"841\":1,\"844\":4,\"845\":4,\"850\":1,\"852\":3,\"1335\":1,\"1354\":1,\"1368\":4,\"1370\":4,\"1371\":1,\"1372\":1,\"1373\":2}}],[\"timer到期触发的逻辑就是realschedule方法\",{\"1\":{\"379\":1}}],[\"timer时间轮等待调度\",{\"1\":{\"379\":1}}],[\"timer则用于加载高延迟的任务\",{\"1\":{\"379\":1}}],[\"times=1\",{\"1\":{\"1445\":3}}],[\"timesbr\",{\"1\":{\"1372\":15}}],[\"times++\",{\"1\":{\"1050\":1}}],[\"timestoretable\",{\"1\":{\"1412\":2,\"1435\":2,\"1436\":1}}],[\"timestotal\",{\"1\":{\"1050\":3}}],[\"timestamp=\",{\"1\":{\"1435\":1,\"1436\":6}}],[\"timestamp\",{\"1\":{\"715\":1,\"967\":1,\"1017\":1,\"1212\":1,\"1371\":1,\"1434\":11,\"1435\":7,\"1436\":4,\"1495\":1,\"1499\":1}}],[\"times\",{\"1\":{\"147\":1,\"181\":2,\"535\":2,\"769\":1,\"1050\":4,\"1053\":1,\"1198\":3,\"1297\":2,\"1434\":1,\"1468\":1}}],[\"timeoutfuture<appendentryresponse>>\",{\"1\":{\"1521\":2}}],[\"timeoutfuture<appendentryresponse>>>\",{\"1\":{\"1514\":1}}],[\"timeoutfuture<pushentryresponse>\",{\"1\":{\"1520\":2}}],[\"timeoutfuture<>\",{\"1\":{\"1520\":1}}],[\"timeoutmillis\",{\"1\":{\"994\":1,\"1171\":3,\"1172\":3}}],[\"timeoutmills\",{\"1\":{\"970\":3}}],[\"timeoutexception\",{\"1\":{\"712\":2}}],[\"timeout\",{\"1\":{\"11\":1,\"351\":7,\"1050\":4,\"1053\":8,\"1117\":1,\"1170\":1,\"1257\":1,\"1269\":1,\"1273\":2,\"1275\":1,\"1276\":1,\"1277\":1,\"1278\":1,\"1427\":3,\"1459\":2,\"1467\":2,\"1477\":1,\"1478\":1,\"1479\":1,\"1520\":2,\"1521\":1}}],[\"time\",{\"1\":{\"9\":2,\"11\":2,\"185\":1,\"232\":1,\"283\":1,\"374\":2,\"625\":1,\"722\":3,\"787\":1,\"844\":1,\"845\":1,\"1020\":1,\"1053\":2,\"1170\":7,\"1195\":1,\"1228\":2,\"1230\":2,\"1277\":1,\"1280\":2,\"1351\":1,\"1352\":1,\"1371\":1,\"1372\":2,\"1375\":3,\"1434\":1,\"1436\":2,\"1459\":1,\"1467\":2,\"1468\":6,\"1519\":1}}],[\"tick\",{\"1\":{\"931\":8}}],[\"ticktime\",{\"1\":{\"664\":1}}],[\"ti\",{\"1\":{\"429\":1}}],[\"till\",{\"1\":{\"145\":1,\"147\":1}}],[\"tail=100\",{\"1\":{\"1079\":1}}],[\"tailmap\",{\"1\":{\"396\":4}}],[\"ta\",{\"1\":{\"436\":1}}],[\"tasks\",{\"1\":{\"1048\":1}}],[\"task\",{\"1\":{\"378\":1}}],[\"task任务\",{\"1\":{\"378\":1}}],[\"tasktracker的检查任务执行情况的定时任务中\",{\"1\":{\"378\":1}}],[\"tasktracker接收到请求后\",{\"1\":{\"378\":1}}],[\"tasktracker逻辑中\",{\"1\":{\"378\":1}}],[\"tasktracker分发任务的时候\",{\"1\":{\"375\":1}}],[\"tasktracker定期任务检测到该instance任务的processortracker长时间未更新上报状态\",{\"1\":{\"375\":1}}],[\"tasktracker会动态加载最新worker列表\",{\"1\":{\"375\":1}}],[\"tasktracker\",{\"1\":{\"372\":5}}],[\"taking\",{\"1\":{\"1497\":1,\"1503\":1}}],[\"takemessages\",{\"1\":{\"1230\":1}}],[\"take\",{\"1\":{\"1168\":1}}],[\"takeaways\",{\"1\":{\"275\":1}}],[\"takari\",{\"1\":{\"65\":1}}],[\"tage\",{\"1\":{\"1443\":1}}],[\"tagd\",{\"1\":{\"1443\":1}}],[\"tag2\",{\"1\":{\"1325\":1}}],[\"tag128\",{\"1\":{\"1325\":2}}],[\"tag1\",{\"1\":{\"1325\":1}}],[\"tag的属性名称为tags\",{\"1\":{\"1308\":1}}],[\"tagfiltertest\",{\"1\":{\"1306\":1,\"1307\":2}}],[\"tagcodelist\",{\"1\":{\"1431\":2}}],[\"tagc\",{\"1\":{\"1306\":1,\"1307\":2,\"1309\":1,\"1443\":1}}],[\"tagb\",{\"1\":{\"1306\":1,\"1307\":1,\"1309\":1,\"1310\":2,\"1443\":1}}],[\"taga||tagb||tagc\",{\"1\":{\"1307\":1}}],[\"taga\",{\"1\":{\"984\":1,\"1006\":1,\"1287\":1,\"1306\":1,\"1307\":2,\"1309\":1,\"1310\":2,\"1443\":1}}],[\"tags=tagc\",{\"1\":{\"1445\":1}}],[\"tags=tagb\",{\"1\":{\"1445\":1}}],[\"tags=tage\",{\"1\":{\"1445\":1}}],[\"tagsstring2tagscode\",{\"1\":{\"1198\":1}}],[\"tagscode\",{\"1\":{\"765\":3,\"767\":2,\"771\":4,\"825\":3,\"828\":2,\"839\":1,\"845\":8,\"860\":7,\"1174\":6,\"1297\":4,\"1318\":2,\"1328\":5,\"1333\":3}}],[\"tags\",{\"0\":{\"1301\":1},\"1\":{\"294\":1,\"645\":1,\"742\":1,\"845\":1,\"860\":1,\"890\":1,\"1017\":1,\"1306\":5,\"1309\":3,\"1310\":4,\"1325\":1,\"1328\":1,\"1333\":1,\"1370\":1,\"1443\":3,\"1538\":1}}],[\"tag\",{\"0\":{\"1305\":1,\"1314\":1,\"1319\":1,\"1327\":1},\"1\":{\"155\":1,\"645\":1,\"749\":1,\"755\":1,\"767\":1,\"835\":1,\"1072\":1,\"1117\":1,\"1170\":1,\"1173\":1,\"1174\":1,\"1239\":1,\"1273\":1,\"1278\":2,\"1287\":2,\"1303\":3,\"1305\":4,\"1306\":2,\"1307\":3,\"1308\":2,\"1314\":8,\"1315\":1,\"1317\":3,\"1318\":3,\"1319\":8,\"1321\":1,\"1324\":1,\"1325\":1,\"1328\":4,\"1329\":3,\"1333\":2,\"1459\":2}}],[\"tab斜掠给每个怪挂斜掠\",{\"1\":{\"412\":1}}],[\"tab2list\",{\"1\":{\"248\":1}}],[\"tabp\",{\"1\":{\"154\":1}}],[\"tabpage\",{\"1\":{\"154\":1}}],[\"tabn\",{\"1\":{\"154\":2}}],[\"tabnew\",{\"1\":{\"154\":1}}],[\"tab切换\",{\"1\":{\"154\":1}}],[\"tabo\",{\"1\":{\"154\":1}}],[\"tabc\",{\"1\":{\"154\":1}}],[\"tabe\",{\"1\":{\"154\":1}}],[\"tab操作\",{\"1\":{\"154\":1}}],[\"tab是可以容纳一系列窗口的容器\",{\"1\":{\"154\":1}}],[\"tab标签页\",{\"0\":{\"154\":1}}],[\"tab\",{\"1\":{\"151\":1}}],[\"tablesize\",{\"1\":{\"385\":4}}],[\"tables\",{\"1\":{\"253\":4,\"769\":2,\"871\":2}}],[\"tableid\",{\"1\":{\"248\":7}}],[\"table\",{\"1\":{\"90\":1,\"253\":12}}],[\"targetoffset\",{\"1\":{\"1427\":2}}],[\"target=target\",{\"1\":{\"490\":1}}],[\"target=focus\",{\"1\":{\"490\":2}}],[\"target指定输出class版本\",{\"1\":{\"25\":1}}],[\"target\",{\"1\":{\"10\":1,\"25\":1,\"43\":1,\"489\":1,\"498\":1,\"690\":1,\"1519\":7}}],[\"tr\",{\"1\":{\"1371\":2,\"1372\":4,\"1373\":17,\"1374\":10}}],[\"trs\",{\"1\":{\"1371\":11,\"1373\":6}}],[\"trigger\",{\"1\":{\"1427\":1}}],[\"triggers\",{\"1\":{\"860\":1}}],[\"trim\",{\"1\":{\"1425\":1}}],[\"triple\",{\"1\":{\"181\":2}}],[\"trust\",{\"1\":{\"961\":1}}],[\"truncateresponse\",{\"1\":{\"1519\":4}}],[\"truncaterequest\",{\"1\":{\"1519\":2}}],[\"truncateentry\",{\"1\":{\"1519\":4}}],[\"truncateindex=\",{\"1\":{\"1519\":3,\"1520\":2}}],[\"truncateindex\",{\"1\":{\"1519\":22,\"1520\":9}}],[\"truncatemessagequeuenotmytopic\",{\"1\":{\"1142\":1}}],[\"truncatebymaxaddress\",{\"1\":{\"771\":1}}],[\"truncate\",{\"1\":{\"771\":1,\"1510\":6,\"1511\":3,\"1519\":16,\"1520\":8}}],[\"truncatedirtyfiles\",{\"1\":{\"771\":1}}],[\"true|false\",{\"1\":{\"515\":1}}],[\"true\",{\"1\":{\"89\":1,\"90\":1,\"91\":1,\"99\":2,\"113\":1,\"125\":3,\"171\":1,\"181\":6,\"186\":8,\"187\":1,\"188\":3,\"253\":1,\"266\":1,\"294\":2,\"299\":3,\"301\":1,\"332\":1,\"333\":2,\"338\":4,\"339\":1,\"341\":1,\"511\":1,\"512\":1,\"518\":1,\"519\":1,\"527\":1,\"544\":1,\"558\":1,\"562\":1,\"591\":2,\"624\":1,\"625\":3,\"626\":3,\"627\":1,\"665\":2,\"684\":1,\"712\":2,\"714\":1,\"715\":1,\"722\":1,\"733\":1,\"735\":1,\"742\":1,\"762\":1,\"765\":2,\"771\":1,\"793\":2,\"797\":2,\"805\":1,\"819\":1,\"844\":2,\"860\":2,\"894\":1,\"915\":2,\"961\":3,\"967\":4,\"971\":1,\"972\":1,\"983\":2,\"995\":1,\"999\":1,\"1005\":1,\"1006\":1,\"1007\":1,\"1017\":1,\"1021\":1,\"1050\":1,\"1051\":1,\"1053\":5,\"1122\":1,\"1144\":5,\"1170\":3,\"1173\":2,\"1174\":1,\"1175\":1,\"1195\":2,\"1197\":1,\"1198\":1,\"1200\":1,\"1224\":5,\"1225\":1,\"1226\":2,\"1228\":1,\"1230\":2,\"1234\":1,\"1247\":5,\"1269\":2,\"1270\":1,\"1275\":1,\"1276\":2,\"1277\":2,\"1278\":2,\"1286\":2,\"1297\":1,\"1299\":2,\"1300\":1,\"1322\":1,\"1328\":8,\"1332\":1,\"1333\":12,\"1370\":1,\"1371\":3,\"1373\":4,\"1374\":5,\"1382\":1,\"1424\":1,\"1427\":6,\"1428\":3,\"1435\":3,\"1436\":2,\"1449\":1,\"1450\":1,\"1459\":1,\"1462\":1,\"1468\":1,\"1472\":2,\"1497\":1,\"1499\":2,\"1500\":1,\"1502\":1,\"1503\":1,\"1516\":1,\"1519\":3,\"1521\":1}}],[\"tr1sosnmq0rdsr9n8xbzqixmwi5ws0s9h7haheuanmzuaiwyewwhgzecxtaxv5k2ot0kpnpruq37vvqq2wm7n6hjf0eyfj8vej\",{\"1\":{\"429\":1}}],[\"traflag\",{\"1\":{\"1462\":2}}],[\"tranexecutor\",{\"1\":{\"1459\":1}}],[\"tran\",{\"1\":{\"1445\":3,\"1449\":1,\"1450\":1,\"1459\":1}}],[\"tranmsg\",{\"1\":{\"1053\":2}}],[\"trantype\",{\"1\":{\"764\":2,\"794\":2,\"843\":3}}],[\"transport=dt\",{\"1\":{\"1080\":1}}],[\"transferring\",{\"1\":{\"1516\":1,\"1517\":1}}],[\"transfer\",{\"1\":{\"1173\":2}}],[\"transflag\",{\"1\":{\"1056\":3}}],[\"transformers>\",{\"1\":{\"64\":1}}],[\"transformer>\",{\"1\":{\"64\":1}}],[\"transbeanlist\",{\"1\":{\"1021\":5}}],[\"transbeanmap\",{\"1\":{\"1021\":4}}],[\"trans\",{\"1\":{\"845\":1,\"860\":1,\"964\":1,\"1053\":1,\"1450\":1,\"1451\":1,\"1453\":1,\"1463\":2,\"1464\":2,\"1468\":5}}],[\"transientstorepool\",{\"0\":{\"883\":1},\"1\":{\"883\":4}}],[\"transient\",{\"1\":{\"687\":1}}],[\"transactionchecklistener\",{\"1\":{\"1472\":7}}],[\"transactioncheckmax\",{\"1\":{\"1468\":3}}],[\"transactiontimeout\",{\"1\":{\"1468\":8}}],[\"transactionfinishlatency\",{\"1\":{\"1464\":1}}],[\"transactionmessagebridge\",{\"0\":{\"1463\":1},\"1\":{\"1463\":1}}],[\"transactionmqproducer\",{\"0\":{\"1458\":1,\"1460\":1},\"1\":{\"1443\":3,\"1449\":1,\"1458\":1,\"1459\":1,\"1460\":1}}],[\"transactionsendresult\",{\"1\":{\"1458\":1,\"1459\":11}}],[\"transactionstate\",{\"1\":{\"1017\":1}}],[\"transactionindex\",{\"1\":{\"1442\":2}}],[\"transactionid=\",{\"1\":{\"1445\":3}}],[\"transactionid\",{\"1\":{\"1017\":1,\"1445\":3,\"1459\":7,\"1460\":2,\"1471\":4}}],[\"transactionlistenerimpl\",{\"1\":{\"1442\":1,\"1443\":1}}],[\"transactionlistener\",{\"1\":{\"1442\":2,\"1443\":4,\"1449\":1,\"1458\":2,\"1459\":5,\"1472\":4}}],[\"transactionalmessagechecklistener\",{\"1\":{\"1469\":1}}],[\"transactionalmessagecheckservice\",{\"0\":{\"1467\":1},\"1\":{\"1453\":1,\"1467\":1}}],[\"transactionalmessagebridge\",{\"1\":{\"1468\":5}}],[\"transactionalmessageutil\",{\"1\":{\"1463\":2}}],[\"transactionalmessageserviceimpl\",{\"0\":{\"1468\":1},\"1\":{\"1453\":1,\"1468\":1}}],[\"transactional\",{\"1\":{\"1438\":1,\"1458\":1,\"1468\":1}}],[\"transaction\",{\"1\":{\"253\":7,\"737\":2,\"764\":4,\"794\":4,\"843\":2,\"1053\":3,\"1056\":2,\"1197\":1,\"1441\":1,\"1443\":1,\"1445\":3,\"1458\":1,\"1459\":4,\"1460\":3,\"1462\":4,\"1463\":2,\"1464\":5,\"1467\":2,\"1468\":1,\"1469\":1,\"1472\":5}}],[\"traget\",{\"1\":{\"690\":1}}],[\"tracing\",{\"1\":{\"1005\":1}}],[\"tracking\",{\"1\":{\"624\":1}}],[\"tracy\",{\"1\":{\"301\":1}}],[\"tracedataencoder\",{\"1\":{\"1021\":1}}],[\"tracedata\",{\"1\":{\"1021\":2}}],[\"tracedispatcher\",{\"1\":{\"1019\":3,\"1021\":1}}],[\"traceconstants\",{\"1\":{\"1021\":2}}],[\"tracecontextqueue\",{\"1\":{\"1021\":4}}],[\"tracecontext\",{\"1\":{\"1017\":2,\"1020\":14,\"1021\":2}}],[\"traceproducer\",{\"1\":{\"1021\":2}}],[\"traceexecutor\",{\"1\":{\"1021\":3}}],[\"traceon\",{\"1\":{\"1020\":3}}],[\"tracebean\",{\"1\":{\"1017\":1,\"1020\":12}}],[\"tracebeans\",{\"1\":{\"1017\":2}}],[\"tracetransferbean\",{\"1\":{\"1021\":1}}],[\"tracetopicname\",{\"1\":{\"1021\":1}}],[\"tracetopicenable=true\",{\"1\":{\"1005\":1}}],[\"tracetype\",{\"1\":{\"1017\":2,\"1020\":2}}],[\"traceresolution参数\",{\"1\":{\"602\":1}}],[\"traceresolution\",{\"0\":{\"602\":1}}],[\"tracer\",{\"1\":{\"261\":3}}],[\"trace\",{\"1\":{\"261\":5,\"625\":1,\"627\":1,\"1002\":1,\"1012\":1,\"1017\":1,\"1019\":1,\"1020\":2,\"1021\":1,\"1434\":1,\"1435\":2,\"1445\":3}}],[\"treemap<string\",{\"1\":{\"995\":1}}],[\"treemap<>\",{\"1\":{\"396\":1}}],[\"treemap\",{\"1\":{\"391\":1,\"395\":1,\"1104\":1,\"1155\":1}}],[\"tree\",{\"1\":{\"96\":1,\"381\":1,\"643\":1}}],[\"tryacquire\",{\"1\":{\"1372\":1}}],[\"trylocklaterandreconsume\",{\"1\":{\"1230\":3}}],[\"trylock\",{\"1\":{\"1225\":1,\"1270\":1,\"1427\":1}}],[\"trylockbatch\",{\"1\":{\"1222\":1}}],[\"trytocompressmessage\",{\"1\":{\"1053\":1}}],[\"trytofindtopicpublishinfo\",{\"1\":{\"1039\":1,\"1050\":2,\"1051\":1,\"1053\":1}}],[\"try\",{\"0\":{\"194\":1},\"1\":{\"34\":1,\"53\":1,\"69\":3,\"70\":2,\"104\":1,\"105\":1,\"106\":1,\"112\":2,\"113\":2,\"122\":1,\"123\":1,\"124\":1,\"125\":2,\"128\":2,\"131\":1,\"133\":1,\"180\":1,\"193\":2,\"194\":4,\"195\":10,\"196\":1,\"356\":1,\"396\":1,\"613\":1,\"712\":1,\"742\":2,\"762\":1,\"765\":1,\"767\":1,\"793\":2,\"794\":1,\"797\":4,\"820\":2,\"823\":1,\"824\":1,\"825\":2,\"844\":1,\"845\":2,\"860\":1,\"861\":3,\"870\":1,\"871\":1,\"872\":1,\"880\":1,\"915\":1,\"961\":1,\"970\":2,\"971\":2,\"972\":4,\"984\":1,\"995\":1,\"999\":2,\"1006\":1,\"1019\":1,\"1021\":1,\"1048\":5,\"1050\":1,\"1052\":1,\"1053\":1,\"1142\":1,\"1143\":1,\"1144\":2,\"1168\":2,\"1170\":3,\"1173\":2,\"1174\":1,\"1175\":1,\"1194\":2,\"1195\":1,\"1197\":2,\"1200\":1,\"1201\":1,\"1222\":2,\"1224\":1,\"1225\":2,\"1226\":1,\"1228\":1,\"1230\":1,\"1266\":1,\"1270\":1,\"1276\":1,\"1278\":1,\"1296\":1,\"1297\":2,\"1332\":2,\"1333\":2,\"1370\":2,\"1371\":2,\"1372\":2,\"1373\":2,\"1374\":3,\"1424\":1,\"1425\":1,\"1427\":1,\"1432\":1,\"1434\":1,\"1435\":3,\"1436\":3,\"1443\":1,\"1459\":3,\"1468\":2,\"1469\":1,\"1472\":2,\"1497\":2,\"1499\":1,\"1516\":1,\"1519\":4,\"1520\":6,\"1521\":2}}],[\"t\",{\"1\":{\"48\":4,\"69\":2,\"103\":1,\"145\":2,\"154\":1,\"171\":1,\"180\":2,\"183\":4,\"184\":3,\"187\":2,\"189\":2,\"332\":1,\"396\":9,\"405\":1,\"411\":1,\"416\":1,\"422\":1,\"425\":1,\"429\":1,\"431\":1,\"432\":1,\"438\":2,\"443\":1,\"445\":1,\"453\":3,\"519\":4,\"520\":2,\"528\":2,\"589\":3,\"845\":2,\"860\":2,\"961\":1,\"1019\":1,\"1079\":1,\"1174\":2,\"1247\":2,\"1248\":1,\"1371\":2,\"1372\":2,\"1374\":2,\"1436\":3,\"1441\":1,\"1497\":2,\"1499\":2,\"1519\":4,\"1520\":12,\"1521\":4}}],[\"type>\",{\"1\":{\"1519\":1}}],[\"type=transaction\",{\"1\":{\"1441\":1}}],[\"type的形式\",{\"1\":{\"593\":1}}],[\"type可以\",{\"1\":{\"564\":1}}],[\"type不支持继承\",{\"1\":{\"564\":1}}],[\"type能够表示非对象类型\",{\"1\":{\"564\":1}}],[\"type命令用来定义一个类型的别名\",{\"1\":{\"517\":1}}],[\"typeof命令的参数不能是类型\",{\"1\":{\"518\":1}}],[\"typeof运算符只可能返回八种结果\",{\"1\":{\"518\":1}}],[\"typeof运算符和instanceof运算符这几种\",{\"1\":{\"503\":1}}],[\"typeof\",{\"0\":{\"518\":1},\"1\":{\"503\":2,\"504\":2,\"508\":1,\"518\":12,\"547\":1,\"558\":3,\"574\":1,\"586\":1}}],[\"typeof操作符可以判断出number\",{\"1\":{\"333\":1}}],[\"typeerror\",{\"1\":{\"356\":1}}],[\"typeclass\",{\"1\":{\"48\":2}}],[\"typescript\",{\"0\":{\"493\":1,\"497\":1},\"1\":{\"493\":1,\"495\":1,\"497\":1,\"498\":2,\"500\":1,\"501\":1,\"502\":2,\"506\":3,\"509\":1,\"518\":2,\"521\":1,\"522\":1,\"524\":2,\"527\":1,\"529\":1,\"533\":1,\"547\":1,\"556\":1,\"564\":1,\"576\":1,\"579\":1,\"580\":1,\"582\":1,\"589\":2,\"591\":1,\"592\":1,\"593\":2,\"595\":2,\"596\":1,\"601\":1,\"606\":1}}],[\"types\",{\"1\":{\"48\":2,\"171\":1,\"515\":1}}],[\"type\",{\"0\":{\"101\":1,\"102\":1,\"517\":1,\"561\":1,\"564\":1,\"592\":1},\"1\":{\"36\":1,\"43\":2,\"46\":9,\"48\":3,\"101\":1,\"104\":1,\"171\":5,\"356\":1,\"515\":1,\"516\":2,\"517\":1,\"518\":2,\"519\":2,\"520\":1,\"527\":4,\"528\":2,\"533\":1,\"538\":1,\"545\":1,\"548\":1,\"550\":1,\"552\":1,\"553\":1,\"561\":1,\"564\":3,\"570\":2,\"578\":2,\"586\":1,\"589\":1,\"591\":1,\"592\":4,\"593\":1,\"606\":1,\"714\":2,\"715\":2,\"717\":1,\"742\":11,\"764\":4,\"794\":4,\"843\":2,\"882\":4,\"894\":1,\"1008\":1,\"1019\":1,\"1020\":1,\"1021\":2,\"1053\":1,\"1195\":1,\"1230\":2,\"1331\":4,\"1420\":2,\"1427\":1,\"1460\":3,\"1463\":1,\"1464\":2,\"1472\":3,\"1519\":31,\"1520\":5}}],[\"thursday\",{\"1\":{\"587\":1}}],[\"thmhsfx3cb0dznoq7\",{\"1\":{\"469\":1}}],[\"than\",{\"1\":{\"396\":1,\"886\":1,\"906\":1,\"1170\":1,\"1201\":1,\"1228\":1,\"1270\":1,\"1370\":1,\"1432\":1,\"1436\":1,\"1497\":1,\"1503\":1,\"1519\":5,\"1520\":3}}],[\"that\",{\"1\":{\"98\":1,\"104\":1,\"767\":1,\"1174\":1,\"1427\":1,\"1430\":1,\"1468\":1}}],[\"thing\",{\"1\":{\"196\":2}}],[\"things3\",{\"1\":{\"177\":1}}],[\"things2\",{\"1\":{\"177\":1}}],[\"things1=\",{\"1\":{\"177\":1}}],[\"things\",{\"1\":{\"177\":1}}],[\"thisheader\",{\"1\":{\"1472\":15}}],[\"this关键字只能用于interface\",{\"1\":{\"564\":1}}],[\"this指向undefined或window\",{\"1\":{\"317\":1}}],[\"this\",{\"0\":{\"580\":1},\"1\":{\"22\":1,\"69\":4,\"98\":2,\"104\":1,\"112\":1,\"113\":1,\"121\":1,\"122\":1,\"124\":5,\"132\":1,\"133\":4,\"196\":1,\"253\":1,\"317\":1,\"318\":1,\"339\":2,\"341\":7,\"342\":5,\"344\":2,\"345\":2,\"396\":4,\"566\":2,\"567\":2,\"568\":1,\"576\":4,\"578\":1,\"580\":1,\"605\":2,\"643\":1,\"737\":48,\"738\":1,\"742\":3,\"762\":9,\"763\":1,\"764\":2,\"765\":17,\"767\":3,\"769\":8,\"771\":8,\"793\":17,\"794\":7,\"796\":2,\"797\":39,\"819\":4,\"820\":2,\"822\":3,\"823\":3,\"824\":11,\"825\":5,\"827\":5,\"828\":1,\"835\":1,\"843\":2,\"844\":7,\"845\":20,\"860\":24,\"861\":19,\"869\":5,\"870\":11,\"871\":5,\"872\":10,\"880\":4,\"882\":6,\"886\":1,\"893\":3,\"894\":6,\"906\":1,\"913\":1,\"915\":2,\"961\":18,\"970\":1,\"971\":12,\"972\":11,\"973\":3,\"995\":1,\"996\":2,\"998\":6,\"999\":7,\"1019\":6,\"1021\":2,\"1047\":19,\"1048\":28,\"1050\":10,\"1051\":7,\"1052\":5,\"1053\":26,\"1055\":9,\"1056\":7,\"1122\":59,\"1123\":13,\"1140\":5,\"1142\":3,\"1143\":11,\"1144\":10,\"1145\":9,\"1168\":6,\"1170\":27,\"1171\":7,\"1172\":2,\"1173\":34,\"1174\":18,\"1175\":16,\"1194\":5,\"1195\":22,\"1197\":10,\"1198\":14,\"1200\":12,\"1201\":6,\"1222\":5,\"1224\":10,\"1225\":5,\"1226\":6,\"1228\":4,\"1229\":9,\"1230\":45,\"1235\":4,\"1266\":3,\"1269\":4,\"1270\":13,\"1271\":2,\"1273\":6,\"1275\":4,\"1276\":1,\"1277\":2,\"1278\":1,\"1279\":1,\"1296\":1,\"1297\":14,\"1329\":1,\"1331\":5,\"1332\":2,\"1333\":3,\"1368\":3,\"1370\":1,\"1371\":3,\"1373\":3,\"1374\":3,\"1424\":15,\"1427\":7,\"1428\":6,\"1430\":1,\"1431\":2,\"1434\":23,\"1435\":16,\"1436\":20,\"1458\":3,\"1459\":4,\"1460\":5,\"1462\":9,\"1464\":6,\"1467\":4,\"1468\":5,\"1471\":3,\"1472\":7,\"1500\":1,\"1519\":5,\"1521\":6,\"1523\":5}}],[\"there\",{\"1\":{\"737\":1,\"1056\":1,\"1427\":1,\"1435\":1,\"1521\":1}}],[\"thencombine\",{\"1\":{\"1432\":1}}],[\"thencompose\",{\"1\":{\"1432\":1,\"1436\":1}}],[\"thenaccept\",{\"1\":{\"1436\":1}}],[\"thenacceptasync\",{\"1\":{\"1427\":1,\"1462\":1}}],[\"thenapply\",{\"1\":{\"1198\":1,\"1428\":1,\"1430\":2,\"1431\":2,\"1436\":1}}],[\"then\",{\"1\":{\"165\":1,\"289\":1,\"349\":1,\"351\":2,\"352\":1,\"353\":1,\"354\":1,\"971\":1,\"1000\":2,\"1279\":2,\"1280\":1,\"1371\":1,\"1372\":1,\"1431\":1,\"1464\":2,\"1516\":1}}],[\"thenexceptionisthrown\",{\"1\":{\"101\":1,\"102\":1}}],[\"thenthrow\",{\"1\":{\"101\":2}}],[\"thenreturnsmocksuccessfully\",{\"1\":{\"105\":1,\"106\":1}}],[\"thenreturn\",{\"1\":{\"97\":3,\"105\":1,\"106\":1}}],[\"them\",{\"1\":{\"98\":1}}],[\"these\",{\"1\":{\"98\":1,\"886\":1}}],[\"the\",{\"1\":{\"97\":4,\"98\":3,\"103\":3,\"104\":5,\"147\":2,\"155\":1,\"165\":6,\"171\":9,\"253\":8,\"396\":10,\"624\":4,\"628\":1,\"640\":1,\"643\":2,\"690\":1,\"737\":2,\"738\":1,\"742\":11,\"797\":2,\"845\":2,\"860\":2,\"861\":1,\"870\":1,\"886\":1,\"895\":1,\"960\":3,\"961\":5,\"971\":1,\"972\":2,\"973\":1,\"983\":1,\"995\":1,\"996\":4,\"998\":1,\"1000\":6,\"1005\":1,\"1008\":1,\"1017\":1,\"1020\":1,\"1021\":1,\"1047\":3,\"1048\":2,\"1053\":2,\"1056\":1,\"1122\":4,\"1123\":2,\"1143\":2,\"1145\":2,\"1170\":9,\"1171\":2,\"1173\":20,\"1175\":3,\"1195\":2,\"1198\":2,\"1200\":3,\"1226\":1,\"1228\":2,\"1230\":7,\"1266\":6,\"1267\":3,\"1270\":1,\"1277\":1,\"1296\":1,\"1368\":1,\"1370\":1,\"1371\":5,\"1372\":6,\"1373\":1,\"1427\":5,\"1432\":1,\"1434\":1,\"1436\":8,\"1437\":1,\"1444\":1,\"1462\":4,\"1464\":1,\"1468\":14,\"1497\":1,\"1500\":3,\"1503\":3,\"1504\":1,\"1516\":5,\"1519\":27,\"1520\":7,\"1521\":4,\"1522\":1}}],[\"threshold\",{\"1\":{\"1170\":2}}],[\"three\",{\"1\":{\"515\":1,\"585\":1,\"1434\":1}}],[\"threadpoolexecutor\",{\"1\":{\"1021\":1,\"1443\":1}}],[\"threadfactoryimpl\",{\"1\":{\"961\":1}}],[\"threadlocalrandom\",{\"1\":{\"1198\":2}}],[\"threadlocalindex\",{\"1\":{\"1021\":2}}],[\"threadlocal\",{\"1\":{\"87\":1,\"1517\":1}}],[\"thread\",{\"1\":{\"11\":1,\"69\":2,\"104\":1,\"112\":2,\"114\":1,\"122\":2,\"793\":2,\"861\":1,\"870\":1,\"871\":1,\"882\":1,\"886\":2,\"913\":2,\"985\":1,\"1007\":1,\"1021\":2,\"1248\":1,\"1277\":1,\"1278\":1,\"1288\":1,\"1297\":2,\"1374\":1,\"1443\":7,\"1444\":1,\"1462\":1,\"1467\":2,\"1468\":2,\"1500\":1,\"1521\":1}}],[\"threads\",{\"1\":{\"11\":1}}],[\"throttle\",{\"1\":{\"624\":1}}],[\"thrown\",{\"1\":{\"193\":1,\"194\":2}}],[\"throwing\",{\"0\":{\"100\":1},\"1\":{\"1436\":1}}],[\"throw\",{\"1\":{\"34\":2,\"103\":2,\"125\":1,\"133\":1,\"193\":3,\"194\":2,\"357\":1,\"396\":2,\"504\":1,\"543\":1,\"558\":1,\"625\":1,\"742\":3,\"960\":1,\"995\":1,\"998\":1,\"1000\":6,\"1047\":2,\"1048\":1,\"1050\":2,\"1053\":3,\"1122\":2,\"1123\":1,\"1171\":2,\"1200\":1,\"1280\":1,\"1331\":1,\"1370\":1,\"1425\":1,\"1458\":1,\"1459\":2,\"1497\":1,\"1499\":1,\"1516\":1,\"1519\":1}}],[\"throws\",{\"1\":{\"34\":1,\"41\":1,\"69\":2,\"70\":2,\"97\":1,\"99\":4,\"103\":1,\"113\":1,\"121\":1,\"124\":1,\"125\":6,\"126\":2,\"128\":2,\"129\":2,\"131\":1,\"132\":1,\"133\":1,\"134\":2,\"712\":1,\"742\":2,\"819\":2,\"820\":3,\"880\":1,\"891\":1,\"960\":3,\"961\":1,\"973\":1,\"984\":1,\"985\":1,\"1047\":1,\"1048\":2,\"1050\":5,\"1053\":1,\"1122\":2,\"1123\":2,\"1171\":5,\"1172\":1,\"1173\":3,\"1197\":5,\"1198\":2,\"1200\":1,\"1248\":2,\"1269\":2,\"1273\":2,\"1279\":1,\"1280\":3,\"1372\":2,\"1425\":1,\"1435\":2,\"1443\":1,\"1444\":1,\"1458\":1,\"1459\":1,\"1460\":1,\"1462\":1,\"1464\":1,\"1469\":2,\"1471\":1,\"1496\":1,\"1497\":1,\"1499\":1,\"1500\":2,\"1502\":2,\"1516\":2,\"1519\":11,\"1520\":2}}],[\"throwable\",{\"1\":{\"33\":1,\"41\":1,\"742\":1,\"820\":1,\"823\":1,\"824\":1,\"825\":2,\"844\":1,\"1019\":1,\"1142\":1,\"1143\":1,\"1173\":1,\"1175\":2,\"1195\":1,\"1201\":1,\"1230\":1,\"1266\":1,\"1276\":1,\"1278\":1,\"1279\":1,\"1280\":1,\"1288\":1,\"1332\":2,\"1333\":2,\"1371\":2,\"1372\":1,\"1373\":2,\"1374\":2,\"1425\":1,\"1427\":1,\"1436\":3,\"1459\":2,\"1460\":1,\"1468\":2,\"1472\":3,\"1497\":3,\"1499\":2,\"1519\":2,\"1520\":6,\"1521\":2}}],[\"throughput\",{\"1\":{\"9\":1,\"11\":2,\"717\":1}}],[\"thrpt\",{\"1\":{\"11\":3,\"741\":4}}],[\"tolist\",{\"1\":{\"1521\":1}}],[\"tolowercase\",{\"1\":{\"1427\":1}}],[\"tomillis\",{\"1\":{\"1427\":3,\"1435\":2}}],[\"toicmetadata\",{\"1\":{\"1421\":1}}],[\"toipic\",{\"1\":{\"906\":1}}],[\"tojsonstring\",{\"1\":{\"1273\":1,\"1497\":1,\"1521\":2}}],[\"tojavalist\",{\"1\":{\"998\":2}}],[\"toset\",{\"1\":{\"1248\":1}}],[\"tostring占用大量时间\",{\"1\":{\"896\":1}}],[\"tostring\",{\"1\":{\"125\":1,\"299\":2,\"820\":4,\"860\":1,\"861\":8,\"960\":1,\"995\":1,\"998\":1,\"1021\":1,\"1170\":1,\"1175\":2,\"1195\":2,\"1197\":1,\"1200\":1,\"1230\":1,\"1235\":1,\"1269\":3,\"1270\":3,\"1445\":3,\"1460\":1}}],[\"token\",{\"1\":{\"995\":2}}],[\"toarray\",{\"1\":{\"872\":1,\"1436\":1}}],[\"tood\",{\"1\":{\"1500\":1}}],[\"too\",{\"1\":{\"720\":1,\"731\":1,\"737\":2,\"1170\":1,\"1173\":3,\"1174\":1,\"1175\":1,\"1270\":1,\"1276\":1,\"1277\":2,\"1427\":3,\"1430\":2,\"1432\":1}}],[\"tools\",{\"1\":{\"643\":1}}],[\"tool\",{\"1\":{\"15\":1}}],[\"tofixed\",{\"1\":{\"502\":1}}],[\"tochararray\",{\"1\":{\"385\":1}}],[\"topicfilter\",{\"1\":{\"1427\":2}}],[\"topicid\",{\"1\":{\"1420\":1,\"1434\":8}}],[\"topicmetadatatable\",{\"1\":{\"1402\":1,\"1420\":1}}],[\"topicname\",{\"1\":{\"1247\":1}}],[\"topic下所有的messagequeue\",{\"1\":{\"1143\":1}}],[\"topicserialnumber\",{\"1\":{\"1420\":1}}],[\"topicsubscribeinfotable\",{\"1\":{\"1133\":1,\"1143\":2}}],[\"topicsysflag\",{\"1\":{\"964\":10,\"968\":2,\"1198\":4}}],[\"topicwithnamespace\",{\"1\":{\"1053\":3}}],[\"topicpublishinfo\",{\"1\":{\"1047\":1,\"1050\":6,\"1051\":12,\"1052\":2,\"1053\":4}}],[\"topicpublishinfotable\",{\"1\":{\"1047\":1,\"1051\":4}}],[\"topicperms\",{\"1\":{\"983\":2}}],[\"topic0607\",{\"1\":{\"984\":1,\"985\":1}}],[\"topicc=sub\",{\"1\":{\"983\":1}}],[\"topicconfig\",{\"0\":{\"1066\":1},\"1\":{\"1056\":4,\"1061\":2,\"1173\":7,\"1198\":6,\"1269\":4}}],[\"topicconfig>\",{\"1\":{\"971\":2}}],[\"topicconfigwrapper\",{\"1\":{\"970\":2,\"971\":5}}],[\"topicconfigserializewrapper\",{\"1\":{\"970\":1,\"971\":1}}],[\"topicconfigtable\",{\"1\":{\"952\":1}}],[\"topicconfigmanager\",{\"1\":{\"952\":1,\"1424\":2}}],[\"topicb=pub|sub\",{\"1\":{\"983\":1}}],[\"topicqueuemappingcontext\",{\"1\":{\"1462\":1}}],[\"topicqueuekey\",{\"1\":{\"1296\":2}}],[\"topicqueue\",{\"1\":{\"972\":1}}],[\"topicqueuetable\",{\"0\":{\"964\":1},\"1\":{\"720\":1,\"736\":1,\"765\":2,\"944\":1,\"949\":1,\"953\":1,\"954\":1,\"957\":1,\"964\":1,\"971\":1,\"972\":4,\"973\":1}}],[\"topicrouteinfomanager\",{\"1\":{\"1266\":4}}],[\"topicroutedata\",{\"1\":{\"950\":1,\"957\":3,\"968\":1,\"973\":9}}],[\"topicroutedata>\",{\"1\":{\"950\":2,\"968\":2}}],[\"topicroutetable\",{\"1\":{\"950\":1,\"956\":1,\"968\":1}}],[\"topic之类的\",{\"1\":{\"845\":1}}],[\"topicvalidator\",{\"1\":{\"843\":1,\"845\":2,\"860\":2,\"1198\":1,\"1468\":1}}],[\"topica=deny\",{\"1\":{\"983\":1}}],[\"topica\",{\"1\":{\"835\":1}}],[\"topic=topictest1234\",{\"1\":{\"1445\":13}}],[\"topic=权限\",{\"1\":{\"983\":1}}],[\"topic=\",{\"1\":{\"823\":1,\"1143\":1,\"1173\":3,\"1174\":1,\"1278\":1,\"1279\":1,\"1280\":1,\"1332\":2,\"1427\":4,\"1431\":3,\"1432\":3,\"1445\":3,\"1468\":1}}],[\"topictest1234\",{\"1\":{\"1441\":1,\"1445\":3}}],[\"topictest\",{\"1\":{\"742\":1,\"890\":1,\"1006\":1,\"1007\":1,\"1248\":1,\"1287\":1,\"1288\":2}}],[\"topiclength\",{\"1\":{\"737\":6}}],[\"topicdata\",{\"1\":{\"737\":6}}],[\"topic\",{\"0\":{\"904\":1,\"905\":1,\"1039\":1,\"1143\":1,\"1441\":1},\"1\":{\"285\":1,\"396\":1,\"737\":2,\"742\":1,\"746\":1,\"747\":5,\"749\":2,\"751\":1,\"755\":2,\"757\":1,\"764\":1,\"765\":4,\"767\":5,\"786\":3,\"787\":1,\"789\":1,\"794\":7,\"815\":2,\"819\":2,\"822\":3,\"823\":5,\"825\":5,\"828\":2,\"834\":6,\"836\":6,\"839\":3,\"843\":10,\"845\":4,\"857\":1,\"860\":3,\"867\":1,\"877\":1,\"878\":2,\"886\":3,\"902\":2,\"904\":2,\"905\":1,\"906\":5,\"921\":1,\"925\":4,\"941\":2,\"944\":2,\"945\":6,\"949\":3,\"950\":7,\"952\":5,\"953\":1,\"956\":1,\"957\":1,\"964\":8,\"968\":4,\"970\":2,\"971\":3,\"972\":5,\"973\":6,\"978\":8,\"983\":1,\"1006\":1,\"1007\":1,\"1012\":4,\"1017\":1,\"1021\":8,\"1028\":4,\"1029\":3,\"1030\":3,\"1037\":1,\"1038\":1,\"1039\":11,\"1041\":1,\"1050\":4,\"1051\":7,\"1053\":3,\"1061\":8,\"1065\":4,\"1066\":1,\"1067\":1,\"1089\":3,\"1090\":1,\"1091\":2,\"1094\":1,\"1095\":3,\"1096\":2,\"1097\":2,\"1100\":3,\"1102\":4,\"1103\":1,\"1116\":2,\"1117\":3,\"1120\":3,\"1122\":2,\"1126\":2,\"1130\":2,\"1133\":3,\"1134\":2,\"1136\":3,\"1137\":4,\"1142\":7,\"1143\":22,\"1144\":3,\"1145\":6,\"1173\":14,\"1174\":11,\"1175\":1,\"1180\":1,\"1181\":1,\"1188\":10,\"1197\":3,\"1198\":14,\"1201\":5,\"1203\":5,\"1218\":1,\"1224\":3,\"1230\":1,\"1239\":1,\"1247\":3,\"1248\":5,\"1249\":1,\"1251\":1,\"1253\":6,\"1255\":1,\"1257\":3,\"1261\":1,\"1263\":6,\"1266\":16,\"1270\":21,\"1271\":3,\"1278\":2,\"1279\":6,\"1280\":4,\"1284\":1,\"1287\":2,\"1290\":12,\"1291\":2,\"1293\":4,\"1297\":4,\"1315\":1,\"1318\":2,\"1323\":2,\"1331\":6,\"1332\":1,\"1337\":1,\"1339\":1,\"1342\":5,\"1348\":2,\"1352\":1,\"1354\":3,\"1355\":1,\"1357\":1,\"1360\":1,\"1364\":1,\"1370\":2,\"1371\":2,\"1374\":1,\"1379\":1,\"1383\":3,\"1395\":4,\"1402\":2,\"1407\":1,\"1419\":1,\"1420\":12,\"1421\":3,\"1427\":17,\"1430\":4,\"1434\":12,\"1436\":7,\"1441\":3,\"1443\":2,\"1444\":1,\"1446\":6,\"1450\":2,\"1451\":3,\"1453\":9,\"1462\":2,\"1463\":7,\"1464\":10,\"1468\":10,\"1469\":2,\"1472\":2}}],[\"todo\",{\"1\":{\"191\":13,\"1371\":1}}],[\"touppercase\",{\"1\":{\"113\":1,\"125\":1}}],[\"total++\",{\"1\":{\"1194\":2}}],[\"totalsize\",{\"1\":{\"737\":2}}],[\"total\",{\"1\":{\"11\":1,\"180\":3,\"183\":1,\"737\":2,\"880\":2,\"995\":2,\"1174\":1,\"1194\":6,\"1371\":1,\"1464\":2}}],[\"to\",{\"1\":{\"11\":1,\"83\":1,\"97\":1,\"98\":1,\"103\":2,\"104\":3,\"113\":1,\"147\":2,\"148\":1,\"165\":4,\"171\":4,\"185\":2,\"200\":1,\"252\":1,\"253\":2,\"256\":1,\"259\":1,\"289\":1,\"351\":1,\"396\":10,\"624\":2,\"626\":9,\"627\":2,\"643\":4,\"645\":1,\"646\":1,\"653\":3,\"720\":3,\"722\":1,\"765\":1,\"767\":5,\"797\":2,\"820\":1,\"870\":1,\"886\":1,\"910\":1,\"913\":2,\"915\":1,\"960\":2,\"961\":1,\"970\":1,\"971\":1,\"983\":1,\"999\":2,\"1021\":1,\"1056\":3,\"1144\":1,\"1145\":4,\"1170\":3,\"1171\":1,\"1173\":3,\"1174\":5,\"1195\":1,\"1200\":2,\"1228\":3,\"1230\":4,\"1247\":1,\"1266\":2,\"1267\":1,\"1271\":1,\"1277\":2,\"1287\":3,\"1297\":2,\"1332\":1,\"1368\":1,\"1371\":3,\"1372\":2,\"1427\":5,\"1430\":6,\"1431\":1,\"1432\":3,\"1434\":1,\"1435\":1,\"1436\":2,\"1444\":1,\"1458\":1,\"1462\":1,\"1467\":2,\"1468\":2,\"1497\":9,\"1500\":4,\"1503\":1,\"1516\":4,\"1519\":6,\"1521\":3}}],[\"team\",{\"1\":{\"381\":1}}],[\"teardown\",{\"1\":{\"4\":1,\"99\":1}}],[\"tencent\",{\"1\":{\"274\":1}}],[\"telecom\",{\"1\":{\"262\":1}}],[\"termchange\",{\"1\":{\"1521\":2}}],[\"term=\",{\"1\":{\"1497\":1,\"1499\":1,\"1519\":1,\"1521\":3}}],[\"term\",{\"1\":{\"171\":2,\"247\":1,\"259\":2,\"690\":1,\"1480\":1,\"1488\":1,\"1489\":5,\"1491\":5,\"1492\":8,\"1496\":3,\"1497\":20,\"1499\":8,\"1500\":12,\"1502\":4,\"1503\":26,\"1508\":1,\"1509\":1,\"1512\":2,\"1514\":1,\"1517\":1,\"1519\":9,\"1521\":19}}],[\"textarea\",{\"1\":{\"348\":4,\"349\":2}}],[\"text=txt\",{\"1\":{\"191\":1}}],[\"text\",{\"1\":{\"155\":2,\"191\":6,\"348\":4,\"349\":1,\"1481\":1}}],[\"tempproperties\",{\"1\":{\"1333\":6}}],[\"temp\",{\"1\":{\"1331\":3}}],[\"templates$\",{\"1\":{\"1079\":3}}],[\"templates\",{\"1\":{\"1074\":3,\"1075\":3,\"1078\":1,\"1079\":1,\"1083\":1,\"1084\":1}}],[\"templates目录中的文件修改\",{\"1\":{\"95\":1}}],[\"tempdataversion\",{\"1\":{\"998\":4}}],[\"temptest\",{\"1\":{\"741\":4}}],[\"tempconvert\",{\"1\":{\"181\":3}}],[\"temporary\",{\"1\":{\"104\":1,\"624\":1}}],[\"testable\",{\"1\":{\"1367\":1}}],[\"testarraylist\",{\"1\":{\"9\":1,\"11\":3}}],[\"testgroup02\",{\"1\":{\"985\":1}}],[\"tester\",{\"1\":{\"272\":1}}],[\"test1\",{\"1\":{\"261\":1}}],[\"tests\",{\"1\":{\"104\":1,\"180\":2}}],[\"testing\",{\"1\":{\"96\":1}}],[\"testcompile\",{\"1\":{\"63\":1}}],[\"testlinkedlist\",{\"1\":{\"9\":1,\"11\":3}}],[\"test\",{\"1\":{\"9\":1,\"60\":1,\"62\":10,\"63\":2,\"64\":1,\"99\":3,\"101\":1,\"102\":1,\"105\":1,\"106\":1,\"180\":3,\"194\":1,\"195\":9,\"248\":7,\"253\":1,\"261\":2,\"348\":2,\"351\":3,\"369\":1,\"674\":1,\"913\":1,\"964\":1,\"1288\":2,\"1427\":1}}],[\"=c0a80109803418b4aac25d18020f0007\",{\"1\":{\"1445\":1}}],[\"=c0a80109803418b4aac25d1801be0001\",{\"1\":{\"1445\":1}}],[\"=c0a80109803418b4aac25d1801e70004\",{\"1\":{\"1445\":1}}],[\"=message\",{\"1\":{\"1445\":3}}],[\"=queueoffsets\",{\"1\":{\"1297\":1}}],[\"=语句加载\",{\"1\":{\"596\":1}}],[\"=语句输出的对象\",{\"1\":{\"596\":1}}],[\"=语句输入\",{\"1\":{\"595\":1}}],[\"=语句\",{\"1\":{\"596\":1}}],[\"=>\",{\"1\":{\"192\":14,\"248\":5,\"331\":5,\"349\":1,\"354\":1,\"369\":1,\"500\":1,\"511\":1,\"512\":1,\"533\":2,\"535\":2,\"546\":2,\"548\":1,\"558\":1,\"568\":1,\"606\":2,\"627\":2}}],[\"=<\",{\"1\":{\"184\":1,\"626\":1}}],[\"=things2\",{\"1\":{\"177\":1}}],[\"=things1\",{\"1\":{\"177\":1}}],[\"=person\",{\"1\":{\"176\":1}}],[\"=是一次模式匹配操作\",{\"1\":{\"173\":1}}],[\"======\",{\"1\":{\"1170\":6,\"1173\":2}}],[\"===\",{\"1\":{\"295\":1,\"325\":1,\"333\":3,\"338\":1,\"339\":1,\"348\":2,\"503\":3,\"504\":2,\"518\":1,\"531\":1,\"547\":1,\"551\":2,\"558\":6}}],[\"==\",{\"1\":{\"125\":7,\"131\":1,\"187\":1,\"295\":1,\"325\":1,\"396\":1,\"503\":1,\"624\":1,\"626\":1,\"737\":6,\"738\":2,\"742\":2,\"762\":1,\"765\":1,\"767\":3,\"769\":2,\"771\":1,\"793\":1,\"794\":3,\"796\":1,\"797\":3,\"822\":1,\"823\":1,\"843\":2,\"844\":1,\"845\":1,\"860\":3,\"861\":2,\"870\":1,\"882\":3,\"893\":1,\"894\":1,\"960\":3,\"971\":5,\"972\":3,\"995\":1,\"996\":1,\"998\":3,\"1000\":4,\"1020\":6,\"1021\":1,\"1048\":2,\"1050\":2,\"1051\":1,\"1052\":1,\"1053\":1,\"1056\":1,\"1122\":1,\"1123\":1,\"1143\":2,\"1170\":5,\"1171\":1,\"1173\":6,\"1174\":9,\"1175\":1,\"1195\":5,\"1198\":6,\"1200\":2,\"1201\":1,\"1222\":2,\"1229\":1,\"1230\":9,\"1266\":5,\"1269\":3,\"1270\":1,\"1273\":1,\"1276\":1,\"1278\":5,\"1279\":2,\"1280\":4,\"1288\":1,\"1297\":2,\"1328\":2,\"1329\":1,\"1331\":6,\"1332\":3,\"1333\":13,\"1368\":4,\"1370\":3,\"1371\":2,\"1372\":5,\"1373\":3,\"1374\":1,\"1427\":1,\"1428\":2,\"1430\":2,\"1431\":2,\"1432\":1,\"1434\":3,\"1435\":3,\"1436\":5,\"1458\":1,\"1459\":3,\"1462\":4,\"1464\":8,\"1468\":16,\"1472\":1,\"1497\":3,\"1499\":2,\"1500\":3,\"1503\":4,\"1516\":1,\"1517\":4,\"1518\":1,\"1519\":13,\"1520\":13,\"1521\":5}}],[\"=\",{\"0\":{\"595\":1,\"596\":1},\"1\":{\"9\":6,\"11\":4,\"22\":2,\"34\":4,\"41\":2,\"48\":6,\"67\":4,\"69\":9,\"70\":8,\"72\":5,\"73\":6,\"89\":2,\"90\":12,\"91\":3,\"92\":8,\"99\":2,\"101\":1,\"102\":1,\"105\":1,\"106\":1,\"112\":2,\"113\":9,\"121\":5,\"122\":4,\"123\":3,\"124\":11,\"125\":9,\"126\":2,\"128\":5,\"129\":2,\"131\":6,\"132\":3,\"133\":9,\"134\":3,\"147\":1,\"153\":1,\"167\":1,\"173\":4,\"176\":4,\"177\":2,\"178\":2,\"180\":2,\"181\":11,\"184\":4,\"186\":4,\"191\":18,\"192\":7,\"229\":2,\"230\":2,\"248\":2,\"253\":31,\"256\":1,\"259\":2,\"272\":1,\"294\":1,\"297\":6,\"298\":12,\"299\":2,\"301\":2,\"302\":2,\"303\":6,\"306\":1,\"309\":6,\"311\":2,\"313\":4,\"314\":1,\"316\":9,\"320\":3,\"323\":2,\"324\":1,\"325\":4,\"329\":2,\"330\":7,\"331\":1,\"332\":5,\"333\":3,\"337\":1,\"338\":1,\"339\":7,\"341\":5,\"342\":8,\"344\":1,\"345\":1,\"348\":6,\"349\":3,\"351\":4,\"352\":2,\"353\":2,\"354\":2,\"361\":4,\"364\":4,\"365\":3,\"369\":4,\"385\":1,\"396\":19,\"419\":1,\"500\":1,\"502\":2,\"503\":7,\"504\":3,\"508\":1,\"509\":4,\"511\":6,\"512\":6,\"514\":4,\"515\":2,\"516\":3,\"517\":2,\"518\":5,\"519\":4,\"520\":3,\"522\":2,\"523\":1,\"524\":4,\"525\":1,\"527\":7,\"528\":2,\"529\":1,\"531\":2,\"533\":4,\"535\":1,\"537\":2,\"538\":1,\"540\":1,\"544\":1,\"545\":3,\"548\":3,\"550\":2,\"551\":5,\"552\":5,\"553\":2,\"554\":2,\"555\":3,\"556\":4,\"558\":1,\"561\":1,\"562\":1,\"564\":1,\"567\":2,\"570\":3,\"573\":2,\"575\":1,\"576\":4,\"577\":1,\"578\":2,\"579\":4,\"580\":2,\"582\":5,\"583\":2,\"584\":4,\"585\":8,\"586\":3,\"587\":1,\"589\":2,\"591\":2,\"595\":3,\"596\":2,\"606\":1,\"624\":2,\"625\":10,\"626\":1,\"627\":1,\"665\":3,\"712\":10,\"714\":6,\"715\":5,\"722\":1,\"737\":12,\"738\":8,\"742\":34,\"762\":9,\"764\":2,\"765\":10,\"767\":13,\"769\":12,\"771\":20,\"793\":18,\"794\":23,\"796\":2,\"797\":35,\"815\":1,\"819\":7,\"820\":3,\"822\":6,\"823\":4,\"824\":2,\"825\":11,\"827\":2,\"835\":1,\"843\":5,\"844\":6,\"845\":28,\"860\":30,\"861\":9,\"870\":18,\"871\":5,\"872\":9,\"880\":2,\"882\":10,\"891\":12,\"893\":1,\"894\":15,\"897\":1,\"904\":3,\"950\":1,\"960\":14,\"961\":11,\"968\":1,\"970\":10,\"971\":24,\"972\":29,\"973\":6,\"984\":6,\"985\":3,\"994\":2,\"995\":14,\"996\":2,\"997\":6,\"998\":27,\"999\":12,\"1000\":9,\"1006\":3,\"1007\":1,\"1017\":16,\"1019\":6,\"1020\":13,\"1021\":25,\"1047\":5,\"1048\":2,\"1050\":25,\"1051\":3,\"1052\":14,\"1053\":35,\"1055\":1,\"1056\":16,\"1075\":14,\"1122\":14,\"1123\":2,\"1142\":3,\"1143\":14,\"1144\":15,\"1145\":10,\"1168\":2,\"1170\":21,\"1171\":9,\"1172\":1,\"1173\":45,\"1174\":63,\"1175\":7,\"1194\":6,\"1195\":30,\"1197\":5,\"1198\":29,\"1200\":8,\"1201\":5,\"1222\":9,\"1224\":15,\"1226\":7,\"1228\":4,\"1229\":7,\"1230\":24,\"1235\":3,\"1241\":1,\"1247\":5,\"1248\":6,\"1255\":1,\"1266\":16,\"1267\":9,\"1269\":25,\"1270\":14,\"1271\":2,\"1273\":11,\"1275\":2,\"1276\":4,\"1277\":14,\"1278\":27,\"1279\":7,\"1280\":8,\"1286\":2,\"1287\":3,\"1288\":5,\"1296\":9,\"1297\":26,\"1299\":5,\"1306\":4,\"1307\":1,\"1308\":2,\"1309\":4,\"1310\":1,\"1323\":1,\"1329\":6,\"1331\":9,\"1332\":10,\"1333\":13,\"1339\":2,\"1367\":2,\"1368\":6,\"1370\":14,\"1371\":28,\"1372\":24,\"1373\":17,\"1374\":14,\"1424\":8,\"1425\":10,\"1427\":30,\"1428\":12,\"1430\":3,\"1431\":10,\"1432\":15,\"1434\":8,\"1435\":28,\"1436\":33,\"1442\":6,\"1443\":8,\"1444\":1,\"1459\":17,\"1460\":9,\"1462\":12,\"1463\":2,\"1464\":10,\"1467\":4,\"1468\":46,\"1469\":5,\"1471\":11,\"1472\":21,\"1496\":3,\"1497\":34,\"1499\":12,\"1500\":3,\"1502\":4,\"1503\":2,\"1514\":4,\"1516\":18,\"1517\":11,\"1518\":5,\"1519\":61,\"1520\":30,\"1521\":22,\"1523\":1}}],[\"秒为每个队列执行一次分发\",{\"1\":{\"1427\":1}}],[\"秒为你提供大量随机的次要属性\",{\"1\":{\"484\":1}}],[\"秒后重新消费发回失败的消息\",{\"1\":{\"1195\":1}}],[\"秒向\",{\"1\":{\"1030\":2}}],[\"秒就没货了\",{\"1\":{\"927\":1}}],[\"秒就开始预铺\",{\"1\":{\"411\":2}}],[\"秒的消息需要先被投递出去\",{\"1\":{\"925\":1}}],[\"秒的消息\",{\"1\":{\"925\":1}}],[\"秒的时候刷新生命绽放\",{\"1\":{\"411\":1}}],[\"秒之后执行\",{\"1\":{\"845\":1}}],[\"秒高额\",{\"1\":{\"446\":1}}],[\"秒一次\",{\"1\":{\"431\":1,\"433\":1}}],[\"秒都会自动获得一个连击点数\",{\"1\":{\"417\":1}}],[\"秒内就可以补\",{\"1\":{\"419\":1}}],[\"秒内提高\",{\"1\":{\"409\":1}}],[\"秒内\",{\"1\":{\"406\":1}}],[\"秒对周围的目标释放月火术\",{\"1\":{\"401\":1}}],[\"秒级任务在任务正常运行状态只会在日志表产生一条运行记录\",{\"1\":{\"374\":1}}],[\"秒次\",{\"1\":{\"9\":1}}],[\"秒\",{\"1\":{\"9\":1,\"11\":2,\"403\":1,\"405\":1,\"419\":1,\"425\":1,\"446\":1,\"1251\":1}}],[\"次事务半消息\",{\"1\":{\"1468\":1}}],[\"次同样的\",{\"1\":{\"1322\":1}}],[\"次重平衡策略\",{\"1\":{\"1255\":1}}],[\"次后\",{\"1\":{\"1241\":1}}],[\"次均失败\",{\"1\":{\"1100\":1}}],[\"次时间间隔为延迟消息配置的每个延迟等级的时间\",{\"1\":{\"1100\":1}}],[\"次则打印日志并跳过该消息\",{\"1\":{\"861\":1}}],[\"次以上\",{\"1\":{\"860\":1}}],[\"次失败后\",{\"1\":{\"854\":1}}],[\"次查询\",{\"1\":{\"687\":1}}],[\"次要属性收益递减\",{\"0\":{\"421\":1}}],[\"次愈合后的下一个星火变成瞬发并且造成\",{\"1\":{\"401\":1}}],[\"次数组复制\",{\"1\":{\"741\":1}}],[\"次数\",{\"1\":{\"155\":1,\"1385\":1}}],[\"次\",{\"1\":{\"9\":2,\"11\":2,\"399\":1,\"401\":1,\"446\":1,\"687\":1,\"725\":1,\"741\":1,\"906\":1,\"1032\":1,\"1040\":3,\"1100\":2,\"1233\":1,\"1241\":1,\"1255\":1,\"1267\":1,\"1322\":1,\"1323\":3,\"1414\":1,\"1434\":1,\"1467\":1,\"1468\":1}}],[\"5~6\",{\"1\":{\"1507\":1}}],[\"5~8byte\",{\"1\":{\"1418\":1,\"1435\":1}}],[\"572m\",{\"1\":{\"1383\":1}}],[\"57\",{\"0\":{\"1376\":1},\"1\":{\"1079\":1,\"1380\":1,\"1437\":1,\"1538\":1}}],[\"58\",{\"1\":{\"1079\":7}}],[\"58e1e7a5e556\",{\"1\":{\"1072\":1}}],[\"5s\",{\"1\":{\"805\":1,\"806\":3,\"815\":1,\"833\":1,\"919\":1,\"925\":1,\"990\":1,\"996\":1,\"1103\":2,\"1182\":1,\"1183\":2,\"1188\":1,\"1191\":1,\"1194\":2,\"1241\":1,\"1275\":1}}],[\"5步\",{\"1\":{\"729\":1}}],[\"5个内部队列\",{\"1\":{\"690\":1}}],[\"52\",{\"1\":{\"1445\":1}}],[\"5290\",{\"1\":{\"1445\":3}}],[\"529\",{\"1\":{\"643\":1}}],[\"521\",{\"1\":{\"643\":1}}],[\"524251838\",{\"1\":{\"398\":1}}],[\"5fe5x\",{\"1\":{\"443\":1}}],[\"54\",{\"1\":{\"1073\":1}}],[\"54kqgdltz4z5mnzmubiergpf6jyz6fzstg\",{\"1\":{\"436\":1}}],[\"54600\",{\"1\":{\"421\":2}}],[\"5440\",{\"1\":{\"421\":1}}],[\"544\",{\"1\":{\"421\":1}}],[\"54acff7d\",{\"1\":{\"267\":1}}],[\"5+\",{\"1\":{\"412\":1,\"417\":1}}],[\"5ms\",{\"1\":{\"1262\":2}}],[\"5m\",{\"1\":{\"399\":1,\"833\":1,\"919\":1,\"925\":1,\"1241\":1}}],[\"512\",{\"1\":{\"390\":2,\"1436\":1}}],[\"59\",{\"1\":{\"301\":1}}],[\"5672\",{\"1\":{\"712\":1}}],[\"56000000000000049738\",{\"1\":{\"230\":1}}],[\"56e\",{\"1\":{\"215\":1}}],[\"56259\",{\"1\":{\"11\":1}}],[\"557667000\",{\"1\":{\"1420\":1}}],[\"55hw3rab\",{\"1\":{\"423\":1}}],[\"55\",{\"1\":{\"185\":1,\"517\":1,\"1445\":1}}],[\"551\",{\"1\":{\"11\":1}}],[\"5>\",{\"1\":{\"174\":1,\"180\":1,\"181\":1,\"185\":1,\"217\":1,\"255\":1}}],[\"50ms\",{\"1\":{\"1159\":1}}],[\"500w\",{\"1\":{\"1435\":2}}],[\"5000\",{\"1\":{\"1197\":1}}],[\"500万个\",{\"1\":{\"787\":2}}],[\"500ms\",{\"1\":{\"735\":1}}],[\"500\",{\"1\":{\"352\":1,\"353\":1,\"1374\":1,\"1519\":1}}],[\"50\",{\"1\":{\"11\":1,\"180\":1,\"421\":1,\"454\":1,\"475\":1,\"618\":1,\"701\":2}}],[\"530\",{\"1\":{\"11\":1}}],[\"5\",{\"0\":{\"42\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"123\":1,\"124\":2,\"125\":1,\"126\":1,\"299\":1,\"315\":1,\"328\":1,\"329\":1,\"330\":1,\"346\":1,\"347\":2,\"348\":2,\"349\":2,\"350\":2,\"351\":1,\"352\":1,\"353\":1,\"354\":1,\"414\":1,\"415\":1,\"416\":1,\"417\":1,\"418\":1,\"419\":1,\"420\":1,\"421\":1,\"449\":1,\"450\":1,\"454\":1,\"499\":1,\"514\":1,\"521\":1,\"522\":1,\"523\":1,\"524\":1,\"525\":1,\"537\":1,\"554\":1,\"568\":1,\"575\":1,\"576\":1,\"586\":1,\"597\":1,\"598\":1,\"599\":1,\"600\":1,\"601\":1,\"602\":2,\"603\":1,\"628\":1,\"675\":1,\"676\":1,\"677\":1,\"678\":1,\"727\":1,\"753\":1,\"759\":1,\"772\":1,\"773\":2,\"846\":1,\"847\":1,\"848\":1,\"882\":1,\"955\":1,\"956\":1,\"957\":1,\"973\":1,\"1009\":1,\"1016\":1,\"1017\":1,\"1018\":1,\"1019\":1,\"1020\":1,\"1021\":1,\"1043\":1,\"1102\":1,\"1119\":1,\"1172\":1,\"1176\":1,\"1243\":1,\"1279\":1,\"1325\":1,\"1335\":1,\"1374\":1,\"1376\":1,\"1389\":1,\"1390\":1,\"1391\":1,\"1411\":1,\"1412\":1,\"1413\":1,\"1416\":1,\"1417\":1,\"1418\":1,\"1422\":1,\"1423\":1,\"1424\":1,\"1425\":1,\"1426\":1,\"1427\":1,\"1428\":1,\"1429\":1,\"1430\":1,\"1431\":1,\"1432\":1,\"1433\":1,\"1434\":1,\"1435\":1,\"1436\":1,\"1445\":1,\"1455\":1,\"1456\":1,\"1457\":1,\"1461\":1,\"1465\":1,\"1466\":1,\"1470\":1,\"1490\":1,\"1501\":1,\"1502\":1,\"1503\":1,\"1521\":1,\"1537\":1},\"1\":{\"9\":4,\"11\":10,\"98\":1,\"106\":2,\"174\":3,\"176\":1,\"180\":1,\"181\":5,\"182\":1,\"184\":2,\"192\":1,\"193\":1,\"194\":2,\"195\":2,\"253\":5,\"255\":1,\"294\":1,\"298\":1,\"309\":2,\"319\":4,\"323\":1,\"324\":1,\"325\":2,\"329\":1,\"332\":1,\"400\":1,\"401\":2,\"411\":3,\"412\":1,\"419\":2,\"421\":1,\"446\":1,\"455\":1,\"519\":1,\"614\":2,\"617\":2,\"628\":2,\"643\":3,\"662\":1,\"688\":1,\"695\":1,\"700\":3,\"701\":1,\"703\":1,\"737\":2,\"773\":1,\"824\":2,\"835\":1,\"866\":1,\"870\":1,\"896\":1,\"902\":1,\"906\":2,\"921\":1,\"944\":1,\"949\":1,\"961\":1,\"1021\":1,\"1053\":1,\"1090\":2,\"1095\":2,\"1105\":1,\"1131\":1,\"1176\":1,\"1195\":1,\"1200\":2,\"1234\":1,\"1245\":1,\"1249\":2,\"1252\":1,\"1257\":1,\"1258\":2,\"1269\":2,\"1281\":1,\"1294\":2,\"1295\":1,\"1307\":2,\"1310\":1,\"1325\":1,\"1337\":1,\"1338\":1,\"1339\":1,\"1378\":1,\"1380\":1,\"1420\":1,\"1427\":1,\"1437\":1,\"1439\":1,\"1441\":1,\"1443\":1,\"1475\":2,\"1506\":2,\"1538\":4}}],[\"类字段设计\",{\"0\":{\"1514\":1}}],[\"类状态流转图\",{\"1\":{\"1510\":1}}],[\"类有\",{\"1\":{\"1510\":1}}],[\"类处理\",{\"1\":{\"1510\":1}}],[\"类即可\",{\"1\":{\"1382\":1}}],[\"类过滤模式\",{\"1\":{\"1333\":1}}],[\"类过滤\",{\"1\":{\"1303\":1,\"1318\":1}}],[\"类保存一些重平衡需要的基本信息\",{\"1\":{\"1133\":1}}],[\"类进行回调\",{\"1\":{\"1102\":1}}],[\"类设计\",{\"0\":{\"1064\":1,\"1482\":1}}],[\"类继承普通消息类\",{\"1\":{\"1044\":1}}],[\"类是\",{\"1\":{\"960\":1}}],[\"类中实现了整个重平衡流程\",{\"1\":{\"1132\":1}}],[\"类中\",{\"1\":{\"856\":1,\"1294\":1}}],[\"类装饰器\",{\"0\":{\"607\":1}}],[\"类只在内部可见\",{\"1\":{\"591\":1}}],[\"类使用\",{\"1\":{\"570\":1}}],[\"类的初始化和启动方法\",{\"1\":{\"960\":1}}],[\"类的方法经常用到this关键字\",{\"1\":{\"580\":1}}],[\"类的内部可以使用static关键字\",{\"1\":{\"577\":1}}],[\"类的内部成员的外部可访问性\",{\"1\":{\"575\":1}}],[\"类的属性和方法默认都是外部可访问的\",{\"1\":{\"575\":1}}],[\"类的自身类型\",{\"0\":{\"574\":1}}],[\"类的\",{\"0\":{\"569\":1}}],[\"类作为\",{\"1\":{\"132\":1}}],[\"类实现\",{\"0\":{\"132\":1}}],[\"类加载器\",{\"1\":{\"85\":1}}],[\"类型断言有两种语法\",{\"1\":{\"589\":1}}],[\"类型断言\",{\"0\":{\"588\":1},\"1\":{\"589\":1}}],[\"类型写法\",{\"1\":{\"554\":1}}],[\"类型表示函数\",{\"1\":{\"534\":1}}],[\"类型推断就不会更新\",{\"1\":{\"523\":1}}],[\"类型推断的自动更新只发生初始值为空数组的情况\",{\"1\":{\"523\":1}}],[\"类型number就是类型number|string的子类型\",{\"1\":{\"520\":1}}],[\"类型的过滤\",{\"1\":{\"1173\":1}}],[\"类型的请求后\",{\"1\":{\"953\":1}}],[\"类型的请求用于\",{\"1\":{\"944\":1}}],[\"类型的交换器\",{\"1\":{\"711\":1}}],[\"类型的\",{\"1\":{\"700\":1,\"1441\":1}}],[\"类型的兼容\",{\"0\":{\"520\":1}}],[\"类型的注解会被加载进jvm\",{\"1\":{\"44\":1}}],[\"类型的注解仅保存在class文件中\",{\"1\":{\"44\":1}}],[\"类型的注解在编译期就被丢掉了\",{\"1\":{\"44\":1}}],[\"类型可以声明在代码块\",{\"1\":{\"519\":1}}],[\"类型缩小\",{\"1\":{\"515\":1}}],[\"类型与\",{\"0\":{\"510\":1}}],[\"类型变量的方法和属性\",{\"1\":{\"503\":1}}],[\"类型污染问题\",{\"1\":{\"503\":1}}],[\"类型\",{\"0\":{\"221\":1,\"501\":3,\"502\":1,\"503\":1,\"504\":1,\"510\":1,\"511\":1,\"512\":1,\"530\":1,\"534\":1,\"541\":1,\"542\":1,\"572\":1,\"581\":1},\"1\":{\"123\":1,\"504\":1,\"518\":1,\"589\":1,\"997\":1,\"1314\":1}}],[\"类型和数量\",{\"1\":{\"76\":1}}],[\"类型系统\",{\"0\":{\"46\":1,\"505\":1}}],[\"类或接口\",{\"1\":{\"43\":1}}],[\"类似本地\",{\"1\":{\"1412\":1}}],[\"类似本地存储的\",{\"1\":{\"1402\":4}}],[\"类似主存索引文件格式\",{\"1\":{\"1394\":1,\"1412\":1}}],[\"类似一个\",{\"1\":{\"1386\":1}}],[\"类似如下的结构\",{\"1\":{\"1346\":1}}],[\"类似的方法是call\",{\"1\":{\"319\":1}}],[\"类似\",{\"1\":{\"9\":2,\"298\":1,\"327\":1,\"941\":1,\"1136\":1,\"1386\":1}}],[\"类变量的作用域\",{\"1\":{\"9\":1}}],[\"类\",{\"0\":{\"36\":1,\"565\":1,\"726\":1},\"1\":{\"9\":1,\"742\":1,\"1420\":1,\"1481\":1}}],[\"<li>索引项经过排序\",{\"1\":{\"1435\":1}}],[\"<li>hash\",{\"1\":{\"1435\":1}}],[\"<li>header\",{\"1\":{\"1435\":1}}],[\"<leader>f\",{\"1\":{\"167\":1}}],[\"<leader>j\",{\"1\":{\"167\":1}}],[\"<ul>\",{\"1\":{\"1435\":1}}],[\"<>\",{\"1\":{\"1308\":1}}],[\"<init>\",{\"1\":{\"1079\":2}}],[\"<1\",{\"1\":{\"971\":1}}],[\"<h>\",{\"1\":{\"742\":1}}],[\"<f>\",{\"1\":{\"742\":1}}],[\"<file>\",{\"1\":{\"171\":1}}],[\"<e>\",{\"1\":{\"742\":1}}],[\"<execution>\",{\"1\":{\"64\":1}}],[\"<executions>\",{\"1\":{\"64\":1}}],[\"<a>\",{\"1\":{\"742\":1}}],[\"<artifactid>amqp\",{\"1\":{\"712\":1}}],[\"<artifactid>spring\",{\"1\":{\"95\":1}}],[\"<artifactid>maven\",{\"1\":{\"64\":1}}],[\"<artifactid>jmh\",{\"1\":{\"8\":2}}],[\"<b>\",{\"1\":{\"742\":1}}],[\"<br>\",{\"1\":{\"738\":1}}],[\"<build>\",{\"1\":{\"64\":1}}],[\"<类型>值\",{\"1\":{\"589\":1}}],[\"<<=\",{\"1\":{\"396\":1}}],[\"<<<\",{\"1\":{\"70\":1}}],[\"<0\",{\"1\":{\"230\":2,\"971\":1}}],[\"<type>value\",{\"1\":{\"589\":1}}],[\"<t>foo\",{\"1\":{\"589\":1}}],[\"<t>\",{\"1\":{\"171\":1}}],[\"<transformer\",{\"1\":{\"64\":1}}],[\"<transformers>\",{\"1\":{\"64\":1}}],[\"<d>\",{\"1\":{\"742\":1}}],[\"<dir>\",{\"1\":{\"171\":1}}],[\"<dependency>\",{\"1\":{\"8\":2,\"95\":1,\"712\":1}}],[\"<x\",{\"1\":{\"171\":1}}],[\"<mod>\",{\"1\":{\"171\":2}}],[\"<mainclass>com\",{\"1\":{\"64\":1}}],[\"<n>\",{\"1\":{\"171\":2}}],[\"<c>\",{\"1\":{\"742\":1}}],[\"<ctrl\",{\"1\":{\"163\":1}}],[\"<command>\",{\"1\":{\"155\":1}}],[\"<configuration>\",{\"1\":{\"64\":1}}],[\"<=\",{\"1\":{\"125\":1,\"184\":1,\"765\":1,\"797\":7,\"825\":1,\"845\":1,\"1194\":1,\"1198\":1,\"1267\":3,\"1278\":2,\"1279\":1,\"1308\":2,\"1428\":1,\"1430\":1,\"1434\":1,\"1436\":5,\"1468\":2,\"1519\":1,\"1520\":1}}],[\"<g>\",{\"1\":{\"742\":1}}],[\"<groupid>com\",{\"1\":{\"712\":1}}],[\"<groupid>org\",{\"1\":{\"8\":2,\"64\":1,\"95\":1}}],[\"<goal>shade<\",{\"1\":{\"64\":1}}],[\"<goals>\",{\"1\":{\"64\":1}}],[\"<version>5\",{\"1\":{\"712\":1}}],[\"<version>3\",{\"1\":{\"64\":1}}],[\"<version>1\",{\"1\":{\"8\":2}}],[\"<plug>\",{\"1\":{\"167\":3}}],[\"<plugin>\",{\"1\":{\"64\":1}}],[\"<plugins>\",{\"1\":{\"64\":1}}],[\"<p>\",{\"1\":{\"122\":2,\"1435\":1}}],[\"<phase>package<\",{\"1\":{\"64\":1}}],[\"<project>\",{\"1\":{\"64\":1}}],[\"<当前目录>\",{\"1\":{\"23\":1}}],[\"<\",{\"0\":{\"184\":1},\"1\":{\"8\":2,\"64\":10,\"95\":1,\"131\":1,\"155\":1,\"161\":2,\"184\":8,\"188\":1,\"194\":1,\"195\":1,\"196\":1,\"253\":11,\"332\":1,\"351\":1,\"396\":3,\"625\":1,\"627\":1,\"712\":3,\"714\":1,\"715\":1,\"742\":2,\"762\":1,\"765\":2,\"767\":2,\"769\":1,\"771\":2,\"794\":3,\"797\":4,\"845\":2,\"860\":2,\"870\":2,\"872\":3,\"882\":1,\"984\":1,\"998\":2,\"999\":2,\"1020\":1,\"1021\":1,\"1050\":2,\"1052\":4,\"1053\":2,\"1056\":1,\"1170\":1,\"1171\":1,\"1173\":4,\"1174\":4,\"1175\":2,\"1194\":4,\"1195\":2,\"1198\":1,\"1201\":1,\"1228\":1,\"1269\":5,\"1275\":2,\"1276\":1,\"1277\":4,\"1280\":2,\"1296\":1,\"1297\":3,\"1306\":1,\"1308\":1,\"1309\":1,\"1331\":2,\"1370\":2,\"1371\":2,\"1373\":1,\"1427\":5,\"1430\":1,\"1431\":1,\"1432\":3,\"1434\":2,\"1435\":3,\"1436\":4,\"1443\":1,\"1468\":4,\"1497\":1,\"1500\":2,\"1503\":4,\"1519\":6,\"1520\":2}}],[\"1f329fef00000000001073741775\",{\"1\":{\"1383\":4}}],[\"1分钟\",{\"1\":{\"1206\":1}}],[\"1分钟内未上报会被移除出可用worker列表\",{\"1\":{\"375\":1}}],[\"1条\",{\"1\":{\"1194\":1}}],[\"1l\",{\"1\":{\"1144\":1,\"1170\":1,\"1224\":1,\"1228\":1,\"1431\":2}}],[\"1ae8a853012b\",{\"1\":{\"1079\":2}}],[\"1w\",{\"1\":{\"927\":1}}],[\"1g\",{\"1\":{\"866\":1,\"876\":1,\"881\":1,\"882\":1,\"1383\":1}}],[\"1g0wkgawbxs0\",{\"1\":{\"469\":1}}],[\"1h\",{\"1\":{\"833\":1,\"919\":1,\"925\":1,\"1241\":1}}],[\"1ms\",{\"1\":{\"1332\":1,\"1521\":1}}],[\"1mb\",{\"1\":{\"1299\":1}}],[\"1m\",{\"1\":{\"833\":1,\"919\":1,\"925\":1,\"1241\":1,\"1299\":1}}],[\"1s检查一次是否有新消息\",{\"1\":{\"1173\":1}}],[\"1s~2s的延迟误差\",{\"1\":{\"922\":1}}],[\"1s再次执行投递任务\",{\"1\":{\"860\":1}}],[\"1s后重新执行该检查任务\",{\"1\":{\"845\":1}}],[\"1s\",{\"1\":{\"752\":1,\"758\":1,\"769\":1,\"805\":1,\"806\":1,\"815\":1,\"833\":1,\"841\":1,\"845\":1,\"915\":1,\"919\":1,\"922\":5,\"924\":2,\"925\":1,\"927\":2,\"928\":1,\"931\":3,\"932\":5,\"1215\":1,\"1225\":2,\"1241\":2,\"1253\":1,\"1259\":1,\"1358\":1,\"1367\":1,\"1519\":1,\"1520\":1}}],[\"1~9\",{\"1\":{\"711\":1}}],[\"1被调用时\",{\"1\":{\"627\":1}}],[\"1将负责发送在credit\",{\"1\":{\"627\":1}}],[\"1会更新credit\",{\"1\":{\"627\":1}}],[\"1和put\",{\"1\":{\"624\":1}}],[\"1方法来处理新增信用值\",{\"1\":{\"626\":1}}],[\"1方法被调用时\",{\"1\":{\"624\":1}}],[\"1方法\",{\"1\":{\"624\":2,\"625\":1}}],[\"1戒指\",{\"1\":{\"480\":1}}],[\"1v1suxnmm0r0ik\",{\"1\":{\"455\":1}}],[\"1yerez0ayuhyq2ynozr\",{\"1\":{\"443\":1}}],[\"1rzuouniqy4ruascsfttqs5l0vcrktvgqt8wk361sybym\",{\"1\":{\"443\":1}}],[\"1到n的所有c值\",{\"1\":{\"184\":1}}],[\"1到n的所有b值\",{\"1\":{\"184\":1}}],[\"19\",{\"1\":{\"1281\":1}}],[\"195\",{\"1\":{\"1079\":1}}],[\"192\",{\"1\":{\"983\":6,\"1240\":1}}],[\"19800\",{\"1\":{\"421\":4}}],[\"1992\",{\"1\":{\"285\":1}}],[\"19>\",{\"1\":{\"178\":1,\"181\":1}}],[\"19126\",{\"1\":{\"11\":3}}],[\"16次\",{\"1\":{\"1233\":1}}],[\"1623305799667\",{\"1\":{\"1008\":1}}],[\"168\",{\"1\":{\"983\":6,\"1240\":1}}],[\"1651564899813\",{\"1\":{\"967\":1}}],[\"1651564857610\",{\"1\":{\"967\":1}}],[\"16000\",{\"1\":{\"1174\":1}}],[\"160\",{\"1\":{\"390\":3}}],[\"1648606091635\",{\"1\":{\"265\":1}}],[\"16\",{\"1\":{\"182\":1,\"215\":1,\"266\":1,\"323\":1,\"390\":1,\"737\":2,\"738\":1,\"741\":1,\"906\":1,\"964\":2,\"1008\":1,\"1072\":1,\"1100\":5,\"1233\":2,\"1241\":2,\"1371\":1,\"1382\":1}}],[\"16>\",{\"1\":{\"178\":1,\"181\":1}}],[\"169084\",{\"1\":{\"11\":1}}],[\"1>\",{\"1\":{\"172\":1,\"173\":1,\"174\":1,\"178\":1,\"180\":1,\"181\":1,\"184\":1,\"217\":1,\"224\":1,\"248\":1,\"252\":1}}],[\"188mb\",{\"1\":{\"1072\":1}}],[\"1846725\",{\"1\":{\"274\":1}}],[\"1823\",{\"1\":{\"268\":1}}],[\"18>\",{\"1\":{\"178\":1,\"181\":1}}],[\"18\",{\"0\":{\"74\":1},\"1\":{\"836\":1,\"852\":1,\"925\":5,\"964\":2,\"1080\":3,\"1338\":1,\"1341\":1,\"1342\":1}}],[\"1<\",{\"1\":{\"64\":1}}],[\"1713719372725\",{\"1\":{\"1420\":1}}],[\"1713719372709\",{\"1\":{\"1420\":2}}],[\"1713719498827\",{\"1\":{\"1420\":1}}],[\"1713719498817\",{\"1\":{\"1420\":1}}],[\"1713719498811\",{\"1\":{\"1420\":1}}],[\"1713719488008\",{\"1\":{\"1420\":1}}],[\"1713719488780\",{\"1\":{\"1420\":1}}],[\"172\",{\"1\":{\"1080\":3}}],[\"17\",{\"0\":{\"604\":1,\"605\":1,\"606\":1,\"607\":1},\"1\":{\"737\":2}}],[\"1700\",{\"1\":{\"421\":1}}],[\"170\",{\"1\":{\"421\":1}}],[\"17>\",{\"1\":{\"178\":1,\"181\":1}}],[\"17的jdk编译\",{\"1\":{\"25\":1}}],[\"17编译一个java程序\",{\"1\":{\"25\":1}}],[\"17对应的class文件版本是61\",{\"1\":{\"25\":1}}],[\"177057\",{\"1\":{\"11\":2}}],[\"116\",{\"1\":{\"1445\":3}}],[\"111\",{\"1\":{\"1445\":6}}],[\"119\",{\"1\":{\"1079\":1}}],[\"11w\",{\"1\":{\"910\":1}}],[\"118\",{\"1\":{\"741\":1}}],[\"11c\",{\"1\":{\"399\":4}}],[\"11c了\",{\"1\":{\"399\":1}}],[\"1156083311884992513l\",{\"1\":{\"266\":1}}],[\"115\",{\"1\":{\"178\":5}}],[\"1120\",{\"1\":{\"902\":1}}],[\"112\",{\"1\":{\"178\":4}}],[\"114\",{\"1\":{\"178\":8}}],[\"114555\",{\"1\":{\"11\":2}}],[\"117\",{\"1\":{\"178\":4}}],[\"11>\",{\"1\":{\"177\":1,\"181\":1,\"192\":1}}],[\"11兼容版本\",{\"1\":{\"25\":1}}],[\"11\",{\"0\":{\"488\":1,\"489\":1,\"490\":1,\"520\":1,\"545\":1,\"565\":1,\"566\":1,\"567\":1,\"568\":1,\"569\":1,\"570\":1,\"571\":1,\"572\":1,\"573\":1,\"574\":1,\"575\":1,\"576\":1,\"577\":1,\"578\":1,\"579\":1,\"580\":1},\"1\":{\"25\":3,\"106\":2,\"398\":1,\"737\":2,\"1079\":7}}],[\"11对应的class文件版本是55\",{\"1\":{\"25\":1}}],[\"138\",{\"1\":{\"1079\":1}}],[\"131ms\",{\"1\":{\"1008\":1}}],[\"1337\",{\"1\":{\"518\":1}}],[\"132000\",{\"1\":{\"421\":1}}],[\"13c\",{\"1\":{\"399\":1,\"401\":1,\"412\":1,\"422\":2,\"476\":1}}],[\"13579\",{\"1\":{\"324\":1}}],[\"13w\",{\"1\":{\"248\":1}}],[\"13>\",{\"1\":{\"177\":1,\"181\":1,\"192\":1}}],[\"13\",{\"0\":{\"492\":1,\"547\":1,\"581\":1,\"582\":1,\"583\":1,\"584\":1,\"585\":1,\"586\":1,\"587\":1,\"739\":1},\"1\":{\"11\":1,\"297\":2,\"368\":1,\"399\":3,\"403\":2,\"712\":1,\"737\":2,\"1080\":1}}],[\"13048\",{\"1\":{\"11\":1}}],[\"1450880018677794\",{\"1\":{\"1299\":1}}],[\"1455\",{\"1\":{\"1297\":1}}],[\"1497\",{\"1\":{\"1074\":1}}],[\"149509\",{\"1\":{\"11\":1}}],[\"1464\",{\"1\":{\"741\":1}}],[\"1482158310125\",{\"1\":{\"742\":1,\"890\":1}}],[\"148404\",{\"1\":{\"643\":1}}],[\"148778\",{\"1\":{\"11\":3}}],[\"140000\",{\"1\":{\"421\":2}}],[\"1400\",{\"1\":{\"421\":1}}],[\"14c\",{\"1\":{\"403\":1}}],[\"14159\",{\"1\":{\"215\":1}}],[\"141579\",{\"1\":{\"11\":1}}],[\"14>\",{\"1\":{\"177\":1}}],[\"14\",{\"0\":{\"59\":1,\"548\":1,\"588\":1,\"589\":1},\"1\":{\"172\":1,\"230\":1,\"272\":1,\"294\":1,\"331\":1,\"338\":4,\"737\":2,\"886\":1,\"906\":1,\"1008\":1,\"1079\":3,\"1080\":1}}],[\"144\",{\"1\":{\"11\":1,\"180\":1}}],[\"147695\",{\"1\":{\"11\":1}}],[\"15次\",{\"1\":{\"1453\":1,\"1468\":1}}],[\"1500\",{\"1\":{\"1275\":1,\"1276\":2}}],[\"15000\",{\"1\":{\"1170\":1,\"1382\":1}}],[\"1590\",{\"1\":{\"741\":1}}],[\"153046\",{\"1\":{\"645\":1}}],[\"15300\",{\"1\":{\"421\":2}}],[\"156000\",{\"1\":{\"421\":1}}],[\"15s\",{\"1\":{\"374\":1,\"1382\":1,\"1406\":1}}],[\"15>\",{\"1\":{\"177\":1,\"181\":1}}],[\"15\",{\"0\":{\"66\":1,\"590\":1,\"591\":1,\"592\":1,\"593\":1,\"594\":1,\"595\":1,\"596\":1,\"597\":1,\"598\":1,\"599\":1,\"600\":1,\"601\":1,\"602\":1,\"603\":1,\"739\":1,\"742\":1},\"1\":{\"181\":1,\"253\":1,\"325\":2,\"329\":1,\"419\":2,\"737\":2,\"922\":1,\"1074\":13,\"1467\":1,\"1468\":1}}],[\"152379\",{\"1\":{\"11\":1}}],[\"155\",{\"1\":{\"11\":1}}],[\"1279869501571105\",{\"1\":{\"1299\":1}}],[\"127\",{\"1\":{\"965\":1,\"967\":1,\"968\":2,\"984\":1,\"985\":1,\"1008\":1,\"1445\":6}}],[\"127n\",{\"1\":{\"518\":1}}],[\"127890\",{\"1\":{\"11\":1}}],[\"120s\",{\"1\":{\"945\":1,\"954\":2}}],[\"120\",{\"1\":{\"401\":1}}],[\"12c\",{\"1\":{\"399\":4,\"403\":1,\"428\":1,\"433\":1}}],[\"128k\",{\"1\":{\"1021\":1}}],[\"128\",{\"1\":{\"390\":1,\"904\":3,\"984\":1}}],[\"12873639\",{\"1\":{\"381\":1}}],[\"1267\",{\"1\":{\"192\":1}}],[\"126507\",{\"1\":{\"11\":1}}],[\"12>\",{\"1\":{\"177\":1,\"181\":1,\"192\":1}}],[\"12345678\",{\"1\":{\"316\":3,\"983\":2,\"984\":1,\"985\":1}}],[\"12345l\",{\"1\":{\"266\":1}}],[\"123\",{\"1\":{\"173\":2,\"256\":1,\"294\":1,\"333\":2,\"338\":2,\"502\":1,\"503\":1,\"511\":1,\"512\":1,\"515\":1,\"523\":1,\"596\":1,\"1287\":1,\"1288\":1}}],[\"12\",{\"0\":{\"491\":1,\"546\":1,\"736\":1},\"1\":{\"106\":2,\"180\":2,\"185\":2,\"230\":1,\"253\":1,\"256\":1,\"297\":1,\"399\":2,\"412\":1,\"737\":2,\"1080\":1}}],[\"1252599548343744\",{\"1\":{\"16\":1}}],[\"10~13\",{\"1\":{\"1507\":1}}],[\"107\",{\"1\":{\"1445\":3}}],[\"108\",{\"1\":{\"1445\":6}}],[\"10880\",{\"1\":{\"421\":2}}],[\"1048576\",{\"1\":{\"1299\":1}}],[\"10932\",{\"1\":{\"1075\":5}}],[\"10931\",{\"1\":{\"1075\":5}}],[\"10909\",{\"1\":{\"1075\":4,\"1079\":3}}],[\"10929\",{\"1\":{\"1075\":5}}],[\"10912\",{\"1\":{\"967\":1,\"1075\":6,\"1079\":3}}],[\"10911\",{\"1\":{\"965\":1,\"967\":1,\"968\":2,\"1075\":5,\"1079\":3,\"1445\":3}}],[\"103\",{\"1\":{\"983\":1}}],[\"10w\",{\"1\":{\"913\":1,\"916\":1}}],[\"10ms\",{\"1\":{\"1230\":1,\"1483\":1}}],[\"10min\",{\"1\":{\"961\":1}}],[\"10m\",{\"1\":{\"833\":1,\"919\":1,\"925\":1,\"1241\":1}}],[\"10s\",{\"1\":{\"833\":1,\"864\":2,\"866\":1,\"867\":1,\"868\":1,\"869\":1,\"870\":1,\"919\":1,\"925\":1,\"945\":1,\"947\":2,\"954\":1,\"961\":3,\"1183\":1,\"1191\":1,\"1201\":1,\"1233\":1,\"1241\":2,\"1339\":1,\"1394\":1,\"1417\":1,\"1435\":1}}],[\"10c\",{\"1\":{\"399\":2}}],[\"10+\",{\"1\":{\"399\":2}}],[\"10200\",{\"1\":{\"421\":1}}],[\"1020\",{\"1\":{\"421\":1}}],[\"1022910821149312\",{\"1\":{\"291\":1}}],[\"1024m\",{\"1\":{\"1383\":8}}],[\"1024\",{\"1\":{\"72\":1,\"73\":1,\"124\":2,\"491\":1,\"815\":1,\"964\":2,\"1170\":2,\"1222\":1,\"1299\":2,\"1382\":2,\"1436\":1}}],[\"10倍提升本地研发效率\",{\"0\":{\"268\":1}}],[\"105\",{\"1\":{\"178\":4,\"643\":1}}],[\"10>\",{\"1\":{\"177\":1,\"181\":1,\"182\":1}}],[\"101\",{\"1\":{\"67\":2,\"178\":4,\"368\":1,\"1445\":6}}],[\"100m\",{\"1\":{\"1383\":4}}],[\"100s\",{\"1\":{\"1342\":1}}],[\"100l\",{\"1\":{\"1278\":1}}],[\"100\",{\"1\":{\"90\":3,\"181\":2,\"182\":1,\"253\":1,\"421\":2,\"552\":1,\"579\":2,\"861\":1,\"1021\":1,\"1174\":1,\"1230\":1,\"1269\":1,\"1278\":1,\"1308\":4,\"1373\":1,\"1443\":1,\"1520\":2,\"1521\":1}}],[\"1000l\",{\"1\":{\"797\":1,\"1434\":1}}],[\"10000ms\",{\"1\":{\"1339\":2}}],[\"10000\",{\"1\":{\"741\":1,\"844\":1,\"1175\":1,\"1233\":1,\"1300\":1,\"1382\":1}}],[\"100000\",{\"1\":{\"714\":1,\"715\":1}}],[\"100001\",{\"1\":{\"316\":1}}],[\"1000\",{\"1\":{\"73\":1,\"351\":1,\"797\":1,\"824\":2,\"861\":1,\"869\":1,\"870\":1,\"882\":1,\"915\":1,\"1048\":4,\"1170\":3,\"1195\":1,\"1200\":2,\"1201\":1,\"1225\":1,\"1226\":1,\"1230\":1,\"1280\":1,\"1297\":2,\"1373\":1,\"1374\":1,\"1464\":1,\"1468\":1,\"1510\":1,\"1519\":5,\"1520\":2,\"1521\":2}}],[\"1000w\",{\"1\":{\"9\":1,\"931\":2}}],[\"100544\",{\"1\":{\"11\":2}}],[\"10\",{\"0\":{\"487\":1,\"519\":1,\"542\":1,\"557\":1,\"558\":1,\"559\":1,\"560\":1,\"561\":1,\"562\":1,\"563\":1,\"564\":1},\"1\":{\"11\":2,\"106\":2,\"150\":1,\"176\":2,\"177\":8,\"180\":1,\"182\":4,\"184\":1,\"253\":2,\"255\":1,\"324\":1,\"325\":1,\"332\":1,\"392\":1,\"393\":1,\"401\":1,\"403\":1,\"409\":1,\"411\":1,\"421\":1,\"455\":1,\"503\":1,\"536\":1,\"700\":2,\"711\":1,\"712\":1,\"737\":2,\"866\":2,\"870\":2,\"961\":2,\"967\":1,\"983\":2,\"1008\":1,\"1048\":3,\"1079\":2,\"1201\":1,\"1230\":3,\"1240\":1,\"1308\":2,\"1309\":1,\"1339\":3,\"1371\":2,\"1374\":1,\"1435\":1,\"1443\":1}}],[\"1\",{\"0\":{\"18\":1,\"80\":1,\"108\":1,\"109\":2,\"110\":1,\"112\":1,\"116\":1,\"120\":1,\"128\":1,\"131\":1,\"132\":1,\"292\":1,\"293\":1,\"294\":2,\"295\":1,\"296\":1,\"297\":1,\"298\":1,\"299\":1,\"300\":1,\"301\":2,\"302\":1,\"303\":1,\"305\":1,\"306\":2,\"307\":1,\"311\":1,\"318\":1,\"322\":1,\"329\":1,\"334\":1,\"337\":1,\"340\":1,\"341\":1,\"344\":1,\"348\":1,\"352\":1,\"356\":1,\"361\":1,\"362\":2,\"364\":1,\"365\":1,\"371\":1,\"374\":1,\"378\":1,\"383\":1,\"384\":2,\"385\":2,\"387\":1,\"390\":1,\"393\":1,\"400\":1,\"403\":1,\"405\":1,\"409\":1,\"411\":1,\"415\":1,\"419\":1,\"423\":1,\"424\":2,\"428\":1,\"430\":1,\"437\":1,\"444\":1,\"450\":1,\"456\":1,\"463\":1,\"470\":1,\"477\":1,\"479\":1,\"482\":1,\"486\":1,\"489\":1,\"494\":1,\"495\":1,\"502\":1,\"506\":1,\"508\":1,\"511\":1,\"522\":1,\"527\":1,\"531\":1,\"533\":1,\"550\":1,\"558\":1,\"560\":1,\"566\":1,\"567\":1,\"568\":1,\"570\":1,\"573\":1,\"582\":1,\"589\":1,\"591\":1,\"595\":1,\"598\":1,\"605\":1,\"610\":1,\"611\":2,\"612\":1,\"613\":2,\"614\":1,\"615\":1,\"616\":1,\"618\":1,\"621\":1,\"624\":1,\"642\":1,\"643\":2,\"644\":1,\"648\":1,\"651\":1,\"652\":2,\"653\":1,\"654\":1,\"657\":1,\"662\":1,\"667\":1,\"668\":2,\"669\":1,\"671\":1,\"676\":1,\"677\":3,\"678\":1,\"681\":1,\"683\":1,\"684\":2,\"685\":1,\"687\":1,\"706\":1,\"707\":2,\"708\":1,\"710\":1,\"714\":1,\"719\":1,\"722\":1,\"745\":1,\"746\":2,\"747\":1,\"749\":1,\"755\":1,\"761\":1,\"762\":2,\"763\":1,\"764\":1,\"765\":1,\"767\":1,\"769\":1,\"771\":1,\"773\":1,\"776\":1,\"777\":2,\"778\":1,\"780\":1,\"785\":1,\"786\":2,\"787\":1,\"792\":1,\"793\":2,\"794\":1,\"795\":1,\"796\":1,\"800\":1,\"801\":2,\"802\":1,\"803\":2,\"804\":1,\"805\":1,\"808\":1,\"809\":2,\"810\":1,\"811\":1,\"814\":1,\"818\":1,\"819\":2,\"820\":1,\"822\":1,\"827\":1,\"831\":1,\"832\":2,\"833\":1,\"836\":1,\"839\":1,\"843\":1,\"845\":1,\"847\":1,\"850\":1,\"852\":1,\"854\":1,\"857\":1,\"860\":1,\"863\":1,\"866\":1,\"870\":1,\"876\":1,\"877\":2,\"878\":1,\"889\":1,\"915\":1,\"940\":1,\"941\":2,\"942\":1,\"944\":1,\"947\":1,\"949\":1,\"952\":1,\"956\":1,\"959\":1,\"960\":2,\"961\":1,\"963\":1,\"970\":1,\"976\":1,\"978\":1,\"980\":1,\"983\":1,\"987\":1,\"988\":2,\"989\":1,\"993\":1,\"994\":2,\"995\":1,\"997\":1,\"1003\":1,\"1005\":1,\"1011\":1,\"1014\":1,\"1017\":1,\"1019\":1,\"1024\":1,\"1026\":1,\"1027\":2,\"1028\":1,\"1032\":1,\"1035\":1,\"1039\":1,\"1046\":1,\"1047\":2,\"1048\":1,\"1050\":1,\"1055\":1,\"1085\":1,\"1086\":1,\"1088\":1,\"1089\":2,\"1090\":1,\"1091\":1,\"1093\":1,\"1097\":1,\"1100\":1,\"1107\":1,\"1109\":1,\"1111\":1,\"1114\":1,\"1115\":2,\"1116\":1,\"1117\":1,\"1118\":1,\"1119\":1,\"1122\":1,\"1125\":1,\"1126\":2,\"1128\":1,\"1132\":1,\"1133\":2,\"1134\":1,\"1136\":1,\"1140\":1,\"1142\":1,\"1147\":1,\"1149\":1,\"1151\":1,\"1155\":1,\"1157\":1,\"1158\":2,\"1159\":1,\"1160\":1,\"1161\":1,\"1163\":1,\"1167\":1,\"1168\":2,\"1169\":1,\"1170\":1,\"1171\":1,\"1172\":1,\"1173\":1,\"1174\":1,\"1175\":1,\"1177\":1,\"1179\":1,\"1182\":1,\"1186\":1,\"1187\":2,\"1188\":1,\"1190\":1,\"1193\":1,\"1194\":2,\"1195\":1,\"1197\":1,\"1200\":1,\"1203\":1,\"1205\":1,\"1206\":2,\"1207\":1,\"1209\":1,\"1211\":1,\"1212\":2,\"1213\":1,\"1214\":1,\"1215\":1,\"1217\":1,\"1221\":1,\"1222\":2,\"1223\":1,\"1224\":2,\"1225\":1,\"1226\":1,\"1228\":1,\"1244\":1,\"1245\":2,\"1246\":1,\"1247\":2,\"1248\":1,\"1249\":1,\"1251\":1,\"1255\":1,\"1257\":1,\"1262\":1,\"1265\":1,\"1266\":2,\"1267\":1,\"1269\":1,\"1273\":1,\"1275\":1,\"1283\":1,\"1284\":2,\"1285\":1,\"1286\":2,\"1287\":1,\"1288\":1,\"1290\":1,\"1291\":1,\"1293\":1,\"1296\":1,\"1302\":1,\"1303\":2,\"1304\":1,\"1305\":2,\"1308\":1,\"1312\":1,\"1314\":1,\"1317\":1,\"1321\":1,\"1327\":1,\"1328\":2,\"1329\":1,\"1331\":1,\"1336\":1,\"1337\":2,\"1338\":1,\"1339\":1,\"1341\":1,\"1342\":2,\"1343\":1,\"1344\":1,\"1346\":1,\"1350\":1,\"1351\":2,\"1352\":1,\"1354\":1,\"1362\":1,\"1366\":1,\"1367\":2,\"1368\":1,\"1370\":1,\"1377\":1,\"1378\":2,\"1379\":1,\"1380\":1,\"1382\":1,\"1385\":1,\"1390\":1,\"1393\":1,\"1397\":1,\"1398\":2,\"1399\":1,\"1405\":1,\"1412\":1,\"1417\":1,\"1420\":1,\"1423\":1,\"1424\":2,\"1425\":1,\"1427\":1,\"1430\":1,\"1434\":1,\"1439\":1,\"1441\":1,\"1448\":1,\"1449\":2,\"1450\":1,\"1451\":1,\"1453\":1,\"1456\":1,\"1457\":2,\"1461\":1,\"1466\":1,\"1475\":1,\"1477\":1,\"1482\":1,\"1484\":1,\"1494\":1,\"1499\":1,\"1502\":1,\"1506\":1,\"1509\":1,\"1514\":1,\"1516\":1,\"1529\":1,\"1531\":1},\"1\":{\"8\":1,\"9\":8,\"11\":14,\"27\":1,\"53\":1,\"92\":2,\"118\":1,\"124\":1,\"125\":4,\"134\":1,\"135\":1,\"155\":2,\"167\":1,\"174\":2,\"176\":1,\"177\":6,\"178\":4,\"180\":2,\"181\":4,\"182\":6,\"184\":5,\"187\":1,\"189\":1,\"192\":5,\"193\":1,\"194\":2,\"195\":8,\"215\":1,\"248\":7,\"253\":6,\"255\":2,\"256\":1,\"261\":4,\"285\":1,\"286\":1,\"294\":4,\"298\":15,\"299\":2,\"302\":1,\"303\":2,\"309\":4,\"311\":2,\"313\":1,\"314\":1,\"316\":3,\"320\":1,\"323\":2,\"324\":1,\"325\":2,\"326\":2,\"327\":1,\"329\":1,\"330\":4,\"332\":5,\"338\":2,\"339\":2,\"342\":1,\"351\":1,\"368\":4,\"369\":3,\"390\":1,\"396\":1,\"399\":1,\"421\":11,\"436\":1,\"438\":1,\"446\":2,\"455\":1,\"479\":2,\"480\":2,\"490\":5,\"503\":1,\"508\":1,\"511\":3,\"512\":3,\"518\":1,\"520\":1,\"522\":2,\"524\":4,\"525\":1,\"527\":3,\"529\":1,\"550\":2,\"551\":1,\"555\":6,\"558\":1,\"579\":2,\"582\":4,\"584\":2,\"587\":1,\"593\":1,\"621\":1,\"624\":3,\"626\":2,\"637\":1,\"638\":1,\"643\":6,\"644\":1,\"645\":5,\"657\":2,\"674\":1,\"687\":1,\"693\":1,\"695\":1,\"700\":1,\"716\":1,\"719\":1,\"720\":2,\"733\":1,\"737\":2,\"743\":1,\"762\":2,\"771\":1,\"774\":1,\"787\":1,\"793\":1,\"794\":1,\"797\":2,\"823\":1,\"827\":1,\"857\":1,\"866\":1,\"870\":3,\"872\":1,\"886\":2,\"902\":1,\"922\":3,\"925\":1,\"927\":3,\"928\":1,\"931\":1,\"937\":1,\"960\":1,\"961\":1,\"964\":10,\"965\":1,\"967\":2,\"968\":4,\"983\":3,\"984\":1,\"985\":1,\"1007\":1,\"1008\":1,\"1017\":1,\"1020\":1,\"1021\":4,\"1028\":1,\"1040\":2,\"1048\":3,\"1050\":2,\"1053\":1,\"1056\":2,\"1074\":7,\"1077\":2,\"1078\":1,\"1079\":2,\"1081\":1,\"1085\":1,\"1095\":1,\"1104\":3,\"1145\":5,\"1171\":1,\"1173\":2,\"1174\":3,\"1180\":1,\"1188\":1,\"1194\":1,\"1195\":8,\"1197\":1,\"1198\":1,\"1203\":2,\"1206\":1,\"1209\":1,\"1212\":1,\"1217\":1,\"1218\":1,\"1230\":2,\"1235\":4,\"1247\":1,\"1248\":1,\"1255\":2,\"1267\":4,\"1269\":2,\"1270\":1,\"1271\":2,\"1273\":2,\"1276\":2,\"1278\":3,\"1280\":3,\"1296\":1,\"1322\":1,\"1331\":2,\"1332\":1,\"1344\":1,\"1347\":1,\"1352\":1,\"1367\":3,\"1368\":5,\"1371\":10,\"1372\":11,\"1373\":3,\"1374\":1,\"1380\":1,\"1383\":1,\"1420\":2,\"1425\":1,\"1431\":1,\"1432\":1,\"1434\":1,\"1435\":1,\"1442\":1,\"1445\":10,\"1453\":1,\"1462\":3,\"1464\":7,\"1468\":11,\"1475\":2,\"1480\":1,\"1496\":1,\"1497\":3,\"1499\":5,\"1506\":2,\"1516\":5,\"1517\":6,\"1518\":1,\"1519\":32,\"1520\":8,\"1521\":8,\"1538\":2}}],[\"当计时器到期仍未得到半数以上投票\",{\"1\":{\"1480\":1}}],[\"当涉及到事务相关的系统模块时\",{\"1\":{\"1439\":1}}],[\"当缓存中的数据大小大于缓存配置大小的\",{\"1\":{\"1404\":1}}],[\"当存在大量\",{\"1\":{\"1290\":1}}],[\"当定时到期\",{\"1\":{\"1253\":1}}],[\"当它超过该时刻还没有被\",{\"1\":{\"1251\":1}}],[\"当某些消费者僵死\",{\"1\":{\"1249\":1}}],[\"当某个\",{\"1\":{\"622\":3}}],[\"当客户端升级或者下线时\",{\"1\":{\"1249\":1}}],[\"当重新消费次数超过最大阈值时\",{\"1\":{\"1180\":1}}],[\"当发生哈希冲突时\",{\"1\":{\"1393\":1}}],[\"当发生\",{\"1\":{\"1101\":1,\"1510\":1}}],[\"当启动该服务后它会以\",{\"1\":{\"999\":1}}],[\"当文件变化时\",{\"1\":{\"961\":1}}],[\"当达到上限时说明有过多的异步投递任务还在执行\",{\"1\":{\"933\":1}}],[\"当达到阈值后\",{\"1\":{\"613\":1}}],[\"当投递任务结束时进行一些状态更新\",{\"1\":{\"933\":1}}],[\"当查询某个\",{\"1\":{\"927\":1}}],[\"当消费失败\",{\"1\":{\"1251\":1}}],[\"当消费失败的时候\",{\"1\":{\"1048\":1}}],[\"当消费者数量扩大到大于队列数量时\",{\"1\":{\"1249\":1}}],[\"当消费者数量很多\",{\"1\":{\"1128\":1}}],[\"当消费的\",{\"1\":{\"910\":1}}],[\"当消息被回查或者丢弃时\",{\"1\":{\"1468\":1}}],[\"当消息发送失败后\",{\"1\":{\"1234\":1}}],[\"当消息发送到被联邦的\",{\"1\":{\"633\":1}}],[\"当消息进入交换器时\",{\"1\":{\"716\":1}}],[\"当没有用到\",{\"0\":{\"901\":1}}],[\"当超过大小限制的时候需要准备新的文件\",{\"1\":{\"881\":1}}],[\"当磁盘容量达到\",{\"1\":{\"866\":1}}],[\"当磁盘容量告急时\",{\"1\":{\"863\":1}}],[\"当到达每天的删除时间\",{\"1\":{\"864\":1}}],[\"当到达指定的发送时间或者延迟相应时间后\",{\"1\":{\"832\":1}}],[\"当写入\",{\"1\":{\"854\":1}}],[\"当写入的索引数超过阈值\",{\"1\":{\"752\":1}}],[\"当延迟消息被延迟等级处理线程重新投递之后\",{\"1\":{\"834\":1}}],[\"当远程调用发生异常\",{\"1\":{\"820\":1}}],[\"当解析请求发生异常时\",{\"1\":{\"819\":1,\"1173\":1}}],[\"当中承载\",{\"1\":{\"1203\":1}}],[\"当中\",{\"1\":{\"1103\":1}}],[\"当中有新的消息存入\",{\"1\":{\"806\":1}}],[\"当中包含这些方法\",{\"1\":{\"118\":1}}],[\"当保存的数据超过上限时\",{\"1\":{\"787\":1}}],[\"当时间满足flushconsumequeuethoroughinterval时\",{\"1\":{\"769\":1}}],[\"当应当保存在该\",{\"1\":{\"765\":1}}],[\"当扫描到新消息被保存到\",{\"1\":{\"756\":1}}],[\"当需要消费这个\",{\"1\":{\"747\":1}}],[\"当需要执行分布式任务时\",{\"1\":{\"372\":1}}],[\"当结果的\",{\"1\":{\"738\":1}}],[\"当权重为\",{\"1\":{\"716\":1}}],[\"当新的队列\",{\"1\":{\"716\":1}}],[\"当新镜像加入时\",{\"1\":{\"658\":1}}],[\"当集群达到内存高水位时其他队列会不会收到影响\",{\"1\":{\"702\":1}}],[\"当每个队列都变成仲裁队列\",{\"1\":{\"701\":1}}],[\"当节点重新上线时\",{\"1\":{\"696\":1}}],[\"当节点数量改变之后计算的结果自然也会改变\",{\"1\":{\"386\":1}}],[\"当生产者发送一条消息\",{\"1\":{\"695\":1}}],[\"当生产者收到队列的所有镜像授予的信用时\",{\"1\":{\"664\":1}}],[\"当主\",{\"1\":{\"1033\":1}}],[\"当主副本所在的节点下线\",{\"1\":{\"695\":1}}],[\"当主节点宕机\",{\"1\":{\"648\":1}}],[\"当所有的从队列保存消息之后\",{\"1\":{\"693\":1}}],[\"当内存不足时\",{\"1\":{\"690\":1}}],[\"当内存中保存的消息数量\",{\"1\":{\"690\":1}}],[\"当负载降低时\",{\"1\":{\"690\":1}}],[\"当队列满时\",{\"1\":{\"1348\":1}}],[\"当队列中投递任务满时触发流控\",{\"1\":{\"855\":1}}],[\"当队列负载很高时\",{\"1\":{\"690\":1}}],[\"当队列比较短的时候这通常不是什么问题\",{\"1\":{\"678\":1}}],[\"当检测到前后两个文件中的有效数据可以合并成一个文件\",{\"1\":{\"688\":1}}],[\"当然可以\",{\"1\":{\"935\":1}}],[\"当然\",{\"1\":{\"681\":1,\"921\":1,\"1024\":1,\"1337\":1,\"1363\":1}}],[\"当然我的理解仅限于\",{\"1\":{\"399\":1}}],[\"当镜像队列发生故障时\",{\"1\":{\"665\":1}}],[\"当网络恢复后\",{\"1\":{\"659\":1}}],[\"当一个索引文件写满后\",{\"1\":{\"1394\":1}}],[\"当一个索引文件写满后创建新索引文件时调用\",{\"1\":{\"789\":1}}],[\"当一个节点下线\",{\"1\":{\"693\":1}}],[\"当一个文件中都是垃圾数据是可以将这个文件删除\",{\"1\":{\"688\":1}}],[\"当一个新节点被添加到集群中时\",{\"1\":{\"657\":1}}],[\"当一个函数返回了一个函数后\",{\"1\":{\"330\":1}}],[\"当unblock\",{\"1\":{\"627\":1}}],[\"当morecreditafter条消息被ack\",{\"1\":{\"626\":1}}],[\"当这个节点故障\",{\"1\":{\"648\":1}}],[\"当这个\",{\"1\":{\"624\":1}}],[\"当credit\",{\"1\":{\"624\":1}}],[\"当rabbit\",{\"1\":{\"624\":1,\"626\":2}}],[\"当累计接收并\",{\"1\":{\"621\":1}}],[\"当进程字典中的信用值达到\",{\"1\":{\"625\":1}}],[\"当进程字典中的信用值降为0时\",{\"1\":{\"621\":1}}],[\"当进程的信用值将为1时\",{\"1\":{\"619\":1}}],[\"当进程处理一条消息并且发给下游进程时\",{\"1\":{\"619\":1}}],[\"当急速超过\",{\"1\":{\"421\":1}}],[\"当有\",{\"1\":{\"945\":1}}],[\"当有新消息到达的时候\",{\"1\":{\"825\":1}}],[\"当有新的客户端连接时\",{\"1\":{\"112\":1}}],[\"当有数据的时候触发请求\",{\"1\":{\"822\":1}}],[\"当有节点失效时\",{\"1\":{\"673\":1}}],[\"当有节点新增时\",{\"1\":{\"673\":1}}],[\"当有持续伤害时不要让林莽卫士的\",{\"1\":{\"413\":1}}],[\"当觅血缠藤或共生绽华生长时\",{\"1\":{\"407\":1}}],[\"当小迅捷的目标选择的比较好时\",{\"1\":{\"405\":1}}],[\"当你有多个镜像队列时\",{\"1\":{\"693\":1}}],[\"当你达到\",{\"1\":{\"417\":1}}],[\"当你对有生命绽放并且在百花齐放圈里的目标用塞纳里奥结界\",{\"1\":{\"413\":1}}],[\"当你使用丛林之魂加成的治疗技能\",{\"1\":{\"409\":1}}],[\"当你的生命绽放效果在盟友身上时\",{\"1\":{\"405\":1}}],[\"当你的生命绽放施放在自己身上时\",{\"1\":{\"405\":1}}],[\"当你确实想要终止当前进程时就用它\",{\"1\":{\"193\":1}}],[\"当共生绽华失效或者你对其目标释放回春术时\",{\"1\":{\"401\":1}}],[\"当\",{\"1\":{\"372\":1,\"405\":1,\"621\":1,\"627\":1,\"674\":2,\"677\":1,\"762\":1,\"809\":1,\"1251\":1,\"1300\":1}}],[\"当数值超过了javascript的number所能表示的最大值时\",{\"1\":{\"294\":1}}],[\"当无法计算结果时用nan表示\",{\"1\":{\"294\":1}}],[\"当分区数达到\",{\"1\":{\"285\":1}}],[\"当函数的参数数量能预先知道时\",{\"1\":{\"200\":1}}],[\"当遇到内部错误或显式调用时\",{\"1\":{\"193\":1}}],[\"当且仅当i\",{\"1\":{\"1299\":1}}],[\"当且仅当其中任意一个\",{\"1\":{\"186\":1}}],[\"当且仅当每个\",{\"1\":{\"186\":1}}],[\"当用户支付了订单\",{\"1\":{\"921\":1,\"1337\":1}}],[\"当用户输入了一个空行\",{\"1\":{\"125\":1}}],[\"当用整数列表表示字符串时\",{\"1\":{\"178\":1}}],[\"当关联一个值与一个变量时\",{\"1\":{\"173\":1}}],[\"当读取到\",{\"1\":{\"125\":1}}],[\"当调用bookservice\",{\"1\":{\"85\":1}}],[\"当jvm在加载abc\",{\"1\":{\"23\":1}}],[\"当前存储的最大日志序号\",{\"1\":{\"1519\":1}}],[\"当前向\",{\"1\":{\"1510\":1}}],[\"当前节点刚被选举成\",{\"1\":{\"1519\":1}}],[\"当前节点不是\",{\"1\":{\"1519\":1}}],[\"当前节点磁盘是否已满\",{\"1\":{\"1517\":1}}],[\"当前节点是否为\",{\"1\":{\"1517\":1}}],[\"当前节点降级为\",{\"1\":{\"1503\":1}}],[\"当前节点切换成\",{\"1\":{\"1488\":3}}],[\"当前轮次\",{\"1\":{\"1502\":1}}],[\"当前集群节点维护的最大投票轮次\",{\"1\":{\"1499\":1}}],[\"当前投票轮次小于\",{\"1\":{\"1497\":1}}],[\"当前投票\",{\"1\":{\"1482\":1}}],[\"当前日志写入状态\",{\"1\":{\"1482\":1}}],[\"当前任期\",{\"1\":{\"1482\":1}}],[\"当前索引文件已满\",{\"1\":{\"1434\":1}}],[\"当前有\",{\"1\":{\"1425\":1}}],[\"当前队列等待提交的消息数量超过阈值\",{\"1\":{\"1403\":1,\"1427\":1}}],[\"当前默认允许的同时上传的\",{\"1\":{\"1403\":1}}],[\"当前默认没有使用\",{\"1\":{\"893\":1}}],[\"当前读取的时间轮槽为空\",{\"1\":{\"1372\":1}}],[\"当前痛点\",{\"0\":{\"1290\":1}}],[\"当前处理回查的事务半消息消费偏移量\",{\"1\":{\"1468\":1}}],[\"当前处理消息数量大于1000\",{\"1\":{\"1170\":1}}],[\"当前处理状态\",{\"1\":{\"124\":1}}],[\"当前消费消息超过100mb\",{\"1\":{\"1170\":1}}],[\"当前消费组中所有的消费者id\",{\"1\":{\"1143\":1}}],[\"当前消费者id\",{\"1\":{\"1143\":1}}],[\"当前topic下\",{\"1\":{\"1143\":1}}],[\"当前使用\",{\"1\":{\"1043\":1}}],[\"当前为字符串拼接模式\",{\"1\":{\"1021\":1}}],[\"当前只有一个默认实现\",{\"1\":{\"990\":1,\"996\":1}}],[\"当前支持多配置文件\",{\"1\":{\"983\":1}}],[\"当前没有注册自定义\",{\"1\":{\"964\":1}}],[\"当前没有可用数据\",{\"1\":{\"125\":1}}],[\"当前不会用到\",{\"1\":{\"944\":1}}],[\"当前不满足要求\",{\"1\":{\"825\":1}}],[\"当前的日志末尾\",{\"1\":{\"1510\":1}}],[\"当前的\",{\"1\":{\"1403\":1}}],[\"当前的分级存储基本已经属于可用的状态\",{\"1\":{\"1380\":1}}],[\"当前的偏移量\",{\"1\":{\"1294\":1}}],[\"当前的逻辑偏移量\",{\"1\":{\"1294\":1}}],[\"当前的做法是在投递任务状态更新线程扫描到状态为失败的任务时就开始重新投递该消息\",{\"1\":{\"934\":1}}],[\"当前的最新逻辑偏移量\",{\"1\":{\"765\":1}}],[\"当前各大消息队列和云厂商都对定时消息和延迟消息有一定程度上的支持\",{\"1\":{\"922\":1}}],[\"当前仍未合入\",{\"1\":{\"913\":1}}],[\"当前\",{\"1\":{\"894\":1,\"1497\":3,\"1510\":1}}],[\"当前已经使用的索引条目个数\",{\"1\":{\"787\":1}}],[\"当前分支不可能发生\",{\"1\":{\"771\":1}}],[\"当前consumequeue被写过的位置\",{\"1\":{\"765\":1}}],[\"当前consumequeue被写过的物理offset\",{\"1\":{\"765\":1}}],[\"当前比较流行的开源调度框架包括quartz\",{\"1\":{\"371\":1}}],[\"当前版成为旧版\",{\"1\":{\"207\":1}}],[\"当前版和旧版\",{\"1\":{\"207\":1}}],[\"当前缓冲区关键字\",{\"1\":{\"162\":1}}],[\"当前文件名\",{\"1\":{\"158\":1}}],[\"当前收到的事件集合\",{\"1\":{\"118\":1}}],[\"当前目录仍为work\",{\"1\":{\"21\":1}}],[\"当前最新的版本为\",{\"1\":{\"8\":1}}],[\"当编译器遇到一个class名称时\",{\"1\":{\"20\":1}}],[\"当对一个程序的一小部分代码或者一个函数进行基准测试时\",{\"1\":{\"3\":1}}],[\"之一段时间之后才会被投递\",{\"1\":{\"1338\":1}}],[\"之所以不直接存\",{\"1\":{\"1319\":1}}],[\"之外另一个需要部署的服务\",{\"1\":{\"941\":1}}],[\"之间使用逗号分割\",{\"1\":{\"1287\":1}}],[\"之间分布不均匀的情况\",{\"1\":{\"1097\":1}}],[\"之间要组个能跳怪的职业\",{\"1\":{\"455\":1}}],[\"之间的区别\",{\"1\":{\"728\":1}}],[\"之间的球留给纳组达\",{\"1\":{\"455\":1}}],[\"之间的所有通信都是通过异步消息传递实现的\",{\"1\":{\"372\":1}}],[\"之间的通信位置透明性\",{\"1\":{\"372\":1}}],[\"之后返回\",{\"1\":{\"1510\":1}}],[\"之后回填这个\",{\"1\":{\"1507\":1}}],[\"之后更新\",{\"1\":{\"1403\":1}}],[\"之后可能相同\",{\"1\":{\"1393\":1}}],[\"之后每次重试按照最大延迟等级对应的时间间隔\",{\"1\":{\"1241\":1}}],[\"之后会先分发到\",{\"1\":{\"1400\":1}}],[\"之后会被重试\",{\"1\":{\"1198\":1}}],[\"之后会根据存储的消息构建消息的索引文件\",{\"1\":{\"839\":1}}],[\"之后默认每\",{\"1\":{\"869\":1}}],[\"之后的所有日志文件\",{\"1\":{\"1520\":1}}],[\"之后的所有日志\",{\"1\":{\"1520\":1}}],[\"之后的文件删除\",{\"1\":{\"1511\":1}}],[\"之后的文件如果引用计数大于\",{\"1\":{\"866\":1}}],[\"之后的值\",{\"1\":{\"1393\":1}}],[\"之后的版本被废弃\",{\"1\":{\"949\":1}}],[\"之后的版本也将\",{\"1\":{\"942\":1}}],[\"之后的版本\",{\"1\":{\"648\":1}}],[\"之后的版本已经原生支持\",{\"1\":{\"8\":1}}],[\"之后的\",{\"1\":{\"387\":1}}],[\"之后\",{\"1\":{\"271\":1,\"421\":1,\"729\":1,\"750\":1,\"781\":1,\"1075\":1}}],[\"之前加载过的二级存储文件信息通过元数据的形式保存在本地文件中\",{\"1\":{\"1395\":1}}],[\"之前没有锁定\",{\"1\":{\"1222\":1}}],[\"之前的挂起等待\",{\"1\":{\"1521\":1}}],[\"之前的日志附加请求\",{\"1\":{\"1512\":1}}],[\"之前的消费进度\",{\"1\":{\"1278\":1}}],[\"之前的所有\",{\"1\":{\"872\":1}}],[\"之前的版本需要引入依赖\",{\"1\":{\"8\":1}}],[\"之前默认为\",{\"1\":{\"735\":1}}],[\"之前尽量把团血刷满\",{\"1\":{\"434\":1}}],[\"之前都可以堆\",{\"1\":{\"421\":1}}],[\"之前玩了\",{\"1\":{\"399\":1}}],[\"之前\",{\"1\":{\"191\":1,\"725\":1,\"1248\":1,\"1294\":1,\"1403\":1}}],[\"添加心跳最大超时时间\",{\"1\":{\"1497\":1}}],[\"添加所有拉取的消息的偏移量与起始偏移量的差值\",{\"1\":{\"1271\":1}}],[\"添加假的消息\",{\"1\":{\"1270\":1}}],[\"添加起始偏移量和所有\",{\"1\":{\"1259\":1}}],[\"添加成功\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"添加处理队列并创建\",{\"1\":{\"1137\":1}}],[\"添加定时任务\",{\"1\":{\"960\":1}}],[\"添加一个索引到索引文件\",{\"1\":{\"790\":1}}],[\"添加节点时需指定节点名称\",{\"1\":{\"393\":1}}],[\"添加节点\",{\"0\":{\"393\":1}}],[\"添加和删除节点\",{\"0\":{\"392\":1}}],[\"添加新的key\",{\"1\":{\"301\":1}}],[\"添加测试\",{\"1\":{\"180\":1}}],[\"添加递归映射\",{\"1\":{\"167\":1}}],[\"添加到内存\",{\"1\":{\"1259\":1}}],[\"添加到请求的扩展属性中\",{\"1\":{\"995\":1}}],[\"添加到\",{\"1\":{\"118\":1,\"125\":1}}],[\"添加数据的性能\",{\"1\":{\"9\":1}}],[\"添加\",{\"1\":{\"7\":1,\"203\":1,\"613\":1,\"1080\":1,\"1144\":1,\"1224\":1,\"1270\":1,\"1271\":1,\"1280\":1}}],[\"0~4byte\",{\"1\":{\"1418\":1,\"1435\":1}}],[\"0~2^32\",{\"1\":{\"396\":1}}],[\"0~255\",{\"1\":{\"53\":1}}],[\"07\",{\"1\":{\"1079\":7}}],[\"0e80d1d53112\",{\"1\":{\"1079\":1}}],[\"04\",{\"1\":{\"1075\":2}}],[\"0l\",{\"1\":{\"844\":1,\"1170\":1,\"1427\":1,\"1435\":1}}],[\"0来判断是否是定时消息\",{\"1\":{\"839\":1,\"843\":1}}],[\"0版本相比\",{\"1\":{\"720\":1}}],[\"0<\",{\"1\":{\"712\":1}}],[\"0v5\",{\"1\":{\"643\":10}}],[\"0jg69pzf3t38\",{\"1\":{\"469\":1}}],[\"0q3w49h6sev9t9ubaudt\",{\"1\":{\"429\":1}}],[\"05s\",{\"1\":{\"1371\":1}}],[\"05\",{\"1\":{\"398\":1}}],[\"01s\",{\"1\":{\"861\":1}}],[\"0187\",{\"1\":{\"446\":1}}],[\"01\",{\"1\":{\"316\":1}}],[\"06\",{\"1\":{\"272\":1,\"1008\":1}}],[\"03\",{\"1\":{\"265\":1,\"692\":1}}],[\"0>\",{\"1\":{\"230\":2}}],[\"0xff\",{\"1\":{\"54\":1,\"396\":1}}],[\"08jmh入门\",{\"1\":{\"15\":1}}],[\"024\",{\"1\":{\"11\":1}}],[\"000l\",{\"1\":{\"1339\":2}}],[\"000\",{\"1\":{\"913\":1,\"1248\":1}}],[\"00000000000000007280\",{\"1\":{\"749\":1}}],[\"00000000000000006240\",{\"1\":{\"749\":1}}],[\"00000000000000005200\",{\"1\":{\"749\":1}}],[\"00000000000000004160\",{\"1\":{\"749\":1}}],[\"00000000000000003120\",{\"1\":{\"749\":1}}],[\"00000000000000002080\",{\"1\":{\"749\":1}}],[\"00000000000000001040\",{\"1\":{\"749\":1}}],[\"00000000000000000000\",{\"1\":{\"749\":2}}],[\"00000000000000307200\",{\"1\":{\"749\":1}}],[\"00000000000000204800\",{\"1\":{\"749\":1}}],[\"00000000000000102400\",{\"1\":{\"749\":1}}],[\"00101010\",{\"1\":{\"215\":1}}],[\"00\",{\"1\":{\"11\":8,\"316\":3}}],[\"0\",{\"0\":{\"1243\":1,\"1335\":1},\"1\":{\"7\":1,\"11\":2,\"41\":1,\"43\":1,\"48\":1,\"65\":1,\"67\":3,\"92\":1,\"124\":3,\"125\":6,\"131\":3,\"145\":1,\"158\":1,\"174\":1,\"177\":1,\"180\":2,\"181\":3,\"183\":1,\"187\":1,\"189\":1,\"192\":1,\"195\":4,\"196\":1,\"215\":1,\"248\":1,\"253\":1,\"255\":2,\"261\":1,\"266\":3,\"294\":1,\"297\":1,\"298\":2,\"303\":1,\"306\":2,\"313\":1,\"314\":1,\"320\":1,\"325\":1,\"326\":1,\"330\":2,\"332\":3,\"385\":1,\"387\":1,\"396\":6,\"421\":2,\"490\":1,\"518\":1,\"524\":4,\"537\":4,\"540\":2,\"552\":2,\"577\":3,\"582\":2,\"583\":1,\"624\":2,\"625\":1,\"626\":3,\"643\":24,\"653\":1,\"688\":1,\"712\":1,\"714\":1,\"715\":1,\"737\":10,\"738\":1,\"742\":5,\"762\":2,\"765\":3,\"767\":2,\"769\":6,\"771\":7,\"773\":1,\"793\":5,\"794\":6,\"796\":2,\"797\":5,\"823\":1,\"841\":1,\"843\":1,\"845\":3,\"860\":2,\"866\":1,\"870\":8,\"871\":2,\"872\":2,\"880\":1,\"882\":7,\"890\":5,\"894\":4,\"915\":1,\"922\":2,\"927\":1,\"931\":3,\"932\":5,\"942\":1,\"952\":2,\"960\":1,\"964\":9,\"965\":5,\"967\":4,\"968\":8,\"970\":1,\"972\":1,\"976\":1,\"983\":3,\"984\":3,\"985\":2,\"990\":1,\"994\":2,\"996\":1,\"998\":5,\"999\":3,\"1003\":1,\"1008\":2,\"1017\":2,\"1020\":1,\"1021\":4,\"1050\":2,\"1052\":7,\"1053\":2,\"1056\":2,\"1075\":26,\"1077\":8,\"1078\":2,\"1079\":20,\"1080\":3,\"1081\":2,\"1095\":2,\"1105\":1,\"1131\":1,\"1144\":1,\"1145\":1,\"1170\":4,\"1171\":1,\"1173\":4,\"1174\":14,\"1175\":2,\"1194\":2,\"1195\":1,\"1197\":1,\"1198\":10,\"1224\":1,\"1229\":2,\"1245\":1,\"1249\":2,\"1255\":1,\"1257\":1,\"1267\":3,\"1269\":7,\"1277\":6,\"1278\":8,\"1280\":3,\"1281\":1,\"1288\":2,\"1293\":1,\"1295\":1,\"1296\":1,\"1297\":5,\"1299\":1,\"1306\":1,\"1309\":1,\"1310\":1,\"1331\":3,\"1358\":1,\"1368\":4,\"1370\":3,\"1371\":5,\"1372\":4,\"1373\":3,\"1374\":1,\"1382\":1,\"1383\":20,\"1420\":18,\"1425\":2,\"1427\":2,\"1428\":2,\"1430\":4,\"1431\":1,\"1432\":1,\"1434\":1,\"1435\":3,\"1436\":7,\"1437\":1,\"1439\":1,\"1442\":2,\"1443\":1,\"1445\":12,\"1459\":1,\"1462\":2,\"1463\":2,\"1468\":7,\"1469\":1,\"1475\":4,\"1497\":5,\"1499\":1,\"1506\":4,\"1516\":2,\"1517\":2,\"1520\":1,\"1521\":2,\"1538\":2}}],[\"dynamic\",{\"1\":{\"1523\":1}}],[\"dynamically\",{\"1\":{\"961\":1}}],[\"dcb86ff200000000002147483550\",{\"1\":{\"1383\":4}}],[\"dleger\",{\"1\":{\"1081\":1}}],[\"dledgermemorystore\",{\"1\":{\"1519\":1}}],[\"dledgermmapfilestore\",{\"1\":{\"1508\":4,\"1511\":1,\"1519\":2}}],[\"dledgerexception\",{\"1\":{\"1516\":2,\"1519\":1}}],[\"dledgerentrycoder\",{\"1\":{\"1517\":4}}],[\"dledgerentry\",{\"1\":{\"1516\":12,\"1517\":3,\"1518\":1,\"1519\":7,\"1520\":10}}],[\"dledgerentrypusher\",{\"0\":{\"1514\":1,\"1518\":1},\"1\":{\"1481\":3,\"1508\":5,\"1509\":1,\"1514\":2,\"1516\":3,\"1519\":1,\"1520\":1,\"1521\":5}}],[\"dledgerutils\",{\"1\":{\"1495\":2,\"1496\":1,\"1497\":1,\"1499\":2,\"1519\":4,\"1520\":2,\"1521\":4}}],[\"dledgerresponsecode\",{\"1\":{\"1499\":2,\"1500\":6,\"1516\":6,\"1517\":8,\"1519\":17,\"1520\":29,\"1521\":1}}],[\"dledgerrpcservice\",{\"1\":{\"1482\":1,\"1499\":1,\"1502\":1,\"1514\":2,\"1519\":4}}],[\"dledgerrolechangehandler\",{\"1\":{\"1424\":2}}],[\"dledgerprotocol\",{\"1\":{\"1482\":1}}],[\"dledgerprotocolhandler\",{\"1\":{\"1482\":2}}],[\"dledgerprotocl\",{\"1\":{\"1482\":1}}],[\"dledgerconfig\",{\"1\":{\"1514\":2,\"1518\":2,\"1519\":6}}],[\"dledgercommitlog\",{\"1\":{\"1424\":1,\"1509\":1}}],[\"dledgerclientprotocol\",{\"1\":{\"1482\":1}}],[\"dledgerclientprotocolhandler\",{\"1\":{\"1482\":1}}],[\"dledgerserver\",{\"0\":{\"1516\":1},\"1\":{\"1482\":3,\"1509\":1}}],[\"dledgerstore\",{\"0\":{\"1517\":1},\"1\":{\"1481\":1,\"1482\":1,\"1512\":1,\"1514\":2,\"1516\":2,\"1519\":21,\"1520\":9,\"1521\":11}}],[\"dledgerleaderelector\",{\"0\":{\"1483\":1},\"1\":{\"1424\":1,\"1481\":1,\"1482\":1,\"1483\":1,\"1488\":1,\"1489\":1,\"1491\":1,\"1492\":1,\"1495\":1,\"1496\":1,\"1497\":1,\"1499\":1,\"1500\":1,\"1502\":1,\"1503\":1}}],[\"dledger\",{\"0\":{\"853\":1,\"1068\":1,\"1079\":1,\"1081\":1,\"1474\":1,\"1505\":1},\"1\":{\"286\":1,\"850\":2,\"853\":3,\"1074\":1,\"1079\":8,\"1080\":14,\"1081\":3,\"1424\":1,\"1474\":1,\"1475\":5,\"1477\":3,\"1481\":3,\"1482\":9,\"1483\":1,\"1504\":1,\"1505\":1,\"1506\":5,\"1507\":4,\"1508\":3,\"1509\":2,\"1514\":2,\"1517\":2,\"1521\":1,\"1538\":3}}],[\"dlq\",{\"1\":{\"1056\":1,\"1100\":1,\"1188\":1,\"1198\":3}}],[\"dns\",{\"0\":{\"888\":1},\"1\":{\"886\":1,\"888\":3}}],[\"dpkg\",{\"1\":{\"643\":4,\"645\":3}}],[\"dps\",{\"1\":{\"405\":1,\"411\":2,\"412\":1,\"416\":1,\"422\":2,\"425\":1,\"434\":1,\"439\":1,\"441\":1,\"443\":1,\"449\":1,\"451\":1}}],[\"dz\",{\"1\":{\"455\":1,\"462\":1}}],[\"dzbzmsrjfkoljw8rkwto2fzinmebk6yuvl6honpiielqellhkbeajzskif8ryhlrb\",{\"1\":{\"455\":1}}],[\"dg91ddtwawttjj2e\",{\"1\":{\"429\":1}}],[\"dgroupid=org\",{\"1\":{\"7\":1}}],[\"dxfzpx\",{\"1\":{\"429\":1}}],[\"dk\",{\"1\":{\"422\":1,\"433\":1,\"458\":1}}],[\"drwxrwxr\",{\"1\":{\"1074\":6}}],[\"drainpermits\",{\"1\":{\"1428\":1}}],[\"drain\",{\"1\":{\"916\":2}}],[\"drawio\",{\"1\":{\"756\":2,\"806\":2,\"812\":2}}],[\"dropped\",{\"1\":{\"1170\":1,\"1195\":2,\"1230\":4}}],[\"drop\",{\"1\":{\"845\":1,\"1195\":1}}],[\"druid\",{\"1\":{\"398\":2,\"491\":1}}],[\"driver\",{\"1\":{\"280\":1}}],[\"dbg\",{\"1\":{\"261\":5}}],[\"duration\",{\"1\":{\"1427\":1}}],[\"durable\",{\"1\":{\"684\":1}}],[\"during\",{\"1\":{\"1050\":1}}],[\"dubbo\",{\"1\":{\"273\":1,\"941\":1}}],[\"dumping\",{\"1\":{\"259\":1}}],[\"dump\",{\"1\":{\"259\":1,\"420\":1}}],[\"duplicated\",{\"1\":{\"720\":1,\"731\":1,\"886\":1,\"901\":1}}],[\"duplicate\",{\"1\":{\"248\":3,\"720\":1,\"1047\":1,\"1122\":1,\"1270\":1,\"1435\":1,\"1436\":1}}],[\"d3\",{\"1\":{\"253\":2}}],[\"d2\",{\"1\":{\"253\":2}}],[\"d1\",{\"1\":{\"253\":2}}],[\"d>\",{\"1\":{\"163\":1}}],[\"d0bnhf0mne3xx8yi0dwj5rngfuvx3dxmyoy9\",{\"1\":{\"469\":1}}],[\"d0\",{\"1\":{\"147\":1}}],[\"d$\",{\"1\":{\"147\":1}}],[\"dt\",{\"1\":{\"147\":1}}],[\"ddgr1c3y\",{\"1\":{\"469\":1}}],[\"dd\",{\"1\":{\"147\":2}}],[\"dw\",{\"1\":{\"147\":2}}],[\"dobatchappend\",{\"1\":{\"1519\":1}}],[\"dobeforerpchooks\",{\"1\":{\"994\":2}}],[\"dobeforerequest\",{\"1\":{\"994\":2,\"995\":1,\"996\":1}}],[\"dohook\",{\"1\":{\"1517\":1}}],[\"dowork\",{\"1\":{\"1510\":1,\"1511\":1,\"1512\":1,\"1519\":1,\"1520\":2,\"1521\":1}}],[\"downloads\",{\"1\":{\"642\":1}}],[\"downstream\",{\"0\":{\"638\":1},\"1\":{\"630\":2}}],[\"down\",{\"1\":{\"585\":2,\"1503\":1}}],[\"dofiltermessage\",{\"1\":{\"1430\":2}}],[\"doflush\",{\"0\":{\"769\":1},\"1\":{\"769\":1}}],[\"doflow\",{\"1\":{\"624\":1}}],[\"doput\",{\"1\":{\"1374\":2}}],[\"doexecuteendtransactionhook\",{\"1\":{\"1460\":1,\"1472\":1}}],[\"doenqueue\",{\"1\":{\"1371\":2}}],[\"doenqueueres\",{\"1\":{\"1371\":2}}],[\"doesn\",{\"1\":{\"103\":1}}],[\"does\",{\"1\":{\"97\":2,\"1171\":1,\"1173\":2,\"1266\":2,\"1472\":1,\"1519\":1}}],[\"doloadbalance\",{\"0\":{\"1266\":1},\"1\":{\"1255\":1,\"1266\":1}}],[\"dodispatchlmqqueue\",{\"1\":{\"1297\":2}}],[\"dodispatch\",{\"0\":{\"763\":1},\"1\":{\"762\":1,\"763\":1,\"827\":1}}],[\"doresponse\",{\"1\":{\"1462\":1}}],[\"dores\",{\"1\":{\"1373\":8,\"1374\":6}}],[\"dorebalance\",{\"0\":{\"1142\":1},\"1\":{\"1104\":1,\"1134\":1,\"1137\":2,\"1140\":1,\"1142\":1,\"1143\":3,\"1144\":7,\"1224\":5}}],[\"doreput\",{\"0\":{\"762\":1,\"827\":1},\"1\":{\"756\":1,\"761\":1,\"762\":1,\"806\":1,\"812\":1,\"814\":1,\"815\":1,\"816\":1,\"827\":2}}],[\"doreturn\",{\"0\":{\"97\":1},\"1\":{\"97\":2}}],[\"doafterresponse\",{\"1\":{\"994\":1,\"996\":1}}],[\"doafterrequest\",{\"1\":{\"994\":1}}],[\"doafterrpchooks\",{\"1\":{\"994\":2}}],[\"doappendinner\",{\"1\":{\"1510\":1,\"1519\":3}}],[\"doappend\",{\"1\":{\"737\":4,\"738\":1,\"765\":2,\"1510\":1,\"1519\":2}}],[\"doanswer\",{\"1\":{\"103\":1}}],[\"dotruncate\",{\"1\":{\"1510\":1,\"1519\":2}}],[\"dot\",{\"0\":{\"419\":1},\"1\":{\"411\":2,\"412\":10,\"419\":1,\"426\":1,\"431\":1,\"432\":1,\"435\":2,\"442\":1,\"448\":3,\"457\":1,\"467\":1,\"472\":1,\"475\":1}}],[\"dothrow\",{\"1\":{\"102\":2}}],[\"domain\",{\"1\":{\"316\":1}}],[\"doscheduledispatch\",{\"0\":{\"1427\":1},\"1\":{\"1403\":3,\"1427\":1}}],[\"dose\",{\"1\":{\"996\":2}}],[\"dos\",{\"1\":{\"288\":1}}],[\"doors\",{\"1\":{\"253\":2}}],[\"donext\",{\"1\":{\"762\":3}}],[\"doneopoffset\",{\"1\":{\"722\":1,\"1468\":6}}],[\"done\",{\"1\":{\"191\":3,\"332\":6,\"643\":3}}],[\"dont\",{\"1\":{\"11\":1}}],[\"dog\",{\"1\":{\"181\":2,\"186\":4,\"563\":4}}],[\"doublecanonicalname2\",{\"1\":{\"742\":1}}],[\"doublecanonicalname1\",{\"1\":{\"742\":1}}],[\"double\",{\"1\":{\"181\":2,\"742\":1,\"1277\":1}}],[\"doug\",{\"0\":{\"107\":1},\"1\":{\"108\":1,\"138\":1}}],[\"do\",{\"1\":{\"104\":1,\"125\":1,\"195\":1,\"196\":2,\"253\":6,\"624\":3,\"643\":1,\"996\":1,\"1170\":3,\"1371\":1,\"1372\":1,\"1435\":4,\"1500\":1,\"1519\":2}}],[\"docheckappendresponse\",{\"1\":{\"1519\":3}}],[\"docommit\",{\"1\":{\"1510\":1,\"1519\":2}}],[\"docompare\",{\"1\":{\"1510\":1,\"1519\":4}}],[\"docompaction\",{\"0\":{\"1435\":1},\"1\":{\"1417\":1,\"1435\":2}}],[\"docompactthenuploadfile\",{\"1\":{\"1417\":1,\"1435\":2}}],[\"doconfigure\",{\"1\":{\"960\":1}}],[\"docker\",{\"0\":{\"1068\":2,\"1072\":1,\"1074\":1,\"1075\":1,\"1076\":1,\"1077\":1,\"1078\":2,\"1079\":1,\"1083\":1,\"1084\":1},\"1\":{\"1068\":1,\"1069\":4,\"1070\":5,\"1071\":1,\"1072\":2,\"1073\":3,\"1074\":5,\"1075\":16,\"1076\":1,\"1077\":3,\"1078\":3,\"1079\":14,\"1080\":4,\"1081\":4,\"1083\":1,\"1084\":1,\"1538\":2}}],[\"docs\",{\"1\":{\"1025\":1}}],[\"document\",{\"1\":{\"348\":2,\"349\":1}}],[\"documentation\",{\"1\":{\"171\":3}}],[\"doc\",{\"1\":{\"96\":1,\"104\":1,\"272\":2,\"679\":1}}],[\"ds\",{\"1\":{\"72\":3,\"73\":6}}],[\"damage\",{\"1\":{\"1519\":1}}],[\"dashboard\",{\"0\":{\"1009\":1,\"1076\":1,\"1077\":1,\"1078\":1,\"1081\":1},\"1\":{\"1009\":1,\"1076\":1,\"1077\":11,\"1078\":6,\"1081\":5}}],[\"daily\",{\"1\":{\"374\":1}}],[\"dag工作流支持\",{\"1\":{\"371\":1}}],[\"date\",{\"0\":{\"334\":1},\"1\":{\"316\":1,\"1468\":3}}],[\"datapos\",{\"1\":{\"1517\":4}}],[\"datafilelist\",{\"1\":{\"1517\":2}}],[\"databuffer\",{\"1\":{\"1517\":9}}],[\"database\",{\"1\":{\"253\":2,\"643\":1,\"645\":1}}],[\"data=\",{\"1\":{\"1332\":1}}],[\"dataconverter\",{\"1\":{\"1273\":1,\"1277\":2,\"1278\":3,\"1280\":1}}],[\"data1\",{\"1\":{\"1075\":5}}],[\"datatopic\",{\"1\":{\"1021\":3}}],[\"dataversions\",{\"1\":{\"998\":2}}],[\"dataversionmap是个map类型\",{\"1\":{\"997\":1}}],[\"dataversionmap\",{\"1\":{\"997\":2,\"998\":6}}],[\"dataversion>\",{\"1\":{\"997\":1,\"998\":1}}],[\"dataversion\",{\"1\":{\"952\":1,\"967\":2,\"998\":8}}],[\"datasource\",{\"1\":{\"89\":3}}],[\"datasource的实例\",{\"1\":{\"89\":1}}],[\"data\",{\"1\":{\"72\":2,\"73\":3,\"165\":3,\"241\":1,\"349\":2,\"371\":1,\"972\":1,\"998\":3,\"1019\":1,\"1021\":1,\"1074\":1,\"1075\":1,\"1080\":9,\"1173\":6,\"1174\":1,\"1175\":1,\"1332\":1,\"1368\":3,\"1382\":1,\"1383\":1,\"1427\":1,\"1504\":1,\"1519\":1,\"1522\":1}}],[\"datagramchannel\",{\"1\":{\"118\":1}}],[\"datagrampacket\",{\"1\":{\"72\":2,\"73\":3}}],[\"datagramsocket没有io流接口\",{\"1\":{\"73\":1}}],[\"datagramsocket\",{\"1\":{\"72\":2,\"73\":2}}],[\"day\",{\"1\":{\"316\":3}}],[\"daw\",{\"1\":{\"147\":1}}],[\"dartifactid=test\",{\"1\":{\"7\":1}}],[\"darchetypeartifactid=jmh\",{\"1\":{\"7\":1}}],[\"darchetypegroupid=org\",{\"1\":{\"7\":1}}],[\"dmaven=3\",{\"1\":{\"65\":1}}],[\"d指定输出的class文件存放bin目录\",{\"1\":{\"21\":1}}],[\"d\",{\"0\":{\"438\":1,\"898\":1},\"1\":{\"21\":2,\"144\":1,\"147\":1,\"155\":1,\"156\":1,\"171\":1,\"298\":2,\"423\":1,\"498\":1,\"576\":5,\"742\":3,\"886\":1,\"890\":1,\"891\":2,\"1000\":1,\"1077\":1,\"1080\":3,\"1081\":1,\"1173\":2,\"1436\":4,\"1519\":6}}],[\"diff\",{\"1\":{\"765\":2,\"787\":1,\"1174\":2}}],[\"different\",{\"1\":{\"886\":1,\"905\":1,\"1173\":2}}],[\"differently\",{\"1\":{\"97\":1}}],[\"difference\",{\"0\":{\"97\":1,\"98\":1}}],[\"diagrams\",{\"1\":{\"756\":1,\"806\":1,\"812\":1}}],[\"diagnostics\",{\"1\":{\"711\":1}}],[\"dialect\",{\"1\":{\"89\":2}}],[\"digest\",{\"1\":{\"396\":3}}],[\"dict\",{\"1\":{\"624\":1}}],[\"dictionary\",{\"1\":{\"217\":1,\"624\":1,\"627\":1}}],[\"dictmock\",{\"1\":{\"101\":3,\"102\":3}}],[\"div\",{\"1\":{\"174\":2}}],[\"dirty\",{\"1\":{\"1519\":1}}],[\"directly\",{\"1\":{\"1248\":1,\"1427\":2,\"1436\":1}}],[\"directbuffer\",{\"1\":{\"882\":1}}],[\"directories\",{\"1\":{\"643\":1,\"645\":1}}],[\"directory\",{\"1\":{\"171\":4,\"1079\":1}}],[\"direction\",{\"1\":{\"585\":1}}],[\"direct\",{\"1\":{\"267\":1,\"1300\":1}}],[\"dir\",{\"1\":{\"171\":2,\"223\":4,\"252\":1,\"793\":2}}],[\"dit\",{\"1\":{\"154\":1}}],[\"diw\",{\"1\":{\"147\":1}}],[\"disruptor\",{\"1\":{\"1065\":1}}],[\"discuss\",{\"1\":{\"1299\":1}}],[\"discarded\",{\"1\":{\"1468\":2}}],[\"discardcount\",{\"1\":{\"1021\":1}}],[\"discard\",{\"1\":{\"845\":1,\"860\":1,\"960\":1,\"1021\":1}}],[\"disconnect\",{\"1\":{\"73\":1}}],[\"disconnected\",{\"1\":{\"69\":1,\"70\":1}}],[\"dist\",{\"1\":{\"498\":1,\"499\":2,\"601\":1}}],[\"distribution\",{\"1\":{\"11\":2}}],[\"diskfallrecorded\",{\"1\":{\"1174\":2}}],[\"disk\",{\"1\":{\"247\":1,\"643\":1,\"690\":5,\"870\":1,\"882\":1,\"1273\":1,\"1382\":2,\"1390\":2,\"1405\":2,\"1459\":1,\"1517\":5,\"1519\":1}}],[\"display\",{\"1\":{\"171\":4}}],[\"dispatchwithsemaphore\",{\"1\":{\"1403\":1,\"1427\":2}}],[\"dispatchtoconsume\",{\"1\":{\"1175\":2,\"1194\":2,\"1229\":2}}],[\"dispatchpullrequest\",{\"1\":{\"1134\":1,\"1137\":1,\"1144\":1,\"1224\":1}}],[\"dispatchrequest\",{\"1\":{\"762\":14,\"763\":1,\"764\":7,\"789\":1,\"794\":5,\"827\":8,\"1297\":7,\"1332\":2,\"1403\":1,\"1427\":6}}],[\"dispatchermap\",{\"1\":{\"1514\":1}}],[\"dispatcherid\",{\"1\":{\"1021\":1}}],[\"dispatcherlist\",{\"1\":{\"763\":1}}],[\"dispatcher\",{\"1\":{\"756\":1,\"763\":2,\"1019\":3,\"1387\":1,\"1403\":6}}],[\"dispatch状态插入taskdo表\",{\"1\":{\"378\":1}}],[\"dispatch或worker\",{\"1\":{\"375\":1}}],[\"dispatch等待派发\",{\"1\":{\"374\":1}}],[\"dispatch\",{\"0\":{\"764\":1},\"1\":{\"119\":1,\"120\":1,\"122\":3,\"756\":2,\"763\":1,\"764\":1,\"1287\":3,\"1296\":3,\"1297\":4,\"1323\":1,\"1332\":1,\"1427\":6}}],[\"disabled\",{\"1\":{\"961\":1}}],[\"disable\",{\"1\":{\"11\":1,\"1382\":1,\"1390\":1,\"1405\":1}}],[\"dinteractivemode=false\",{\"1\":{\"7\":1}}],[\"djmh\",{\"1\":{\"11\":1}}],[\"deepcopyflatfiletolist\",{\"1\":{\"1427\":1}}],[\"dequeuestatuschangeflag\",{\"1\":{\"1372\":2,\"1374\":2}}],[\"dequeuegetqueue\",{\"1\":{\"1358\":1,\"1359\":2,\"1372\":5,\"1373\":1}}],[\"dequeueputqueue\",{\"1\":{\"1356\":1,\"1359\":2,\"1360\":2,\"1371\":2,\"1372\":2,\"1373\":2,\"1374\":2}}],[\"dequeue\",{\"1\":{\"1353\":1,\"1372\":6,\"1373\":3,\"1374\":2}}],[\"decrementandget\",{\"1\":{\"1277\":2}}],[\"decoratedvalue\",{\"1\":{\"606\":1}}],[\"decorator是装饰器的类型定义\",{\"1\":{\"606\":1}}],[\"decorator\",{\"1\":{\"606\":1}}],[\"decodemessageid\",{\"1\":{\"1460\":2}}],[\"decodeproperties\",{\"1\":{\"1333\":1}}],[\"decodes\",{\"1\":{\"1329\":1}}],[\"decodesendmessageheaderv2\",{\"1\":{\"742\":1}}],[\"decodecommandcustomheader\",{\"1\":{\"742\":1,\"890\":1,\"973\":1,\"1173\":1,\"1198\":1,\"1273\":1,\"1464\":1,\"1471\":1}}],[\"decode\",{\"1\":{\"111\":1,\"116\":1,\"127\":1,\"128\":1,\"886\":1,\"889\":1,\"891\":1,\"1333\":1,\"1420\":1,\"1471\":2}}],[\"deny\",{\"1\":{\"978\":1,\"983\":3}}],[\"debugging\",{\"1\":{\"1444\":1}}],[\"debug\",{\"1\":{\"720\":1,\"722\":1,\"1173\":1,\"1332\":1,\"1333\":3,\"1371\":1,\"1427\":1,\"1431\":2,\"1435\":1,\"1436\":2,\"1459\":1,\"1468\":4,\"1471\":1,\"1472\":1}}],[\"deb\",{\"0\":{\"643\":1},\"1\":{\"625\":8,\"643\":3,\"644\":1,\"645\":4}}],[\"de\",{\"1\":{\"601\":1}}],[\"dead\",{\"1\":{\"489\":2,\"490\":3}}],[\"deal\",{\"1\":{\"97\":1}}],[\"develop\",{\"1\":{\"1025\":1}}],[\"developer\",{\"1\":{\"274\":1,\"381\":1}}],[\"devtools<\",{\"1\":{\"95\":1}}],[\"del\",{\"1\":{\"1373\":2}}],[\"delegated\",{\"1\":{\"1296\":1}}],[\"deleting\",{\"1\":{\"870\":1}}],[\"deletepreparemessage\",{\"1\":{\"1464\":2}}],[\"deletephysicfilesinterval\",{\"1\":{\"870\":2}}],[\"deletelist\",{\"1\":{\"1372\":3}}],[\"deletelatch\",{\"1\":{\"1372\":3}}],[\"deletelogicsfilesinterval\",{\"1\":{\"871\":3,\"872\":1}}],[\"deletemsgstack\",{\"1\":{\"1372\":5}}],[\"deleted\",{\"1\":{\"1371\":1,\"1372\":1,\"1519\":1}}],[\"deleteuniqkeys\",{\"1\":{\"1359\":2,\"1372\":2}}],[\"deletewhen\",{\"1\":{\"1075\":2}}],[\"deletefilesinterval\",{\"1\":{\"870\":4}}],[\"deletecount++\",{\"1\":{\"870\":1}}],[\"deletecount\",{\"1\":{\"870\":5,\"871\":2}}],[\"deleteexpiredfilebytime\",{\"1\":{\"870\":2}}],[\"deleteexpiredfiles\",{\"1\":{\"870\":1,\"871\":1,\"872\":1}}],[\"deleteexpiredfile\",{\"1\":{\"795\":1,\"870\":3,\"871\":1,\"872\":3}}],[\"deleteonexit\",{\"1\":{\"52\":1}}],[\"delete\",{\"1\":{\"52\":1,\"91\":2,\"125\":1,\"144\":1,\"147\":8,\"248\":1,\"253\":1,\"299\":2,\"301\":1,\"524\":1,\"862\":1,\"870\":3,\"1371\":4,\"1372\":1,\"1373\":1}}],[\"delta三种状态之一\",{\"1\":{\"690\":1}}],[\"delta队列是消息按序存盘后的一种逻辑队列\",{\"1\":{\"690\":1}}],[\"delta\",{\"1\":{\"690\":5}}],[\"delaytimelevel\",{\"1\":{\"1459\":1}}],[\"delaytime\",{\"1\":{\"1371\":1}}],[\"delayedtime\",{\"1\":{\"1370\":2,\"1371\":10,\"1372\":2}}],[\"delayed\",{\"1\":{\"1351\":1,\"1352\":1}}],[\"delayleveltable\",{\"1\":{\"844\":1}}],[\"delaylevel2queueid\",{\"1\":{\"843\":1,\"845\":1,\"860\":1}}],[\"delaylevel\",{\"1\":{\"837\":1,\"845\":9,\"860\":3,\"861\":3,\"1197\":5,\"1198\":5}}],[\"delay\",{\"1\":{\"374\":1,\"835\":1,\"843\":1,\"844\":1,\"845\":3,\"860\":5,\"861\":1,\"1053\":2,\"1170\":4,\"1375\":3,\"1459\":1}}],[\"delivertime\",{\"1\":{\"1278\":3}}],[\"delivertimestamp\",{\"1\":{\"845\":2,\"860\":2}}],[\"delivermessage\",{\"1\":{\"860\":1}}],[\"deliver\",{\"1\":{\"860\":2,\"1287\":1}}],[\"deliversuc\",{\"1\":{\"860\":4}}],[\"deliverpendingtable\",{\"1\":{\"857\":1,\"860\":1,\"861\":1}}],[\"deliverexecutorservice\",{\"1\":{\"857\":1}}],[\"deliverdelayedmessagetimertask\",{\"0\":{\"841\":1,\"845\":1},\"1\":{\"841\":1,\"844\":1,\"845\":5,\"857\":1}}],[\"deliverymode\",{\"1\":{\"685\":1}}],[\"delivery\",{\"1\":{\"276\":1,\"843\":1}}],[\"deliberately\",{\"1\":{\"624\":1}}],[\"deliberate\",{\"1\":{\"256\":2}}],[\"destbrokername\",{\"1\":{\"1460\":3}}],[\"destroyexpiredfile\",{\"1\":{\"1435\":1}}],[\"destroyed\",{\"1\":{\"972\":7}}],[\"destroyfile\",{\"1\":{\"1427\":2}}],[\"destroymapedfileintervalforcibly\",{\"1\":{\"870\":2}}],[\"destroy\",{\"1\":{\"793\":1,\"870\":2,\"872\":1,\"1435\":2}}],[\"descendingmap\",{\"1\":{\"1436\":1}}],[\"description\",{\"1\":{\"1073\":1}}],[\"desired\",{\"1\":{\"767\":1,\"1174\":1,\"1430\":1}}],[\"design\",{\"1\":{\"253\":8,\"774\":1}}],[\"desktop\",{\"1\":{\"255\":5}}],[\"determines\",{\"1\":{\"737\":1}}],[\"detectfastjson\",{\"1\":{\"960\":1}}],[\"detection\",{\"1\":{\"280\":2}}],[\"detected\",{\"1\":{\"11\":1}}],[\"details\",{\"1\":{\"491\":1,\"1436\":2}}],[\"detail\",{\"1\":{\"381\":1}}],[\"dets\",{\"0\":{\"247\":1},\"1\":{\"247\":2,\"248\":1}}],[\"demo=new\",{\"1\":{\"266\":1}}],[\"demo\",{\"1\":{\"253\":4,\"266\":2,\"272\":2}}],[\"demo2\",{\"1\":{\"195\":4}}],[\"demo1\",{\"1\":{\"194\":2}}],[\"def\",{\"1\":{\"1308\":2}}],[\"definition\",{\"1\":{\"652\":1,\"653\":1,\"654\":1}}],[\"defined\",{\"1\":{\"104\":1,\"316\":2,\"998\":1}}],[\"define\",{\"0\":{\"213\":1},\"1\":{\"97\":1,\"104\":1,\"171\":1,\"213\":3,\"624\":1}}],[\"deferred列表\",{\"1\":{\"627\":1}}],[\"deferred列表中保存的所有消息\",{\"1\":{\"627\":1}}],[\"deferred\",{\"1\":{\"626\":3,\"627\":1}}],[\"defaultstore\",{\"1\":{\"1427\":5}}],[\"defaultstoremetricsmanager\",{\"1\":{\"1371\":1,\"1374\":1}}],[\"defaultconsumeridschangelistener\",{\"1\":{\"1331\":1}}],[\"defaultcluster\",{\"1\":{\"964\":2,\"965\":1,\"966\":1,\"968\":2,\"1075\":2,\"1383\":1,\"1441\":1}}],[\"defaultlitepullconsumer\",{\"1\":{\"1136\":1}}],[\"defaultxxxxconsumer\",{\"1\":{\"1109\":2}}],[\"defaultaclfile\",{\"1\":{\"998\":5,\"999\":4}}],[\"defaultacldir\",{\"1\":{\"998\":1,\"999\":1}}],[\"defaultappendmessagecallback\",{\"1\":{\"737\":1,\"738\":1}}],[\"defaultgroupperm\",{\"1\":{\"983\":2}}],[\"defaultrequestprocessor\",{\"1\":{\"944\":1,\"953\":1,\"957\":1,\"973\":1}}],[\"defaultmappedfile\",{\"1\":{\"1435\":1}}],[\"defaultmetadatastore\",{\"1\":{\"1382\":1,\"1402\":1,\"1420\":1}}],[\"defaultmessagestore\",{\"0\":{\"763\":1,\"767\":1,\"811\":1,\"816\":1,\"826\":1,\"1164\":1,\"1174\":1},\"1\":{\"738\":1,\"756\":1,\"757\":1,\"760\":1,\"762\":7,\"764\":1,\"766\":1,\"769\":6,\"793\":1,\"794\":1,\"796\":2,\"827\":7,\"837\":1,\"843\":2,\"844\":1,\"845\":3,\"860\":4,\"861\":1,\"869\":5,\"870\":5,\"871\":3,\"872\":3,\"1061\":2,\"1296\":1,\"1318\":1,\"1398\":1,\"1424\":9,\"1425\":1}}],[\"defaultmqadminext\",{\"1\":{\"1248\":2}}],[\"defaultmqxxxxconsumer\",{\"1\":{\"1110\":1,\"1111\":1,\"1112\":1,\"1118\":2}}],[\"defaultmqxxxxconsumerimpl\",{\"1\":{\"1109\":3,\"1110\":1,\"1111\":3,\"1112\":2,\"1118\":4}}],[\"defaultmqpushconsumerimpl\",{\"0\":{\"1159\":1,\"1170\":1},\"1\":{\"1019\":2,\"1021\":1,\"1119\":1,\"1120\":2,\"1145\":6,\"1155\":1,\"1159\":1,\"1175\":17,\"1188\":1,\"1195\":7,\"1197\":2,\"1225\":4,\"1229\":9,\"1230\":9}}],[\"defaultmqpushconsumer\",{\"1\":{\"985\":2,\"1007\":2,\"1019\":1,\"1109\":1,\"1120\":1,\"1122\":20,\"1136\":1,\"1170\":10,\"1175\":2,\"1194\":1,\"1195\":5,\"1197\":5,\"1229\":2,\"1230\":5,\"1248\":2,\"1444\":2}}],[\"defaultmqpullconsumer\",{\"1\":{\"805\":1,\"1109\":1,\"1136\":1,\"1288\":14}}],[\"defaultmqproducerimpl\",{\"0\":{\"1047\":1,\"1122\":1,\"1459\":1,\"1472\":1},\"1\":{\"1021\":1,\"1036\":4,\"1037\":3,\"1039\":1,\"1042\":1,\"1047\":1,\"1050\":1,\"1051\":1,\"1053\":1,\"1122\":1,\"1449\":1,\"1454\":1,\"1458\":1,\"1459\":2,\"1472\":4}}],[\"defaultmqproducer\",{\"1\":{\"984\":2,\"1006\":2,\"1021\":1,\"1036\":3,\"1037\":1,\"1047\":8,\"1048\":1,\"1050\":4,\"1051\":1,\"1053\":10,\"1123\":1,\"1235\":4,\"1287\":2,\"1459\":2,\"1460\":3,\"1472\":1}}],[\"defaulttopicperm\",{\"1\":{\"983\":2}}],[\"defaulttopicqueuenums\",{\"1\":{\"742\":1}}],[\"defaulttopic\",{\"1\":{\"742\":1}}],[\"defaultheaders\",{\"1\":{\"598\":1}}],[\"default\",{\"1\":{\"43\":3,\"62\":1,\"191\":1,\"267\":1,\"396\":1,\"618\":1,\"624\":2,\"720\":1,\"732\":1,\"984\":1,\"1000\":3,\"1006\":1,\"1047\":1,\"1048\":1,\"1050\":1,\"1053\":1,\"1075\":1,\"1122\":2,\"1123\":1,\"1143\":1,\"1144\":1,\"1172\":1,\"1173\":3,\"1175\":1,\"1195\":2,\"1198\":1,\"1224\":1,\"1266\":1,\"1287\":1,\"1299\":5,\"1306\":1,\"1309\":1,\"1331\":1,\"1370\":1,\"1371\":1,\"1432\":1,\"1436\":1,\"1443\":2,\"1459\":1,\"1460\":1,\"1472\":1,\"1497\":1,\"1499\":1,\"1519\":2,\"1520\":2}}],[\"deprecated\",{\"1\":{\"1136\":1,\"1300\":1}}],[\"depends\",{\"1\":{\"643\":4,\"645\":1,\"1078\":1}}],[\"dependency\",{\"1\":{\"643\":3,\"645\":1}}],[\"dependency>\",{\"1\":{\"8\":2,\"95\":1,\"712\":1}}],[\"dependencies\",{\"1\":{\"369\":1,\"643\":1}}],[\"depiction\",{\"1\":{\"614\":2,\"621\":2}}],[\"deploy\",{\"1\":{\"62\":1}}],[\"dversion=1\",{\"1\":{\"7\":1}}],[\"gc\",{\"1\":{\"882\":1,\"1080\":1}}],[\"gcd\",{\"1\":{\"401\":1,\"403\":3,\"411\":3,\"413\":1,\"471\":1,\"482\":1,\"492\":2}}],[\"gamma\",{\"1\":{\"690\":4}}],[\"garbage\",{\"1\":{\"688\":1}}],[\"gawu7kthldofutcajkvsmi0uvuauqp2go\",{\"1\":{\"423\":1}}],[\"gm\",{\"0\":{\"673\":1},\"1\":{\"668\":1,\"672\":2,\"673\":5}}],[\"gmt+0800\",{\"1\":{\"316\":1}}],[\"g0qa6pggkklyqcxudarc8ff\",{\"1\":{\"469\":1}}],[\"gysodjai55lcu\",{\"1\":{\"455\":1}}],[\"guava\",{\"1\":{\"1323\":1}}],[\"guaranteed\",{\"0\":{\"673\":1}}],[\"guard2\",{\"1\":{\"187\":1,\"188\":2,\"229\":1,\"232\":1}}],[\"guard1\",{\"1\":{\"187\":2,\"188\":3,\"229\":1,\"232\":1}}],[\"guardexprn`\",{\"1\":{\"186\":1}}],[\"guardexpr2\",{\"1\":{\"186\":1}}],[\"guard\",{\"1\":{\"186\":10}}],[\"guides\",{\"1\":{\"398\":1}}],[\"guide\",{\"1\":{\"398\":2}}],[\"guidence\",{\"1\":{\"381\":1}}],[\"grpc\",{\"1\":{\"1095\":1,\"1249\":1}}],[\"graph\",{\"1\":{\"886\":1}}],[\"gradually\",{\"1\":{\"861\":1}}],[\"grade\",{\"1\":{\"299\":1,\"342\":3,\"345\":5}}],[\"grant\",{\"1\":{\"626\":2}}],[\"greatly\",{\"1\":{\"886\":1,\"913\":1}}],[\"greater\",{\"1\":{\"396\":1,\"886\":1,\"906\":1,\"1270\":1}}],[\"green和blue\",{\"1\":{\"582\":1}}],[\"green\",{\"1\":{\"582\":6,\"583\":2}}],[\"greeter\",{\"1\":{\"575\":2}}],[\"greet\",{\"1\":{\"361\":4,\"364\":2,\"535\":1,\"575\":2}}],[\"group2\",{\"1\":{\"1235\":1}}],[\"group1\",{\"1\":{\"1235\":1}}],[\"groupvalue\",{\"1\":{\"1222\":6}}],[\"groupid\",{\"1\":{\"1469\":4}}],[\"groupid=\",{\"1\":{\"1173\":2,\"1469\":1}}],[\"groupid>\",{\"1\":{\"8\":2,\"64\":1,\"95\":1,\"712\":1}}],[\"group=\",{\"1\":{\"1143\":1,\"1170\":1,\"1173\":1,\"1174\":1,\"1195\":1,\"1431\":2}}],[\"group=权限\",{\"1\":{\"983\":1}}],[\"groupname\",{\"1\":{\"1017\":1,\"1200\":3,\"1247\":1}}],[\"groupcommitcount\",{\"1\":{\"1427\":2}}],[\"groupcommitsize\",{\"1\":{\"1427\":2}}],[\"groupcommitservice\",{\"1\":{\"720\":1,\"723\":1}}],[\"groupc=sub\",{\"1\":{\"983\":1}}],[\"groupb=pub|sub\",{\"1\":{\"983\":1}}],[\"groupa=deny\",{\"1\":{\"983\":1}}],[\"groupperms\",{\"1\":{\"983\":2}}],[\"grouptransferservice\",{\"1\":{\"724\":1}}],[\"group\",{\"0\":{\"904\":1},\"1\":{\"381\":1,\"673\":1,\"742\":1,\"757\":1,\"767\":3,\"886\":1,\"890\":1,\"904\":2,\"983\":1,\"1021\":1,\"1047\":3,\"1053\":1,\"1122\":2,\"1142\":1,\"1143\":1,\"1173\":15,\"1174\":5,\"1175\":1,\"1195\":2,\"1197\":1,\"1198\":5,\"1200\":1,\"1201\":5,\"1212\":1,\"1222\":6,\"1230\":2,\"1247\":3,\"1248\":4,\"1266\":5,\"1270\":1,\"1278\":1,\"1279\":1,\"1280\":1,\"1287\":1,\"1317\":1,\"1331\":4,\"1430\":4,\"1431\":3,\"1443\":1,\"1444\":1,\"1445\":3,\"1459\":1,\"1469\":1,\"1471\":7,\"1472\":5,\"1516\":1}}],[\"gn`\",{\"1\":{\"186\":1}}],[\"g2\",{\"1\":{\"186\":1}}],[\"gtk3\",{\"1\":{\"643\":4}}],[\"gt\",{\"1\":{\"154\":3}}],[\"globalwhiteremoteaddressstrategylist\",{\"1\":{\"998\":5}}],[\"globalwhiteremoteaddressstrategy用来缓存所有acl配置文件的全局白名单\",{\"1\":{\"997\":1}}],[\"globalwhiteremoteaddressstrategymap是个map类型\",{\"1\":{\"997\":1}}],[\"globalwhiteremoteaddressstrategymap\",{\"1\":{\"997\":2,\"998\":4}}],[\"globalwhiteremoteaddressstrategy\",{\"1\":{\"997\":2,\"998\":4,\"1000\":1}}],[\"globalwhiteremoteaddresseslist\",{\"1\":{\"998\":5}}],[\"globalwhiteremoteaddresses\",{\"1\":{\"983\":3,\"998\":3}}],[\"globalctxmanager\",{\"1\":{\"266\":2}}],[\"global\",{\"1\":{\"150\":1,\"1000\":1}}],[\"ggjjjjjjjjjjk\",{\"1\":{\"167\":1}}],[\"gg\",{\"1\":{\"145\":1,\"398\":1}}],[\"g\",{\"0\":{\"905\":1},\"1\":{\"143\":1,\"145\":2,\"150\":1,\"167\":2,\"290\":1,\"298\":2,\"316\":3,\"498\":1,\"500\":1,\"575\":2,\"742\":3,\"886\":1,\"890\":1,\"1079\":1,\"1247\":2,\"1248\":1}}],[\"give\",{\"1\":{\"1371\":1}}],[\"givenstaticmethodwithargs\",{\"1\":{\"106\":1}}],[\"givenstaticmethodwithnoargs\",{\"1\":{\"105\":1}}],[\"given\",{\"1\":{\"103\":1}}],[\"givenvoidreturntype\",{\"1\":{\"102\":1}}],[\"givennonvoidreturntype\",{\"1\":{\"101\":1}}],[\"git\",{\"1\":{\"850\":1,\"1070\":3}}],[\"gitbook\",{\"1\":{\"774\":1}}],[\"githubusercontent\",{\"1\":{\"165\":1,\"756\":1,\"806\":1,\"812\":1}}],[\"github\",{\"1\":{\"1\":1,\"16\":1,\"96\":2,\"107\":1,\"110\":1,\"137\":1,\"139\":1,\"165\":1,\"168\":1,\"263\":1,\"268\":1,\"272\":1,\"275\":1,\"287\":1,\"291\":1,\"370\":1,\"381\":1,\"382\":1,\"398\":1,\"493\":1,\"609\":1,\"629\":1,\"641\":1,\"645\":3,\"647\":1,\"680\":1,\"692\":1,\"705\":1,\"719\":1,\"744\":1,\"775\":1,\"799\":1,\"830\":1,\"849\":1,\"852\":1,\"862\":1,\"873\":1,\"885\":1,\"918\":1,\"939\":1,\"975\":1,\"1002\":1,\"1023\":1,\"1025\":1,\"1053\":1,\"1058\":1,\"1068\":1,\"1070\":1,\"1085\":1,\"1106\":1,\"1124\":1,\"1146\":1,\"1176\":1,\"1202\":1,\"1231\":1,\"1243\":1,\"1282\":1,\"1284\":1,\"1297\":1,\"1299\":1,\"1301\":1,\"1335\":1,\"1376\":1,\"1438\":1,\"1474\":1,\"1504\":1,\"1505\":1,\"1522\":1,\"1523\":1,\"1524\":1,\"1528\":1}}],[\"gi\",{\"1\":{\"142\":1}}],[\"go\",{\"1\":{\"1503\":2}}],[\"gotchas\",{\"1\":{\"679\":1}}],[\"google\",{\"1\":{\"298\":5}}],[\"good\",{\"1\":{\"41\":1}}],[\"goals>\",{\"1\":{\"64\":1}}],[\"goal>\",{\"1\":{\"64\":1}}],[\"goal\",{\"0\":{\"63\":1}}],[\"goal相当于class的method\",{\"1\":{\"61\":1}}],[\"gemweaver‍尼鲁布宝石编织者\",{\"1\":{\"486\":1}}],[\"gensortlist\",{\"1\":{\"1279\":1}}],[\"genackuniqueid\",{\"1\":{\"1273\":1}}],[\"gen\",{\"1\":{\"624\":1}}],[\"gender\",{\"1\":{\"316\":2,\"515\":1}}],[\"genericarraytype\",{\"1\":{\"46\":2}}],[\"generating\",{\"1\":{\"1053\":1}}],[\"generation\",{\"1\":{\"720\":3,\"736\":3}}],[\"generationtype\",{\"1\":{\"90\":1}}],[\"generator\",{\"0\":{\"332\":1},\"1\":{\"8\":1,\"184\":1}}],[\"generateoffsetmovedevent\",{\"1\":{\"1173\":1}}],[\"generatedvalue\",{\"1\":{\"90\":1}}],[\"generate\",{\"1\":{\"7\":1,\"62\":4,\"171\":1,\"193\":7,\"194\":1,\"195\":2,\"1323\":1,\"1331\":1}}],[\"geometry\",{\"1\":{\"180\":11}}],[\"getuserproperty\",{\"1\":{\"1463\":1,\"1468\":3,\"1469\":3}}],[\"getuniqid\",{\"1\":{\"1373\":1}}],[\"getuniqkey\",{\"1\":{\"794\":4}}],[\"getq\",{\"1\":{\"1275\":1}}],[\"getqueueoffset\",{\"1\":{\"819\":1,\"1173\":8,\"1175\":1,\"1229\":1,\"1278\":3,\"1280\":1,\"1371\":1,\"1427\":1,\"1432\":1,\"1459\":1,\"1460\":1,\"1468\":1,\"1469\":1}}],[\"getqueueidbybroker\",{\"1\":{\"1052\":1}}],[\"getqueueid\",{\"1\":{\"737\":2,\"762\":1,\"764\":1,\"819\":1,\"827\":1,\"843\":2,\"845\":1,\"860\":2,\"1053\":1,\"1056\":1,\"1171\":1,\"1173\":11,\"1198\":2,\"1200\":1,\"1269\":3,\"1273\":1,\"1276\":1,\"1278\":5,\"1280\":2,\"1296\":1,\"1297\":1,\"1332\":1,\"1427\":1,\"1431\":3,\"1432\":3,\"1436\":2,\"1463\":1}}],[\"getwholebuffer\",{\"1\":{\"1368\":1,\"1372\":1}}],[\"getwhichbrokerwhenconsumeslowly\",{\"1\":{\"1173\":2}}],[\"getwrotebytes\",{\"1\":{\"1198\":2}}],[\"getwroteposition\",{\"1\":{\"765\":3,\"1368\":3}}],[\"getwritequeuenums\",{\"1\":{\"1056\":1}}],[\"getjsonarray\",{\"1\":{\"998\":3}}],[\"getyamldataobject\",{\"1\":{\"998\":1}}],[\"getkvconfig\",{\"1\":{\"973\":1}}],[\"getkvconfigmanager\",{\"1\":{\"973\":1}}],[\"getkeys\",{\"1\":{\"794\":1,\"1020\":1,\"1459\":2}}],[\"getkey\",{\"1\":{\"396\":6,\"844\":1,\"971\":1,\"972\":4,\"1000\":1,\"1021\":2,\"1142\":1,\"1144\":1,\"1200\":1,\"1224\":1,\"1520\":18,\"1521\":2}}],[\"gethalfmsg\",{\"1\":{\"1453\":1,\"1468\":2}}],[\"gethashcode\",{\"1\":{\"1436\":2}}],[\"gethaserveraddr\",{\"1\":{\"971\":1}}],[\"getheartbeatbrokerinterval\",{\"1\":{\"1048\":1}}],[\"gethoststring\",{\"1\":{\"888\":1}}],[\"gethostname\",{\"1\":{\"888\":1}}],[\"getrawslot\",{\"1\":{\"1367\":2}}],[\"getrunningflags\",{\"1\":{\"1297\":3}}],[\"getruntime\",{\"1\":{\"960\":1}}],[\"getrole\",{\"1\":{\"1521\":2}}],[\"getrouteinfomanager\",{\"1\":{\"973\":1}}],[\"getrouteinforequestheader\",{\"1\":{\"973\":3}}],[\"getrouteinfobytopic\",{\"1\":{\"957\":1,\"973\":2}}],[\"getrocketmqhome\",{\"1\":{\"960\":2}}],[\"getrealtopic\",{\"1\":{\"1371\":1,\"1374\":1}}],[\"getreadaheadmessagesizethreshold\",{\"1\":{\"1432\":1}}],[\"getreadaheadmessagecountthreshold\",{\"1\":{\"1431\":1,\"1432\":1}}],[\"getreadbehind\",{\"1\":{\"1278\":1}}],[\"getreadqueuenums\",{\"1\":{\"1173\":2,\"1269\":6}}],[\"getrebalanceimpl\",{\"1\":{\"1288\":1}}],[\"getreviveoffset\",{\"1\":{\"1279\":3}}],[\"getrevivescantime\",{\"1\":{\"1278\":1}}],[\"getrevivemessage\",{\"1\":{\"1278\":1}}],[\"getrevivetime\",{\"1\":{\"1275\":1,\"1276\":1,\"1277\":1,\"1278\":1,\"1279\":1,\"1280\":1}}],[\"getrevivequeueoffset\",{\"1\":{\"1277\":2}}],[\"getrevivequeuenum\",{\"1\":{\"1269\":1}}],[\"getreviveqid\",{\"1\":{\"1273\":1}}],[\"getretrymaxtimes\",{\"1\":{\"1198\":1}}],[\"getretryqueuenums\",{\"1\":{\"1198\":3}}],[\"getretrytopic\",{\"1\":{\"1197\":1,\"1198\":1}}],[\"getretrytimeswhensendasyncfailed\",{\"1\":{\"1053\":1}}],[\"getretrytimeswhensendfailed\",{\"1\":{\"1050\":1}}],[\"getreconsumetime\",{\"1\":{\"1053\":1}}],[\"getreconsumetimes\",{\"1\":{\"737\":2,\"1020\":1,\"1056\":2,\"1195\":1,\"1197\":2,\"1198\":3,\"1280\":2,\"1462\":1}}],[\"getrequestid\",{\"1\":{\"1020\":1}}],[\"getrequestcode\",{\"1\":{\"1000\":2}}],[\"getrequestcommand\",{\"1\":{\"825\":2}}],[\"getregionid\",{\"1\":{\"1020\":1,\"1021\":1}}],[\"getresponseremark\",{\"1\":{\"1464\":1}}],[\"getresponsecode\",{\"1\":{\"1464\":3}}],[\"getresourcepermmap\",{\"1\":{\"1000\":2}}],[\"getresult\",{\"1\":{\"767\":2,\"1174\":16,\"1468\":13}}],[\"getremoteid\",{\"1\":{\"1516\":2}}],[\"getremoteaddressstrategy\",{\"1\":{\"998\":1,\"1000\":1}}],[\"getremotesocketaddress\",{\"1\":{\"69\":1}}],[\"getremark\",{\"1\":{\"894\":1}}],[\"getvoteresult\",{\"1\":{\"1497\":2}}],[\"getvoteresponse\",{\"1\":{\"1497\":1}}],[\"getversion\",{\"1\":{\"894\":1,\"1198\":1}}],[\"getvalue\",{\"1\":{\"844\":1,\"971\":2,\"972\":5,\"1000\":1,\"1021\":1,\"1144\":1,\"1200\":1,\"1224\":1,\"1277\":1,\"1436\":1,\"1520\":9,\"1521\":1}}],[\"getledgerbeginindex\",{\"1\":{\"1519\":7,\"1520\":1,\"1521\":2}}],[\"getledgerendterm\",{\"1\":{\"1497\":1,\"1503\":8}}],[\"getledgerendindex\",{\"1\":{\"1497\":1,\"1503\":4,\"1519\":8,\"1520\":3,\"1521\":4}}],[\"getleaderid\",{\"1\":{\"1495\":1,\"1496\":1,\"1500\":12,\"1503\":7,\"1516\":1,\"1519\":2,\"1520\":2,\"1521\":1}}],[\"getlength\",{\"1\":{\"72\":2,\"73\":1}}],[\"getlanguage\",{\"1\":{\"894\":1}}],[\"getlastappliedindex\",{\"1\":{\"1521\":2}}],[\"getlastentryindex\",{\"1\":{\"1520\":1}}],[\"getlastmodifiedtimestamp\",{\"1\":{\"870\":1}}],[\"getlastmappedfile\",{\"1\":{\"765\":1,\"1368\":3}}],[\"getlastindexfile\",{\"1\":{\"793\":1}}],[\"getlogger\",{\"1\":{\"960\":2,\"1514\":1}}],[\"getlogicsmsgtimestamp\",{\"1\":{\"769\":1}}],[\"getlong\",{\"1\":{\"767\":2,\"771\":2,\"797\":1,\"845\":2,\"860\":2,\"1174\":2,\"1367\":3,\"1370\":2,\"1372\":3,\"1468\":1}}],[\"getnum\",{\"1\":{\"1277\":1,\"1280\":1}}],[\"getnexttimetorequestvote\",{\"1\":{\"1497\":6}}],[\"getnextsealedfile\",{\"1\":{\"1435\":1}}],[\"getnextbeginoffset\",{\"1\":{\"1173\":3,\"1175\":5,\"1229\":1,\"1270\":6,\"1271\":2,\"1431\":2,\"1468\":3}}],[\"getnextoffset\",{\"1\":{\"861\":1,\"1170\":2,\"1175\":2,\"1228\":1,\"1229\":1}}],[\"getnotnullannotation\",{\"1\":{\"742\":1}}],[\"getnamesrvaddr\",{\"1\":{\"1048\":2,\"1123\":1}}],[\"getnamesrvconfig\",{\"1\":{\"973\":1}}],[\"getnameserveraddresslist\",{\"1\":{\"970\":1}}],[\"getnamespacefromresource\",{\"1\":{\"1198\":1}}],[\"getnamespace\",{\"1\":{\"886\":1,\"901\":1,\"902\":1,\"903\":1,\"1053\":5,\"1195\":1,\"1197\":1,\"1230\":1,\"1458\":1,\"1471\":2}}],[\"getname\",{\"1\":{\"41\":1,\"90\":1,\"580\":2,\"742\":1,\"985\":1,\"995\":1,\"1007\":1,\"1143\":2,\"1248\":1,\"1444\":1,\"1519\":1,\"1520\":1,\"1521\":1}}],[\"getmintimestamp\",{\"1\":{\"1435\":1}}],[\"getminoffset\",{\"1\":{\"871\":1,\"872\":1,\"1173\":2,\"1430\":2,\"1432\":3}}],[\"getminoffsetinqueue\",{\"1\":{\"845\":1,\"860\":1,\"1174\":1,\"1370\":3,\"1427\":1}}],[\"getm\",{\"1\":{\"1332\":1}}],[\"getmode\",{\"1\":{\"1266\":1}}],[\"getmodifiers\",{\"1\":{\"742\":1}}],[\"getmqset\",{\"1\":{\"1226\":1}}],[\"getmqclientfactory\",{\"1\":{\"1145\":1,\"1288\":1}}],[\"getmqclientapiimpl\",{\"1\":{\"1053\":2,\"1171\":1,\"1197\":1,\"1200\":2,\"1226\":1,\"1460\":1,\"1472\":1}}],[\"getmqtracecontext\",{\"1\":{\"1020\":1}}],[\"getmappedbytebuffer\",{\"1\":{\"1435\":1}}],[\"getmappedfiles\",{\"1\":{\"771\":1}}],[\"getmagic\",{\"1\":{\"1373\":2,\"1374\":3}}],[\"getmaxpushtimeoutms\",{\"1\":{\"1519\":1}}],[\"getmaxwroteposition\",{\"1\":{\"1519\":1}}],[\"getmaxwaitacktimems\",{\"1\":{\"1518\":2}}],[\"getmaxoffset\",{\"1\":{\"1173\":2,\"1174\":1,\"1270\":1,\"1430\":5,\"1431\":2,\"1432\":7,\"1468\":2}}],[\"getmaxoffsetinqueue\",{\"1\":{\"823\":1,\"825\":1,\"860\":1,\"1174\":3,\"1270\":4,\"1427\":1}}],[\"getmaxmsgnums\",{\"1\":{\"1173\":1,\"1269\":1,\"1270\":3}}],[\"getmaxmsgsnumbatch\",{\"1\":{\"794\":1}}],[\"getmaxspan\",{\"1\":{\"1170\":2}}],[\"getmaxreconsumetimes\",{\"1\":{\"1053\":1,\"1197\":2,\"1198\":1}}],[\"getmaxdelaylevel\",{\"1\":{\"843\":2}}],[\"getmsg\",{\"1\":{\"1371\":3,\"1374\":3,\"1468\":3}}],[\"getmsgstoretime\",{\"1\":{\"1333\":1}}],[\"getmsgs\",{\"1\":{\"1195\":12}}],[\"getmsgsize\",{\"1\":{\"762\":1,\"1170\":1,\"1297\":2}}],[\"getmsgfoundlist\",{\"1\":{\"1175\":6,\"1229\":6,\"1288\":1,\"1468\":1}}],[\"getmsgtreemap\",{\"1\":{\"1170\":6}}],[\"getmsgcount4commercial\",{\"1\":{\"1173\":1}}],[\"getmsgcount\",{\"1\":{\"1170\":1}}],[\"getmsglist\",{\"1\":{\"1020\":6}}],[\"getmsgid\",{\"1\":{\"738\":2,\"845\":1,\"860\":2,\"1020\":1,\"1197\":1,\"1198\":1,\"1459\":1,\"1460\":3,\"1464\":2,\"1469\":2,\"1472\":1}}],[\"getmergekey\",{\"1\":{\"1275\":1}}],[\"getmessagenullcount++\",{\"1\":{\"1468\":1}}],[\"getmessagenullcount\",{\"1\":{\"1468\":3}}],[\"getmessagetype\",{\"1\":{\"1462\":2}}],[\"getmessagetmpresult\",{\"1\":{\"1270\":27,\"1271\":5}}],[\"getmessagefromcache\",{\"1\":{\"1431\":2}}],[\"getmessagefromcacheasync\",{\"0\":{\"1431\":1},\"1\":{\"1409\":1,\"1430\":1,\"1431\":1}}],[\"getmessagefromtieredstoreasync\",{\"0\":{\"1432\":1},\"1\":{\"1408\":1,\"1409\":1,\"1430\":1,\"1431\":1,\"1432\":4}}],[\"getmessagefilter\",{\"1\":{\"825\":2}}],[\"getmessageasync\",{\"0\":{\"1430\":1},\"1\":{\"1401\":2,\"1405\":2,\"1407\":1,\"1430\":1}}],[\"getmessagebycommitoffset\",{\"1\":{\"1370\":1,\"1373\":1}}],[\"getmessagebinary\",{\"1\":{\"1329\":1}}],[\"getmessagebufferlist\",{\"1\":{\"1269\":1}}],[\"getmessagemapedlist\",{\"1\":{\"1269\":1,\"1270\":5,\"1431\":1}}],[\"getmessagemodel\",{\"1\":{\"1122\":4,\"1170\":1,\"1173\":1,\"1195\":1}}],[\"getmessagecount\",{\"1\":{\"1173\":2,\"1174\":1,\"1270\":2,\"1431\":1}}],[\"getmessagequeueoffset\",{\"1\":{\"1270\":2,\"1271\":1,\"1431\":1}}],[\"getmessagequeue\",{\"1\":{\"1170\":5,\"1175\":8,\"1195\":5,\"1197\":1,\"1228\":1,\"1229\":4,\"1427\":5,\"1431\":2,\"1432\":5,\"1459\":1,\"1460\":1}}],[\"getmessagequeuelist\",{\"1\":{\"1052\":3}}],[\"getmessagelistenerinner\",{\"1\":{\"1122\":4}}],[\"getmessagestoreplugin\",{\"1\":{\"1425\":1}}],[\"getmessagestore\",{\"1\":{\"819\":1,\"823\":1,\"825\":1,\"1056\":1,\"1173\":4,\"1198\":2,\"1270\":6,\"1278\":2,\"1462\":2}}],[\"getmessagestoreconfig\",{\"1\":{\"762\":1,\"769\":2,\"794\":1,\"827\":1,\"844\":1,\"860\":1,\"870\":4,\"871\":1,\"872\":1,\"1173\":4,\"1296\":2,\"1297\":4,\"1464\":1}}],[\"getmessagestatus\",{\"1\":{\"767\":2,\"1174\":14,\"1269\":2,\"1270\":7,\"1430\":5,\"1431\":4,\"1432\":7}}],[\"getmessageresultext\",{\"1\":{\"1431\":1,\"1432\":2}}],[\"getmessageresult\",{\"1\":{\"757\":1,\"767\":1,\"1173\":24,\"1174\":4,\"1269\":12,\"1270\":8,\"1271\":1,\"1430\":2}}],[\"getmessage\",{\"0\":{\"767\":1},\"1\":{\"112\":2,\"113\":2,\"757\":2,\"766\":1,\"767\":2,\"1173\":2,\"1174\":4,\"1270\":2,\"1318\":3}}],[\"getmeaning\",{\"1\":{\"101\":2}}],[\"getmethods\",{\"1\":{\"39\":1}}],[\"getmethod\",{\"1\":{\"39\":1}}],[\"getflatfile\",{\"1\":{\"1430\":1}}],[\"getflagbits\",{\"1\":{\"1174\":1}}],[\"getflag\",{\"1\":{\"737\":2,\"894\":1,\"1053\":1,\"1056\":1,\"1197\":1,\"1198\":1}}],[\"getflushconsumeroffsetinterval\",{\"1\":{\"1201\":1}}],[\"getflushconsumequeuethoroughinterval\",{\"1\":{\"769\":1}}],[\"getflushconsumequeueleastpages\",{\"1\":{\"769\":1}}],[\"getflushdelayoffsetinterval\",{\"1\":{\"844\":1}}],[\"getfirstentryindex\",{\"1\":{\"1520\":4}}],[\"getfilterbitmap\",{\"1\":{\"1333\":1}}],[\"getfiletowrite\",{\"1\":{\"1435\":2}}],[\"getfilesegmentlist\",{\"1\":{\"1435\":1}}],[\"getfilestatus\",{\"1\":{\"1435\":2}}],[\"getfilesize\",{\"1\":{\"1368\":3}}],[\"getfilelock\",{\"1\":{\"1427\":3}}],[\"getfilereservedtime\",{\"1\":{\"870\":1}}],[\"getfilefromoffset\",{\"1\":{\"765\":1,\"771\":2,\"1368\":1}}],[\"getfilename\",{\"1\":{\"765\":1,\"771\":4}}],[\"getfields\",{\"1\":{\"38\":1}}],[\"getfield\",{\"1\":{\"38\":1}}],[\"getslotvalue\",{\"1\":{\"1434\":1,\"1435\":1,\"1436\":1}}],[\"getslotposition\",{\"1\":{\"1434\":1,\"1435\":1,\"1436\":2}}],[\"getslot\",{\"1\":{\"1367\":1,\"1371\":1,\"1372\":1}}],[\"getslotindex\",{\"1\":{\"1367\":3}}],[\"getso\",{\"1\":{\"1275\":1}}],[\"getsystemclock\",{\"1\":{\"1174\":2}}],[\"getsysflag\",{\"1\":{\"737\":4,\"738\":1,\"764\":1,\"794\":1,\"843\":1,\"1173\":3,\"1198\":1,\"1463\":1,\"1464\":1}}],[\"getsignature\",{\"1\":{\"1000\":1}}],[\"getsizefromitem\",{\"1\":{\"1432\":2}}],[\"getsizepy\",{\"1\":{\"1371\":1,\"1373\":1}}],[\"getsize\",{\"1\":{\"762\":1,\"767\":1,\"845\":1,\"860\":1,\"1174\":1,\"1370\":1,\"1427\":4,\"1428\":1,\"1431\":1,\"1432\":2,\"1519\":1}}],[\"getselfid\",{\"1\":{\"1495\":1,\"1497\":4,\"1499\":3,\"1500\":3,\"1502\":2,\"1503\":2,\"1516\":4,\"1517\":1,\"1518\":2,\"1519\":3,\"1520\":1,\"1521\":6}}],[\"getsendmsgtimeout\",{\"1\":{\"1460\":1}}],[\"getsendwhichqueue\",{\"1\":{\"1052\":2}}],[\"getsendstatus\",{\"1\":{\"1050\":1,\"1459\":2}}],[\"getsecretkey\",{\"1\":{\"995\":1,\"1000\":1}}],[\"getsecuritytoken\",{\"1\":{\"995\":3}}],[\"getserverworkerthreads\",{\"1\":{\"961\":1}}],[\"getservicename\",{\"1\":{\"824\":3,\"999\":3,\"1140\":2,\"1168\":2,\"1371\":2,\"1373\":3,\"1374\":3,\"1427\":2,\"1435\":1}}],[\"getscheduleasyncdelivermaxpendinglimit\",{\"1\":{\"860\":1}}],[\"getschedulemessageservice\",{\"1\":{\"843\":2}}],[\"getsuggestwhichbrokerid\",{\"1\":{\"1173\":2,\"1329\":1}}],[\"getsuspendtimeoutmillis\",{\"1\":{\"1173\":1}}],[\"getsuspendtimestamp\",{\"1\":{\"825\":1}}],[\"getsubscription\",{\"1\":{\"1173\":3}}],[\"getsubscriptiongroupmanager\",{\"1\":{\"1173\":1,\"1198\":1,\"1279\":1}}],[\"getsubscriptioninner\",{\"1\":{\"1142\":1,\"1170\":2}}],[\"getsubstring\",{\"1\":{\"1170\":1,\"1173\":1,\"1328\":1}}],[\"getsubversion\",{\"1\":{\"1145\":1,\"1170\":1,\"1173\":5}}],[\"getsuperclass\",{\"1\":{\"40\":1}}],[\"getsuppressed\",{\"1\":{\"34\":1}}],[\"getshortpollingtimemills\",{\"1\":{\"819\":1,\"824\":1,\"1173\":1}}],[\"getstring\",{\"1\":{\"998\":1}}],[\"getstatus\",{\"1\":{\"861\":1,\"1173\":2,\"1269\":1,\"1270\":7,\"1280\":1,\"1431\":5}}],[\"getstartoffset\",{\"1\":{\"762\":1,\"1276\":1,\"1278\":3,\"1372\":1,\"1431\":1,\"1432\":1}}],[\"getstoresize\",{\"1\":{\"1020\":1}}],[\"getstorecheckpoint\",{\"1\":{\"769\":3,\"793\":1,\"796\":2,\"1297\":2}}],[\"getstorehost\",{\"1\":{\"737\":1,\"738\":1,\"1056\":1,\"1197\":1,\"1198\":1,\"1273\":2,\"1280\":2}}],[\"getstorehostbytes\",{\"1\":{\"737\":1}}],[\"getstoretimestamp\",{\"1\":{\"737\":2,\"738\":1,\"762\":1,\"827\":1,\"1020\":1,\"1280\":1,\"1297\":3,\"1370\":1,\"1427\":3,\"1464\":1,\"1468\":3}}],[\"gettagcode\",{\"1\":{\"1432\":1}}],[\"gettagcodelist\",{\"1\":{\"1431\":1}}],[\"gettagsset\",{\"1\":{\"1329\":2}}],[\"gettags\",{\"1\":{\"1020\":1,\"1198\":1,\"1278\":2,\"1280\":2,\"1329\":2,\"1459\":2}}],[\"gettagscode\",{\"1\":{\"762\":1,\"827\":1,\"845\":1,\"860\":1,\"1174\":1,\"1297\":3,\"1427\":1}}],[\"gettieredstorefilereservedtime\",{\"1\":{\"1435\":1}}],[\"gettieredstoregroupcommittimeout\",{\"1\":{\"1427\":1}}],[\"gettieredstoregroupcommitcount\",{\"1\":{\"1427\":3}}],[\"gettieredstoregroupcommitsize\",{\"1\":{\"1427\":2}}],[\"gettimediff\",{\"1\":{\"1436\":1}}],[\"gettimermessagestore\",{\"1\":{\"1278\":2}}],[\"gettimestamp\",{\"1\":{\"1020\":1,\"1434\":1,\"1435\":13,\"1436\":4}}],[\"gettimeoutmillis\",{\"1\":{\"825\":1}}],[\"gettostorebits\",{\"1\":{\"1277\":2}}],[\"gettopicid\",{\"1\":{\"1427\":1}}],[\"gettopicsubscribeinfo\",{\"1\":{\"1266\":2}}],[\"gettopicrouteinfomanager\",{\"1\":{\"1266\":1}}],[\"gettopicconfigmanager\",{\"1\":{\"1056\":1,\"1173\":1,\"1198\":2,\"1269\":2,\"1279\":1}}],[\"gettopicconfigtable\",{\"1\":{\"971\":1,\"1424\":2}}],[\"gettopic\",{\"1\":{\"737\":2,\"762\":1,\"764\":1,\"794\":1,\"819\":1,\"827\":1,\"843\":2,\"845\":3,\"860\":2,\"973\":3,\"1020\":1,\"1021\":1,\"1050\":3,\"1053\":5,\"1056\":2,\"1144\":1,\"1170\":2,\"1171\":3,\"1173\":24,\"1175\":3,\"1195\":4,\"1197\":3,\"1198\":7,\"1200\":2,\"1224\":1,\"1229\":2,\"1230\":1,\"1267\":1,\"1269\":3,\"1270\":2,\"1273\":2,\"1276\":1,\"1278\":4,\"1279\":2,\"1280\":7,\"1296\":1,\"1297\":1,\"1332\":3,\"1427\":2,\"1431\":3,\"1432\":3,\"1458\":1,\"1459\":2,\"1460\":1,\"1463\":1,\"1464\":3,\"1469\":1,\"1471\":1,\"1472\":1}}],[\"gett\",{\"1\":{\"1275\":1}}],[\"gettryunlocktimes\",{\"1\":{\"1225\":1}}],[\"gettransferee\",{\"1\":{\"1516\":1,\"1517\":1}}],[\"gettranstatetableoffset\",{\"1\":{\"1464\":1,\"1472\":1}}],[\"gettransactionalmessagechecklistener\",{\"1\":{\"1467\":1}}],[\"gettransactionalmessageservice\",{\"1\":{\"1056\":1,\"1462\":4,\"1464\":6,\"1467\":1}}],[\"gettransactioncheckmax\",{\"1\":{\"1467\":1}}],[\"gettransactioncheckinterval\",{\"1\":{\"1467\":1}}],[\"gettransactiontimeout\",{\"1\":{\"1467\":1}}],[\"gettransactionmetrics\",{\"1\":{\"1462\":2,\"1464\":2}}],[\"gettransactionid\",{\"1\":{\"1442\":2,\"1459\":5,\"1460\":1,\"1472\":1}}],[\"gettransactionvalue\",{\"1\":{\"764\":1,\"794\":1,\"843\":1}}],[\"gettracebeans\",{\"1\":{\"1020\":3,\"1021\":2}}],[\"gettype\",{\"1\":{\"742\":1,\"1520\":7}}],[\"getterm\",{\"1\":{\"1497\":2,\"1499\":1,\"1500\":6,\"1503\":4,\"1518\":4,\"1519\":2,\"1520\":6}}],[\"getter\",{\"1\":{\"567\":1,\"606\":1}}],[\"getpeerwatermark\",{\"1\":{\"1519\":2}}],[\"getpeerpushthrottlepoint\",{\"1\":{\"1519\":1}}],[\"getpeerpushquota\",{\"1\":{\"1519\":1}}],[\"getpeerslivetable\",{\"1\":{\"1499\":3}}],[\"getpeermap\",{\"1\":{\"1499\":1,\"1502\":1,\"1518\":1}}],[\"getperm\",{\"1\":{\"1173\":1,\"1198\":1}}],[\"getpersistconsumeroffsetinterval\",{\"1\":{\"1048\":1}}],[\"getpt\",{\"1\":{\"1275\":1}}],[\"getpos\",{\"1\":{\"1427\":2,\"1516\":1,\"1518\":4,\"1519\":2,\"1520\":1,\"1521\":1}}],[\"getpopckstaybuffertime\",{\"1\":{\"1276\":1,\"1277\":2}}],[\"getpopckstaybuffertimeout\",{\"1\":{\"1275\":1,\"1276\":1,\"1277\":1}}],[\"getpopckmaxbuffersize\",{\"1\":{\"1275\":1}}],[\"getpopbuffermergeservice\",{\"1\":{\"1273\":1}}],[\"getpopmessageprocessor\",{\"1\":{\"1273\":1,\"1280\":2}}],[\"getpoptime\",{\"1\":{\"1273\":2,\"1276\":2,\"1277\":2,\"1278\":3,\"1280\":2}}],[\"getpopoffset\",{\"1\":{\"1270\":2}}],[\"getpopsharequeuenum\",{\"1\":{\"1266\":1}}],[\"getpollnameserverinterval\",{\"1\":{\"1048\":1}}],[\"getport\",{\"1\":{\"515\":1}}],[\"getputmessagefutureexecutor\",{\"1\":{\"1462\":1}}],[\"getputmessagestatus\",{\"1\":{\"845\":1,\"861\":1,\"1198\":2,\"1273\":4,\"1462\":1}}],[\"getpullresult\",{\"1\":{\"1468\":6}}],[\"getpullrequestholdservice\",{\"1\":{\"819\":1,\"1173\":1}}],[\"getpullinterval\",{\"1\":{\"1175\":2,\"1229\":2}}],[\"getpullstatus\",{\"1\":{\"1175\":1,\"1229\":1,\"1329\":1,\"1468\":4}}],[\"getpullbatchsize\",{\"1\":{\"1170\":1}}],[\"getpullthresholdsizeforqueue\",{\"1\":{\"1145\":1,\"1170\":2}}],[\"getpullthresholdsizefortopic\",{\"1\":{\"1145\":1}}],[\"getpullthresholdforqueue\",{\"1\":{\"1145\":1,\"1170\":2}}],[\"getpullthresholdfortopic\",{\"1\":{\"1145\":1}}],[\"getpullmessageprocessor\",{\"1\":{\"825\":2}}],[\"getpullmessageexecutor\",{\"1\":{\"820\":1}}],[\"getpullfromthisoffset\",{\"1\":{\"825\":2}}],[\"getpreparemessage\",{\"1\":{\"1464\":11}}],[\"getpreparedtransactionoffset\",{\"1\":{\"737\":2}}],[\"getproducermanager\",{\"1\":{\"1469\":1}}],[\"getproducergroup\",{\"1\":{\"1047\":4,\"1053\":2,\"1459\":1,\"1460\":1,\"1472\":1}}],[\"getprocessqueue\",{\"1\":{\"1170\":2,\"1175\":1,\"1195\":3,\"1228\":1}}],[\"getprops\",{\"1\":{\"1020\":1,\"1195\":1,\"1230\":1}}],[\"getproperty\",{\"1\":{\"1020\":2,\"1053\":4,\"1198\":2,\"1296\":1,\"1299\":2,\"1370\":1,\"1371\":2,\"1373\":2,\"1459\":1,\"1462\":2,\"1464\":2,\"1469\":1,\"1471\":2}}],[\"getproperties\",{\"1\":{\"843\":1,\"1053\":1,\"1056\":3,\"1197\":1,\"1198\":3,\"1273\":2,\"1280\":5,\"1427\":1,\"1463\":1,\"1472\":1}}],[\"getpropertiesmap\",{\"1\":{\"762\":1,\"827\":1,\"1297\":2,\"1332\":2}}],[\"getpropertiesstring\",{\"1\":{\"737\":4}}],[\"getphysicalnode\",{\"1\":{\"396\":2}}],[\"getpassword\",{\"1\":{\"90\":1}}],[\"getpath\",{\"1\":{\"52\":1,\"793\":1,\"1428\":1}}],[\"get请求的地址不是类似\",{\"1\":{\"368\":1}}],[\"geterrorcode\",{\"1\":{\"1432\":1}}],[\"getescapebridge\",{\"1\":{\"1273\":1,\"1280\":1}}],[\"getentry\",{\"1\":{\"1520\":12}}],[\"getenqueuetime\",{\"1\":{\"1374\":1}}],[\"getenqueuebehind\",{\"1\":{\"1278\":1}}],[\"getendindex\",{\"1\":{\"1519\":4}}],[\"getendphyoffset\",{\"1\":{\"793\":1,\"794\":2,\"872\":2}}],[\"getendtimestamp\",{\"1\":{\"793\":2,\"794\":1,\"796\":1,\"1435\":1}}],[\"getencode\",{\"1\":{\"737\":1}}],[\"getexpression\",{\"1\":{\"1333\":2}}],[\"getexpressiontype\",{\"1\":{\"1170\":1,\"1173\":6,\"1328\":1,\"1333\":2}}],[\"getextrainfo\",{\"1\":{\"1273\":1}}],[\"getext\",{\"1\":{\"845\":1,\"860\":1,\"1174\":1}}],[\"getextfields\",{\"1\":{\"742\":1,\"894\":1,\"1173\":1}}],[\"getexistingreplicas\",{\"1\":{\"396\":2}}],[\"getelementbyid\",{\"1\":{\"348\":2,\"349\":1}}],[\"getemail\",{\"1\":{\"90\":1}}],[\"getgetmessagetimestotalmiss\",{\"1\":{\"1174\":1}}],[\"getgetmessagetimestotalfound\",{\"1\":{\"1174\":1}}],[\"getgetmessagetransferedmsgcount\",{\"1\":{\"1174\":1}}],[\"getgenericsuperclass\",{\"1\":{\"48\":1}}],[\"getgroup\",{\"1\":{\"1198\":6,\"1499\":1,\"1502\":1,\"1516\":5,\"1518\":1,\"1519\":2,\"1520\":1,\"1521\":2}}],[\"getgroupname\",{\"1\":{\"1020\":1}}],[\"getgrade\",{\"1\":{\"342\":1}}],[\"getbatchentry\",{\"1\":{\"1520\":2}}],[\"getbatchmsgs\",{\"1\":{\"1516\":4}}],[\"getbatchsize\",{\"1\":{\"1296\":1}}],[\"getbloomfilterdata\",{\"1\":{\"1332\":2,\"1333\":3}}],[\"getbloomfilter\",{\"1\":{\"1332\":2,\"1333\":1}}],[\"getbizmessage\",{\"1\":{\"1280\":1}}],[\"getbitnum\",{\"1\":{\"1333\":1}}],[\"getbit\",{\"1\":{\"1277\":2,\"1280\":1}}],[\"getbits\",{\"1\":{\"1276\":1,\"1277\":1}}],[\"getbitmap\",{\"1\":{\"762\":1,\"827\":1,\"1278\":1,\"1280\":1,\"1297\":1}}],[\"getbroker2client\",{\"1\":{\"1331\":1,\"1469\":1}}],[\"getbrokerstatsmanager\",{\"1\":{\"1173\":4,\"1198\":5,\"1270\":3,\"1273\":2}}],[\"getbrokerid\",{\"1\":{\"1173\":2}}],[\"getbrokerip1\",{\"1\":{\"1056\":1,\"1173\":1,\"1198\":1,\"1462\":1}}],[\"getbrokerpermission\",{\"1\":{\"1173\":1,\"1198\":1}}],[\"getbrokeraddrtable\",{\"1\":{\"1248\":1}}],[\"getbrokeraddr\",{\"1\":{\"1171\":1,\"1200\":2,\"1226\":1}}],[\"getbrokeraddrs\",{\"1\":{\"971\":3,\"972\":2}}],[\"getbrokerversion\",{\"1\":{\"1171\":2}}],[\"getbrokerclustername\",{\"1\":{\"1056\":1}}],[\"getbrokerconfigpath\",{\"1\":{\"1523\":1}}],[\"getbrokerconfig\",{\"1\":{\"819\":2,\"824\":2,\"1056\":3,\"1173\":11,\"1198\":2,\"1266\":1,\"1269\":2,\"1270\":2,\"1275\":5,\"1276\":6,\"1277\":4,\"1278\":3,\"1280\":1,\"1331\":1,\"1425\":1,\"1462\":3,\"1467\":3,\"1469\":1}}],[\"getbrokernamefrommessagequeue\",{\"1\":{\"1460\":1}}],[\"getbrokername\",{\"1\":{\"972\":3,\"1050\":3,\"1052\":2,\"1053\":5,\"1171\":4,\"1173\":1,\"1197\":1,\"1200\":3,\"1226\":1,\"1267\":1,\"1270\":2,\"1273\":1,\"1276\":1,\"1280\":1,\"1469\":1,\"1472\":1}}],[\"getbrokerrole\",{\"1\":{\"762\":1,\"827\":1,\"1173\":3,\"1297\":1,\"1464\":1}}],[\"getbeginindex\",{\"1\":{\"1519\":2}}],[\"getbegintimestamp\",{\"1\":{\"794\":1,\"797\":3}}],[\"getbean\",{\"1\":{\"266\":3}}],[\"getbuffertotalsize\",{\"1\":{\"767\":2,\"1173\":3,\"1174\":4,\"1270\":1}}],[\"getbuffersize\",{\"1\":{\"762\":2}}],[\"getbornhostnamestring\",{\"1\":{\"888\":1}}],[\"getbornhost\",{\"1\":{\"737\":1,\"1198\":1}}],[\"getbornhostbytes\",{\"1\":{\"737\":1}}],[\"getborntimestamp\",{\"1\":{\"737\":2,\"1056\":1,\"1198\":1,\"1280\":1,\"1464\":1,\"1468\":3}}],[\"getbodycrc\",{\"1\":{\"737\":2}}],[\"getbody\",{\"1\":{\"737\":6,\"1053\":1,\"1056\":1,\"1197\":1,\"1198\":1,\"1278\":2,\"1280\":1,\"1471\":1,\"1516\":1,\"1517\":1}}],[\"getbytebuffer\",{\"1\":{\"762\":1,\"767\":3,\"845\":3,\"860\":3,\"1174\":4,\"1370\":3,\"1372\":8,\"1427\":3,\"1431\":1,\"1432\":2,\"1434\":1}}],[\"getbytes\",{\"1\":{\"72\":1,\"73\":1,\"123\":1,\"125\":2,\"133\":1,\"396\":1,\"712\":1,\"714\":1,\"715\":1,\"737\":4,\"835\":1,\"984\":1,\"1006\":1,\"1273\":1,\"1287\":1,\"1306\":1,\"1309\":1,\"1339\":1,\"1443\":1}}],[\"getbyname\",{\"1\":{\"73\":1}}],[\"get\",{\"0\":{\"197\":1},\"1\":{\"92\":1,\"97\":1,\"125\":1,\"217\":8,\"223\":1,\"253\":1,\"301\":3,\"348\":1,\"349\":2,\"354\":1,\"368\":1,\"396\":2,\"567\":1,\"568\":1,\"606\":2,\"618\":1,\"624\":2,\"627\":2,\"643\":2,\"644\":2,\"645\":1,\"646\":2,\"738\":1,\"742\":14,\"771\":2,\"793\":1,\"794\":1,\"822\":1,\"825\":1,\"844\":2,\"860\":1,\"861\":1,\"872\":1,\"971\":4,\"995\":2,\"998\":9,\"999\":3,\"1000\":4,\"1020\":1,\"1021\":3,\"1051\":3,\"1052\":2,\"1056\":1,\"1143\":3,\"1145\":1,\"1170\":4,\"1173\":2,\"1175\":1,\"1194\":2,\"1195\":2,\"1200\":2,\"1201\":1,\"1222\":2,\"1226\":1,\"1229\":1,\"1266\":2,\"1267\":1,\"1275\":2,\"1276\":1,\"1277\":2,\"1278\":2,\"1279\":2,\"1280\":2,\"1297\":4,\"1331\":1,\"1332\":1,\"1367\":12,\"1370\":3,\"1371\":1,\"1373\":3,\"1427\":2,\"1428\":1,\"1431\":3,\"1432\":1,\"1434\":5,\"1435\":3,\"1436\":8,\"1442\":1,\"1462\":1,\"1468\":4,\"1472\":1,\"1497\":16,\"1499\":15,\"1500\":1,\"1503\":1,\"1517\":2,\"1518\":2,\"1519\":17,\"1520\":4,\"1521\":6}}],[\"getimmunitytime\",{\"1\":{\"1468\":2}}],[\"getitemindex\",{\"1\":{\"1436\":1}}],[\"getitemposition\",{\"1\":{\"1434\":1,\"1435\":1,\"1436\":1}}],[\"getip\",{\"1\":{\"1017\":1}}],[\"getiloggerfactory\",{\"1\":{\"960\":1}}],[\"getid\",{\"1\":{\"90\":1}}],[\"getinvisibletime\",{\"1\":{\"1269\":1,\"1270\":2,\"1273\":1}}],[\"getindex\",{\"1\":{\"1517\":2,\"1518\":4,\"1519\":4,\"1520\":8}}],[\"getindexcount\",{\"1\":{\"797\":9}}],[\"getindexmsgtimestamp\",{\"1\":{\"793\":1}}],[\"getindexbuffer\",{\"1\":{\"767\":1,\"845\":1,\"860\":1,\"1174\":1,\"1370\":1}}],[\"getint\",{\"1\":{\"767\":1,\"771\":1,\"797\":5,\"845\":1,\"860\":1,\"1174\":1,\"1367\":2,\"1370\":1,\"1372\":4,\"1435\":1,\"1436\":2}}],[\"getinterfaces\",{\"1\":{\"40\":1}}],[\"getinstancename\",{\"1\":{\"1170\":1,\"1235\":1}}],[\"getinstance\",{\"1\":{\"396\":1,\"1047\":2,\"1122\":1,\"1427\":1,\"1436\":1}}],[\"getinstances\",{\"1\":{\"266\":3}}],[\"getinputstream\",{\"1\":{\"69\":1,\"70\":1,\"113\":1}}],[\"getdispatchrequestlist\",{\"1\":{\"1427\":2}}],[\"getdispatcherlist\",{\"1\":{\"1424\":1}}],[\"getdledgerentryforappend\",{\"1\":{\"1519\":2}}],[\"getdledgerleaderelector\",{\"1\":{\"1424\":1}}],[\"getdledgerserver\",{\"1\":{\"1424\":1}}],[\"getdlqtopic\",{\"1\":{\"1198\":1}}],[\"getdefaulttopicqueuenums\",{\"1\":{\"1053\":1}}],[\"getdefaulttopicperm\",{\"1\":{\"1000\":1}}],[\"getdefaultmqpullconsumerimpl\",{\"1\":{\"1288\":1}}],[\"getdefaultmqpushconsumer\",{\"1\":{\"1145\":6}}],[\"getdefaultmqpushconsumerimpl\",{\"1\":{\"1019\":2}}],[\"getdefaultmqproducer\",{\"1\":{\"1197\":1}}],[\"getdefaultmqproducerimpl\",{\"1\":{\"1048\":1,\"1123\":1}}],[\"getdefaultgroupperm\",{\"1\":{\"1000\":1}}],[\"getdestroymapedfileintervalforcibly\",{\"1\":{\"870\":1}}],[\"getdeletelist\",{\"1\":{\"1373\":5}}],[\"getdeleteconsumequeuefilesinterval\",{\"1\":{\"871\":1,\"872\":1}}],[\"getdeletecommitlogfilesinterval\",{\"1\":{\"870\":1}}],[\"getdelivertimems\",{\"1\":{\"1278\":1}}],[\"getdelaytime\",{\"1\":{\"1371\":2}}],[\"getdelaytimelevel\",{\"1\":{\"843\":3,\"1459\":1,\"1462\":1}}],[\"getdelaylevel\",{\"1\":{\"1198\":1}}],[\"getdelaylevelwhennextconsume\",{\"1\":{\"1197\":1}}],[\"getdeclaredmethods\",{\"1\":{\"39\":1}}],[\"getdeclaredmethod\",{\"1\":{\"39\":1}}],[\"getdeclaredfields\",{\"1\":{\"38\":1,\"995\":1}}],[\"getdeclaredfield\",{\"1\":{\"38\":1,\"99\":2}}],[\"getdatafilelist\",{\"1\":{\"1519\":1}}],[\"getdataversion\",{\"1\":{\"971\":2}}],[\"getdata\",{\"1\":{\"72\":1,\"73\":1,\"762\":1}}],[\"getordefault\",{\"1\":{\"1427\":2}}],[\"getoriginmsgid\",{\"1\":{\"1198\":1}}],[\"getoriginmessageid\",{\"1\":{\"1197\":1,\"1198\":1}}],[\"getorcreatemqclientinstance\",{\"1\":{\"1047\":1,\"1122\":1}}],[\"getopqueue\",{\"1\":{\"1468\":1}}],[\"getoptionvalue\",{\"1\":{\"960\":1}}],[\"getopaque\",{\"1\":{\"820\":1,\"894\":1,\"1173\":1,\"1273\":1}}],[\"getoffsetmsgid\",{\"1\":{\"1460\":2}}],[\"getoffsetid\",{\"1\":{\"1427\":1}}],[\"getoffsetpy\",{\"1\":{\"1371\":1,\"1373\":1}}],[\"getoffsetnew\",{\"1\":{\"1173\":1}}],[\"getoffsetrequest\",{\"1\":{\"1173\":1}}],[\"getoffsetstore\",{\"1\":{\"1122\":2,\"1195\":1,\"1225\":2}}],[\"getoffset\",{\"1\":{\"72\":2,\"73\":1,\"1198\":2,\"1273\":1,\"1436\":2,\"1460\":1}}],[\"getoutputstream\",{\"1\":{\"69\":1,\"70\":1,\"113\":1}}],[\"getchecklistener\",{\"1\":{\"1459\":1,\"1472\":1}}],[\"getchannel\",{\"1\":{\"880\":1,\"972\":1}}],[\"getcid\",{\"1\":{\"1278\":3,\"1279\":3,\"1280\":4}}],[\"getck\",{\"1\":{\"1276\":1,\"1277\":1}}],[\"getckqueueoffset\",{\"1\":{\"1273\":1}}],[\"getc\",{\"1\":{\"1275\":1}}],[\"getcreatetopickey\",{\"1\":{\"1047\":1,\"1053\":1}}],[\"getcreatedat\",{\"1\":{\"90\":1}}],[\"getclientversion\",{\"1\":{\"1173\":2}}],[\"getclientip\",{\"1\":{\"1053\":1,\"1235\":1}}],[\"getclientid\",{\"1\":{\"1048\":1,\"1123\":1,\"1143\":2,\"1200\":1,\"1222\":1,\"1226\":1}}],[\"getclientconfig\",{\"1\":{\"1053\":2,\"1471\":2}}],[\"getclientchannel\",{\"1\":{\"825\":2}}],[\"getcleanresourceinterval\",{\"1\":{\"869\":1}}],[\"getclass\",{\"1\":{\"995\":3,\"996\":1}}],[\"getclassloader\",{\"1\":{\"41\":1}}],[\"getclazzfields\",{\"1\":{\"742\":1}}],[\"getcount\",{\"1\":{\"1520\":2}}],[\"getcounter\",{\"1\":{\"1370\":1,\"1373\":3}}],[\"getcompactedfilepath\",{\"1\":{\"1435\":1}}],[\"getcompiledexpression\",{\"1\":{\"1332\":2,\"1333\":3}}],[\"getcommercialsizepermsg\",{\"1\":{\"1269\":1}}],[\"getcommercialbasecount\",{\"1\":{\"1173\":1}}],[\"getcommitindex\",{\"1\":{\"1520\":5}}],[\"getcommittedindex\",{\"1\":{\"1519\":1,\"1521\":2}}],[\"getcommitorrollback\",{\"1\":{\"1464\":3}}],[\"getcommitoffset\",{\"1\":{\"1173\":1,\"1428\":1,\"1435\":1}}],[\"getcommitlogasync\",{\"1\":{\"1432\":1}}],[\"getcommitlogmaxoffset\",{\"1\":{\"1427\":1}}],[\"getcommitlogrollinginterval\",{\"1\":{\"1427\":1}}],[\"getcommitlog\",{\"1\":{\"845\":1,\"860\":1,\"1424\":1}}],[\"getcommitlogoffsetfromitem\",{\"1\":{\"1432\":3}}],[\"getcommitlogoffset\",{\"1\":{\"794\":3,\"1297\":5,\"1332\":3,\"1464\":3,\"1468\":1,\"1469\":1,\"1472\":1}}],[\"getcontentlength\",{\"1\":{\"1428\":1}}],[\"getcontent\",{\"1\":{\"1000\":1}}],[\"getconfiguration\",{\"1\":{\"960\":1}}],[\"getconsumequeueasync\",{\"1\":{\"1432\":1}}],[\"getconsumequeueminoffset\",{\"1\":{\"1430\":1,\"1432\":1}}],[\"getconsumequeuemaxoffset\",{\"1\":{\"1427\":1}}],[\"getconsumequeuecommitoffset\",{\"1\":{\"1427\":1,\"1430\":1,\"1432\":1}}],[\"getconsumequeue\",{\"1\":{\"1370\":1,\"1427\":1}}],[\"getconsumequeueoffset\",{\"1\":{\"762\":1,\"827\":1,\"1297\":1}}],[\"getconsumelock\",{\"1\":{\"1225\":2,\"1230\":2}}],[\"getconsumetimeout\",{\"1\":{\"1195\":1,\"1230\":1}}],[\"getconsumemessagebatchmaxsize\",{\"1\":{\"1194\":1,\"1230\":1}}],[\"getconsumerorderinfomanager\",{\"1\":{\"1270\":2}}],[\"getconsumeroffsetmanager\",{\"1\":{\"1173\":1,\"1270\":3,\"1278\":1,\"1279\":1}}],[\"getconsumerstatsmanager\",{\"1\":{\"1175\":2,\"1195\":4,\"1229\":2,\"1230\":1}}],[\"getconsumerfiltermanager\",{\"1\":{\"1173\":3,\"1331\":2}}],[\"getconsumermanager\",{\"1\":{\"1173\":1,\"1266\":1}}],[\"getconsumergroupinfo\",{\"1\":{\"1173\":1,\"1266\":1}}],[\"getconsumergroup\",{\"1\":{\"1020\":1,\"1122\":8,\"1170\":1,\"1173\":24,\"1175\":2,\"1195\":2,\"1197\":3,\"1229\":2,\"1230\":2,\"1269\":3,\"1270\":12,\"1273\":2,\"1276\":1,\"1278\":1}}],[\"getconsumeconcurrentlymaxspan\",{\"1\":{\"1170\":1}}],[\"getconstructor\",{\"1\":{\"123\":1,\"133\":1,\"1425\":1}}],[\"getcodeset\",{\"1\":{\"1328\":1}}],[\"getcode\",{\"1\":{\"819\":1,\"894\":2,\"1056\":1,\"1173\":2,\"1462\":1,\"1464\":3,\"1499\":3,\"1500\":6,\"1516\":3,\"1519\":12,\"1520\":13,\"1521\":1}}],[\"getcanonicalname\",{\"1\":{\"742\":1}}],[\"getcanonicalpath\",{\"1\":{\"52\":1}}],[\"getcvar\",{\"1\":{\"420\":1}}],[\"getcurrentsession\",{\"1\":{\"91\":5,\"92\":2}}],[\"getavailablechannel\",{\"1\":{\"1469\":1}}],[\"getappendoffset\",{\"1\":{\"1435\":2}}],[\"getappendmessageresult\",{\"1\":{\"1198\":2,\"1280\":2,\"1462\":1}}],[\"getawaitterminationmilliswhenshutdown\",{\"1\":{\"1122\":1}}],[\"getallclientid\",{\"1\":{\"1266\":1}}],[\"getallocatemessagequeuestrategy\",{\"1\":{\"1122\":1}}],[\"getallaclfiles\",{\"1\":{\"998\":1,\"999\":1}}],[\"getackoffset\",{\"1\":{\"1276\":1,\"1278\":1}}],[\"getackindex\",{\"1\":{\"1195\":1}}],[\"getaccessmessageinmemorymaxratio\",{\"1\":{\"1174\":1}}],[\"getaccesskey\",{\"1\":{\"995\":2,\"998\":4,\"1000\":7}}],[\"getaclrpchook\",{\"1\":{\"984\":2,\"985\":2}}],[\"getactualtypearguments\",{\"1\":{\"48\":1}}],[\"getandincrement\",{\"1\":{\"1269\":1,\"1442\":1}}],[\"getandchecknotnull\",{\"1\":{\"891\":4}}],[\"getandcreatelastindexfile\",{\"1\":{\"789\":2,\"793\":2}}],[\"getannotation\",{\"1\":{\"44\":4}}],[\"getabsolutepath\",{\"1\":{\"52\":1}}],[\"gb2312\",{\"1\":{\"27\":1}}],[\"上存在\",{\"1\":{\"1519\":1}}],[\"上写入的日志已经被确认\",{\"1\":{\"1509\":1}}],[\"上只有一个\",{\"1\":{\"1288\":1,\"1297\":1}}],[\"上加锁\",{\"1\":{\"1270\":1}}],[\"上保存和管理的分布式锁\",{\"1\":{\"1212\":1}}],[\"上保持生命绽放\",{\"1\":{\"411\":1}}],[\"上一次投票结果是需要等待下一轮投票\",{\"1\":{\"1486\":1}}],[\"上一次发送\",{\"1\":{\"1519\":1}}],[\"上一次发送失败会规避上次发送的\",{\"1\":{\"1052\":1}}],[\"上一次发送成功则选择下一个队列\",{\"1\":{\"1052\":1}}],[\"上一次发送异常的情况下它将执行\",{\"1\":{\"1041\":1}}],[\"上一篇主要介绍并发消费\",{\"1\":{\"1203\":1}}],[\"上一篇重平衡篇有提到\",{\"1\":{\"1152\":1}}],[\"上一个\",{\"1\":{\"145\":1}}],[\"上产生此对象\",{\"1\":{\"1035\":1}}],[\"上恢复数据\",{\"1\":{\"1033\":1}}],[\"上生产和消费\",{\"1\":{\"978\":1}}],[\"上传该\",{\"1\":{\"1417\":1}}],[\"上传到二级存储的索引文件引用\",{\"1\":{\"1412\":1}}],[\"上传到分级存储的操作也分为两步\",{\"1\":{\"1403\":1}}],[\"上传完成之后将该\",{\"1\":{\"1417\":1}}],[\"上传完成之后更新\",{\"1\":{\"1403\":1}}],[\"上传完成之后会删掉处于本地的新老索引文件\",{\"1\":{\"1394\":1}}],[\"上传是一系列操作\",{\"1\":{\"1403\":1}}],[\"上传数据的流程为定时发起\",{\"1\":{\"1403\":1}}],[\"上传成功后再批量上传消费索引数据\",{\"1\":{\"1388\":1}}],[\"上传的过程中\",{\"1\":{\"1388\":1}}],[\"上传的过程是\",{\"1\":{\"1388\":1}}],[\"上传\",{\"1\":{\"945\":1}}],[\"上报执行结果给\",{\"1\":{\"1449\":1}}],[\"上报给\",{\"1\":{\"1120\":1}}],[\"上报消费进度\",{\"1\":{\"1117\":1}}],[\"上报的元数据中\",{\"1\":{\"1293\":1}}],[\"上报的路由信息保存到\",{\"1\":{\"971\":1}}],[\"上报的路由信息为例展示\",{\"1\":{\"963\":1}}],[\"上报的路由信息存起来\",{\"1\":{\"951\":1}}],[\"上报的心跳包请求类型是\",{\"1\":{\"952\":1}}],[\"上报\",{\"1\":{\"952\":1,\"1145\":1}}],[\"上报心跳和路由信息\",{\"0\":{\"952\":1,\"970\":1},\"1\":{\"970\":1}}],[\"上报路由信息\",{\"1\":{\"941\":1,\"951\":1}}],[\"上报本机任务执行情况和执行状态等功能\",{\"1\":{\"372\":1}}],[\"上获取属性remoteaddr\",{\"1\":{\"897\":1}}],[\"上次打印水位线日志的时间戳\",{\"1\":{\"1521\":1}}],[\"上次检测泄漏的时间戳\",{\"1\":{\"1521\":1}}],[\"上次检测泄露的时间\",{\"1\":{\"1519\":1}}],[\"上次检查\",{\"1\":{\"1520\":1}}],[\"上次提交成功\",{\"1\":{\"1428\":1}}],[\"上次提交失败\",{\"1\":{\"1428\":1}}],[\"上次提交到当前时间是否超过分级存储存储的提交时间阈值\",{\"1\":{\"1403\":1,\"1427\":1}}],[\"上次请求偏移量\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"上次拉取完成\",{\"1\":{\"1155\":1}}],[\"上次拉取消息的时间距离现在超过设置时间\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"上次发送失败\",{\"1\":{\"1052\":1}}],[\"上次发送的\",{\"1\":{\"1052\":1}}],[\"上次发送心跳时间\",{\"1\":{\"945\":1}}],[\"上次更新时间戳\",{\"1\":{\"967\":1}}],[\"上次是否是正常退出\",{\"1\":{\"793\":1}}],[\"上次插入文本\",{\"1\":{\"158\":1}}],[\"上图展示了加锁流程\",{\"1\":{\"1214\":1}}],[\"上图展示的就是该方法中的逻辑\",{\"1\":{\"857\":1}}],[\"上图为\",{\"1\":{\"945\":1,\"947\":1,\"1482\":1}}],[\"上图来自艾瑞克的技术江湖\",{\"1\":{\"755\":1}}],[\"上图中标识了\",{\"1\":{\"1136\":1}}],[\"上图中\",{\"1\":{\"622\":1}}],[\"上所有消息都顺序保存在\",{\"1\":{\"736\":1}}],[\"上接收生产者发送的消息后投递到\",{\"1\":{\"668\":1}}],[\"上游集群配置\",{\"0\":{\"637\":1}}],[\"上下游\",{\"1\":{\"635\":1}}],[\"上下文对象\",{\"1\":{\"606\":1}}],[\"上下文中的方法\",{\"1\":{\"272\":1}}],[\"上开启\",{\"1\":{\"635\":1}}],[\"上例的变量c等于1\",{\"1\":{\"582\":1}}],[\"上去之后刚好能钩下来\",{\"1\":{\"459\":1}}],[\"上限更高\",{\"1\":{\"401\":1}}],[\"上已经算前\",{\"1\":{\"399\":1}}],[\"上都会产生一个\",{\"1\":{\"372\":1}}],[\"上运行\",{\"1\":{\"237\":1}}],[\"上移窗口\",{\"1\":{\"153\":1}}],[\"上附上自己\",{\"1\":{\"124\":1}}],[\"上的历史数据无法保留\",{\"1\":{\"1379\":1}}],[\"上的物理偏移量\",{\"1\":{\"1352\":1}}],[\"上的队列\",{\"1\":{\"1138\":1}}],[\"上的队列轮流分给不同消费者\",{\"1\":{\"1097\":1}}],[\"上的偏移量\",{\"1\":{\"1017\":1}}],[\"上的引用\",{\"1\":{\"870\":1}}],[\"上的这些\",{\"1\":{\"673\":1}}],[\"上的\",{\"1\":{\"132\":2,\"133\":2,\"944\":1,\"949\":1,\"954\":1}}],[\"上的操作如果无法立即完成\",{\"1\":{\"124\":2}}],[\"上的处理器\",{\"1\":{\"122\":1}}],[\"上的注册信息\",{\"1\":{\"118\":1}}],[\"上注册的事件就绪\",{\"1\":{\"118\":1}}],[\"上之后就可以在客户端连接事件到达时取出\",{\"1\":{\"118\":1}}],[\"上感兴趣的事件\",{\"1\":{\"118\":1}}],[\"上\",{\"1\":{\"118\":1,\"121\":1,\"124\":1,\"130\":1,\"133\":1,\"673\":1,\"897\":1,\"941\":1,\"950\":1,\"968\":1,\"971\":1,\"1029\":1,\"1033\":1,\"1338\":1}}],[\"上面方法第\",{\"1\":{\"1258\":1}}],[\"上面主要讲的是推模式消费者\",{\"1\":{\"1136\":1}}],[\"上面是一个发送消息的请求\",{\"1\":{\"890\":1}}],[\"上面是挂起的消息拉取请求容器\",{\"1\":{\"815\":1}}],[\"上面已经提到\",{\"1\":{\"786\":1}}],[\"上面说过\",{\"1\":{\"834\":1}}],[\"上面说它的逻辑结构类似\",{\"1\":{\"780\":1}}],[\"上面说到\",{\"1\":{\"386\":1,\"625\":1,\"814\":1}}],[\"上面代码中\",{\"1\":{\"606\":1}}],[\"上面所有类型的名称都是小写字母\",{\"1\":{\"506\":1}}],[\"上面这个命令写成tsconfig\",{\"1\":{\"499\":1}}],[\"上面这么多种事务的传播级别\",{\"1\":{\"87\":1}}],[\"上面的代码在发送消息时设置消息的\",{\"1\":{\"715\":1}}],[\"上面的代码将\",{\"1\":{\"715\":1}}],[\"上面的代码创建了一个一致性哈希交换器\",{\"1\":{\"714\":1}}],[\"上面的\",{\"1\":{\"127\":1,\"330\":1,\"994\":1,\"1258\":1}}],[\"上面提到的\",{\"1\":{\"1300\":1}}],[\"上面提到\",{\"1\":{\"118\":1}}],[\"上述程序存在缺陷\",{\"1\":{\"114\":1}}],[\"上述代码中\",{\"1\":{\"112\":1}}],[\"上界通配符\",{\"0\":{\"49\":1}}],[\"上测试\",{\"1\":{\"7\":1}}],[\"上语言程序的性能\",{\"1\":{\"2\":1}}],[\"包并完成初始化后\",{\"1\":{\"372\":1}}],[\"包装成消息放入磁盘\",{\"1\":{\"1277\":1}}],[\"包装对象的概念\",{\"0\":{\"508\":1}}],[\"包装对象类型与字面量类型\",{\"0\":{\"509\":1}}],[\"包装对象类型\",{\"0\":{\"507\":1}}],[\"包装对象\",{\"1\":{\"333\":1}}],[\"包装类型可以把基本类型变成引用类型\",{\"1\":{\"30\":1}}],[\"包装类型\",{\"0\":{\"30\":1}}],[\"包含上面的\",{\"1\":{\"1507\":4}}],[\"包含创建时间\",{\"1\":{\"1420\":1}}],[\"包含整个分级存储的\",{\"1\":{\"1387\":1}}],[\"包含过滤信息\",{\"1\":{\"1170\":1}}],[\"包含需要拉取的消费队列信息\",{\"1\":{\"1170\":1,\"1228\":1}}],[\"包含队列信息\",{\"1\":{\"1149\":1}}],[\"包含两种消费模式\",{\"1\":{\"1117\":1}}],[\"包含两个\",{\"1\":{\"133\":1}}],[\"包含消息合法性检查\",{\"1\":{\"1056\":1}}],[\"包含如下\",{\"1\":{\"978\":1}}],[\"包含用户名\",{\"1\":{\"978\":1}}],[\"包含最后更新时间\",{\"1\":{\"971\":1}}],[\"包含自身\",{\"1\":{\"945\":1}}],[\"包含当前所有存活的\",{\"1\":{\"944\":1}}],[\"包含每个集群中所有的\",{\"1\":{\"944\":1}}],[\"包含大量字符串操作\",{\"1\":{\"900\":1}}],[\"包含配置文件持久化的函数和重新加载配置文件到内存的函数\",{\"1\":{\"840\":1}}],[\"包含索引文件的存储结构和一系列操作\",{\"1\":{\"790\":1}}],[\"包含一些基本信息\",{\"1\":{\"787\":1}}],[\"包含一个自带地址空间和进程组的完整虚拟机\",{\"1\":{\"237\":1}}],[\"包含的最大索引数量是相同的\",{\"1\":{\"780\":1}}],[\"包含\",{\"1\":{\"749\":1,\"786\":1,\"949\":1,\"1520\":1}}],[\"包含在\",{\"1\":{\"672\":1}}],[\"包含其名称\",{\"1\":{\"391\":1,\"944\":1}}],[\"包含了压缩前的索引文件引用\",{\"1\":{\"1412\":1}}],[\"包含了放入缓冲区中等待上传的消息数据\",{\"1\":{\"1403\":1}}],[\"包含了消息物理偏移量等信息\",{\"1\":{\"1393\":1}}],[\"包含了\",{\"1\":{\"1017\":1}}],[\"包含了每个\",{\"1\":{\"952\":1}}],[\"包含了某个值的\",{\"1\":{\"606\":1}}],[\"包含了许多强大的工具\",{\"1\":{\"262\":1}}],[\"包含了一组库和实现方式\",{\"1\":{\"262\":1}}],[\"包含库的头文件\",{\"1\":{\"211\":1}}],[\"包含文件的扩展名是\",{\"1\":{\"211\":1}}],[\"包含文件\",{\"0\":{\"211\":1}}],[\"包含文件关键字\",{\"1\":{\"162\":1}}],[\"包含预定义的模块属性和用户定义的属性\",{\"1\":{\"202\":1}}],[\"包含空格\",{\"1\":{\"155\":1}}],[\"包中\",{\"1\":{\"118\":1,\"827\":1}}],[\"包提供了非阻塞以及事件驱动机制的支持\",{\"1\":{\"118\":1}}],[\"包对这种机制提供了支持\",{\"1\":{\"116\":1}}],[\"包的三种实现\",{\"1\":{\"110\":1}}],[\"包括从\",{\"1\":{\"1037\":1}}],[\"包括该目录的子目录\",{\"1\":{\"998\":1}}],[\"包括索引文件的加载\",{\"1\":{\"789\":1}}],[\"包括接收消息\",{\"1\":{\"689\":1}}],[\"包括接受来自\",{\"1\":{\"372\":1}}],[\"包括消息的存储地点\",{\"1\":{\"687\":1}}],[\"包括网络\",{\"1\":{\"662\":1}}],[\"包括网络i\",{\"1\":{\"657\":1}}],[\"包括三个部分ha\",{\"1\":{\"652\":1}}],[\"包括取值器\",{\"1\":{\"567\":1}}],[\"包括数组\",{\"1\":{\"564\":1}}],[\"包括它自己\",{\"1\":{\"295\":1}}],[\"包括函数名\",{\"1\":{\"256\":1}}],[\"包括事件的通知\",{\"1\":{\"120\":1}}],[\"包括\",{\"1\":{\"108\":1,\"727\":1,\"750\":1,\"781\":1,\"801\":1,\"1025\":1,\"1048\":1}}],[\"包括父类\",{\"1\":{\"38\":2,\"39\":2}}],[\"包括interface\",{\"1\":{\"36\":1}}],[\"包括error及其子类\",{\"1\":{\"33\":1}}],[\"包括exception及其子类\",{\"1\":{\"33\":1}}],[\"包括任意深度的子目录\",{\"1\":{\"21\":1}}],[\"包括预热该文件\",{\"1\":{\"881\":1}}],[\"包括预热\",{\"1\":{\"9\":1}}],[\"包十分有用\",{\"1\":{\"7\":1}}],[\"包\",{\"0\":{\"19\":1,\"24\":1,\"118\":1},\"1\":{\"7\":1,\"118\":1,\"372\":1}}],[\"这行是多余的\",{\"1\":{\"1435\":1}}],[\"这对分级存储来说是非常昂贵的\",{\"1\":{\"1402\":1}}],[\"这对于保证消息的fifo排序是必要的\",{\"1\":{\"660\":1}}],[\"这体现在消息数据的存储和\",{\"1\":{\"1290\":1}}],[\"这给多语言客户端的支持造成很大的阻碍\",{\"1\":{\"1249\":1}}],[\"这两种消费方式的流程又比较类似\",{\"1\":{\"1187\":1}}],[\"这两个元数据会定期持久化到磁盘\",{\"1\":{\"1509\":1}}],[\"这两个方法也会调用元数据存储的\",{\"1\":{\"1421\":1}}],[\"这两个方法会先初始化一个\",{\"1\":{\"1263\":1}}],[\"这两个参数含义如下\",{\"1\":{\"1299\":1}}],[\"这两个参数在老一点的版本中为\",{\"1\":{\"618\":1}}],[\"这两个配置是\",{\"1\":{\"1299\":1}}],[\"这两个消费进度管理器都保存一个消费进度缓存表\",{\"1\":{\"1191\":1}}],[\"这两个返回值都表示服务器暂时没有这个队列\",{\"1\":{\"1173\":1}}],[\"这两个步骤\",{\"1\":{\"1147\":1}}],[\"这两个问题可以通过精心的设计存储方案来解决\",{\"1\":{\"926\":1}}],[\"这两个指标往往不能兼得\",{\"1\":{\"924\":1}}],[\"这两个概念虽然感觉起来不同\",{\"1\":{\"920\":1}}],[\"这两个文件一定是逻辑上相邻的两个文件\",{\"1\":{\"688\":1}}],[\"这两个技能循环\",{\"1\":{\"448\":1}}],[\"这两个也是集合石擦屁股神器\",{\"1\":{\"403\":1}}],[\"这两个操作原理基本相同\",{\"1\":{\"723\":1}}],[\"这两个操作\",{\"1\":{\"124\":2}}],[\"这张图是阿里云的文章讲解消费时用到的\",{\"1\":{\"1104\":1}}],[\"这多个消费同样\",{\"1\":{\"1089\":1}}],[\"这三个类\",{\"1\":{\"1110\":1}}],[\"这三个修饰符的位置\",{\"1\":{\"575\":1}}],[\"这三种发送方式中\",{\"1\":{\"1027\":1}}],[\"这边的\",{\"1\":{\"990\":1}}],[\"这部分开始讲解\",{\"1\":{\"986\":1}}],[\"这其实没有太大的必要\",{\"1\":{\"942\":1}}],[\"这其实并不属于流控机制\",{\"1\":{\"615\":1}}],[\"这条消息重新可以被消费\",{\"1\":{\"1251\":1}}],[\"这条消息对所有消费者不可见\",{\"1\":{\"1251\":1}}],[\"这条定时消息就会丢失\",{\"1\":{\"934\":1}}],[\"这条语句就成立了\",{\"1\":{\"173\":1}}],[\"这么小的内存无法生产消费消息\",{\"1\":{\"1080\":1}}],[\"这么多消息要投递存不下怎么办\",{\"1\":{\"931\":1}}],[\"这么设计的原因\",{\"1\":{\"836\":1}}],[\"这显然不是一个好办法\",{\"1\":{\"928\":1}}],[\"这篇文章\",{\"1\":{\"1386\":2}}],[\"这篇文章丢给他\",{\"1\":{\"938\":1}}],[\"这篇文章中有详细解释\",{\"1\":{\"914\":1}}],[\"这篇翻译就是在\",{\"1\":{\"399\":1}}],[\"这篇翻译会加很多我自己的个人理解\",{\"1\":{\"399\":1}}],[\"这会增加内存的使用量\",{\"1\":{\"702\":1}}],[\"这会避免出现网络分区时\",{\"1\":{\"695\":1}}],[\"这\",{\"1\":{\"700\":1,\"1508\":1}}],[\"这引出了第二个致命的设计缺陷\",{\"1\":{\"693\":1}}],[\"这也是本文将着重解析的类\",{\"1\":{\"1482\":1}}],[\"这也是为了后面能够重新消费到这条半消息再次进行回查的判断\",{\"1\":{\"1453\":1}}],[\"这也是一个难点\",{\"1\":{\"1343\":1}}],[\"这也是大部分场景下会使用到的消费模式\",{\"1\":{\"1091\":1}}],[\"这也是他占用如此高\",{\"1\":{\"896\":1}}],[\"这也是\",{\"1\":{\"692\":1}}],[\"这也就是为什么生命绽放在还剩\",{\"1\":{\"419\":1}}],[\"这实际会降低rabbitmq的处理性能\",{\"1\":{\"690\":1}}],[\"这将减少冗余\",{\"1\":{\"678\":1}}],[\"这将使用参数集创建一个新的消费者\",{\"1\":{\"665\":1}}],[\"这可能是由于将消息存入队列的过程中引起服务器\",{\"1\":{\"622\":1}}],[\"这时会真正读一次磁盘上的文件\",{\"1\":{\"879\":1}}],[\"这时需要保证消息队列的逻辑位置和consumequeue文件的起始文件的偏移量一致\",{\"1\":{\"765\":1}}],[\"这时需要暂时限制生产者的生产速度\",{\"1\":{\"611\":1}}],[\"这时\",{\"1\":{\"529\":1,\"576\":1,\"580\":1}}],[\"这时候就需要一个机制\",{\"1\":{\"921\":1,\"1337\":1}}],[\"这时候操作系统会引发一个缺页中断\",{\"1\":{\"879\":1}}],[\"这时候会出现两种可能情况\",{\"1\":{\"879\":1}}],[\"这时候的处理是对失败消息进行重新投递\",{\"1\":{\"854\":1}}],[\"这时候可能没法读条愈合\",{\"1\":{\"465\":1}}],[\"这时候还需要跑路到安全的排放口\",{\"1\":{\"440\":1}}],[\"这时候林莽卫士的治疗就会受到多层精通加成\",{\"1\":{\"413\":1}}],[\"这时候在奶德群里看到有大佬说这赛季怎么也打到\",{\"1\":{\"399\":1}}],[\"这囊括了几乎所有的值\",{\"1\":{\"511\":1}}],[\"这几个部分\",{\"1\":{\"986\":1}}],[\"这几个都共\",{\"1\":{\"485\":1}}],[\"这几年国家政策大力引导下\",{\"1\":{\"276\":1}}],[\"这确保了在当前操作后你的下一个动作能立即执行\",{\"1\":{\"420\":1}}],[\"这是为了方便连续地读取单个队列中的消息\",{\"1\":{\"1402\":1}}],[\"这是由于不同的\",{\"1\":{\"1314\":1}}],[\"这是由于使用了\",{\"1\":{\"704\":1}}],[\"这是一个难点\",{\"1\":{\"1342\":1}}],[\"这是一个\",{\"1\":{\"836\":1}}],[\"这是关键的设计缺陷\",{\"1\":{\"677\":1}}],[\"这是常用的方法\",{\"1\":{\"660\":1}}],[\"这是默认模式\",{\"1\":{\"658\":1}}],[\"这是默认值\",{\"1\":{\"593\":1}}],[\"这是因为缺少一些依赖包\",{\"1\":{\"643\":1}}],[\"这是因为它和光合作用\",{\"1\":{\"415\":1}}],[\"这是唯一造成\",{\"1\":{\"460\":1}}],[\"这是唯一造成大量伤害的时候\",{\"1\":{\"453\":1}}],[\"这是唯一有伤害的时候\",{\"1\":{\"458\":1}}],[\"这是我通灵的天赋点\",{\"1\":{\"455\":1}}],[\"这是我使用的天赋\",{\"1\":{\"449\":1}}],[\"这是非常麻烦的事\",{\"1\":{\"270\":1}}],[\"这套光用免费星火也能打个\",{\"1\":{\"403\":1}}],[\"这套除了没有打断\",{\"1\":{\"403\":1}}],[\"这套是输出向树奶天赋\",{\"1\":{\"403\":1}}],[\"这套是纯输出猫奶\",{\"1\":{\"403\":1}}],[\"这套是标准的双绽放结界猫奶\",{\"1\":{\"403\":1}}],[\"这套天赋是通用天赋\",{\"1\":{\"403\":1}}],[\"这一过程被称为重平衡机制\",{\"1\":{\"1098\":1}}],[\"这一过程中整理和回收内存都需要消耗更多的时间\",{\"1\":{\"904\":1}}],[\"这一步不是必须要的\",{\"1\":{\"1072\":1}}],[\"这一部分其实也是为了优化\",{\"1\":{\"913\":1}}],[\"这一批\",{\"1\":{\"720\":1}}],[\"这一套是偏向于治疗量的猫奶\",{\"1\":{\"403\":1}}],[\"这一段时间正反馈还是很足的\",{\"1\":{\"399\":1}}],[\"这一具有分布式处理能力的处理器\",{\"1\":{\"372\":1}}],[\"这次也改到锁外先生成好\",{\"1\":{\"736\":1}}],[\"这次将\",{\"1\":{\"735\":1}}],[\"这次\",{\"1\":{\"399\":1}}],[\"这赛季\",{\"1\":{\"399\":1}}],[\"这就决定了消费者的横向扩展能力受到\",{\"1\":{\"1249\":1}}],[\"这就导致了几个问题\",{\"1\":{\"1249\":1}}],[\"这就导致同步和异步方法存在大量重复代码\",{\"1\":{\"731\":1}}],[\"这就是\",{\"1\":{\"944\":1}}],[\"这就是这个优化的改动\",{\"1\":{\"906\":1}}],[\"这就是第一个致命的设计缺陷\",{\"1\":{\"693\":1}}],[\"这就意味这个\",{\"1\":{\"622\":1}}],[\"这就意味着会删除\",{\"1\":{\"1519\":1}}],[\"这就意味着延迟时间超过\",{\"1\":{\"1343\":1}}],[\"这就意味着同样\",{\"1\":{\"787\":1}}],[\"这就意味着每个\",{\"1\":{\"780\":1}}],[\"这就意味着在消息持久化时出现了性能瓶颈\",{\"1\":{\"622\":1}}],[\"这就意味着有一个或者多个队列出现了性能瓶颈\",{\"1\":{\"622\":1}}],[\"这就意味着\",{\"1\":{\"622\":1}}],[\"这就意味着如果仍然需要正常使用这个分布式系统\",{\"1\":{\"385\":1}}],[\"这就需要引入一致性哈希算法\",{\"1\":{\"385\":1}}],[\"这台server连接着这个分组下所有的worker\",{\"1\":{\"380\":1}}],[\"这在\",{\"1\":{\"379\":1}}],[\"这避免了传统的锁和线程同步以及资源竞争问题\",{\"1\":{\"372\":1}}],[\"这段代码的所有\",{\"1\":{\"364\":1}}],[\"这符合了\",{\"1\":{\"173\":1}}],[\"这里主要会记录消息轨迹\",{\"1\":{\"1460\":1}}],[\"这里会重新计算消息数据的偏移量并覆盖写入\",{\"1\":{\"1517\":1}}],[\"这里会增加事务半消息属性中的重试次数\",{\"1\":{\"1468\":1}}],[\"这里会新写入一条消息\",{\"1\":{\"1453\":1}}],[\"这里会加大查询消息错误的概率\",{\"1\":{\"797\":1}}],[\"这里创建一个\",{\"1\":{\"1441\":1}}],[\"这里持久化了\",{\"1\":{\"1420\":1}}],[\"这里不再赘述\",{\"1\":{\"1418\":1}}],[\"这里不再使用共同的这个解析器\",{\"1\":{\"742\":1}}],[\"这里选择了\",{\"1\":{\"1382\":1}}],[\"这里针对普通消息\",{\"1\":{\"1260\":1}}],[\"这里\",{\"1\":{\"1253\":1,\"1453\":1}}],[\"这里有个问题是\",{\"1\":{\"1468\":1}}],[\"这里有引入了如下痛点\",{\"1\":{\"1249\":1}}],[\"这里有意思的是\",{\"1\":{\"379\":1}}],[\"这里为\",{\"1\":{\"1212\":1}}],[\"这里为0\",{\"1\":{\"882\":1}}],[\"这里讲解集群模式下消费进度的更新流程\",{\"1\":{\"1191\":1}}],[\"这里都使用了内存缓存\",{\"1\":{\"1190\":1}}],[\"这里用到了代理模式\",{\"1\":{\"1118\":1}}],[\"这里使用了代理模式\",{\"1\":{\"1109\":1}}],[\"这里所说的顺序消费指的是队列维度的顺序\",{\"1\":{\"1102\":1}}],[\"这里地延迟重试采用了\",{\"1\":{\"1100\":1}}],[\"这里面涉及到许多消费模式和特性\",{\"1\":{\"1086\":1}}],[\"这里面存的是真正投递时间\",{\"1\":{\"845\":1}}],[\"这里以消费者为例\",{\"1\":{\"1018\":1}}],[\"这里以生产者为例\",{\"1\":{\"1011\":1}}],[\"这里以持久化消息为例\",{\"1\":{\"690\":1}}],[\"这里没有直接覆盖全局配置\",{\"1\":{\"998\":1}}],[\"这里没有用\",{\"1\":{\"841\":1}}],[\"这里需要注意以下几点\",{\"1\":{\"998\":1}}],[\"这里需要引入第二个线程\",{\"1\":{\"933\":1}}],[\"这里转换成小时\",{\"1\":{\"870\":1}}],[\"这里按异步讲解\",{\"1\":{\"857\":1}}],[\"这里直接纠正下一次定时任务的offset为当前定时任务队列的最小值\",{\"1\":{\"845\":1}}],[\"这里调用了\",{\"1\":{\"827\":1}}],[\"这里key可以有多个\",{\"1\":{\"794\":1}}],[\"这里存在\",{\"1\":{\"786\":1}}],[\"这里还不是非常平均\",{\"1\":{\"711\":1}}],[\"这里我分为\",{\"1\":{\"1252\":1}}],[\"这里我发送\",{\"1\":{\"711\":1}}],[\"这里我们将\",{\"1\":{\"711\":1}}],[\"这里我就直接放上我个人用的宏了\",{\"1\":{\"488\":1}}],[\"这里要注意的是ha\",{\"1\":{\"659\":1}}],[\"这里如果是\",{\"1\":{\"644\":1}}],[\"这里to是发送者\",{\"1\":{\"626\":1}}],[\"这里更新了进程字典中credit\",{\"1\":{\"625\":1}}],[\"这里仅仅把推荐天赋的强化驱散换成了森林小径\",{\"1\":{\"455\":1}}],[\"这里原作者推荐了树奶\",{\"1\":{\"443\":1}}],[\"这里可以进行选择\",{\"1\":{\"403\":1}}],[\"这里描述的有些过于绝对\",{\"1\":{\"401\":1}}],[\"这里装了\",{\"1\":{\"400\":1}}],[\"这里引入了\",{\"1\":{\"891\":1}}],[\"这里引入了一个阻塞队列作为异步投递任务的容器\",{\"1\":{\"855\":1}}],[\"这里引入虚拟节点\",{\"1\":{\"388\":1}}],[\"这里引用\",{\"1\":{\"396\":1}}],[\"这里就可以用到定时消息\",{\"1\":{\"1253\":1}}],[\"这里就存在并发问题\",{\"1\":{\"1215\":1}}],[\"这里就存在\",{\"1\":{\"1096\":1}}],[\"这里就需要使用到一致性哈希算法\",{\"1\":{\"384\":1}}],[\"这里就是根据worker配置的server的ip列表去请求\",{\"1\":{\"380\":1}}],[\"这里定时调用discovery方法\",{\"1\":{\"380\":1}}],[\"这里逻辑同上类似\",{\"1\":{\"379\":1}}],[\"这里indicator线程模拟了指针的转动\",{\"1\":{\"379\":1}}],[\"这里轮盘个数为2的n次方\",{\"1\":{\"379\":1}}],[\"这里实现了多级时间轮\",{\"1\":{\"379\":1}}],[\"这里的处理队列指\",{\"1\":{\"1137\":1}}],[\"这里的作用是\",{\"1\":{\"961\":1}}],[\"这里的优化点就是想办法把这个方法逻辑从构建消费索引的逻辑中抽离出去\",{\"1\":{\"914\":1}}],[\"这里的强制删除并不会马上删除未过期的文件\",{\"1\":{\"866\":1}}],[\"这里的逻辑下标的含义跟\",{\"1\":{\"787\":1}}],[\"这里的逻辑是\",{\"1\":{\"624\":1}}],[\"这里的信用指的时发送许可\",{\"1\":{\"664\":1}}],[\"这里的pid是\",{\"1\":{\"624\":1}}],[\"这里的public不能省略\",{\"1\":{\"576\":1}}],[\"这里的进程与操作系统的进程不同\",{\"1\":{\"623\":1}}],[\"这里的\",{\"1\":{\"385\":1,\"711\":1,\"712\":1,\"866\":1,\"1006\":1}}],[\"这里的appid逻辑分组概念比较类似rocketmq的consumergroup\",{\"1\":{\"380\":1}}],[\"这里的阈值是30秒\",{\"1\":{\"379\":1}}],[\"这里的mfa是一个\",{\"1\":{\"261\":1}}],[\"这里只会插入一个任务实例执行一次\",{\"1\":{\"374\":1}}],[\"这里也没有多线程的情况\",{\"1\":{\"909\":1}}],[\"这里也会发送一个\",{\"1\":{\"812\":1}}],[\"这里也是借鉴\",{\"1\":{\"133\":1}}],[\"这里也应用分而治之的优化方法\",{\"1\":{\"130\":1}}],[\"这里初始化\",{\"1\":{\"124\":1}}],[\"这里先不设置感兴趣的事件\",{\"1\":{\"124\":1}}],[\"这里是异步单向请求\",{\"1\":{\"1449\":1}}],[\"这里是rabbit\",{\"1\":{\"624\":1,\"625\":1}}],[\"这里是\",{\"1\":{\"121\":1}}],[\"这里指\",{\"1\":{\"9\":1}}],[\"这通常用于\",{\"1\":{\"118\":2}}],[\"这意味着少部分比较慢的副本不会影响整个队列的性能\",{\"1\":{\"695\":1}}],[\"这意味着它们暂时耗尽了信用值\",{\"1\":{\"622\":1}}],[\"这意味着你可以在当前施法结束前最多400毫秒按下下一个技能\",{\"1\":{\"420\":1}}],[\"这意味着不能将\",{\"1\":{\"118\":1}}],[\"这意味着线程在等待i\",{\"1\":{\"114\":1}}],[\"这些线程都作为\",{\"1\":{\"1508\":1}}],[\"这些队列的数量可能非常多\",{\"1\":{\"1284\":1}}],[\"这些生产者和消费者的元数据配置是相同的\",{\"1\":{\"1235\":1}}],[\"这些方法都是数据统计用的\",{\"1\":{\"908\":1}}],[\"这些特性在仲裁队列的第一个版本中不会提供\",{\"1\":{\"698\":1}}],[\"这些是\",{\"1\":{\"644\":1}}],[\"这些逻辑通常放在构造函数里面\",{\"1\":{\"606\":1}}],[\"这些天赋让你能够在生命绽放的目标上叠加大量持续治疗效果\",{\"1\":{\"415\":1}}],[\"这些无不昭示着这一产业在飞速发展\",{\"1\":{\"276\":1}}],[\"这些文件\",{\"1\":{\"191\":1}}],[\"这些文件的修改可以实时更新\",{\"1\":{\"95\":1}}],[\"这些表达式以逗号分隔\",{\"1\":{\"186\":1}}],[\"这些问题会更频繁地出现\",{\"1\":{\"2\":1}}],[\"这正是aop需要解决的问题\",{\"1\":{\"85\":1}}],[\"这样日志在多数节点复制完成后会推进\",{\"1\":{\"1510\":1}}],[\"这样后面判断半消息是否需要回查时可以直接根据半消息本身来判断\",{\"1\":{\"1453\":1}}],[\"这样查询时就存在多次随机读\",{\"1\":{\"1393\":1}}],[\"这样能够减少精确过滤的次数\",{\"1\":{\"1318\":1}}],[\"这样才能识别\",{\"1\":{\"1286\":1}}],[\"这样才是一个完整的功能\",{\"1\":{\"935\":1}}],[\"这样也存在两个消费者同时消费一个队列的情况\",{\"1\":{\"1208\":1}}],[\"这样也被朋友说过很多次\",{\"1\":{\"399\":1}}],[\"这样不是很占用存储吗\",{\"1\":{\"1188\":1}}],[\"这样启动之后\",{\"1\":{\"1077\":1}}],[\"这样高可靠的消息队列中\",{\"1\":{\"934\":1}}],[\"这样看来\",{\"1\":{\"931\":1}}],[\"这样的转变\",{\"1\":{\"1390\":1}}],[\"这样的队列模型也有助于实现\",{\"1\":{\"1291\":1}}],[\"这样的话消费进度存在\",{\"1\":{\"1181\":1}}],[\"这样的话你就受不到生命绽放提供的大量吸血治疗量\",{\"1\":{\"415\":1}}],[\"这样的好处是免去了一次\",{\"1\":{\"930\":1}}],[\"这样消费者会马上解除挂起状态开始消费消息\",{\"1\":{\"914\":1}}],[\"这样消息才会在重启之后仍然存在\",{\"1\":{\"681\":1}}],[\"这样修改之后会影响两个地方\",{\"1\":{\"912\":1}}],[\"这样做的用意是将堆中的变量复制到栈上\",{\"1\":{\"904\":1}}],[\"这样它就可以预先计算\",{\"1\":{\"897\":1}}],[\"这样虽然繁琐但是执行速度最快\",{\"1\":{\"891\":1}}],[\"这样在消费者重启或队列重平衡时可以根据消费进度继续消费\",{\"1\":{\"1103\":1}}],[\"这样在消费较小的消息时只需要查询\",{\"1\":{\"687\":1}}],[\"这样在高并发时\",{\"1\":{\"883\":1}}],[\"这样操作系统会分配物理内存并且将物理地址与逻辑地址简历映射关系\",{\"1\":{\"882\":1}}],[\"这样操作会给每个页产生恰好一次的缺页中断\",{\"1\":{\"882\":1}}],[\"这样会影响读写性能\",{\"1\":{\"882\":1}}],[\"这样会导致资源利用率低下\",{\"1\":{\"114\":1}}],[\"这样这个方法获得了大约\",{\"1\":{\"742\":1}}],[\"这样处理每条消息写\",{\"1\":{\"733\":1}}],[\"这样同步只会阻塞很短的时间\",{\"1\":{\"693\":1}}],[\"这样数据全部保留不会丢失\",{\"1\":{\"659\":1}}],[\"这样一个方法\",{\"1\":{\"914\":1}}],[\"这样一种手段\",{\"1\":{\"589\":1}}],[\"这样一来\",{\"1\":{\"347\":1,\"836\":1,\"927\":1}}],[\"这样你就不用跑路\",{\"1\":{\"471\":1}}],[\"这样你才可以立即驱散一个\",{\"1\":{\"431\":1}}],[\"这样伤害比较平均\",{\"1\":{\"438\":1}}],[\"这样中间不会被污染\",{\"1\":{\"425\":1}}],[\"这样可以让查询时的多次随机\",{\"1\":{\"1393\":1}}],[\"这样可以保证每个队列最多被一个消费线程处理\",{\"1\":{\"1206\":1}}],[\"这样可以保证消息的顺序\",{\"1\":{\"1155\":1}}],[\"这样可以节省客户端资源\",{\"1\":{\"1036\":1}}],[\"这样可以及时对他释放回春术\",{\"1\":{\"401\":1}}],[\"这样可以自动生成基准测试代码\",{\"1\":{\"7\":1}}],[\"这样每个节点的分布就相对更均匀\",{\"1\":{\"388\":1}}],[\"这样每个节点保存的数据可能是不同的\",{\"1\":{\"384\":1}}],[\"这样每次有新的worker上线\",{\"1\":{\"378\":1}}],[\"这样避免了多个server通过加锁来抢占调度任务的情况\",{\"1\":{\"380\":1}}],[\"这样设计的原因是\",{\"1\":{\"1313\":1}}],[\"这样设计的初衷应该是考虑到秒级任务执行频率较大\",{\"1\":{\"374\":1}}],[\"这样设计可以减少资源消耗\",{\"1\":{\"379\":1}}],[\"这样就实现了为不同请求码设置对应线程池\",{\"1\":{\"1055\":1}}],[\"这样就实现了内存级别的读写分离\",{\"1\":{\"883\":1}}],[\"这样就不会增加其他\",{\"1\":{\"1012\":1}}],[\"这样就会造成生产方和消费方互相\",{\"1\":{\"1003\":1}}],[\"这样就会造成很多额外的出入队操作\",{\"1\":{\"931\":1}}],[\"这样就会经历\",{\"1\":{\"687\":1}}],[\"这样就可能造成主从切换后丢失消息\",{\"1\":{\"930\":1}}],[\"这样就可以访问\",{\"1\":{\"1508\":1}}],[\"这样就可以实现多个客户端同时拉取一个队列的效果\",{\"1\":{\"1250\":1}}],[\"这样就可以像发送普通消息一样发送批量消息\",{\"1\":{\"1044\":1}}],[\"这样就可以免去将投递任务加入到时间轮这个操作\",{\"1\":{\"932\":1}}],[\"这样就可以在投递完后的第二天把整个文件队列删除\",{\"1\":{\"928\":1}}],[\"这样就可以在不重新复制字节数组的情况下传递\",{\"1\":{\"730\":1}}],[\"这样就可以立即消费到最新的消息\",{\"1\":{\"803\":1}}],[\"这样就可以节省\",{\"1\":{\"401\":1}}],[\"这样就可以通过一个线程管理多个\",{\"1\":{\"118\":1}}],[\"这样就无需有内核态再往用户态的拷贝\",{\"1\":{\"880\":1}}],[\"这样就节省了从磁盘上读取数据的时间\",{\"1\":{\"879\":1}}],[\"这样就带来了较大且不稳定的内存消耗\",{\"1\":{\"681\":1}}],[\"这样就出现了数据丢失\",{\"1\":{\"659\":1}}],[\"这样就形成了一个小型的子系统\",{\"1\":{\"380\":1}}],[\"这样就能充分利用线程\",{\"1\":{\"116\":1}}],[\"这样\",{\"1\":{\"81\":1,\"124\":2,\"365\":1,\"368\":1,\"375\":1,\"438\":1,\"459\":1,\"622\":2,\"633\":1,\"678\":1,\"879\":1,\"925\":1,\"1188\":1,\"1255\":1,\"1287\":1,\"1291\":1,\"1393\":1,\"1398\":1,\"1400\":1,\"1511\":1}}],[\"这种情况通常发生在\",{\"1\":{\"1519\":1}}],[\"这种情况在\",{\"1\":{\"1511\":2,\"1520\":2}}],[\"这种情况下可能之前推送的日志条目被\",{\"1\":{\"1510\":1}}],[\"这种情况下不能贸然释放\",{\"1\":{\"1215\":1}}],[\"这种情况可以在方法中自行覆盖参数\",{\"1\":{\"273\":1}}],[\"这种发送方式性能最高\",{\"1\":{\"1027\":1}}],[\"这种方式的优点是\",{\"1\":{\"1364\":1}}],[\"这种方式相比于同步发送\",{\"1\":{\"1027\":1}}],[\"这种方式最为可靠\",{\"1\":{\"1027\":1}}],[\"这种方式需要定义新的关键字并扩展编译器\",{\"1\":{\"85\":1}}],[\"这种\",{\"1\":{\"773\":1}}],[\"这种高性能中间件来说\",{\"1\":{\"722\":1}}],[\"这种类就叫做\",{\"1\":{\"579\":1}}],[\"这种类型的异常称为checked\",{\"1\":{\"33\":1}}],[\"这种写法其实在\",{\"1\":{\"556\":1}}],[\"这种程序结构称为\",{\"1\":{\"329\":1}}],[\"这种复杂性增加了系统状态可观测性的难度\",{\"1\":{\"276\":1}}],[\"这种调用形式要比apply好得多\",{\"1\":{\"200\":1}}],[\"这种函数式编程语言的不可变状态\",{\"1\":{\"173\":1}}],[\"这种编程方式也就是\",{\"1\":{\"111\":1}}],[\"这种传播级别可用于核心更新逻辑\",{\"1\":{\"87\":1}}],[\"这种传播级别可用于查询方法\",{\"1\":{\"87\":1}}],[\"这种无侵入的设计有以下好处\",{\"1\":{\"81\":1}}],[\"这种搜索全部子目录的做法\",{\"1\":{\"21\":1}}],[\"这个表中存储着集群中所有节点的日志转发最新水位\",{\"1\":{\"1507\":1}}],[\"这个索引文件处于未压缩状态\",{\"1\":{\"1411\":1}}],[\"这个过程在这里是同步的\",{\"1\":{\"1403\":1}}],[\"这个过程称为\",{\"1\":{\"1251\":1}}],[\"这个配置默认为\",{\"1\":{\"1308\":1}}],[\"这个特性主要是为了支持在一些消息场景下可能存在的大量队列场景\",{\"1\":{\"1284\":1}}],[\"这个实现可能导致消费线程池中多个线程同时等待一把锁\",{\"1\":{\"1207\":1}}],[\"这个实现方案太重了\",{\"1\":{\"942\":1}}],[\"这个线程的作用是\",{\"1\":{\"1358\":1,\"1359\":1,\"1360\":1}}],[\"这个线程通过遍历消费队列索引的方式不断扫描定时消息\",{\"1\":{\"1355\":1}}],[\"这个线程仅仅是异步发送自动拉取请求\",{\"1\":{\"1155\":1}}],[\"这个线程每\",{\"1\":{\"864\":1}}],[\"这个拉取请求中保存一个处理队列\",{\"1\":{\"1104\":1}}],[\"这个脚本预留了定义额外的\",{\"1\":{\"1080\":1}}],[\"这个地方\",{\"1\":{\"1072\":1}}],[\"这个项目提供了\",{\"1\":{\"1069\":1}}],[\"这个异步线程池批量将轨迹信息打包发送给\",{\"1\":{\"1011\":1}}],[\"这个简单的场景涉及了几个概念\",{\"1\":{\"978\":1}}],[\"这个集合保存在内存中可能会造成内存泄漏\",{\"1\":{\"935\":1}}],[\"这个阻塞队列的长度就代表着同时可以的进行异步投递任务的数量\",{\"1\":{\"933\":1}}],[\"这个回调的触发可以用分布式定时任务来处理\",{\"1\":{\"921\":1,\"1337\":1}}],[\"这个方案的好处是可以不需要\",{\"1\":{\"1453\":1}}],[\"这个方案的局限性在于扫描的每个队列的消息延迟时间必须是相同的\",{\"1\":{\"1342\":1}}],[\"这个方案是实际提交的优化方案\",{\"1\":{\"916\":1}}],[\"这个方法获取信号量\",{\"1\":{\"1403\":1}}],[\"这个方法用于推模式的消费\",{\"1\":{\"1187\":1}}],[\"这个方法用于创建消息的全局唯一\",{\"1\":{\"899\":1}}],[\"这个方法中填写本地事务逻辑\",{\"1\":{\"1442\":1}}],[\"这个方法中包含了消息发送的核心逻辑\",{\"1\":{\"1038\":1}}],[\"这个方法中根据topic和queueid查询相应的consumequeue\",{\"1\":{\"757\":1}}],[\"这个方法具体在\",{\"1\":{\"914\":1}}],[\"这个方法试图从\",{\"1\":{\"896\":1}}],[\"这个方法被客户端在发送消息时调用\",{\"1\":{\"896\":1}}],[\"这个方法占用了\",{\"1\":{\"896\":1}}],[\"这个方法会先释放\",{\"1\":{\"870\":1}}],[\"这个方法是重新唤醒拉取请求的核心方法\",{\"1\":{\"825\":1}}],[\"这个方法在两个地方被调用\",{\"1\":{\"825\":1}}],[\"这个方法在内部使用了stringjoiner来拼接字符串\",{\"1\":{\"29\":1}}],[\"这个修改将消费\",{\"1\":{\"913\":1}}],[\"这个修改可以提升\",{\"1\":{\"910\":1}}],[\"这个提交优化了\",{\"1\":{\"894\":1}}],[\"这个读的过程就会比较慢\",{\"1\":{\"879\":1}}],[\"这个任务不是周期性任务\",{\"1\":{\"858\":1}}],[\"这个任务的\",{\"1\":{\"857\":1}}],[\"这个任务并不是周期性任务\",{\"1\":{\"857\":1}}],[\"这个改动将延迟消息的任务调度器从\",{\"1\":{\"852\":1}}],[\"这个类承载\",{\"1\":{\"1396\":1}}],[\"这个类仅定义了\",{\"1\":{\"989\":1}}],[\"这个类\",{\"1\":{\"897\":1}}],[\"这个类扩展了\",{\"1\":{\"840\":1}}],[\"这个类的初始化做了以下几件事\",{\"1\":{\"379\":1}}],[\"这个解析\",{\"1\":{\"742\":1,\"890\":1}}],[\"这个消息\",{\"1\":{\"736\":1}}],[\"这个优化是本批次修改里面改动最大的\",{\"1\":{\"736\":1}}],[\"这个优化比较简单\",{\"1\":{\"722\":1}}],[\"这个锁里面干的事情非常的多\",{\"1\":{\"736\":1}}],[\"这个锁也就是影响\",{\"1\":{\"733\":1,\"736\":1}}],[\"这个参数改成\",{\"1\":{\"735\":1}}],[\"这个问题同样使节点的滚动升级存在很大的隐患\",{\"1\":{\"693\":1}}],[\"这个问题也引发滚动升级的问题\",{\"1\":{\"678\":1}}],[\"这个时候\",{\"1\":{\"673\":1}}],[\"这个时候你需要持续高额的治疗\",{\"1\":{\"433\":1}}],[\"这个组的信息会记录在\",{\"1\":{\"673\":1}}],[\"这个组件用来实现多路复用\",{\"1\":{\"118\":1}}],[\"这个设置非常保守\",{\"1\":{\"657\":1}}],[\"这个节点上的所有队列都不再可用\",{\"1\":{\"648\":1}}],[\"这个包\",{\"1\":{\"645\":1}}],[\"这个接收进程就阻塞在receive方法上\",{\"1\":{\"625\":1}}],[\"这个函数要么不返回值\",{\"1\":{\"605\":1}}],[\"这个函数接受所修饰对象的一些相关值作为参数\",{\"1\":{\"605\":1}}],[\"这个函数的作用是指示\",{\"1\":{\"193\":1}}],[\"这个函数的作用是抛出一个调用者可能想要捕捉的异常错误\",{\"1\":{\"193\":1}}],[\"这个语句只能输入类型\",{\"1\":{\"592\":1}}],[\"这个层数其实都可以\",{\"1\":{\"476\":1}}],[\"这个本属于没有特别明显的难点\",{\"1\":{\"468\":1}}],[\"这个本老一前面的怪\",{\"1\":{\"468\":1}}],[\"这个本道具的规划也很重要\",{\"1\":{\"455\":1}}],[\"这个本\",{\"1\":{\"455\":1}}],[\"这个本难度为四星\",{\"1\":{\"455\":1}}],[\"这个是本赛季治疗压力最大的\",{\"1\":{\"446\":1}}],[\"这个是纯机制\",{\"1\":{\"445\":1}}],[\"这个技能每\",{\"1\":{\"433\":1}}],[\"这个技能不会受到\",{\"1\":{\"413\":1}}],[\"这个\",{\"1\":{\"425\":1,\"426\":1,\"427\":1,\"432\":1,\"434\":1,\"441\":1,\"453\":1,\"458\":1,\"459\":1,\"626\":1,\"714\":1,\"731\":1,\"987\":1,\"990\":1,\"1012\":1,\"1418\":1,\"1435\":2}}],[\"这个窗口设定为\",{\"1\":{\"420\":1}}],[\"这个机制允许你在读完一个技能之前就排队执行下一个技能\",{\"1\":{\"420\":1}}],[\"这个天赋让你可以在两个不同目标身上释放生命绽放\",{\"1\":{\"405\":1}}],[\"这个天赋推荐给新手使用\",{\"1\":{\"403\":1}}],[\"这个在冲层时可以提升生存能力\",{\"1\":{\"401\":1}}],[\"这个环被称为哈希环\",{\"1\":{\"387\":1}}],[\"这个属性不一定是xiaoming的\",{\"1\":{\"299\":1}}],[\"这个内置函数\",{\"1\":{\"261\":1}}],[\"这个操作就会失败\",{\"1\":{\"192\":1}}],[\"这个操作总是成功的\",{\"1\":{\"192\":1}}],[\"这个列表包含了代表字符串里各个字符的整数字符代码\",{\"1\":{\"178\":1}}],[\"这个变量具有那个值\",{\"1\":{\"173\":1}}],[\"这个单词及环绕这个单词的字符\",{\"1\":{\"155\":1}}],[\"这个命令时\",{\"1\":{\"62\":1}}],[\"这个图片可以帮助快速查阅\",{\"1\":{\"12\":1}}],[\"sbr\",{\"1\":{\"1372\":3}}],[\"sbrs\",{\"1\":{\"1372\":3}}],[\"sb\",{\"1\":{\"1235\":7}}],[\"sba8hu3a5rynbn7l9jpbb3m5x4blqmzu07df07v6cbv9yfngppeawfcuhg9tgidaomdpspa3d7sbihotecvfv\",{\"1\":{\"423\":1}}],[\"smaller\",{\"1\":{\"1370\":1,\"1432\":1,\"1519\":2,\"1520\":3}}],[\"small\",{\"1\":{\"1173\":2,\"1174\":1,\"1175\":1,\"1270\":1,\"1427\":1,\"1430\":2,\"1432\":1,\"1497\":2,\"1503\":2}}],[\"smartcase\",{\"1\":{\"167\":1}}],[\"sd\",{\"1\":{\"1170\":5}}],[\"sdk\",{\"0\":{\"712\":1},\"1\":{\"712\":1,\"1235\":1,\"1385\":1}}],[\"skipped\",{\"1\":{\"1370\":1}}],[\"skip\",{\"1\":{\"861\":3,\"894\":1,\"1020\":2,\"1266\":1,\"1278\":1,\"1279\":2,\"1280\":3,\"1435\":1,\"1468\":1}}],[\"svg\",{\"1\":{\"756\":1,\"806\":1,\"812\":1}}],[\"swapout\",{\"1\":{\"882\":1}}],[\"swap\",{\"1\":{\"882\":2}}],[\"swaprequests\",{\"1\":{\"725\":2}}],[\"swimmable\",{\"1\":{\"571\":1}}],[\"swimming\",{\"1\":{\"490\":1}}],[\"switchpop\",{\"1\":{\"1248\":3}}],[\"switch\",{\"1\":{\"515\":1,\"764\":1,\"794\":1,\"819\":1,\"861\":1,\"971\":1,\"1020\":2,\"1047\":1,\"1048\":1,\"1050\":1,\"1053\":1,\"1122\":2,\"1123\":1,\"1143\":1,\"1144\":1,\"1172\":1,\"1173\":4,\"1175\":1,\"1195\":2,\"1198\":1,\"1224\":1,\"1229\":1,\"1266\":1,\"1331\":1,\"1432\":1,\"1436\":1,\"1442\":1,\"1459\":1,\"1460\":1,\"1472\":1,\"1497\":1,\"1499\":1,\"1519\":2,\"1520\":2}}],[\"switching\",{\"1\":{\"368\":1}}],[\"s4\",{\"1\":{\"509\":1}}],[\"s3\",{\"1\":{\"509\":1}}],[\"slow\",{\"1\":{\"1173\":1}}],[\"slotbuffer\",{\"1\":{\"1436\":4}}],[\"slotoldvalue\",{\"1\":{\"1434\":4}}],[\"slotstotal\",{\"1\":{\"1367\":2}}],[\"slotvalue\",{\"1\":{\"797\":10,\"1435\":5,\"1436\":5}}],[\"slotposition\",{\"1\":{\"1434\":3,\"1435\":4,\"1436\":4}}],[\"slotpos\",{\"1\":{\"797\":4}}],[\"slot\",{\"1\":{\"787\":3,\"1367\":10,\"1371\":10,\"1372\":4,\"1434\":1,\"1435\":4,\"1436\":3}}],[\"sleep\",{\"1\":{\"861\":2,\"870\":1,\"871\":1,\"882\":1,\"1278\":2,\"1288\":1,\"1297\":2,\"1374\":1,\"1443\":1,\"1468\":2,\"1510\":1,\"1519\":4,\"1520\":1,\"1521\":1}}],[\"slave收到数据后保存到自己的commitlog\",{\"1\":{\"729\":1}}],[\"slave\",{\"1\":{\"672\":2,\"729\":4,\"762\":1,\"827\":1,\"840\":1,\"886\":1,\"910\":1,\"912\":1,\"965\":1,\"971\":2,\"1173\":3,\"1200\":1,\"1273\":2,\"1278\":1,\"1279\":1,\"1280\":1,\"1297\":1,\"1372\":1,\"1459\":2,\"1464\":3}}],[\"sl3ifmwud2mpznezfrz8wh2kqwivyr\",{\"1\":{\"469\":1}}],[\"slicebytebuffer\",{\"1\":{\"771\":2}}],[\"slice\",{\"1\":{\"298\":3,\"547\":1,\"882\":1,\"1174\":1,\"1432\":4,\"1517\":1}}],[\"sline\",{\"1\":{\"147\":1}}],[\"sj\",{\"1\":{\"469\":1}}],[\"sndbuf\",{\"1\":{\"1300\":1}}],[\"snapshot\",{\"1\":{\"942\":1,\"1171\":1}}],[\"sname\",{\"1\":{\"252\":1}}],[\"snuvxctkngeu5mobintjiqehcg2\",{\"1\":{\"436\":1}}],[\"salve连接到master\",{\"1\":{\"729\":1}}],[\"saturday\",{\"1\":{\"587\":1}}],[\"same\",{\"1\":{\"971\":1,\"1173\":2,\"1371\":1}}],[\"samkfrd7vtwwyapnia6iwyufnruqknobzgsgyqjklygyjlj5rqiltczmry5kwsx2m\",{\"1\":{\"469\":1}}],[\"sample\",{\"1\":{\"7\":1,\"21\":4,\"1519\":1}}],[\"save\",{\"1\":{\"364\":1,\"720\":2,\"1056\":1,\"1297\":2}}],[\"s1\",{\"1\":{\"302\":1,\"509\":1}}],[\"sqs\",{\"1\":{\"922\":1}}],[\"sqrt\",{\"1\":{\"196\":3}}],[\"squarerootnegativeargument\",{\"1\":{\"196\":1}}],[\"square\",{\"1\":{\"180\":4}}],[\"sqlfilter\",{\"1\":{\"1321\":1}}],[\"sqlfiltertest\",{\"1\":{\"1309\":1,\"1310\":2}}],[\"sql92\",{\"0\":{\"1301\":1,\"1308\":1,\"1315\":1,\"1320\":1,\"1330\":1},\"1\":{\"1117\":1,\"1170\":1,\"1173\":1,\"1303\":2,\"1308\":3,\"1310\":1,\"1315\":3,\"1317\":2,\"1318\":4,\"1321\":4,\"1322\":1,\"1323\":1,\"1325\":1,\"1328\":1,\"1331\":1,\"1332\":1,\"1333\":4,\"1538\":1}}],[\"sqlserver\",{\"1\":{\"371\":1}}],[\"sql\",{\"0\":{\"1321\":1},\"1\":{\"89\":1,\"253\":4,\"1321\":2}}],[\"s2\",{\"1\":{\"167\":2,\"302\":1,\"509\":1}}],[\"s句子\",{\"1\":{\"155\":1}}],[\"since\",{\"1\":{\"1056\":1}}],[\"sing\",{\"1\":{\"544\":2}}],[\"single\",{\"1\":{\"720\":1,\"736\":1,\"1468\":1}}],[\"single=true\",{\"1\":{\"316\":1}}],[\"singleton\",{\"0\":{\"99\":1},\"1\":{\"99\":5}}],[\"signature\",{\"1\":{\"995\":3,\"1000\":4}}],[\"sig后再无太大动静\",{\"1\":{\"276\":1}}],[\"simplified\",{\"1\":{\"614\":2,\"621\":2}}],[\"simpleconsumer\",{\"1\":{\"1310\":1}}],[\"simpledecorator\",{\"1\":{\"605\":2}}],[\"simplehash\",{\"1\":{\"385\":1}}],[\"simple\",{\"1\":{\"96\":1,\"1500\":1}}],[\"side\",{\"1\":{\"180\":6,\"886\":1,\"1281\":1}}],[\"site\",{\"1\":{\"165\":1}}],[\"size=\",{\"1\":{\"1170\":2,\"1431\":1}}],[\"sizepy=\",{\"1\":{\"845\":2,\"860\":1,\"1174\":1}}],[\"sizepy\",{\"1\":{\"767\":2,\"845\":5,\"860\":8,\"1174\":4,\"1370\":3,\"1371\":3,\"1372\":2}}],[\"size之间有一个快速的网络\",{\"1\":{\"658\":1}}],[\"size\",{\"1\":{\"124\":4,\"172\":1,\"737\":9,\"762\":2,\"765\":8,\"767\":2,\"771\":8,\"793\":1,\"794\":3,\"797\":5,\"845\":3,\"860\":4,\"870\":1,\"882\":3,\"970\":2,\"994\":2,\"998\":4,\"999\":2,\"1020\":3,\"1021\":1,\"1052\":4,\"1072\":1,\"1143\":3,\"1145\":1,\"1170\":1,\"1174\":4,\"1175\":1,\"1194\":4,\"1195\":8,\"1222\":2,\"1229\":1,\"1267\":5,\"1269\":1,\"1270\":3,\"1275\":1,\"1277\":1,\"1278\":1,\"1329\":1,\"1332\":1,\"1333\":1,\"1352\":2,\"1367\":2,\"1370\":4,\"1371\":8,\"1372\":5,\"1373\":3,\"1374\":1,\"1420\":2,\"1428\":1,\"1431\":2,\"1432\":6,\"1434\":8,\"1435\":15,\"1436\":18,\"1468\":3,\"1516\":2,\"1517\":1,\"1518\":1,\"1519\":2,\"1521\":3}}],[\"silent\",{\"1\":{\"99\":1}}],[\"spongecaptain\",{\"1\":{\"1527\":1}}],[\"spi\",{\"1\":{\"990\":1,\"996\":1}}],[\"spied\",{\"1\":{\"97\":1}}],[\"sph9a0n3lqvqt3iymyjbvdlqwxkz\",{\"1\":{\"443\":1}}],[\"spend\",{\"1\":{\"1332\":1}}],[\"speed\",{\"1\":{\"886\":1,\"913\":1}}],[\"spellqueuewindow\",{\"1\":{\"420\":1}}],[\"spell\",{\"1\":{\"420\":1}}],[\"specifying\",{\"1\":{\"1287\":1}}],[\"specify\",{\"1\":{\"1047\":1,\"1122\":1}}],[\"specified\",{\"1\":{\"97\":1,\"396\":1,\"1048\":1,\"1123\":1,\"1269\":1}}],[\"spec\",{\"1\":{\"223\":2,\"241\":1}}],[\"spm=a2c6h\",{\"1\":{\"381\":1}}],[\"splice\",{\"1\":{\"298\":4}}],[\"splitmessagebuffer\",{\"1\":{\"1432\":1}}],[\"splitintolists\",{\"1\":{\"1372\":2}}],[\"splitter\",{\"1\":{\"1296\":2,\"1297\":2}}],[\"splitor\",{\"1\":{\"1021\":2}}],[\"split性能更好的方法\",{\"1\":{\"743\":1}}],[\"split\",{\"1\":{\"143\":2,\"547\":1,\"741\":2,\"794\":1,\"823\":1,\"1021\":1,\"1270\":2,\"1273\":1,\"1287\":1,\"1296\":1,\"1297\":2,\"1425\":1,\"1432\":1,\"1480\":1,\"1516\":1}}],[\"span\",{\"1\":{\"1170\":1}}],[\"spawn\",{\"1\":{\"229\":2,\"230\":2,\"235\":1}}],[\"spacefull\",{\"1\":{\"870\":5}}],[\"space\",{\"1\":{\"147\":2,\"643\":1,\"737\":3,\"765\":1,\"870\":1,\"882\":1}}],[\"sp\",{\"1\":{\"143\":1,\"153\":1}}],[\"spy\",{\"1\":{\"97\":1,\"98\":1}}],[\"springboot\",{\"1\":{\"372\":1}}],[\"springframework\",{\"1\":{\"95\":1,\"266\":4}}],[\"spring本身也开发了一个mvc框架\",{\"1\":{\"93\":1}}],[\"spring虽然都可以集成任何web框架\",{\"1\":{\"93\":1}}],[\"spring总是把jdbc相关的connection和transactionstatus实例绑定到threadlocal\",{\"1\":{\"87\":1}}],[\"spring使用声明式事务\",{\"1\":{\"87\":1}}],[\"spring提供的声明式事务极大地方便了在数据库中使用事务\",{\"1\":{\"87\":1}}],[\"spring提供了resource类便于注入资源文件\",{\"1\":{\"83\":1}}],[\"spring的aop实现就是基于jvm的动态代理\",{\"1\":{\"85\":1}}],[\"spring的ioc容器是一个高度可扩展的无侵入容器\",{\"1\":{\"81\":1}}],[\"spring还提供了\",{\"1\":{\"84\":1}}],[\"spring允许通过\",{\"1\":{\"84\":1}}],[\"spring默认使用singleton创建bean\",{\"1\":{\"82\":1}}],[\"spring\",{\"0\":{\"79\":1,\"94\":1,\"265\":1,\"266\":1},\"1\":{\"84\":1,\"95\":2,\"266\":1,\"269\":1,\"272\":7,\"273\":1,\"1004\":1}}],[\"sh\",{\"1\":{\"1072\":4,\"1074\":10,\"1075\":5,\"1077\":5,\"1079\":11,\"1080\":6,\"1081\":2,\"1083\":2,\"1084\":2}}],[\"sheep\",{\"1\":{\"563\":4}}],[\"shell也是一个进程\",{\"1\":{\"230\":1}}],[\"shell打印某个列表的值时\",{\"1\":{\"178\":1}}],[\"shell\",{\"0\":{\"171\":1,\"243\":1},\"1\":{\"171\":4,\"180\":1,\"191\":3,\"195\":6,\"224\":2,\"230\":1,\"371\":1}}],[\"shift\",{\"1\":{\"298\":6}}],[\"shortpollingtimemills\",{\"1\":{\"805\":1}}],[\"short\",{\"1\":{\"737\":4,\"1296\":3}}],[\"shorthand\",{\"1\":{\"171\":1}}],[\"shouldrunningdequeue\",{\"1\":{\"1371\":1}}],[\"shouldrunpoprevive\",{\"1\":{\"1278\":1,\"1279\":1,\"1280\":1}}],[\"should\",{\"1\":{\"396\":3,\"983\":1,\"1053\":1,\"1145\":1,\"1266\":2,\"1277\":1,\"1333\":1,\"1444\":1,\"1500\":1,\"1520\":1}}],[\"shout\",{\"1\":{\"255\":2}}],[\"shop\",{\"1\":{\"180\":1,\"183\":1,\"253\":42}}],[\"showtooltips\",{\"1\":{\"489\":1,\"490\":1}}],[\"showtooltip\",{\"1\":{\"489\":8,\"490\":7}}],[\"shows\",{\"1\":{\"289\":2}}],[\"show\",{\"1\":{\"89\":1}}],[\"shutdownablethread\",{\"1\":{\"1519\":1,\"1520\":1,\"1521\":1}}],[\"shutdownhook\",{\"1\":{\"1021\":1}}],[\"shutdownhookthread\",{\"1\":{\"960\":1}}],[\"shutdown\",{\"1\":{\"113\":1,\"126\":1,\"129\":1,\"657\":1,\"659\":2,\"861\":1,\"866\":2,\"960\":2,\"961\":6,\"967\":1,\"984\":1,\"1047\":1,\"1122\":2,\"1136\":2,\"1174\":2,\"1427\":1,\"1435\":1,\"1436\":1}}],[\"share\",{\"1\":{\"1247\":1,\"1267\":1}}],[\"shared\",{\"1\":{\"23\":2}}],[\"shape\",{\"1\":{\"560\":2}}],[\"sha\",{\"1\":{\"390\":3}}],[\"shade\",{\"1\":{\"64\":3}}],[\"scenarios\",{\"1\":{\"1427\":1}}],[\"screen\",{\"1\":{\"767\":1,\"1174\":1,\"1430\":1}}],[\"script\",{\"1\":{\"500\":1}}],[\"scheme\",{\"1\":{\"515\":2}}],[\"schema\",{\"1\":{\"252\":2,\"253\":1}}],[\"schedulenexttimertask\",{\"1\":{\"860\":5}}],[\"schedulenormaljob0方法中\",{\"1\":{\"379\":1}}],[\"schedulenormaljob0方法为例\",{\"1\":{\"374\":1}}],[\"scheduleatfixedrate\",{\"1\":{\"844\":2,\"869\":1,\"961\":2,\"1048\":5,\"1201\":1}}],[\"schedulemessagetimerthread\",{\"1\":{\"844\":1}}],[\"schedulemessageservice的内部类\",{\"1\":{\"841\":1}}],[\"schedulemessageservice\",{\"0\":{\"840\":1,\"844\":1},\"1\":{\"836\":1,\"843\":1,\"844\":1,\"845\":12,\"856\":1,\"860\":7,\"861\":7}}],[\"schedule\",{\"1\":{\"836\":1,\"843\":1,\"844\":1,\"845\":7,\"860\":4,\"861\":1,\"964\":1,\"1048\":1,\"1198\":1,\"1201\":1}}],[\"scheduledtask\",{\"1\":{\"1048\":5}}],[\"scheduledexecutorservice\",{\"1\":{\"840\":1,\"850\":1,\"852\":2,\"869\":1,\"961\":3,\"1048\":5,\"1201\":1}}],[\"scheduled\",{\"1\":{\"830\":1,\"849\":1,\"918\":1,\"930\":2,\"1339\":1}}],[\"schedulerx\",{\"1\":{\"381\":1}}],[\"schedule方法的逻辑比较简单\",{\"1\":{\"379\":1}}],[\"school\",{\"1\":{\"299\":5,\"316\":4}}],[\"scantimes\",{\"1\":{\"1277\":2}}],[\"scantimes++\",{\"1\":{\"1277\":1}}],[\"scancommitoffset\",{\"1\":{\"1277\":1}}],[\"scan\",{\"0\":{\"1277\":1},\"1\":{\"1262\":1,\"1277\":1,\"1278\":2}}],[\"scannotactivebroker\",{\"1\":{\"961\":1}}],[\"scanner\",{\"1\":{\"70\":4}}],[\"scarb\",{\"1\":{\"255\":5}}],[\"scalable\",{\"0\":{\"107\":1},\"1\":{\"108\":1,\"136\":1,\"138\":1}}],[\"score\",{\"1\":{\"11\":2,\"741\":1}}],[\"scope\",{\"1\":{\"9\":1,\"60\":1,\"104\":2}}],[\"ssl\",{\"1\":{\"961\":2,\"1074\":1}}],[\"sslcontext\",{\"1\":{\"961\":2}}],[\"ss\",{\"1\":{\"69\":2,\"167\":2,\"455\":1}}],[\"soon\",{\"1\":{\"870\":1}}],[\"socat\",{\"1\":{\"645\":4}}],[\"sock\",{\"1\":{\"69\":10,\"70\":4,\"625\":3}}],[\"socketaddress2bytebuffer\",{\"1\":{\"737\":2,\"738\":2}}],[\"socketchannel\",{\"1\":{\"118\":2,\"123\":3,\"124\":4,\"128\":1,\"133\":4,\"135\":1}}],[\"socket\",{\"1\":{\"69\":3,\"70\":2,\"113\":10,\"121\":3,\"123\":4,\"124\":9,\"125\":4,\"128\":4,\"133\":5,\"614\":1,\"621\":1,\"668\":1,\"1080\":1,\"1300\":1}}],[\"socket是一个抽象概念\",{\"1\":{\"68\":1}}],[\"solutions\",{\"1\":{\"642\":1,\"644\":1}}],[\"solution\",{\"1\":{\"642\":1,\"644\":1}}],[\"sorted\",{\"1\":{\"1521\":1}}],[\"sortedwatermarks\",{\"1\":{\"1521\":3}}],[\"sortedmap<string\",{\"1\":{\"995\":2}}],[\"sortedmap<long\",{\"1\":{\"396\":2}}],[\"sortedmap\",{\"1\":{\"995\":1}}],[\"sortlist\",{\"1\":{\"1279\":2}}],[\"sort\",{\"0\":{\"326\":1},\"1\":{\"298\":2,\"793\":1,\"995\":1,\"1143\":2,\"1266\":2}}],[\"somevalue\",{\"1\":{\"546\":2}}],[\"somefunction\",{\"1\":{\"207\":1}}],[\"somemodule\",{\"1\":{\"207\":1}}],[\"somemethod\",{\"1\":{\"103\":1}}],[\"sometag\",{\"1\":{\"204\":2}}],[\"some\",{\"1\":{\"196\":1,\"208\":1,\"252\":1,\"253\":1,\"396\":1,\"720\":4,\"732\":1,\"736\":2,\"886\":1,\"1056\":1,\"1427\":1,\"1519\":2}}],[\"someexpression时\",{\"1\":{\"173\":1}}],[\"someobj\",{\"1\":{\"103\":1}}],[\"so\",{\"1\":{\"97\":1,\"646\":1,\"845\":1,\"860\":1,\"1144\":1,\"1170\":4,\"1174\":2,\"1225\":1,\"1228\":1,\"1230\":2,\"1297\":1,\"1300\":1,\"1373\":1,\"1435\":1,\"1464\":1}}],[\"sources\",{\"1\":{\"62\":4,\"644\":1}}],[\"source\",{\"1\":{\"25\":1,\"43\":1,\"44\":1,\"165\":1}}],[\"source指定源码版本\",{\"1\":{\"25\":1}}],[\"segment\",{\"1\":{\"1436\":2}}],[\"sealtimestamp\",{\"1\":{\"1420\":2}}],[\"sealed\",{\"1\":{\"1394\":3,\"1412\":2,\"1414\":1,\"1415\":1,\"1417\":1,\"1434\":2,\"1435\":4,\"1436\":4}}],[\"searchliveinfo\",{\"1\":{\"266\":1}}],[\"search\",{\"1\":{\"143\":1,\"1073\":1}}],[\"separator\",{\"1\":{\"793\":1,\"794\":1,\"823\":1,\"1201\":1}}],[\"serializetypecurrentrpc\",{\"1\":{\"893\":1,\"894\":2}}],[\"serializetypeconfiginthisserver\",{\"1\":{\"893\":1}}],[\"serializetype\",{\"1\":{\"893\":3,\"894\":2}}],[\"serialize\",{\"1\":{\"737\":2,\"894\":1}}],[\"series\",{\"1\":{\"642\":1}}],[\"serving\",{\"1\":{\"1275\":1,\"1276\":1,\"1277\":1}}],[\"servicestate\",{\"1\":{\"1047\":8,\"1048\":5,\"1122\":8,\"1123\":5}}],[\"serviceprovider\",{\"1\":{\"996\":2}}],[\"service\",{\"1\":{\"824\":3,\"990\":1,\"996\":2,\"999\":3,\"1047\":2,\"1048\":3,\"1075\":1,\"1078\":1,\"1122\":2,\"1140\":2,\"1168\":3,\"1371\":2,\"1373\":2,\"1374\":2,\"1427\":2,\"1435\":1,\"1467\":2}}],[\"servicethread\",{\"1\":{\"724\":1,\"915\":1,\"1140\":2}}],[\"serverless\",{\"1\":{\"1378\":2}}],[\"serverless设计理念也在不断被一些分布式系统设计者逐步接受\",{\"1\":{\"276\":1}}],[\"server1\",{\"1\":{\"1287\":1,\"1288\":1}}],[\"serverv\",{\"1\":{\"1173\":1}}],[\"server=y\",{\"1\":{\"1080\":1}}],[\"serverutil\",{\"1\":{\"960\":3}}],[\"server2\",{\"1\":{\"624\":2,\"1287\":1,\"1288\":1}}],[\"server在下一次下发serverschedulejobreq请求时会携带最新worker信息\",{\"1\":{\"375\":1}}],[\"server端主要对两种actor\",{\"1\":{\"374\":1}}],[\"server端只是负责拉起这个任务\",{\"1\":{\"374\":1}}],[\"server网络通信层初始化\",{\"1\":{\"374\":1}}],[\"server初始化流程\",{\"0\":{\"374\":1}}],[\"serverbootstrapacceptor\",{\"1\":{\"135\":3}}],[\"serverbootstrap\",{\"1\":{\"133\":1,\"135\":2}}],[\"serversocketchannel\",{\"1\":{\"118\":2,\"121\":2,\"131\":2,\"132\":2,\"133\":5}}],[\"serversocket\",{\"1\":{\"69\":2,\"112\":4,\"121\":5,\"123\":1,\"131\":2,\"133\":6}}],[\"server\",{\"1\":{\"69\":2,\"70\":1,\"78\":1,\"112\":2,\"368\":1,\"369\":4,\"372\":3,\"380\":3,\"645\":8,\"646\":2,\"943\":1,\"947\":4,\"949\":1,\"950\":1,\"953\":1,\"960\":10,\"961\":2,\"968\":1,\"970\":4,\"971\":2,\"973\":1,\"1048\":1,\"1080\":5,\"1120\":1,\"1123\":1,\"1160\":1,\"1281\":1,\"1446\":1}}],[\"servlet\",{\"0\":{\"78\":1},\"1\":{\"60\":1,\"78\":3}}],[\"security\",{\"1\":{\"995\":2}}],[\"securitytoken\",{\"1\":{\"995\":5}}],[\"secure\",{\"1\":{\"171\":1}}],[\"secret\",{\"1\":{\"983\":1,\"984\":2,\"985\":2,\"1504\":1,\"1522\":1}}],[\"secretkey\",{\"1\":{\"978\":1,\"983\":3,\"987\":1}}],[\"secretcar\",{\"1\":{\"571\":1}}],[\"sec\",{\"1\":{\"368\":5}}],[\"seconds\",{\"1\":{\"351\":2,\"961\":1,\"1079\":11,\"1370\":1,\"1373\":1,\"1435\":1,\"1443\":1,\"1468\":1,\"1519\":2}}],[\"second\",{\"1\":{\"316\":1,\"1079\":1,\"1278\":3,\"1279\":1}}],[\"second=0\",{\"1\":{\"316\":1}}],[\"see\",{\"1\":{\"289\":1}}],[\"seq2\",{\"1\":{\"188\":1}}],[\"seq1\",{\"1\":{\"188\":2}}],[\"sequence\",{\"1\":{\"186\":1,\"756\":1,\"812\":1,\"894\":1}}],[\"sequentially\",{\"1\":{\"104\":1}}],[\"seq\",{\"1\":{\"184\":3}}],[\"sent\",{\"1\":{\"171\":1,\"624\":1,\"712\":1}}],[\"sensible\",{\"1\":{\"165\":1}}],[\"sendheartbeats\",{\"0\":{\"1499\":1},\"1\":{\"1488\":1,\"1496\":1,\"1499\":1}}],[\"sendheartbeattoallbroker\",{\"1\":{\"1048\":1}}],[\"sendheartbeattoallbrokerwithlock\",{\"1\":{\"1047\":1,\"1048\":1,\"1122\":1,\"1145\":1}}],[\"sendcheckmessage\",{\"1\":{\"1469\":2}}],[\"sendcallback\",{\"1\":{\"1050\":4,\"1053\":4}}],[\"sendfinalmessage\",{\"1\":{\"1464\":1}}],[\"sender\",{\"1\":{\"1446\":1}}],[\"sendprocessor\",{\"1\":{\"1055\":7}}],[\"sendstatus=send\",{\"1\":{\"1445\":10}}],[\"sendstatus\",{\"1\":{\"1050\":1}}],[\"sendkernelimpl\",{\"1\":{\"1042\":1,\"1050\":2,\"1053\":3}}],[\"sendlatencyfaultenable=true\",{\"1\":{\"1052\":1}}],[\"sendlatencyfaultenable=false\",{\"1\":{\"1052\":1}}],[\"sendlatencyfaultenable\",{\"1\":{\"1041\":1,\"1052\":1,\"1234\":1}}],[\"senddefaultimpl\",{\"1\":{\"1038\":1,\"1040\":1,\"1050\":1}}],[\"sendtransactionpreparemessage\",{\"1\":{\"1462\":6}}],[\"sendtracedata\",{\"1\":{\"1021\":2}}],[\"sendtimems\",{\"1\":{\"1519\":3}}],[\"sendtime\",{\"1\":{\"1008\":1}}],[\"sendwhichqueue\",{\"1\":{\"1021\":1,\"1052\":1}}],[\"sendresult\",{\"1\":{\"984\":3,\"1006\":3,\"1050\":8,\"1053\":7,\"1287\":2,\"1306\":2,\"1309\":3,\"1339\":1,\"1443\":3,\"1445\":10,\"1459\":12,\"1460\":11,\"1464\":3}}],[\"sendmessagecallback\",{\"1\":{\"1462\":4}}],[\"sendmessagecontext\",{\"1\":{\"1053\":2,\"1056\":1,\"1462\":6}}],[\"sendmessageintransaction\",{\"0\":{\"1458\":1,\"1459\":1},\"1\":{\"1443\":1,\"1449\":3,\"1458\":2,\"1459\":1}}],[\"sendmessageprossor\",{\"1\":{\"1188\":1}}],[\"sendmessageprocessor\",{\"0\":{\"1462\":1},\"1\":{\"1043\":1,\"1055\":4,\"1056\":2,\"1061\":1,\"1198\":1,\"1450\":1,\"1462\":1}}],[\"sendmessageback\",{\"1\":{\"1117\":1,\"1187\":1,\"1188\":2,\"1195\":1,\"1197\":5}}],[\"sendmessageresponseheader\",{\"1\":{\"1056\":2}}],[\"sendmessagerequestheader\",{\"1\":{\"1053\":2,\"1056\":1,\"1462\":1}}],[\"sendmessagerequestheaderv2\",{\"1\":{\"720\":1,\"742\":7,\"890\":1,\"891\":1}}],[\"sendmessagehooklist\",{\"1\":{\"1055\":1}}],[\"sendmessage\",{\"1\":{\"1053\":2,\"1462\":1}}],[\"sendmessagewithvipchannel=\",{\"1\":{\"1047\":1}}],[\"sendmessageexecutor\",{\"1\":{\"1043\":1,\"1055\":5}}],[\"sendmessageasync\",{\"1\":{\"1040\":1}}],[\"sendmessagetracehookimpl\",{\"1\":{\"1014\":1}}],[\"sendmessagethreadpoolnums\",{\"1\":{\"720\":1,\"732\":1,\"733\":1,\"734\":2}}],[\"sending\",{\"1\":{\"124\":1,\"125\":3,\"128\":1,\"1056\":1,\"1197\":1,\"1198\":2,\"1462\":1,\"1496\":1}}],[\"send\",{\"1\":{\"72\":1,\"73\":1,\"111\":2,\"116\":1,\"125\":2,\"128\":1,\"348\":1,\"369\":2,\"624\":6,\"835\":1,\"886\":1,\"905\":1,\"984\":1,\"1006\":1,\"1019\":1,\"1023\":1,\"1050\":1,\"1055\":4,\"1197\":1,\"1287\":2,\"1306\":1,\"1309\":1,\"1339\":1,\"1458\":1,\"1459\":3,\"1462\":1,\"1469\":1}}],[\"seldom\",{\"1\":{\"690\":1}}],[\"selfid=\",{\"1\":{\"1500\":1,\"1503\":1}}],[\"self\",{\"1\":{\"230\":1,\"235\":1,\"325\":2,\"625\":1,\"626\":2,\"627\":1,\"964\":1,\"1278\":1,\"1503\":4}}],[\"sel\",{\"1\":{\"118\":1}}],[\"selectproducer\",{\"1\":{\"1471\":1}}],[\"selectphyoffset\",{\"1\":{\"789\":1,\"790\":1,\"794\":1,\"797\":3}}],[\"selectbufferresult\",{\"1\":{\"1407\":1,\"1431\":2,\"1432\":1}}],[\"selectbrokeraddr\",{\"1\":{\"1248\":1}}],[\"selectmappedbuffer\",{\"1\":{\"1368\":1}}],[\"selectmappedbufferresult\",{\"1\":{\"762\":1,\"767\":2,\"845\":1,\"860\":1,\"1174\":2,\"1270\":1,\"1368\":1,\"1370\":1,\"1372\":2,\"1427\":1,\"1431\":1,\"1432\":2}}],[\"selecttopicconfig\",{\"1\":{\"1056\":1,\"1173\":1,\"1269\":2,\"1279\":1}}],[\"selectonemessagebyoffset\",{\"1\":{\"1427\":2}}],[\"selectonemessagequeue\",{\"1\":{\"1041\":1,\"1050\":2,\"1052\":7}}],[\"selectorparser\",{\"1\":{\"1321\":4}}],[\"selector\",{\"1\":{\"118\":13,\"119\":1,\"121\":5,\"122\":3,\"123\":2,\"124\":9,\"128\":5,\"132\":2,\"133\":3,\"136\":1}}],[\"selectresult\",{\"1\":{\"767\":2,\"1174\":5}}],[\"selecting\",{\"1\":{\"643\":1,\"1052\":1}}],[\"selectionkey\",{\"1\":{\"118\":7,\"121\":5,\"122\":8,\"124\":10,\"125\":6,\"128\":4,\"131\":1,\"132\":2,\"133\":5}}],[\"selected\",{\"1\":{\"171\":2}}],[\"selectedkey\",{\"1\":{\"124\":1}}],[\"selectedkeys\",{\"1\":{\"118\":2,\"122\":4}}],[\"select\",{\"1\":{\"92\":1,\"118\":2,\"122\":2,\"124\":2,\"125\":1,\"253\":6}}],[\"sessioncredentials\",{\"1\":{\"984\":1,\"985\":1,\"995\":6}}],[\"sessionfactory\",{\"1\":{\"91\":5,\"92\":2}}],[\"sessionfactorybean\",{\"1\":{\"89\":5}}],[\"sessionfactory创建一个新的session\",{\"1\":{\"89\":1}}],[\"session是封装了一个jdbc\",{\"1\":{\"89\":1}}],[\"setwroteposition\",{\"1\":{\"1368\":1}}],[\"setwaitstoremsgok\",{\"1\":{\"1198\":1}}],[\"setvipchannelenabled\",{\"1\":{\"1288\":1}}],[\"setqueueoffset\",{\"1\":{\"1171\":1,\"1296\":1,\"1370\":1,\"1459\":1,\"1464\":1}}],[\"setqueueid\",{\"1\":{\"843\":1,\"1052\":1,\"1053\":1,\"1056\":1,\"1171\":1,\"1173\":2,\"1198\":1,\"1200\":1,\"1273\":3,\"1280\":1,\"1463\":1,\"1469\":1}}],[\"setnextbeginoffset\",{\"1\":{\"1173\":1,\"1174\":1,\"1430\":5,\"1432\":7}}],[\"setnextoffset\",{\"1\":{\"1144\":1,\"1170\":1,\"1175\":3,\"1224\":1,\"1228\":1,\"1229\":1}}],[\"setnamespace\",{\"1\":{\"1053\":1,\"1195\":1,\"1230\":1}}],[\"setnamesrvaddr\",{\"1\":{\"984\":1,\"985\":1,\"1006\":1,\"1235\":2,\"1287\":1,\"1288\":1,\"1443\":1,\"1444\":1}}],[\"setname\",{\"1\":{\"91\":1,\"1443\":1}}],[\"set<messagequeue>\",{\"1\":{\"1116\":1,\"1143\":3,\"1144\":1,\"1145\":2,\"1200\":1,\"1222\":4,\"1224\":1,\"1226\":1,\"1266\":3,\"1468\":1}}],[\"set<string>>\",{\"1\":{\"972\":1}}],[\"set<string>>>\",{\"1\":{\"972\":1}}],[\"set<string>\",{\"1\":{\"971\":1,\"972\":1,\"1248\":1,\"1372\":1,\"1434\":2}}],[\"set<string\",{\"1\":{\"949\":1,\"966\":1}}],[\"set<selectionkey>\",{\"1\":{\"122\":1}}],[\"setunitname\",{\"1\":{\"1235\":2}}],[\"setunitmode\",{\"1\":{\"1053\":1}}],[\"setuniqid\",{\"1\":{\"1053\":1}}],[\"setupsingletons\",{\"1\":{\"99\":2}}],[\"setup\",{\"1\":{\"4\":1,\"9\":2,\"99\":1,\"640\":1}}],[\"setremoteid\",{\"1\":{\"1499\":1,\"1502\":1,\"1519\":2}}],[\"setremark\",{\"1\":{\"973\":2,\"1056\":1,\"1173\":16,\"1198\":10,\"1269\":1,\"1462\":1,\"1464\":1}}],[\"setregistertopics\",{\"1\":{\"1288\":1}}],[\"setregionid\",{\"1\":{\"1020\":2}}],[\"setreviveoffset\",{\"1\":{\"1278\":1}}],[\"setreviveqid\",{\"1\":{\"1269\":1}}],[\"setrestnum\",{\"1\":{\"1269\":1}}],[\"setresponsecode\",{\"1\":{\"1050\":2}}],[\"setreconsumetime\",{\"1\":{\"1197\":1}}],[\"setreconsumetimes\",{\"1\":{\"1053\":2,\"1056\":1,\"1195\":1,\"1198\":1,\"1280\":1}}],[\"setrequestid\",{\"1\":{\"1020\":1}}],[\"setretrytimeswhensendasyncfailed\",{\"1\":{\"1233\":1}}],[\"setretrytimeswhensendfailed\",{\"1\":{\"1233\":1}}],[\"setretrytimes\",{\"1\":{\"1020\":1}}],[\"setsendstatus\",{\"1\":{\"1459\":1}}],[\"setsendmsgtimeout\",{\"1\":{\"1233\":1}}],[\"setsendresult\",{\"1\":{\"1053\":1}}],[\"setstate\",{\"1\":{\"1373\":4,\"1374\":4}}],[\"setstatus\",{\"1\":{\"1174\":1,\"1195\":1,\"1230\":1,\"1269\":2,\"1430\":5,\"1432\":7}}],[\"setstartoffset\",{\"1\":{\"1273\":1}}],[\"setstartoffsetinfo\",{\"1\":{\"1269\":1}}],[\"setstoresize\",{\"1\":{\"1469\":1}}],[\"setstorehost\",{\"1\":{\"1056\":1,\"1198\":1,\"1273\":1,\"1280\":1}}],[\"setstoretimestamp\",{\"1\":{\"1464\":1}}],[\"setstoretime\",{\"1\":{\"1020\":1}}],[\"setsuggestpullingfromslave\",{\"1\":{\"1174\":1}}],[\"setsuggestwhichbrokerid\",{\"1\":{\"1173\":7}}],[\"setsubscription\",{\"1\":{\"1171\":1}}],[\"setsubversion\",{\"1\":{\"1145\":1,\"1171\":1}}],[\"setsuspendtimeoutmillis\",{\"1\":{\"1171\":1}}],[\"setsuccess\",{\"1\":{\"1020\":1,\"1195\":2,\"1230\":2}}],[\"setsysflag\",{\"1\":{\"1053\":1,\"1171\":1,\"1198\":1,\"1463\":1,\"1464\":1}}],[\"setsotimeout\",{\"1\":{\"73\":1}}],[\"setordercountinfo\",{\"1\":{\"1269\":1}}],[\"setordertopicconf\",{\"1\":{\"973\":1}}],[\"setoriginmessageid\",{\"1\":{\"1197\":1,\"1198\":1}}],[\"setoffsetmsgid\",{\"1\":{\"1469\":1}}],[\"setoffsetid\",{\"1\":{\"1427\":1}}],[\"setoffsetnew\",{\"1\":{\"1173\":1}}],[\"setoffsetrequest\",{\"1\":{\"1173\":1}}],[\"setoffsetstore\",{\"1\":{\"1122\":1}}],[\"setopaque\",{\"1\":{\"820\":1,\"1173\":1,\"1273\":1}}],[\"setopts\",{\"1\":{\"625\":1}}],[\"setmintimestamp\",{\"1\":{\"1435\":1}}],[\"setminoffset\",{\"1\":{\"1173\":1,\"1174\":1,\"1430\":1,\"1432\":1}}],[\"setmagic\",{\"1\":{\"1517\":1}}],[\"setmaxtimestamp\",{\"1\":{\"1435\":1}}],[\"setmaxoffset\",{\"1\":{\"1173\":1,\"1174\":1,\"1430\":1,\"1432\":1}}],[\"setmaxmsgnums\",{\"1\":{\"1171\":1}}],[\"setmaxreconsumetimes\",{\"1\":{\"1053\":1,\"1197\":1}}],[\"setmasteraddr\",{\"1\":{\"971\":1}}],[\"setmsg\",{\"1\":{\"1373\":1}}],[\"setmsgstoretime\",{\"1\":{\"1297\":1}}],[\"setmsgoffsetinfo\",{\"1\":{\"1269\":1}}],[\"setmsglist\",{\"1\":{\"1195\":1,\"1230\":1}}],[\"setmsgtype\",{\"1\":{\"1053\":2}}],[\"setmsgid\",{\"1\":{\"1020\":1,\"1459\":1,\"1460\":1,\"1469\":1,\"1472\":1}}],[\"setmqclientfactory\",{\"1\":{\"1122\":1}}],[\"setmq\",{\"1\":{\"1053\":1,\"1195\":1,\"1230\":1}}],[\"setmqtracecontext\",{\"1\":{\"1020\":1}}],[\"setmessagebinary\",{\"1\":{\"1329\":1}}],[\"setmessagerequestmoderequestbody\",{\"1\":{\"1266\":5}}],[\"setmessagerequestmode\",{\"1\":{\"1248\":1}}],[\"setmessagequeue\",{\"1\":{\"1144\":1,\"1173\":1,\"1224\":1,\"1459\":1}}],[\"setmessagemodel\",{\"1\":{\"1122\":1}}],[\"setmessage\",{\"1\":{\"1053\":1}}],[\"setm\",{\"1\":{\"742\":1}}],[\"setledgerendterm\",{\"1\":{\"1502\":1}}],[\"setledgerendindex\",{\"1\":{\"1502\":1}}],[\"setleaderid\",{\"1\":{\"1499\":1,\"1502\":1,\"1516\":2,\"1518\":1,\"1519\":2,\"1521\":2}}],[\"setlatch\",{\"1\":{\"1371\":1,\"1372\":2}}],[\"setlastlocktimestamp\",{\"1\":{\"1226\":1}}],[\"setlastupdatetimestamp\",{\"1\":{\"1222\":2}}],[\"setlastpulltimestamp\",{\"1\":{\"1170\":1}}],[\"setlocalid\",{\"1\":{\"1499\":1}}],[\"setlocaltransactionstate\",{\"1\":{\"1459\":1}}],[\"setlocked\",{\"1\":{\"1226\":1}}],[\"setlogicsmsgtimestamp\",{\"1\":{\"769\":1,\"1297\":1}}],[\"setlistenport\",{\"1\":{\"960\":1}}],[\"setl\",{\"1\":{\"742\":1}}],[\"setkeys\",{\"1\":{\"1020\":1}}],[\"setk\",{\"1\":{\"742\":1}}],[\"setj\",{\"1\":{\"742\":1}}],[\"setindexterm\",{\"1\":{\"1517\":1}}],[\"setindex\",{\"1\":{\"1517\":1,\"1518\":1,\"1520\":1,\"1521\":2}}],[\"setindexmsgtimestamp\",{\"1\":{\"796\":1}}],[\"setinstancename\",{\"1\":{\"1288\":1}}],[\"setinstanceid\",{\"1\":{\"1053\":1}}],[\"setinvisibletime\",{\"1\":{\"1269\":1}}],[\"setint\",{\"1\":{\"894\":3}}],[\"seti\",{\"1\":{\"742\":1}}],[\"setid\",{\"1\":{\"266\":1}}],[\"setgroup\",{\"1\":{\"1499\":1,\"1502\":1,\"1516\":1,\"1518\":1,\"1519\":2,\"1520\":1,\"1521\":2}}],[\"setgroupname\",{\"1\":{\"1020\":2}}],[\"setgetmessageentiretimemax\",{\"1\":{\"1174\":1}}],[\"setg\",{\"1\":{\"742\":1}}],[\"setfromtransactioncheck\",{\"1\":{\"1472\":1}}],[\"setfilterbitmap\",{\"1\":{\"1297\":1}}],[\"setfilterserverlist\",{\"1\":{\"970\":1}}],[\"setflag\",{\"1\":{\"1053\":1,\"1056\":1,\"1197\":1,\"1198\":1}}],[\"setflushedwhere\",{\"1\":{\"765\":1,\"771\":1}}],[\"setf\",{\"1\":{\"742\":1}}],[\"setentry\",{\"1\":{\"1519\":1}}],[\"setendindex\",{\"1\":{\"1520\":1}}],[\"setendtimestamp\",{\"1\":{\"797\":1}}],[\"setendphyoffset\",{\"1\":{\"797\":1}}],[\"setexecutorservice\",{\"1\":{\"1443\":1}}],[\"setexpressiontype\",{\"1\":{\"1171\":1}}],[\"sete\",{\"1\":{\"742\":1}}],[\"setdropped\",{\"1\":{\"1144\":2,\"1175\":1,\"1224\":2}}],[\"setdeletelist\",{\"1\":{\"1372\":1}}],[\"setdelaytimems\",{\"1\":{\"1339\":1}}],[\"setdelaytimesec\",{\"1\":{\"1339\":1}}],[\"setdelaytimelevel\",{\"1\":{\"835\":1,\"843\":1,\"1197\":1,\"1198\":2}}],[\"setdelivertimems\",{\"1\":{\"1273\":1,\"1339\":1}}],[\"setdefaulttopicqueuenums\",{\"1\":{\"1053\":1}}],[\"setdefaulttopic\",{\"1\":{\"1053\":1}}],[\"setdaemon\",{\"1\":{\"793\":1}}],[\"setdatasource\",{\"1\":{\"89\":1}}],[\"setdata\",{\"1\":{\"72\":1}}],[\"setd\",{\"1\":{\"742\":1}}],[\"setcurrvotefor\",{\"1\":{\"1503\":1}}],[\"setclientrebalance\",{\"1\":{\"1248\":1}}],[\"setclientip\",{\"1\":{\"1240\":1}}],[\"setclientid\",{\"1\":{\"1222\":2,\"1226\":1}}],[\"setclustername\",{\"1\":{\"970\":1}}],[\"setcount\",{\"1\":{\"1520\":1}}],[\"setcosttime\",{\"1\":{\"1020\":1}}],[\"setcode\",{\"1\":{\"973\":2,\"1056\":1,\"1173\":26,\"1198\":10,\"1269\":3,\"1462\":1,\"1464\":4,\"1516\":2,\"1520\":1,\"1521\":1}}],[\"setcompacttimestamp\",{\"1\":{\"1435\":1}}],[\"setcompressed\",{\"1\":{\"970\":1}}],[\"setcommercialowner\",{\"1\":{\"1173\":3}}],[\"setcommercialrcvsize\",{\"1\":{\"1173\":1}}],[\"setcommercialrcvstats\",{\"1\":{\"1173\":3}}],[\"setcommercialrcvtimes\",{\"1\":{\"1173\":3}}],[\"setcommitindex\",{\"1\":{\"1519\":1}}],[\"setcommitorrollback\",{\"1\":{\"1460\":3,\"1472\":3}}],[\"setcommitoffset\",{\"1\":{\"1171\":1,\"1200\":1}}],[\"setcommitlogoffset\",{\"1\":{\"1460\":1,\"1469\":1,\"1472\":1}}],[\"setcommittedwhere\",{\"1\":{\"765\":1,\"771\":1}}],[\"setcommunicationmode\",{\"1\":{\"1053\":1}}],[\"setconsumertimeoutmilliswhensuspend\",{\"1\":{\"1288\":1}}],[\"setconsumergroup\",{\"1\":{\"1122\":1,\"1144\":1,\"1171\":1,\"1173\":2,\"1195\":1,\"1200\":1,\"1224\":1,\"1226\":1,\"1230\":1,\"1273\":1,\"1288\":1}}],[\"setconsumemode\",{\"1\":{\"1247\":1,\"1248\":1}}],[\"setconsumestarttimestamp\",{\"1\":{\"1195\":1}}],[\"setconsumetimestamp\",{\"1\":{\"1007\":1}}],[\"setconsumefromwhere\",{\"1\":{\"985\":1,\"1007\":1,\"1248\":1,\"1444\":1}}],[\"setcontextcode\",{\"1\":{\"1020\":1}}],[\"setcontext\",{\"1\":{\"960\":1}}],[\"setconfigstorepath\",{\"1\":{\"960\":1}}],[\"setc\",{\"1\":{\"742\":1}}],[\"setbit\",{\"1\":{\"1278\":1}}],[\"setbitmap\",{\"1\":{\"1278\":1,\"1332\":1}}],[\"setbatch\",{\"1\":{\"1053\":1}}],[\"setborntimestamp\",{\"1\":{\"1053\":1,\"1056\":1,\"1198\":1,\"1273\":1,\"1280\":1}}],[\"setbornhost\",{\"1\":{\"1053\":1,\"1056\":1,\"1198\":1,\"1273\":1,\"1280\":1}}],[\"setbodylength\",{\"1\":{\"1020\":1}}],[\"setbodycrc32\",{\"1\":{\"970\":1}}],[\"setbody\",{\"1\":{\"835\":1,\"973\":1,\"1053\":2,\"1056\":1,\"1173\":1,\"1198\":1,\"1273\":1,\"1280\":1,\"1516\":2}}],[\"setbrokersuspendmaxtimemillis\",{\"1\":{\"1288\":1}}],[\"setbrokername\",{\"1\":{\"970\":1,\"1052\":1,\"1173\":1,\"1273\":1,\"1460\":1,\"1469\":1,\"1472\":1}}],[\"setbrokerid\",{\"1\":{\"970\":1}}],[\"setbrokeraddr\",{\"1\":{\"970\":1,\"1053\":1}}],[\"setbeginindex\",{\"1\":{\"1520\":1}}],[\"setbegintimestamp\",{\"1\":{\"797\":1}}],[\"setbeginphyoffset\",{\"1\":{\"797\":1}}],[\"setb\",{\"1\":{\"742\":1}}],[\"setackoffset\",{\"1\":{\"1273\":1}}],[\"setaccessible\",{\"1\":{\"99\":2,\"742\":1,\"995\":1}}],[\"setallocatemessagequeuestrategy\",{\"1\":{\"1122\":1}}],[\"seta\",{\"1\":{\"742\":1}}],[\"sethaserveraddr\",{\"1\":{\"970\":1,\"971\":1}}],[\"seth\",{\"1\":{\"742\":1}}],[\"sethostconsumer\",{\"1\":{\"1019\":1}}],[\"sethost\",{\"1\":{\"712\":1}}],[\"sethibernateproperties\",{\"1\":{\"89\":1}}],[\"settype\",{\"1\":{\"1519\":2}}],[\"settranstatetableoffset\",{\"1\":{\"1460\":1,\"1469\":1,\"1472\":1}}],[\"settransactionid\",{\"1\":{\"1459\":2,\"1460\":1,\"1469\":1,\"1471\":1,\"1472\":1}}],[\"settransactionlistener\",{\"1\":{\"1443\":1}}],[\"settracebeans\",{\"1\":{\"1020\":2}}],[\"settracetype\",{\"1\":{\"1020\":2}}],[\"settagscode\",{\"1\":{\"1198\":1,\"1297\":1}}],[\"settags\",{\"1\":{\"835\":1,\"1020\":1,\"1273\":1,\"1280\":1,\"1306\":2}}],[\"settopicconfigserializewrapper\",{\"1\":{\"970\":1}}],[\"settopic\",{\"1\":{\"835\":1,\"843\":1,\"1020\":1,\"1050\":1,\"1053\":3,\"1056\":1,\"1171\":1,\"1173\":2,\"1197\":2,\"1198\":1,\"1200\":1,\"1273\":2,\"1280\":2,\"1458\":1,\"1460\":1,\"1463\":1,\"1469\":2,\"1471\":1,\"1472\":1}}],[\"settimestamp\",{\"1\":{\"1020\":1}}],[\"settimeout\",{\"1\":{\"351\":1,\"352\":2,\"353\":2}}],[\"settings\",{\"1\":{\"628\":1}}],[\"setting\",{\"1\":{\"515\":1}}],[\"setterm\",{\"1\":{\"1499\":1,\"1502\":1,\"1516\":1,\"1517\":1,\"1518\":1,\"1519\":2,\"1520\":1,\"1521\":1}}],[\"setter\",{\"1\":{\"81\":2,\"567\":1,\"606\":1}}],[\"set\",{\"0\":{\"300\":1,\"302\":1},\"1\":{\"99\":2,\"143\":5,\"156\":2,\"158\":1,\"171\":2,\"248\":6,\"249\":1,\"289\":2,\"300\":1,\"301\":2,\"302\":2,\"303\":1,\"351\":1,\"567\":1,\"606\":2,\"653\":2,\"742\":2,\"915\":1,\"960\":1,\"1053\":1,\"1143\":1,\"1266\":1,\"1277\":1,\"1288\":1,\"1359\":1,\"1368\":1,\"1371\":1,\"1427\":2,\"1434\":2,\"1435\":1,\"1444\":1,\"1497\":1,\"1499\":1,\"1519\":1}}],[\"setpos\",{\"1\":{\"1517\":2,\"1518\":2,\"1521\":1}}],[\"setpositions\",{\"1\":{\"1516\":1}}],[\"setpoptime\",{\"1\":{\"1269\":1,\"1273\":1}}],[\"setphysicmsgtimestamp\",{\"1\":{\"1297\":1}}],[\"setpreparedtransactionoffset\",{\"1\":{\"1464\":1}}],[\"setpreviouslylocked\",{\"1\":{\"1170\":1,\"1228\":1}}],[\"setprops\",{\"1\":{\"1195\":1,\"1230\":1}}],[\"setproperties\",{\"1\":{\"1053\":1,\"1056\":1,\"1197\":1,\"1198\":1,\"1280\":1}}],[\"setpropertiesstring\",{\"1\":{\"843\":1,\"1056\":3,\"1198\":2,\"1273\":1,\"1280\":1,\"1463\":1}}],[\"setproperty\",{\"1\":{\"89\":3,\"894\":1,\"960\":1}}],[\"setprocessqueue\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"setproducergroup\",{\"1\":{\"1053\":2,\"1460\":1,\"1472\":1}}],[\"setproducer\",{\"1\":{\"1053\":1}}],[\"setpullthresholdsizeforqueue\",{\"1\":{\"1145\":1}}],[\"setpullthresholdforqueue\",{\"1\":{\"1145\":1}}],[\"setparameter\",{\"1\":{\"92\":4}}],[\"setpackagestoscan\",{\"1\":{\"89\":1}}],[\"suggestbrokerid=\",{\"1\":{\"1173\":2}}],[\"suggesttodo\",{\"1\":{\"973\":1,\"1047\":2,\"1050\":1,\"1122\":2,\"1173\":4,\"1198\":1}}],[\"suggested\",{\"1\":{\"643\":1}}],[\"suspendcurrentqueuetimemillis\",{\"1\":{\"1241\":1}}],[\"suspend\",{\"1\":{\"1170\":4,\"1230\":3}}],[\"suspend=n\",{\"1\":{\"1080\":1}}],[\"suspendtimeoutmillislong\",{\"1\":{\"819\":1,\"1173\":2}}],[\"suspendpullrequest\",{\"0\":{\"822\":1},\"1\":{\"812\":1,\"815\":1,\"819\":1,\"822\":1,\"1173\":1}}],[\"sufficient\",{\"1\":{\"737\":1}}],[\"sudo\",{\"1\":{\"643\":1,\"644\":2,\"646\":2}}],[\"suveq\",{\"1\":{\"429\":1}}],[\"succnum=\",{\"1\":{\"1499\":1}}],[\"succnum\",{\"1\":{\"1499\":7}}],[\"succeed\",{\"1\":{\"999\":1}}],[\"successful\",{\"1\":{\"1464\":1,\"1519\":1}}],[\"successfully\",{\"1\":{\"1427\":1,\"1462\":1}}],[\"success\",{\"1\":{\"348\":2,\"375\":1,\"861\":2,\"973\":1,\"985\":1,\"1007\":1,\"1008\":1,\"1173\":4,\"1195\":5,\"1198\":2,\"1230\":4,\"1248\":1,\"1269\":1,\"1273\":1,\"1427\":4,\"1434\":5,\"1435\":1,\"1444\":1,\"1462\":1,\"1464\":5,\"1499\":1,\"1511\":2,\"1519\":5,\"1520\":8}}],[\"suc\",{\"1\":{\"1269\":1}}],[\"such\",{\"1\":{\"46\":1,\"1079\":1}}],[\"sunday\",{\"1\":{\"587\":1}}],[\"sun\",{\"1\":{\"316\":1,\"882\":1}}],[\"summary\",{\"1\":{\"1085\":1}}],[\"summer\",{\"1\":{\"286\":1}}],[\"sum\",{\"0\":{\"183\":1},\"1\":{\"183\":4,\"314\":2,\"329\":5,\"331\":3,\"385\":3,\"538\":1,\"1428\":1}}],[\"surprise\",{\"1\":{\"178\":2}}],[\"sure\",{\"1\":{\"104\":1,\"1267\":1,\"1435\":1}}],[\"surefire\",{\"1\":{\"63\":1,\"64\":1}}],[\"super\",{\"1\":{\"128\":1,\"345\":1,\"844\":1,\"1519\":1,\"1520\":1,\"1521\":1}}],[\"supplyasync\",{\"1\":{\"1436\":1}}],[\"supplier<string>\",{\"1\":{\"738\":1}}],[\"supplier\",{\"1\":{\"738\":4}}],[\"suppresswarnings\",{\"1\":{\"1425\":1,\"1428\":1}}],[\"suppressed\",{\"1\":{\"34\":1}}],[\"support\",{\"1\":{\"886\":1,\"905\":1,\"1171\":1,\"1173\":1,\"1281\":1,\"1375\":3,\"1437\":1}}],[\"supported相比\",{\"1\":{\"87\":1}}],[\"supported\",{\"1\":{\"87\":1,\"742\":1}}],[\"supports和requires\",{\"1\":{\"87\":1}}],[\"supports\",{\"1\":{\"87\":1}}],[\"sublist\",{\"1\":{\"1436\":1}}],[\"submap\",{\"1\":{\"1436\":1}}],[\"submitconsumerequestlater\",{\"1\":{\"1194\":2,\"1195\":1,\"1230\":1}}],[\"submitconsumerequest\",{\"1\":{\"1104\":1,\"1119\":1,\"1175\":1,\"1187\":1,\"1188\":1,\"1194\":1,\"1229\":1}}],[\"submit\",{\"1\":{\"113\":1,\"820\":1,\"1021\":1,\"1194\":2,\"1427\":1,\"1472\":1,\"1516\":1}}],[\"sub=\",{\"1\":{\"1333\":1}}],[\"subversion\",{\"1\":{\"1171\":3}}],[\"subtable\",{\"1\":{\"1142\":3}}],[\"subtype\",{\"1\":{\"520\":1}}],[\"subexpression\",{\"1\":{\"1117\":1,\"1170\":4,\"1171\":3}}],[\"subaftercontext\",{\"1\":{\"1020\":10}}],[\"subafter\",{\"1\":{\"1017\":1,\"1020\":1}}],[\"subbeforecontext\",{\"1\":{\"1020\":8}}],[\"subbefore\",{\"1\":{\"1017\":1,\"1020\":2}}],[\"subscriptiongroupconfig\",{\"1\":{\"1173\":9,\"1198\":7}}],[\"subscription\",{\"1\":{\"1145\":2,\"1170\":2,\"1173\":14,\"1198\":3,\"1247\":1}}],[\"subscriptioninner\",{\"1\":{\"1133\":1,\"1145\":1}}],[\"subscriptiondatalist\",{\"1\":{\"1331\":2}}],[\"subscriptiondata>\",{\"1\":{\"1142\":2}}],[\"subscriptiondata\",{\"1\":{\"819\":1,\"1145\":4,\"1170\":6,\"1173\":14,\"1175\":1,\"1229\":1,\"1317\":1,\"1328\":6,\"1329\":6,\"1333\":7}}],[\"subscribe\",{\"1\":{\"985\":1,\"1007\":1,\"1117\":1,\"1136\":1,\"1248\":1,\"1307\":2,\"1310\":2,\"1444\":1}}],[\"substring\",{\"1\":{\"298\":1,\"741\":2}}],[\"substitute\",{\"1\":{\"148\":1}}],[\"sub系统的投递语义与推送效率\",{\"1\":{\"278\":1}}],[\"sub\",{\"1\":{\"132\":4,\"133\":3,\"978\":2,\"983\":3,\"1328\":1}}],[\"subreactorgroup\",{\"1\":{\"133\":5,\"134\":2}}],[\"subreactor\",{\"1\":{\"122\":1,\"133\":3}}],[\"sys\",{\"1\":{\"843\":1,\"845\":2,\"860\":2,\"964\":1,\"1012\":1,\"1198\":1,\"1288\":2,\"1354\":1,\"1383\":1,\"1450\":1,\"1451\":1,\"1453\":1,\"1463\":2,\"1464\":2,\"1468\":4}}],[\"sysflag=8\",{\"1\":{\"1445\":3}}],[\"sysflaginner\",{\"1\":{\"1171\":5}}],[\"sysflag\",{\"1\":{\"737\":2,\"738\":2,\"742\":1,\"1053\":4,\"1170\":2,\"1171\":3}}],[\"systemclock\",{\"1\":{\"824\":2}}],[\"system32\",{\"1\":{\"52\":1}}],[\"system\",{\"1\":{\"34\":1,\"41\":2,\"48\":1,\"69\":3,\"70\":5,\"112\":3,\"113\":3,\"171\":2,\"231\":1,\"597\":1,\"712\":2,\"722\":1,\"769\":1,\"793\":1,\"825\":1,\"845\":1,\"860\":1,\"870\":1,\"882\":1,\"894\":1,\"900\":1,\"960\":7,\"971\":1,\"984\":1,\"985\":2,\"1006\":1,\"1007\":2,\"1008\":1,\"1017\":1,\"1019\":1,\"1020\":2,\"1050\":3,\"1053\":4,\"1145\":1,\"1170\":2,\"1173\":3,\"1175\":1,\"1195\":3,\"1198\":5,\"1222\":2,\"1226\":1,\"1229\":1,\"1230\":4,\"1240\":1,\"1248\":2,\"1269\":1,\"1273\":1,\"1275\":1,\"1276\":1,\"1277\":2,\"1278\":4,\"1280\":1,\"1288\":1,\"1299\":2,\"1309\":1,\"1332\":1,\"1339\":1,\"1370\":2,\"1373\":3,\"1427\":2,\"1434\":1,\"1435\":1,\"1443\":1,\"1444\":2,\"1464\":1,\"1467\":2,\"1468\":5,\"1496\":1,\"1497\":2,\"1499\":2,\"1500\":2,\"1519\":7,\"1520\":2,\"1521\":5}}],[\"symbol\",{\"0\":{\"530\":1},\"1\":{\"506\":1,\"508\":2,\"518\":2,\"531\":6,\"606\":2}}],[\"synchronously\",{\"1\":{\"1200\":1}}],[\"synchronize\",{\"1\":{\"11\":1}}],[\"synchronized\",{\"1\":{\"2\":1,\"128\":2,\"133\":1,\"726\":1,\"733\":1,\"1021\":1,\"1048\":1,\"1122\":1,\"1123\":1,\"1230\":1,\"1495\":1,\"1496\":1,\"1497\":2,\"1500\":1,\"1503\":1,\"1517\":1,\"1519\":2}}],[\"syncdeliver\",{\"1\":{\"860\":1}}],[\"synced\",{\"1\":{\"659\":2}}],[\"sync\",{\"1\":{\"652\":2,\"653\":1,\"654\":1,\"658\":2,\"720\":1,\"736\":1,\"853\":1,\"882\":3,\"1027\":1,\"1050\":2,\"1053\":2,\"1172\":1,\"1173\":1}}],[\"syntaxerror\",{\"1\":{\"314\":1}}],[\"syntax\",{\"1\":{\"143\":1}}],[\"src目录按包结构存放java源码\",{\"1\":{\"21\":1}}],[\"src\",{\"1\":{\"21\":5,\"272\":1,\"601\":3}}],[\"stepped\",{\"1\":{\"1503\":1}}],[\"styletang\",{\"1\":{\"1073\":1}}],[\"student\",{\"1\":{\"339\":6,\"341\":9,\"342\":4,\"344\":1,\"345\":1}}],[\"stdlib\",{\"1\":{\"253\":1}}],[\"stdev\",{\"1\":{\"11\":2}}],[\"store=\",{\"1\":{\"1468\":1}}],[\"storesize=420\",{\"1\":{\"1445\":3}}],[\"storestatsservice\",{\"1\":{\"1174\":4}}],[\"storefile\",{\"1\":{\"1435\":3}}],[\"storeexecutor\",{\"1\":{\"1427\":1}}],[\"storeplugin\",{\"1\":{\"1424\":1}}],[\"storepath\",{\"1\":{\"749\":1,\"793\":2,\"1394\":2,\"1412\":2,\"1417\":2,\"1420\":1}}],[\"storeconfig\",{\"1\":{\"1370\":2,\"1371\":2,\"1372\":2,\"1373\":1,\"1374\":1,\"1427\":9,\"1430\":1,\"1431\":1,\"1432\":2,\"1435\":2}}],[\"storecheckpoint\",{\"1\":{\"769\":1,\"793\":1}}],[\"stored\",{\"1\":{\"1277\":2,\"1468\":1}}],[\"storeoffset=\",{\"1\":{\"1201\":1}}],[\"storeoffset\",{\"1\":{\"1201\":4}}],[\"storeoffsetenable\",{\"1\":{\"1173\":6}}],[\"storeutil\",{\"1\":{\"1174\":1}}],[\"storetime\",{\"1\":{\"1017\":1}}],[\"storetimestamp=1737222675591\",{\"1\":{\"1445\":1}}],[\"storetimestamp=1737222675592\",{\"1\":{\"1445\":2}}],[\"storetimestamp\",{\"1\":{\"737\":2,\"738\":1,\"790\":1,\"797\":5,\"1436\":3}}],[\"storehost=\",{\"1\":{\"1445\":3}}],[\"storehost\",{\"1\":{\"1017\":1}}],[\"storehostlength\",{\"1\":{\"737\":1}}],[\"storehostholder\",{\"1\":{\"737\":2}}],[\"storehostaddress\",{\"1\":{\"737\":2,\"738\":2}}],[\"store\",{\"0\":{\"1058\":1,\"1263\":1},\"1\":{\"614\":1,\"619\":1,\"621\":2,\"680\":1,\"687\":3,\"690\":1,\"720\":1,\"749\":1,\"756\":1,\"765\":2,\"767\":1,\"771\":2,\"825\":1,\"827\":1,\"845\":3,\"860\":3,\"882\":2,\"983\":1,\"1035\":1,\"1056\":4,\"1058\":1,\"1075\":2,\"1080\":6,\"1173\":2,\"1174\":6,\"1201\":1,\"1270\":3,\"1277\":3,\"1296\":1,\"1333\":1,\"1370\":4,\"1395\":1,\"1424\":1,\"1425\":2,\"1463\":2,\"1464\":1,\"1516\":1,\"1538\":1}}],[\"storage\",{\"1\":{\"247\":1,\"737\":2,\"1436\":2,\"1437\":5}}],[\"stopwatch\",{\"1\":{\"1435\":9,\"1436\":4}}],[\"stopcasting\",{\"1\":{\"490\":1}}],[\"stopped\",{\"1\":{\"255\":1,\"1021\":5,\"1168\":1,\"1427\":1}}],[\"stop\",{\"1\":{\"171\":2,\"224\":3,\"252\":1,\"253\":1,\"255\":2,\"625\":1,\"794\":1,\"1496\":1}}],[\"still\",{\"1\":{\"97\":1}}],[\"struct\",{\"1\":{\"1106\":1}}],[\"structure\",{\"1\":{\"755\":2,\"972\":1}}],[\"str\",{\"1\":{\"333\":2,\"535\":2,\"547\":1,\"891\":12,\"904\":1}}],[\"strawberry\",{\"1\":{\"325\":2}}],[\"strategyname\",{\"1\":{\"1266\":5}}],[\"strategy\",{\"1\":{\"90\":1,\"1143\":4,\"1266\":2}}],[\"street\",{\"1\":{\"316\":1}}],[\"streaming系统的流批实时性\",{\"1\":{\"278\":1}}],[\"stream\",{\"1\":{\"118\":1,\"1248\":1,\"1428\":1,\"1436\":1,\"1521\":1}}],[\"strict\",{\"0\":{\"296\":1},\"1\":{\"296\":2,\"360\":1}}],[\"stringutils\",{\"1\":{\"1021\":1,\"1296\":2,\"1297\":2,\"1434\":2,\"1471\":1}}],[\"string>>\",{\"1\":{\"971\":1,\"972\":1}}],[\"string>\",{\"1\":{\"742\":1,\"825\":1,\"828\":1,\"891\":1,\"894\":1,\"971\":3,\"972\":1,\"995\":3,\"998\":1,\"1020\":1,\"1056\":1,\"1195\":1,\"1230\":1,\"1280\":1,\"1297\":2,\"1318\":2,\"1333\":2,\"1427\":1}}],[\"stringcanonicalname\",{\"1\":{\"742\":1}}],[\"stringconcatfactory会自动把字符串连接操作优化为数组复制或者stringbuilder操作\",{\"1\":{\"28\":1}}],[\"stringbuffer\",{\"0\":{\"907\":1},\"1\":{\"741\":1,\"886\":1,\"907\":1,\"909\":1}}],[\"stringbuilder\",{\"0\":{\"28\":1,\"906\":1},\"1\":{\"28\":1,\"124\":2,\"125\":1,\"741\":3,\"886\":1,\"900\":2,\"906\":5,\"909\":1,\"1235\":2,\"1270\":3}}],[\"string2messageproperties\",{\"1\":{\"720\":2,\"741\":2,\"1056\":1}}],[\"string|any\",{\"1\":{\"547\":2}}],[\"string|null\",{\"1\":{\"515\":1}}],[\"string|number\",{\"1\":{\"504\":1,\"515\":1,\"523\":1}}],[\"stringorarray\",{\"1\":{\"547\":4}}],[\"string类型只能赋值为字面量\",{\"1\":{\"509\":1}}],[\"string类型可以赋值为字符串的字面量\",{\"1\":{\"509\":1}}],[\"stringify\",{\"1\":{\"337\":2,\"338\":1,\"349\":1}}],[\"stringarg1\",{\"1\":{\"103\":1}}],[\"string\",{\"0\":{\"741\":1,\"907\":1},\"1\":{\"34\":1,\"36\":1,\"41\":2,\"43\":2,\"69\":2,\"70\":3,\"72\":2,\"73\":2,\"90\":3,\"92\":2,\"113\":5,\"125\":1,\"126\":1,\"129\":1,\"134\":1,\"150\":2,\"298\":1,\"333\":3,\"368\":2,\"385\":1,\"396\":4,\"500\":1,\"503\":1,\"504\":2,\"506\":2,\"508\":3,\"509\":6,\"514\":2,\"516\":2,\"518\":1,\"519\":1,\"527\":4,\"528\":2,\"533\":3,\"535\":3,\"543\":1,\"545\":2,\"547\":3,\"553\":2,\"554\":2,\"558\":16,\"560\":1,\"561\":2,\"562\":1,\"564\":4,\"566\":3,\"568\":4,\"570\":4,\"606\":2,\"712\":8,\"714\":3,\"715\":3,\"738\":1,\"741\":3,\"742\":8,\"757\":2,\"767\":2,\"786\":4,\"789\":2,\"790\":2,\"793\":1,\"794\":8,\"797\":4,\"815\":1,\"819\":1,\"822\":2,\"823\":3,\"825\":2,\"828\":1,\"843\":2,\"860\":1,\"880\":1,\"886\":1,\"891\":1,\"894\":2,\"896\":1,\"900\":3,\"904\":1,\"907\":1,\"908\":1,\"950\":1,\"960\":2,\"961\":2,\"968\":1,\"970\":5,\"971\":6,\"972\":6,\"973\":1,\"984\":3,\"985\":3,\"994\":3,\"995\":4,\"996\":2,\"997\":1,\"998\":3,\"999\":6,\"1000\":9,\"1017\":13,\"1019\":3,\"1020\":3,\"1021\":10,\"1050\":3,\"1051\":1,\"1052\":3,\"1053\":5,\"1056\":3,\"1116\":1,\"1117\":1,\"1142\":1,\"1143\":1,\"1144\":1,\"1145\":1,\"1169\":1,\"1170\":1,\"1171\":3,\"1172\":1,\"1173\":7,\"1174\":3,\"1195\":2,\"1197\":5,\"1198\":7,\"1201\":6,\"1222\":3,\"1224\":1,\"1230\":1,\"1235\":1,\"1241\":1,\"1248\":4,\"1266\":4,\"1267\":2,\"1270\":2,\"1271\":2,\"1273\":1,\"1278\":4,\"1279\":1,\"1280\":1,\"1288\":1,\"1296\":4,\"1297\":8,\"1306\":2,\"1309\":3,\"1331\":5,\"1371\":1,\"1373\":1,\"1425\":3,\"1427\":1,\"1430\":2,\"1431\":1,\"1434\":3,\"1436\":9,\"1443\":3,\"1444\":1,\"1459\":1,\"1460\":4,\"1462\":1,\"1463\":2,\"1468\":3,\"1469\":1,\"1471\":3,\"1472\":7,\"1496\":1,\"1499\":2,\"1502\":1,\"1519\":3}}],[\"string还提供了一个静态方法join\",{\"1\":{\"29\":1}}],[\"stringjoiner\",{\"0\":{\"29\":1},\"1\":{\"29\":1}}],[\"stayed\",{\"1\":{\"1277\":1}}],[\"stay\",{\"1\":{\"1276\":1,\"1277\":1}}],[\"stages\",{\"1\":{\"1074\":1,\"1075\":3,\"1078\":1,\"1079\":4,\"1083\":1,\"1084\":1}}],[\"stage\",{\"1\":{\"1074\":5}}],[\"stars\",{\"1\":{\"1073\":1}}],[\"starting\",{\"1\":{\"1519\":1}}],[\"startheartbeattimems\",{\"1\":{\"1499\":2}}],[\"startvotetimems\",{\"1\":{\"1497\":2}}],[\"startoffsetinfo\",{\"1\":{\"1269\":5,\"1270\":3}}],[\"startdelivertime\",{\"1\":{\"1053\":1}}],[\"startfactory\",{\"1\":{\"1047\":2}}],[\"startscantime\",{\"1\":{\"1278\":2}}],[\"startscheduledtask\",{\"1\":{\"956\":1,\"1047\":1,\"1048\":2,\"1123\":1}}],[\"startswith\",{\"1\":{\"742\":1,\"1053\":1,\"1142\":1,\"1143\":1,\"1175\":1,\"1266\":1,\"1280\":1}}],[\"started\",{\"1\":{\"824\":1,\"844\":2,\"985\":1,\"999\":1,\"1007\":1,\"1047\":1,\"1075\":3,\"1122\":1,\"1140\":1,\"1168\":1,\"1248\":1,\"1427\":1,\"1444\":1,\"1445\":1}}],[\"starter\",{\"1\":{\"272\":2}}],[\"starttick\",{\"1\":{\"1370\":1,\"1371\":1,\"1372\":1,\"1374\":1}}],[\"starttime\",{\"1\":{\"722\":1,\"1277\":1,\"1332\":2,\"1468\":4}}],[\"startthread\",{\"1\":{\"122\":1,\"126\":1,\"129\":1,\"133\":1}}],[\"start\",{\"0\":{\"1047\":1},\"1\":{\"69\":1,\"112\":1,\"147\":1,\"224\":4,\"235\":1,\"248\":3,\"253\":3,\"255\":3,\"767\":1,\"793\":1,\"840\":1,\"844\":2,\"869\":1,\"947\":2,\"952\":1,\"960\":4,\"961\":4,\"984\":1,\"985\":1,\"999\":3,\"1006\":1,\"1007\":1,\"1037\":1,\"1047\":5,\"1048\":13,\"1077\":3,\"1081\":2,\"1122\":8,\"1123\":8,\"1136\":1,\"1174\":1,\"1235\":2,\"1248\":2,\"1287\":2,\"1288\":1,\"1371\":1,\"1373\":5,\"1374\":2,\"1430\":1,\"1436\":1,\"1443\":1,\"1444\":1,\"1445\":3,\"1467\":1,\"1519\":1}}],[\"stance\",{\"1\":{\"490\":3}}],[\"standardcharsets\",{\"1\":{\"69\":2,\"70\":2,\"72\":2,\"125\":1,\"396\":1,\"1339\":1}}],[\"standard\",{\"1\":{\"27\":1}}],[\"stackoverflow\",{\"1\":{\"646\":1}}],[\"stacktrace\",{\"0\":{\"197\":1}}],[\"stack\",{\"1\":{\"171\":1}}],[\"statstype\",{\"1\":{\"1173\":3}}],[\"status中出现的erlang节点名\",{\"1\":{\"657\":1}}],[\"status\",{\"1\":{\"191\":7,\"348\":2,\"645\":2,\"767\":2,\"861\":2,\"1008\":1,\"1075\":1,\"1077\":1,\"1079\":2,\"1174\":14,\"1195\":13,\"1230\":14,\"1420\":3,\"1435\":3,\"1442\":5}}],[\"static关键字前面可以使用\",{\"1\":{\"577\":1}}],[\"staticutils\",{\"1\":{\"105\":5,\"106\":5}}],[\"static\",{\"0\":{\"104\":1,\"105\":1,\"106\":1},\"1\":{\"34\":1,\"41\":1,\"69\":1,\"70\":2,\"95\":1,\"104\":4,\"113\":3,\"124\":3,\"126\":3,\"128\":2,\"129\":3,\"134\":3,\"385\":1,\"396\":1,\"577\":2,\"606\":2,\"712\":4,\"742\":1,\"893\":1,\"894\":1,\"897\":1,\"904\":1,\"960\":2,\"984\":4,\"985\":4,\"1017\":1,\"1248\":4,\"1299\":5,\"1425\":1,\"1443\":1,\"1444\":1,\"1514\":1}}],[\"statemachinecaller\",{\"1\":{\"1521\":1}}],[\"statemachine\",{\"1\":{\"1521\":1}}],[\"statemaintainer\",{\"1\":{\"1483\":1}}],[\"state1\",{\"1\":{\"624\":5}}],[\"state\",{\"1\":{\"9\":1,\"124\":1,\"125\":8,\"128\":2,\"614\":2,\"624\":4,\"625\":11,\"643\":1,\"690\":1,\"711\":1,\"1047\":1,\"1122\":1,\"1170\":1,\"1472\":1,\"1500\":1,\"1510\":1,\"1511\":3,\"1519\":5,\"1520\":16}}],[\"s\",{\"1\":{\"11\":2,\"69\":3,\"70\":2,\"72\":1,\"97\":1,\"104\":1,\"143\":1,\"148\":3,\"150\":1,\"153\":1,\"171\":4,\"224\":4,\"259\":3,\"290\":1,\"297\":8,\"303\":2,\"333\":1,\"337\":1,\"339\":3,\"361\":4,\"423\":1,\"503\":3,\"508\":3,\"527\":1,\"558\":1,\"566\":1,\"568\":5,\"720\":1,\"723\":1,\"736\":1,\"741\":4,\"742\":39,\"960\":2,\"972\":2,\"984\":1,\"985\":2,\"998\":1,\"1000\":5,\"1006\":1,\"1007\":2,\"1021\":1,\"1079\":2,\"1145\":1,\"1170\":2,\"1173\":18,\"1195\":5,\"1198\":1,\"1230\":8,\"1248\":2,\"1309\":1,\"1371\":2,\"1425\":1,\"1443\":1,\"1444\":2,\"1516\":4,\"1519\":6,\"1520\":1}}],[\"可应用到状态机\",{\"1\":{\"1508\":1}}],[\"可移植性\",{\"1\":{\"1385\":1}}],[\"可转化为数字的字符串也被认为是数字\",{\"1\":{\"1308\":1}}],[\"可在\",{\"1\":{\"833\":1}}],[\"可想而知这种方法非常浪费网络资源\",{\"1\":{\"804\":1}}],[\"可访问性修饰符\",{\"0\":{\"575\":1}}],[\"可与其他移动速度能力叠加\",{\"1\":{\"477\":1}}],[\"可点可不点\",{\"1\":{\"403\":1}}],[\"可见实力和理解\",{\"1\":{\"403\":1}}],[\"可根据配置的重试策略完成重试\",{\"1\":{\"371\":1}}],[\"可视化得对任务进行编排\",{\"1\":{\"371\":1}}],[\"可视模式下快捷键\",{\"1\":{\"144\":1}}],[\"可变参数\",{\"1\":{\"331\":1}}],[\"可靠性最差\",{\"1\":{\"1027\":1}}],[\"可靠性也不会降低\",{\"1\":{\"735\":1}}],[\"可靠性案例分析\",{\"0\":{\"284\":1}}],[\"可靠性\",{\"1\":{\"277\":1}}],[\"可惜的是\",{\"1\":{\"276\":1}}],[\"可选属性读取之前\",{\"1\":{\"551\":1}}],[\"可选属性\",{\"0\":{\"551\":1}}],[\"可选参数\",{\"0\":{\"536\":1},\"1\":{\"652\":1}}],[\"可选成员必须在必选成员之后\",{\"1\":{\"527\":1}}],[\"可选\",{\"1\":{\"118\":1,\"635\":1,\"1006\":1,\"1007\":1}}],[\"可通过别名\",{\"1\":{\"82\":1}}],[\"可使用\",{\"1\":{\"82\":1}}],[\"可用性\",{\"1\":{\"1385\":1}}],[\"可用且当前节点为主节点\",{\"1\":{\"1163\":1}}],[\"可用于组合任意简单的逻辑判断\",{\"1\":{\"1308\":1}}],[\"可用于比较数字和字符串\",{\"1\":{\"1308\":1}}],[\"可用于函数定义的头部\",{\"1\":{\"186\":1}}],[\"可用于简单的测试和比较\",{\"1\":{\"186\":1}}],[\"可用来查询匹配次数\",{\"1\":{\"150\":1}}],[\"可用带\",{\"1\":{\"82\":1}}],[\"可用\",{\"1\":{\"82\":1,\"762\":1}}],[\"可将相同类型的bean注入list或数组\",{\"1\":{\"82\":1}}],[\"可单独进行测试\",{\"1\":{\"81\":1}}],[\"可能比之前小\",{\"1\":{\"1520\":1}}],[\"可能比宕机之前小\",{\"1\":{\"1511\":1}}],[\"可能已经创建新索引文件并正在压缩\",{\"1\":{\"1436\":1}}],[\"可能造成消息堆积\",{\"1\":{\"1249\":1}}],[\"可能存在老的日志在多数节点复制完之后更新\",{\"1\":{\"1510\":1}}],[\"可能存在正常或者异常宕机\",{\"1\":{\"1362\":1}}],[\"可能存在重平衡后要释放某个队列的\",{\"1\":{\"1215\":1}}],[\"可能存在同时有多个同一队列的消费任务被提交到消费线程池的情况\",{\"1\":{\"1207\":1}}],[\"可能存在消息可能丢失的情况\",{\"1\":{\"854\":1}}],[\"可能耗时较多\",{\"1\":{\"888\":1}}],[\"可能包含多个文件\",{\"1\":{\"867\":1}}],[\"可能由于流控等原因\",{\"1\":{\"855\":1}}],[\"可能导致更大的磁盘使用\",{\"1\":{\"701\":1}}],[\"可能要消耗几分钟\",{\"1\":{\"693\":1}}],[\"可能是由于发生网络分区导致出现多个\",{\"1\":{\"1479\":1}}],[\"可能是由于故意设计成这样\",{\"1\":{\"693\":1}}],[\"可能是危险的\",{\"1\":{\"657\":1}}],[\"可能是非常简单的给定一个特定的条件\",{\"1\":{\"276\":1}}],[\"可能在较长时间内都没有授予\",{\"1\":{\"622\":1}}],[\"可能取以下的值\",{\"1\":{\"606\":1}}],[\"可能有多个\",{\"1\":{\"971\":1}}],[\"可能有多个泛型类型\",{\"1\":{\"48\":1}}],[\"可能有人不知道什么时候驱散\",{\"1\":{\"438\":1}}],[\"可能会重试推送最后一条消息\",{\"1\":{\"1520\":1}}],[\"可能会重复且并发地消费那批没有消费完的消息\",{\"1\":{\"1215\":1}}],[\"可能会推送\",{\"1\":{\"1520\":1}}],[\"可能会比之前更小\",{\"1\":{\"1520\":1}}],[\"可能会随着某些条目在多数节点复制完成后推进\",{\"1\":{\"1519\":1}}],[\"可能会出现为空的情况\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"可能会导致生产停止\",{\"1\":{\"702\":1}}],[\"可能会导致内部进程邮箱的大小很快达到内存阈值\",{\"1\":{\"611\":1}}],[\"可能会被拖入宇宙奇点而死亡\",{\"1\":{\"427\":1}}],[\"可能会花很长时间\",{\"1\":{\"247\":1}}],[\"可能会有这样的情况发生\",{\"1\":{\"130\":1}}],[\"可能缓冲区满可能比较慢\",{\"1\":{\"54\":1}}],[\"可能一次也可能多次\",{\"1\":{\"4\":1}}],[\"可以投递给消费者\",{\"1\":{\"1446\":1}}],[\"可以作为\",{\"1\":{\"1397\":1}}],[\"可以避免消息的滚动导致的写放大\",{\"1\":{\"1364\":1}}],[\"可以做到根据时间查询该时刻的所有定时消息\",{\"1\":{\"1364\":1}}],[\"可以做到比推模式消费者更高的拉取效率\",{\"1\":{\"1136\":1}}],[\"可以仅保存消息的存储位置\",{\"1\":{\"1346\":1}}],[\"可以减少比较次数\",{\"1\":{\"1313\":1}}],[\"可以减少传统\",{\"1\":{\"880\":1}}],[\"可以过滤消息的属性和\",{\"1\":{\"1308\":1}}],[\"可以匹配多个\",{\"1\":{\"1307\":1}}],[\"可以设置\",{\"1\":{\"1305\":1}}],[\"可以设置队列为种惰性队列\",{\"1\":{\"681\":1}}],[\"可以新建一个过滤类\",{\"1\":{\"1303\":1}}],[\"可以加速匹配\",{\"1\":{\"1262\":1}}],[\"可以修改\",{\"1\":{\"1251\":1}}],[\"可以解决\",{\"1\":{\"1249\":1}}],[\"可以向\",{\"1\":{\"1225\":1}}],[\"可以有\",{\"1\":{\"1203\":1}}],[\"可以有多个层级\",{\"1\":{\"1290\":1}}],[\"可以有多个元组拥有相同的键\",{\"1\":{\"248\":1}}],[\"可以有多个子句\",{\"1\":{\"181\":1}}],[\"可以同时处理\",{\"1\":{\"1187\":1}}],[\"可以同时输入类型和正常接口\",{\"1\":{\"592\":1}}],[\"可以进行重平衡\",{\"1\":{\"1136\":1}}],[\"可以多次调用该方法来订阅多个主题\",{\"1\":{\"1117\":1}}],[\"可以自动感知有组件挂掉的情况并重新调整消费者的订阅关系\",{\"1\":{\"1101\":1}}],[\"可以访问\",{\"1\":{\"1081\":1}}],[\"可以可视化的查看\",{\"1\":{\"1076\":1}}],[\"可以预先准备好\",{\"1\":{\"1071\":1}}],[\"可以预分配缓冲区\",{\"1\":{\"28\":1}}],[\"可以很快地用\",{\"1\":{\"1069\":1}}],[\"可以从备\",{\"1\":{\"1033\":1}}],[\"可以从classpath中读取指定资源\",{\"1\":{\"56\":1}}],[\"可以传入要发送的队列信息\",{\"1\":{\"1029\":1}}],[\"可以分为多个队列\",{\"1\":{\"1029\":1}}],[\"可以保证发送消息和另外的操作同时成功或者同时失败\",{\"1\":{\"1028\":1}}],[\"可以保存任何类型的erlang数据结构\",{\"1\":{\"251\":1}}],[\"可以达成较高的可靠性和很高的性能\",{\"1\":{\"1027\":1}}],[\"可以达到预取一批消息到消费者进行消费的目的\",{\"1\":{\"616\":1}}],[\"可以马上定位到这个\",{\"1\":{\"927\":1}}],[\"可以马上算出索引在\",{\"1\":{\"751\":1}}],[\"可以计算投递时间到当前时间的时间差\",{\"1\":{\"920\":1}}],[\"可以实现二层过滤\",{\"1\":{\"1318\":1}}],[\"可以实现延迟消息的效果\",{\"1\":{\"920\":1}}],[\"可以实现在\",{\"1\":{\"848\":1}}],[\"可以上升到\",{\"1\":{\"915\":1}}],[\"可以想到消费者消费时实际是读取消费队列\",{\"1\":{\"1291\":1}}],[\"可以想象一下消费时要做的操作\",{\"1\":{\"1117\":1}}],[\"可以想象成linux的虚拟桌面\",{\"1\":{\"154\":1}}],[\"可以想办法进行优化\",{\"1\":{\"908\":1}}],[\"可以更大程度上提升性能\",{\"1\":{\"887\":1}}],[\"可以大幅度提高延迟消息处理速度\",{\"1\":{\"852\":1}}],[\"可以大幅降低对\",{\"1\":{\"735\":1}}],[\"可以唤醒挂起的请求\",{\"1\":{\"824\":1}}],[\"可以配置轮询方式\",{\"1\":{\"805\":1}}],[\"可以无限扩展\",{\"1\":{\"787\":1}}],[\"可以省下进出重量锁的开销\",{\"1\":{\"733\":1}}],[\"可以直接把从\",{\"1\":{\"730\":1}}],[\"可以直接运行\",{\"1\":{\"500\":1}}],[\"可以直接运行空测试函数\",{\"1\":{\"9\":1}}],[\"可以充分利用多个节点的计算和存储资源\",{\"1\":{\"648\":1}}],[\"可以观察到该进程的状态为黄色flow\",{\"1\":{\"614\":1}}],[\"可以对内存和磁盘使用量设置阈值\",{\"1\":{\"613\":1}}],[\"可以对某个模式里的变量执行简单的测试和比较\",{\"1\":{\"186\":1}}],[\"可以处理的速度\",{\"1\":{\"611\":1}}],[\"可以手动指定脚本模块的基准目录\",{\"1\":{\"601\":1}}],[\"可以让当前文件当作模块处理\",{\"1\":{\"591\":1}}],[\"可以让他走出百花齐放的圈\",{\"1\":{\"416\":1}}],[\"可以混合赋值\",{\"1\":{\"585\":1}}],[\"可以扩展原始数据类型\",{\"1\":{\"564\":1}}],[\"可以以分号结尾\",{\"1\":{\"550\":1}}],[\"可以试数组\",{\"1\":{\"539\":1}}],[\"可以放置任意数量和类型的成员\",{\"1\":{\"527\":1}}],[\"可以赋值给任意其他类型\",{\"1\":{\"504\":1}}],[\"可以吃到巨熊活力的生命值加成\",{\"1\":{\"492\":1}}],[\"可以卡视角规避\",{\"1\":{\"475\":1}}],[\"可以安抚\",{\"1\":{\"458\":1,\"475\":2}}],[\"可以晕上面的一个怪拿一个盾来用\",{\"1\":{\"455\":1}}],[\"可以留到易伤去压\",{\"1\":{\"451\":1}}],[\"可以给铁皮和小迅捷\",{\"1\":{\"447\":1}}],[\"可以给接收语句增加一个超时设置\",{\"1\":{\"232\":1}}],[\"可以按\",{\"1\":{\"446\":1}}],[\"可以按个人喜好选择\",{\"1\":{\"401\":1}}],[\"可以尽快奶爆吸奶盾\",{\"1\":{\"445\":1}}],[\"可以先绽放再刷\",{\"1\":{\"433\":1}}],[\"可以先挑简单的去打\",{\"1\":{\"422\":1}}],[\"可以奶一口之后给他一个绽放\",{\"1\":{\"411\":1}}],[\"可以选择点种植\",{\"1\":{\"407\":1}}],[\"可以当作一个减伤来应对尖刺伤害\",{\"1\":{\"406\":1}}],[\"可以走出百花齐放的圈里\",{\"1\":{\"405\":1}}],[\"可以治疗最多3名拥有你的百花齐放效果的目标\",{\"1\":{\"405\":1}}],[\"可以去奶别人\",{\"1\":{\"403\":1}}],[\"可以点出种植天赋来稳定生成共生绽华\",{\"1\":{\"401\":1}}],[\"可以提供更好的消息吞吐量\",{\"1\":{\"696\":1}}],[\"可以提供\",{\"1\":{\"401\":1,\"484\":1}}],[\"可以根据\",{\"1\":{\"395\":1}}],[\"可以是虚拟节点的名称\",{\"1\":{\"391\":1}}],[\"可以采用取哈希算法得到结果的前\",{\"1\":{\"390\":1}}],[\"可以换一个思路\",{\"1\":{\"387\":1}}],[\"可以考虑将appid切分为appid1\",{\"1\":{\"380\":1}}],[\"可以看这篇文章\",{\"1\":{\"716\":1}}],[\"可以看出消费者发回消息并没有将整个消息都发回去\",{\"1\":{\"1188\":1}}],[\"可以看出该拉模式消费者与推模式消费者的重平衡机制比较类似\",{\"1\":{\"1136\":1}}],[\"可以看出\",{\"1\":{\"380\":1}}],[\"可以看到配置文件主要分两个大项\",{\"1\":{\"983\":1}}],[\"可以看到\",{\"1\":{\"755\":1,\"922\":1,\"945\":1}}],[\"可以看到右边的代码使用了\",{\"1\":{\"741\":1}}],[\"可以看到非持久化消息的生命周期会简单很多\",{\"1\":{\"690\":1}}],[\"可以看到在rabbit\",{\"1\":{\"624\":1}}],[\"可以看到在每次测试前后\",{\"1\":{\"4\":1}}],[\"可以看到会先执行rabbit\",{\"1\":{\"624\":1}}],[\"可以看到hashedwheeltimer是最为关键的类\",{\"1\":{\"379\":1}}],[\"可以轻松地支持数百万并发\",{\"1\":{\"372\":1}}],[\"可以应对任何情况\",{\"1\":{\"365\":1}}],[\"可以利用exports这个已存在的空对象\",{\"1\":{\"365\":1}}],[\"可以被消费者消费\",{\"1\":{\"1464\":1}}],[\"可以被共享的队列数\",{\"1\":{\"1255\":1}}],[\"可以被\",{\"1\":{\"904\":1}}],[\"可以被删除\",{\"1\":{\"870\":1}}],[\"可以被梦境之力增强\",{\"1\":{\"401\":1}}],[\"可以被其他地方引用\",{\"1\":{\"361\":1}}],[\"可以被多个进程共享\",{\"1\":{\"247\":1}}],[\"可以完全满足工程上的需求\",{\"1\":{\"360\":1}}],[\"可以串联起来\",{\"1\":{\"351\":1}}],[\"可以返回一个对象\",{\"1\":{\"341\":1}}],[\"可以返回多次\",{\"1\":{\"332\":1}}],[\"可以接收一个判断函数\",{\"1\":{\"326\":1}}],[\"可以忽略它们\",{\"1\":{\"303\":1}}],[\"可以参考官方文档\",{\"1\":{\"1025\":1}}],[\"可以参考上面的时间轴来给手牌\",{\"1\":{\"434\":1}}],[\"可以参考\",{\"1\":{\"266\":1}}],[\"可以构建大规模\",{\"1\":{\"262\":1}}],[\"可以跟踪所有的函数调用\",{\"1\":{\"261\":1}}],[\"可以简单地在程序的关键位置添加\",{\"1\":{\"258\":1}}],[\"可以创建两种类型的\",{\"1\":{\"632\":1}}],[\"可以创建端口\",{\"1\":{\"241\":1}}],[\"可以创建或删除文件和目录\",{\"1\":{\"52\":1}}],[\"可以公布进程标识符\",{\"1\":{\"234\":1}}],[\"可以改进错误信息\",{\"1\":{\"196\":1}}],[\"可以将一个消费组切换成\",{\"1\":{\"1247\":1}}],[\"可以将超时时间设为\",{\"1\":{\"1233\":1}}],[\"可以将消息发到其他集群\",{\"1\":{\"633\":1}}],[\"可以将子任务分发给新的worker去计算\",{\"1\":{\"378\":1}}],[\"可以将意外停机时间减少50\",{\"1\":{\"276\":1}}],[\"可以将元组中的元素绑定到特定的名称\",{\"1\":{\"191\":1}}],[\"可以将业务处理过程\",{\"1\":{\"127\":1}}],[\"可以由一系列\",{\"1\":{\"186\":1}}],[\"可以用作消息的业务标识\",{\"1\":{\"1305\":1}}],[\"可以用命令行提供的诊断命令查看一致性哈希交换器的哈希环节点分布\",{\"1\":{\"711\":1}}],[\"可以用给\",{\"1\":{\"613\":1}}],[\"可以用对象的形式\",{\"1\":{\"570\":1}}],[\"可以用类型别名\",{\"1\":{\"538\":1}}],[\"可以用\",{\"1\":{\"480\":1,\"1303\":1}}],[\"可以用人形态野性冲锋来赶路\",{\"1\":{\"471\":1}}],[\"可以用野性冲锋来快速接近\",{\"1\":{\"453\":1}}],[\"可以用狂奔怒吼帮助落位\",{\"1\":{\"440\":1}}],[\"可以用hasownproperty\",{\"1\":{\"299\":1}}],[\"可以用库模块\",{\"1\":{\"261\":1}}],[\"可以用来表示布尔值\",{\"1\":{\"206\":1}}],[\"可以用它来增加模式匹配的威力\",{\"1\":{\"186\":1}}],[\"可以用java\",{\"1\":{\"25\":1}}],[\"可以与erlang节点系统中任何节点上的任何程序进行交互\",{\"1\":{\"171\":1}}],[\"可以挂接一个shell到集群里另一个erlang节点上运行的erlang系统\",{\"1\":{\"171\":1}}],[\"可以方便的应用在多行文本上\",{\"1\":{\"159\":1}}],[\"可以组织为窗口的一个工作区\",{\"1\":{\"151\":1}}],[\"可以监听\",{\"1\":{\"118\":1}}],[\"可以监控classpath路径上的文件\",{\"1\":{\"95\":1}}],[\"可以读和写\",{\"1\":{\"118\":1}}],[\"可以定义factorybean来使用工厂模式创建bean\",{\"1\":{\"82\":1}}],[\"可以定义annotation是否可重复\",{\"1\":{\"43\":1}}],[\"可以把不同业务的权限配置分别放在多个文件中\",{\"1\":{\"983\":1}}],[\"可以把取消消息的状态更新到该字段中存储\",{\"1\":{\"935\":1}}],[\"可以把\",{\"1\":{\"749\":1}}],[\"可以把前者看做数据生产者\",{\"1\":{\"724\":1}}],[\"可以把治疗手牌留到多个憎恶存在的时候\",{\"1\":{\"459\":1}}],[\"可以把赛梦换成萌芽之叶来增加治疗量\",{\"1\":{\"403\":1}}],[\"可以把实例化的匿名类改写为lambda表达式\",{\"1\":{\"75\":1}}],[\"可以把socket简单理解为ip地址加端口号\",{\"1\":{\"68\":1}}],[\"可以把一个outputstream和任意个filteroutputstream组合\",{\"1\":{\"55\":1}}],[\"可以把一个inputstream和任意个filterinputstream组合\",{\"1\":{\"55\":1}}],[\"可以为一个项目指定特定的maven版本\",{\"1\":{\"65\":1}}],[\"可以获取目录的文件和子目录\",{\"1\":{\"52\":1}}],[\"可以获取路径\",{\"1\":{\"52\":1}}],[\"可以在\",{\"1\":{\"1072\":1}}],[\"可以在消息生产\",{\"1\":{\"1010\":1}}],[\"可以在rocketmq集群中选择其中一个broker节点专用于存储消息轨迹\",{\"1\":{\"1004\":1}}],[\"可以在不重启服务的情况下自动生效\",{\"1\":{\"997\":1}}],[\"可以在聊天框中输入以下命令查看\",{\"1\":{\"420\":1}}],[\"可以在任何本中使用\",{\"1\":{\"403\":1}}],[\"可以在运行期修改原型对象\",{\"1\":{\"339\":1}}],[\"可以在运行时根据条件加载不同的实现类\",{\"1\":{\"37\":1}}],[\"可以在字符串和带引号的原子里使用转义序列来输入任何不可打印的字符\",{\"1\":{\"209\":1}}],[\"可以在添加\",{\"1\":{\"135\":1}}],[\"可以在代码中直观地看到查询语句\",{\"1\":{\"92\":1}}],[\"可以在bin目录下看到如下class文件\",{\"1\":{\"21\":1}}],[\"可以指定消息的属性\",{\"1\":{\"1035\":1}}],[\"可以指定保存消息轨迹的\",{\"1\":{\"1006\":1,\"1007\":1}}],[\"可以指定多个phase\",{\"1\":{\"62\":1}}],[\"可以指定开头和结尾\",{\"1\":{\"29\":1}}],[\"可以指定main\",{\"1\":{\"24\":1}}],[\"可以通过索引文件来辅助定时消息的查询\",{\"1\":{\"1346\":1}}],[\"可以通过表达式过滤的方式设置需要过滤的\",{\"1\":{\"1307\":1}}],[\"可以通过一个开关实时进行切换\",{\"1\":{\"1095\":1}}],[\"可以通过映射地址加偏移量的方式直接操作\",{\"1\":{\"880\":1}}],[\"可以通过messageindexenable属性配置打开或关闭\",{\"1\":{\"777\":1}}],[\"可以通过配置故障延迟机制来指定是在本次消息发送时暂时避开发送失败的\",{\"1\":{\"1032\":1}}],[\"可以通过配置\",{\"1\":{\"687\":1}}],[\"可以通过垂直或者水平扩容的方式增加\",{\"1\":{\"648\":1}}],[\"可以通过成员值获得成员名\",{\"1\":{\"587\":1}}],[\"可以通过哈希算法计算出其所有虚拟节点在哈希环上的位置\",{\"1\":{\"394\":1}}],[\"可以通过调用\",{\"1\":{\"118\":1}}],[\"可以通过outputstreamwriter将outputstream转换为writer\",{\"1\":{\"58\":1}}],[\"可以通过inputstreamreader在指定编码的同时将任何inputstream转换为reader\",{\"1\":{\"57\":1}}],[\"可以通过\",{\"1\":{\"10\":1,\"118\":1,\"1078\":1,\"1362\":1}}],[\"可以使用编译参数moduleresolution\",{\"1\":{\"597\":1}}],[\"可以使用map\",{\"1\":{\"371\":1}}],[\"可以使用宏录制一系列操作\",{\"1\":{\"159\":1}}],[\"可以使用\",{\"1\":{\"7\":1}}],[\"并等待超过半数节点\",{\"1\":{\"1516\":1}}],[\"并记录投票给谁\",{\"1\":{\"1478\":1}}],[\"并创建一个\",{\"1\":{\"1428\":1}}],[\"并创建一个基于该原型的新对象\",{\"1\":{\"339\":1}}],[\"并验证是否合法\",{\"1\":{\"1408\":1,\"1432\":1}}],[\"并没有重写消息存储的方法\",{\"1\":{\"1400\":1}}],[\"并没有将\",{\"1\":{\"882\":1}}],[\"并新建一个\",{\"1\":{\"1394\":1}}],[\"并新建重平衡服务\",{\"1\":{\"1111\":1}}],[\"并开始订正\",{\"1\":{\"1362\":1}}],[\"并分成定时请求和定时消息取消请求两类\",{\"1\":{\"1358\":1}}],[\"并批量放入\",{\"1\":{\"1356\":1}}],[\"并检查该\",{\"1\":{\"1279\":1}}],[\"并作一些校验\",{\"1\":{\"1260\":1}}],[\"并放到\",{\"1\":{\"1253\":1}}],[\"并放入缓存\",{\"1\":{\"1431\":1}}],[\"并放入\",{\"1\":{\"1120\":1}}],[\"并释放\",{\"1\":{\"1224\":1}}],[\"并恢复\",{\"1\":{\"1218\":1}}],[\"并提交\",{\"1\":{\"1194\":1}}],[\"并提供一系列操作接口\",{\"1\":{\"1386\":1}}],[\"并提供全面的结果报告\",{\"1\":{\"277\":1}}],[\"并提供对应的源码实现和解释\",{\"1\":{\"110\":1}}],[\"并更新日志转发器状态\",{\"1\":{\"1519\":1}}],[\"并更新日志转发器的状态\",{\"1\":{\"1519\":1}}],[\"并更新加锁时间\",{\"1\":{\"1214\":1}}],[\"并更新消费进度\",{\"1\":{\"1179\":1}}],[\"并更新下一次触发时间\",{\"1\":{\"379\":1}}],[\"并对拉取到的消息进行消费处理\",{\"1\":{\"1151\":1}}],[\"并实现了重分配的方法\",{\"1\":{\"1129\":1}}],[\"并置于和集群同一个网络下\",{\"1\":{\"1078\":1}}],[\"并进入该仓库\",{\"1\":{\"1070\":1}}],[\"并支持多种部署模式\",{\"1\":{\"1069\":1}}],[\"并指定为内存存储的\",{\"1\":{\"1061\":1}}],[\"并指定用户名和密码参数\",{\"1\":{\"980\":1}}],[\"并设置相关属性\",{\"1\":{\"1464\":1}}],[\"并设置事务\",{\"1\":{\"1464\":1}}],[\"并设置事务标识\",{\"1\":{\"1053\":1}}],[\"并设置\",{\"1\":{\"1443\":1,\"1517\":1}}],[\"并设置压缩标识\",{\"1\":{\"1053\":1}}],[\"并设置了\",{\"1\":{\"665\":1}}],[\"并调用拉消费者实现类的\",{\"1\":{\"1119\":1}}],[\"并调用\",{\"1\":{\"999\":1}}],[\"并返回投票\",{\"1\":{\"1492\":1}}],[\"并返回自己投的\",{\"1\":{\"1492\":1}}],[\"并返回给客户端\",{\"1\":{\"957\":1,\"973\":1}}],[\"并返回字节表示的\",{\"1\":{\"53\":1}}],[\"并将索引追加到\",{\"1\":{\"1517\":1}}],[\"并将分发请求追加到\",{\"1\":{\"1427\":1}}],[\"并将默认\",{\"1\":{\"1425\":1}}],[\"并将没有匹配的消息重试\",{\"1\":{\"1253\":1}}],[\"并将订阅关系上报到\",{\"1\":{\"1130\":1}}],[\"并将该时间与\",{\"1\":{\"999\":1}}],[\"并将自身的\",{\"1\":{\"952\":1}}],[\"并将它们同步的分派给关联的请求处理程序\",{\"1\":{\"119\":1}}],[\"并从队列中移除投递任务\",{\"1\":{\"858\":1}}],[\"并从时间格的任务链表中删除对应任务\",{\"1\":{\"379\":1}}],[\"并为每个延迟等级设计单独的\",{\"1\":{\"836\":1}}],[\"并为架构演进提供进一步优化建议\",{\"1\":{\"278\":1}}],[\"并与\",{\"1\":{\"1081\":1}}],[\"并与交换器绑定\",{\"1\":{\"712\":1}}],[\"并与团队沟通\",{\"1\":{\"446\":1}}],[\"并需要同步来恢复全部数据冗余\",{\"1\":{\"678\":1}}],[\"并考虑它们而不是经典的镜像队列\",{\"1\":{\"675\":1}}],[\"并传到\",{\"1\":{\"643\":1}}],[\"并用万灵把血抬满\",{\"1\":{\"461\":1}}],[\"并使用从节点的轮次\",{\"1\":{\"1499\":1}}],[\"并使用\",{\"1\":{\"417\":1}}],[\"并使你在目标身上的持续治疗效果的持续时间延长8秒\",{\"1\":{\"405\":1}}],[\"并判断如果是已经到期或者过期任务\",{\"1\":{\"379\":1}}],[\"并添加到对应时间格的任务链表中\",{\"1\":{\"379\":1}}],[\"并根据任务类型\",{\"1\":{\"374\":1}}],[\"并根据配置的并发数创建相应的客户端\",{\"1\":{\"280\":1}}],[\"并计算delay后放入时间轮或立即执行\",{\"1\":{\"374\":1}}],[\"并计算该测试模式所关注的指标\",{\"1\":{\"4\":1}}],[\"并定期将任务的运行时信息上报给\",{\"1\":{\"372\":1}}],[\"并非用于加密数据\",{\"1\":{\"368\":1}}],[\"并继续在上面添加新的键值\",{\"1\":{\"365\":1}}],[\"并行执行并只获得先返回的结果\",{\"0\":{\"353\":1}}],[\"并行执行多个任务\",{\"0\":{\"352\":1}}],[\"并绑定this\",{\"1\":{\"342\":1}}],[\"并在消费任务执行时加锁\",{\"1\":{\"1217\":1}}],[\"并在生产时指定队列\",{\"1\":{\"1102\":1}}],[\"并在停机时变得不同步\",{\"1\":{\"657\":1}}],[\"并在集群的两个节点上完成进行\",{\"1\":{\"653\":1}}],[\"并在它们都完成后执行then\",{\"1\":{\"352\":1}}],[\"并在内部用call\",{\"1\":{\"342\":1}}],[\"并在拦截前后进行安全检查\",{\"1\":{\"85\":1}}],[\"并会根据需要测试的分布式基础设施找到对应的driver组件并载入\",{\"1\":{\"280\":1}}],[\"并会显著增加系统负载\",{\"1\":{\"255\":1}}],[\"并以两个实战案例展示了openchaos在实际应用场景中可以发挥的效果\",{\"1\":{\"275\":1}}],[\"并阐述了openchaos在传统混沌工程上的优化与创新\",{\"1\":{\"275\":1}}],[\"并配置好插件获取\",{\"1\":{\"272\":1}}],[\"并受防火墙保护\",{\"1\":{\"237\":1}}],[\"并管理超时\",{\"1\":{\"233\":1}}],[\"并执行sleep\",{\"1\":{\"379\":1}}],[\"并执行\",{\"1\":{\"230\":1}}],[\"并执行它进行请求分发\",{\"1\":{\"122\":1}}],[\"并发恢复\",{\"1\":{\"1421\":1}}],[\"并发将\",{\"1\":{\"1371\":1}}],[\"并发有两层含义\",{\"1\":{\"1203\":1}}],[\"并发模式下\",{\"1\":{\"1187\":1}}],[\"并发消费的消费线程池\",{\"1\":{\"1206\":1}}],[\"并发消费的方式是调用消费者的指定\",{\"1\":{\"1102\":1}}],[\"并发消费是比较常用的一种消费方式\",{\"1\":{\"1203\":1}}],[\"并发消费服务提交消费请求\",{\"0\":{\"1194\":1}}],[\"并发消费服务将消息封装成一个个消费请求\",{\"1\":{\"1179\":1}}],[\"并发消费\",{\"1\":{\"1179\":1}}],[\"并发消费和顺序消费\",{\"1\":{\"1117\":1,\"1187\":1}}],[\"并发消费与顺序消费\",{\"0\":{\"1102\":1}}],[\"并发送消费者取消通知\",{\"1\":{\"665\":1}}],[\"并发生不可用时\",{\"1\":{\"284\":1}}],[\"并发程序模板\",{\"1\":{\"235\":1}}],[\"并发编程\",{\"0\":{\"228\":1}}],[\"并发和分布式程序\",{\"0\":{\"226\":1}}],[\"并祈祷它能收到并理解这个消息\",{\"1\":{\"227\":1}}],[\"并插入必要的包含文件\",{\"1\":{\"208\":1}}],[\"并修改\",{\"1\":{\"191\":1}}],[\"并把处理结果放入\",{\"1\":{\"125\":1}}],[\"并强制任何正在缓冲的输出字节被写入到底层输出设备\",{\"1\":{\"54\":1}}],[\"并且回查是一个异步过程\",{\"1\":{\"1468\":1}}],[\"并且传入默认的消息存储实现的引用\",{\"1\":{\"1424\":1}}],[\"并且提供了读\",{\"1\":{\"1402\":1}}],[\"并且提供了常用的\",{\"1\":{\"1069\":1}}],[\"并且可以调整槽位对应的时间窗长度来控制定时的精确度\",{\"1\":{\"1346\":1}}],[\"并且可以连接\",{\"1\":{\"1070\":1}}],[\"并且消费队列索引扩展文件会创建新的文件\",{\"1\":{\"1325\":1}}],[\"并且没有存入磁盘\",{\"1\":{\"1277\":1}}],[\"并且本次拉取是由客户端触发\",{\"1\":{\"1173\":1}}],[\"并且会将该对象进行持久化\",{\"1\":{\"944\":1}}],[\"并且先计算好长度\",{\"1\":{\"909\":1}}],[\"并且也不必再通过调用read或write方法对文件进行读写\",{\"1\":{\"880\":1}}],[\"并且从节点会定期从主节点拉去该表的最新值\",{\"1\":{\"857\":1}}],[\"并且避免多延迟等级消息同时发送时造成的阻塞\",{\"1\":{\"852\":1}}],[\"并且启动长轮询\",{\"1\":{\"814\":1,\"819\":1}}],[\"并且刷新\",{\"1\":{\"789\":1}}],[\"并且把上一个索引文件异步刷盘\",{\"1\":{\"789\":1}}],[\"并且把复制因子设置为\",{\"1\":{\"703\":1}}],[\"并且将消费者和消费队列排序的方法\",{\"1\":{\"1127\":1}}],[\"并且将上一个写满的索引文件刷盘\",{\"1\":{\"783\":1}}],[\"并且将该偏移量加一\",{\"1\":{\"765\":1}}],[\"并且将它注册到之前的\",{\"1\":{\"124\":1}}],[\"并且一并传入数据的开始位置和长度\",{\"1\":{\"730\":1}}],[\"并且一个包含镜像的节点宕机\",{\"1\":{\"657\":1}}],[\"并且复制因子为\",{\"1\":{\"701\":1}}],[\"并且有它自己的局限性\",{\"1\":{\"694\":1}}],[\"并且还未完成消息的同步\",{\"1\":{\"659\":1}}],[\"并且cluster\",{\"1\":{\"659\":1}}],[\"并且在\",{\"1\":{\"630\":1}}],[\"并且在运行期可以被程序读取\",{\"1\":{\"44\":1}}],[\"并且这个\",{\"1\":{\"622\":1}}],[\"并且控制发送消息的速度\",{\"1\":{\"615\":1}}],[\"并且控制链好\",{\"1\":{\"469\":1}}],[\"并且根据参数的不同\",{\"1\":{\"547\":1}}],[\"并且只在当前代码块有效\",{\"1\":{\"519\":1}}],[\"并且不会改变\",{\"1\":{\"497\":1}}],[\"并且能够在高额\",{\"1\":{\"482\":1}}],[\"并且能够收到精通的加成\",{\"1\":{\"405\":1}}],[\"并且点出了吹风\",{\"1\":{\"455\":1}}],[\"并且点出野性之心来输出\",{\"1\":{\"449\":1}}],[\"并且过量奶中\",{\"1\":{\"448\":1}}],[\"并且与其他很多天赋有联动\",{\"1\":{\"405\":1}}],[\"并且双大迅捷让你可以在万灵时几乎总是有一个大迅捷\",{\"1\":{\"403\":1}}],[\"并且放入哈希环\",{\"1\":{\"393\":1}}],[\"并且实现起来非常简洁\",{\"1\":{\"372\":1}}],[\"并且无需考虑浏览器兼容性问题\",{\"1\":{\"360\":1}}],[\"并且\",{\"1\":{\"332\":1,\"688\":1,\"900\":1}}],[\"并且永远指向当前函数的调用者传入的所有参数\",{\"1\":{\"308\":1}}],[\"并且依赖于观察是极其主观的\",{\"1\":{\"277\":1}}],[\"并且前后的一些操作的结果也是我不想要的\",{\"1\":{\"271\":1}}],[\"并且每个元组都有相同的结构\",{\"1\":{\"190\":1}}],[\"并且对其进行了扩展和优化\",{\"1\":{\"135\":1}}],[\"并且管理服务端\",{\"1\":{\"133\":1}}],[\"并且支持异步读\",{\"1\":{\"118\":1}}],[\"并且事件启动无法避免所有的阻塞\",{\"1\":{\"117\":1}}],[\"并且它通常会阻止\",{\"1\":{\"3\":1}}],[\"并不断重试\",{\"1\":{\"1520\":1}}],[\"并不适合海量\",{\"1\":{\"1290\":1}}],[\"并不负责请求处理\",{\"1\":{\"1155\":1}}],[\"并不会持久化\",{\"1\":{\"944\":1}}],[\"并不会直接去读写磁盘上的文件\",{\"1\":{\"879\":1}}],[\"并不能保证服务的可用性\",{\"1\":{\"942\":1}}],[\"并不是实际上限\",{\"1\":{\"1300\":1}}],[\"并不是仅在\",{\"1\":{\"870\":1}}],[\"并不是一次性把所有用到的\",{\"1\":{\"37\":1}}],[\"并不需要我们将其改写为stringbuilder\",{\"1\":{\"28\":1}}],[\"并关联起来\",{\"1\":{\"36\":1}}],[\"并输出class为java\",{\"1\":{\"25\":1}}],[\"在配置类被更新时刷新配置项\",{\"1\":{\"1523\":1}}],[\"在待写队列中没有找到对应的\",{\"1\":{\"1520\":1}}],[\"在具体讲解每个步骤之前\",{\"1\":{\"1508\":1}}],[\"在概要设计中\",{\"1\":{\"1508\":1}}],[\"在从节点上保存\",{\"1\":{\"1481\":1}}],[\"在选举超时后开始新的选举轮次\",{\"1\":{\"1480\":1}}],[\"在选举超时后\",{\"1\":{\"1477\":1}}],[\"在操作消息中的所有半消息的偏移量\",{\"1\":{\"1468\":1}}],[\"在后面服务端定期回查前\",{\"1\":{\"1446\":1}}],[\"在当下的互联网时代\",{\"1\":{\"1439\":1}}],[\"在没有上传成功之前\",{\"1\":{\"1417\":1}}],[\"在读取前查询和读取缓存\",{\"1\":{\"1402\":1}}],[\"在默认存储的消息分发器中添加分级存储的消息分发器实例\",{\"1\":{\"1400\":1}}],[\"在插件存储中仍然可以调用默认存储\",{\"1\":{\"1398\":1}}],[\"在插钥匙之前可以卡一个\",{\"1\":{\"485\":1}}],[\"在重启恢复分级存储模块时读取\",{\"1\":{\"1419\":1}}],[\"在重启后\",{\"1\":{\"1395\":1}}],[\"在重新启动时\",{\"1\":{\"1362\":1}}],[\"在文件中的位置是随机的\",{\"1\":{\"1418\":1}}],[\"在文件中连续存储和读取\",{\"1\":{\"1393\":1}}],[\"在文件尾部添加如下配置\",{\"1\":{\"1078\":1}}],[\"在其他分发器都分发完毕后被调用\",{\"1\":{\"1388\":1}}],[\"在其之上做了一些修改\",{\"1\":{\"1321\":1}}],[\"在相同流量下性能提升了\",{\"1\":{\"1388\":1}}],[\"在转冷的过程中能够做一些消息系统内部的格式变化来加速冷数据的读取\",{\"1\":{\"1385\":1}}],[\"在云原生和\",{\"1\":{\"1378\":1}}],[\"在性能测试中\",{\"1\":{\"1363\":1}}],[\"在时间轮表示的这段时间过去之后\",{\"1\":{\"1351\":1}}],[\"在时间轮的时间窗口之内\",{\"1\":{\"1347\":1}}],[\"在时间上是前一条\",{\"1\":{\"786\":1}}],[\"在构造消息时提供了\",{\"1\":{\"1339\":1}}],[\"在构建消费队列时会保存根据消息\",{\"1\":{\"1314\":1}}],[\"在此方法返回\",{\"1\":{\"1299\":1}}],[\"在此处选择对应版本的\",{\"1\":{\"643\":1}}],[\"在码表上标记对应的消息为\",{\"1\":{\"1263\":1}}],[\"在保存和匹配时都对应一批消息\",{\"1\":{\"1258\":1}}],[\"在保留时间内\",{\"1\":{\"870\":1}}],[\"在切换\",{\"1\":{\"1255\":1}}],[\"在创建\",{\"1\":{\"1248\":1}}],[\"在创建一致性哈希交换器时指定\",{\"1\":{\"714\":1}}],[\"在接下来的一段时间内所有的客户端都不会向对应的\",{\"1\":{\"1234\":1}}],[\"在接下来一段时间内都不再向其发送消息\",{\"1\":{\"1041\":1}}],[\"在方法后面的逻辑中立即执行拉取\",{\"1\":{\"1228\":1}}],[\"在步骤\",{\"1\":{\"1203\":1}}],[\"在如下位置被调用\",{\"1\":{\"1168\":1}}],[\"在停止时\",{\"1\":{\"1136\":1}}],[\"在订阅\",{\"1\":{\"1136\":1}}],[\"在系列后面的文章中会详细讲解\",{\"1\":{\"1119\":1}}],[\"在系统环境变量中设置classpath环境变量\",{\"1\":{\"23\":1}}],[\"在图中\",{\"1\":{\"1119\":1}}],[\"在拉取消息处理方法中\",{\"1\":{\"1324\":1}}],[\"在拉取消息时如果没有新消息\",{\"1\":{\"804\":1}}],[\"在拉消息方法中被调用\",{\"1\":{\"1324\":1}}],[\"在拉消费者背后\",{\"1\":{\"1119\":1}}],[\"在首次启动前\",{\"1\":{\"1111\":1}}],[\"在推送消息给消费者\",{\"1\":{\"1094\":1}}],[\"在了解它们之前\",{\"1\":{\"1088\":1}}],[\"在正常情况下\",{\"1\":{\"1041\":1}}],[\"在对\",{\"1\":{\"1364\":1}}],[\"在对响应时间敏感\",{\"1\":{\"1027\":1}}],[\"在对读到的数据解码之后交给对应的业务线程进行业务处理\",{\"1\":{\"135\":1}}],[\"在该模式下\",{\"1\":{\"1004\":1}}],[\"在该服务中会记录其监控的acl配置文件目录\",{\"1\":{\"999\":1}}],[\"在处理完请求后调用\",{\"1\":{\"996\":1}}],[\"在处理消息时性能损耗的点\",{\"1\":{\"887\":1}}],[\"在服务端接收到请求并解码后\",{\"1\":{\"996\":1}}],[\"在请求之前注册\",{\"1\":{\"990\":1}}],[\"在请求处理前后增加方法\",{\"1\":{\"990\":1}}],[\"在进行选举的时候\",{\"1\":{\"942\":1}}],[\"在进程字典中用来保存ack消息数的\",{\"1\":{\"626\":1}}],[\"在早期版本的\",{\"1\":{\"942\":1}}],[\"在第一层过滤\",{\"1\":{\"1315\":1}}],[\"在第一次发送消息时\",{\"1\":{\"1039\":1}}],[\"在第二节中\",{\"1\":{\"936\":1}}],[\"在第1\",{\"1\":{\"284\":1}}],[\"在遇见和解决一个一个坑之后实现了高性能高可靠的任意时间定时消息\",{\"1\":{\"934\":1}}],[\"在扫描每个延迟等级的队列时具体的逻辑是\",{\"1\":{\"932\":1}}],[\"在异步投递的情况下顺序可能与主节点不一致\",{\"1\":{\"930\":1}}],[\"在设计消息轨迹功能时\",{\"1\":{\"1010\":1}}],[\"在设计定时消息的实现方案前\",{\"1\":{\"923\":1}}],[\"在设计上更倾向于消息被及时消费\",{\"1\":{\"681\":1}}],[\"在设计上\",{\"1\":{\"81\":1}}],[\"在比如\",{\"1\":{\"921\":1,\"1337\":1}}],[\"在比较坏的情况下\",{\"1\":{\"906\":1}}],[\"在开源版本中支持延迟消息的功能\",{\"1\":{\"919\":1}}],[\"在写入成功后更新checkpoint中的最新写入时间\",{\"1\":{\"1297\":1}}],[\"在写\",{\"0\":{\"910\":1}}],[\"在客户端每次发送消息时会调用\",{\"1\":{\"899\":1}}],[\"在预分配的\",{\"1\":{\"882\":1}}],[\"在预热和测试执行过程中\",{\"1\":{\"4\":1}}],[\"在用户空间的应用程序无法直接访问\",{\"1\":{\"880\":1}}],[\"在整体上看都是顺序读写\",{\"1\":{\"879\":1}}],[\"在调用系统的\",{\"1\":{\"879\":1}}],[\"在多副本的情况下\",{\"1\":{\"1403\":1}}],[\"在多线程写\",{\"1\":{\"877\":1}}],[\"在多个消费者同时消费一个\",{\"1\":{\"1126\":1}}],[\"在多个机器下可以有多台机器同时并行处理同一个任务\",{\"1\":{\"371\":1}}],[\"在多个窗口打开多个文件\",{\"1\":{\"151\":1}}],[\"在删除文件时\",{\"1\":{\"870\":1}}],[\"在磁盘上存储多份\",{\"1\":{\"1290\":1}}],[\"在磁盘容量达到\",{\"1\":{\"866\":1}}],[\"在磁盘中\",{\"1\":{\"701\":1}}],[\"在老版本中使用\",{\"1\":{\"942\":1}}],[\"在老版本中\",{\"1\":{\"852\":1}}],[\"在启动和停止时也不会向\",{\"1\":{\"1136\":1}}],[\"在启动时从磁盘中加载\",{\"1\":{\"840\":1}}],[\"在启动jvm时设置classpath变量\",{\"1\":{\"23\":1}}],[\"在存储消息时\",{\"1\":{\"1400\":1}}],[\"在存储层面查询消息的入口是\",{\"1\":{\"757\":1}}],[\"在存盘之前\",{\"1\":{\"839\":1,\"843\":1}}],[\"在定时消息放入时间轮前进行判断\",{\"1\":{\"1347\":1}}],[\"在定时消息被老化之前\",{\"1\":{\"1347\":1}}],[\"在定时消息场景下有一种极端情况\",{\"1\":{\"1344\":1}}],[\"在定时消息功能中\",{\"1\":{\"836\":1}}],[\"在定义某个\",{\"1\":{\"191\":1}}],[\"在长轮询等待时如果有新消息到达\",{\"1\":{\"814\":1}}],[\"在生产环境中建议将超时时间合重试次数设大一点\",{\"1\":{\"1233\":1}}],[\"在生产者写入\",{\"1\":{\"725\":1}}],[\"在生产者确认机制中\",{\"1\":{\"663\":1}}],[\"在生成消费索引时一并生成\",{\"1\":{\"1294\":1}}],[\"在生成过程中已经设置了\",{\"1\":{\"1053\":1}}],[\"在生成索引之后\",{\"1\":{\"811\":1}}],[\"在链表头部插入最新的索引项\",{\"1\":{\"797\":1}}],[\"在broker重新启动时会扫描consumequeue的目录\",{\"1\":{\"770\":1}}],[\"在backingqueue中\",{\"1\":{\"690\":1}}],[\"在doreput方法中被调用\",{\"1\":{\"763\":1}}],[\"在disk和ram之间置换\",{\"1\":{\"690\":1}}],[\"在收到\",{\"1\":{\"1512\":1}}],[\"在收到客户端的请求之后\",{\"1\":{\"757\":1}}],[\"在收到消息后再返回一个echo\",{\"1\":{\"369\":1}}],[\"在返回时将结果复制到\",{\"1\":{\"741\":1}}],[\"在消费者注册时根据消费者名称和订阅的\",{\"1\":{\"1323\":1}}],[\"在消费者上报心跳\",{\"1\":{\"1319\":1}}],[\"在消费者启动时创建\",{\"1\":{\"1191\":1}}],[\"在消费者端处理拉取结果的方法\",{\"1\":{\"1319\":1}}],[\"在消费者端需要处理拉取请求的发送和\",{\"1\":{\"1155\":1}}],[\"在消费者端用一个固定的分配策略将所有的消费队列分配给所有的消费者\",{\"1\":{\"1127\":1}}],[\"在消费者端也有一组锁\",{\"1\":{\"1102\":1}}],[\"在消费者数量变化时\",{\"1\":{\"1126\":1}}],[\"在消费者客户端消费时\",{\"1\":{\"1102\":1}}],[\"在消费时\",{\"1\":{\"1293\":1,\"1307\":1}}],[\"在消费时使用\",{\"1\":{\"1017\":1}}],[\"在消费时可能由多条数据\",{\"1\":{\"1017\":1}}],[\"在消费消息时\",{\"1\":{\"687\":1}}],[\"在消息属性中\",{\"1\":{\"1453\":1}}],[\"在消息写入\",{\"1\":{\"1403\":1}}],[\"在消息生产时在\",{\"1\":{\"1323\":1}}],[\"在消息生产时用布隆过滤器计算二进制数组的操作和构造消费队列扩展存储的操作默认都是关闭的\",{\"1\":{\"1315\":1}}],[\"在消息生产时构造消费队列的过程当中\",{\"1\":{\"1315\":1}}],[\"在消息拉取和顺序消费服务每消费一批消息前\",{\"1\":{\"1209\":1}}],[\"在消息队列中\",{\"1\":{\"935\":1}}],[\"在消息存入\",{\"1\":{\"806\":1,\"1294\":1}}],[\"在消息传输时用字符串存储一个\",{\"1\":{\"740\":1}}],[\"在同步方法中调用异步方法的等待方法\",{\"1\":{\"731\":1}}],[\"在同一消费组中的不同消费者会根据负载机制来平均地订阅\",{\"1\":{\"1091\":1}}],[\"在同一线程中运行\",{\"1\":{\"123\":1}}],[\"在同一个测试类中共享\",{\"1\":{\"9\":1}}],[\"在commitlog\",{\"1\":{\"1346\":1}}],[\"在commitlog保存消息之后\",{\"1\":{\"726\":1}}],[\"在command模式下执行normal模式命令\",{\"0\":{\"161\":1}}],[\"在发送\",{\"1\":{\"1519\":1}}],[\"在发送消息时\",{\"1\":{\"1035\":1}}],[\"在发送消息时指定消息\",{\"1\":{\"714\":1}}],[\"在发布\",{\"1\":{\"700\":1}}],[\"在某些情况下\",{\"1\":{\"714\":1}}],[\"在某个或某些\",{\"1\":{\"135\":1}}],[\"在使用时可以在生产者和消费者上指定消息轨迹发送的自定义\",{\"1\":{\"1012\":1}}],[\"在使用\",{\"1\":{\"707\":1}}],[\"在使用树皮书时增加一个小的持续治疗和移动速度加成\",{\"1\":{\"407\":1}}],[\"在仲裁队列中\",{\"1\":{\"704\":1}}],[\"在节点挂掉或重启时提供高可用的能力\",{\"1\":{\"695\":1}}],[\"在rabbitmq中\",{\"1\":{\"689\":1}}],[\"在队列索引中建立消息索引\",{\"1\":{\"687\":1}}],[\"在许多情况下\",{\"1\":{\"675\":1}}],[\"在镜像队列的情况下\",{\"1\":{\"668\":1}}],[\"在内存中恢复所有分级存储的文件句柄\",{\"1\":{\"1395\":1}}],[\"在内存中重建\",{\"1\":{\"1395\":1}}],[\"在内存中移除\",{\"1\":{\"1277\":1}}],[\"在内存中时间大于阈值\",{\"1\":{\"1277\":1}}],[\"在内存中停留太久没有被匹配\",{\"1\":{\"1261\":1}}],[\"在内存中\",{\"1\":{\"1191\":1}}],[\"在内存中异步投递\",{\"1\":{\"933\":1}}],[\"在内存中也会保留一份备份\",{\"1\":{\"681\":1}}],[\"在内存中模拟一个字节流输出\",{\"1\":{\"54\":1}}],[\"在内存中模拟一个字节流输入\",{\"1\":{\"53\":1}}],[\"在内部数据库的路由表中\",{\"1\":{\"668\":1}}],[\"在事务机制中\",{\"1\":{\"663\":1}}],[\"在之前的\",{\"1\":{\"1300\":1}}],[\"在之前的命令完成后执行\",{\"1\":{\"224\":1}}],[\"在之后的版本中镜像队列将被移除\",{\"1\":{\"648\":1}}],[\"在下面的详细设计中\",{\"1\":{\"1507\":1}}],[\"在下一次重平衡时尝试加锁\",{\"1\":{\"1224\":1}}],[\"在下游节点配置\",{\"1\":{\"636\":2}}],[\"在下图中\",{\"1\":{\"622\":1}}],[\"在两个\",{\"1\":{\"635\":1}}],[\"在两个目标\",{\"1\":{\"411\":1}}],[\"在将队列中的消息存入磁盘的过程中引起服务器\",{\"1\":{\"622\":1}}],[\"在管理\",{\"1\":{\"622\":1}}],[\"在初始化时\",{\"1\":{\"619\":1}}],[\"在1秒之内\",{\"1\":{\"614\":1}}],[\"在脚本头部添加\",{\"1\":{\"591\":1}}],[\"在属性名后面加一个问号\",{\"1\":{\"551\":1}}],[\"在极限\",{\"1\":{\"485\":1}}],[\"在非输出本我个人是吃全能合剂来增加生存能力\",{\"1\":{\"485\":1}}],[\"在聚怪时使用它\",{\"1\":{\"483\":1}}],[\"在不加锁的情况下判断\",{\"1\":{\"1495\":1}}],[\"在不同\",{\"1\":{\"1097\":1}}],[\"在不同情况下分别提供主要属性和次要属性\",{\"1\":{\"483\":1}}],[\"在不下线的情况下将数据从一个集群同步到另一个集群\",{\"1\":{\"631\":1}}],[\"在不需要指定\",{\"1\":{\"29\":1}}],[\"在虚空涌动时强奶\",{\"1\":{\"474\":1}}],[\"在虚空释能时开个减\",{\"1\":{\"439\":1}}],[\"在暗影飓风时用狂奔怒吼帮助落位\",{\"1\":{\"474\":1}}],[\"在暗黑法球爆炸的时候注意奶中深渊轰击的人\",{\"1\":{\"448\":1}}],[\"在暮光打击时开个减\",{\"1\":{\"473\":1}}],[\"在暮光打击时用治疗手牌\",{\"1\":{\"473\":1}}],[\"在命令咆哮前变熊\",{\"1\":{\"471\":1}}],[\"在激流破奔前开减伤\",{\"1\":{\"466\":1}}],[\"在释放前把队伍的血刷满\",{\"1\":{\"466\":1}}],[\"在炽烈弹射前进行\",{\"1\":{\"465\":1}}],[\"在关键时刻用狂奔怒吼帮助队友落位\",{\"1\":{\"459\":1}}],[\"在酸蚀排放\",{\"1\":{\"453\":1}}],[\"在猜谜游戏的时候使用个减\",{\"1\":{\"452\":1}}],[\"在紧急的时候使用\",{\"1\":{\"451\":1}}],[\"在晦影腐朽\",{\"1\":{\"448\":1}}],[\"在侵蚀喷涌\",{\"1\":{\"447\":1}}],[\"在黑曜光束前尽量奶满\",{\"1\":{\"445\":1}}],[\"在燃烧之影前尽量多铺点\",{\"1\":{\"445\":1}}],[\"在危险的时候用就行\",{\"1\":{\"445\":1}}],[\"在放水前进行预铺\",{\"1\":{\"441\":1}}],[\"在出球的时候会有一波\",{\"1\":{\"439\":1}}],[\"在加固壳壁前再吃一个球\",{\"1\":{\"439\":1}}],[\"在大多数情况下\",{\"1\":{\"662\":1}}],[\"在大量读条小怪聚怪开始读条的时候可以就交减伤\",{\"1\":{\"492\":1}}],[\"在大米下的属性优先级如下\",{\"1\":{\"476\":1}}],[\"在大米的环境下\",{\"1\":{\"401\":1}}],[\"在大半条血吃尖刺\",{\"1\":{\"434\":1}}],[\"在尖刺\",{\"1\":{\"434\":1}}],[\"在霜凝匕首前就站到近战位\",{\"1\":{\"432\":1}}],[\"在疑之影点名的时候分散站位\",{\"1\":{\"431\":1}}],[\"在抓握之血的时候关注你的化生\",{\"1\":{\"427\":1}}],[\"在血少的紧急情况时使用甘霖\",{\"1\":{\"425\":1}}],[\"在树皮术和铁皮\",{\"1\":{\"425\":1}}],[\"在树皮术期间\",{\"1\":{\"407\":1}}],[\"在超过一定阈值后会按照属性值所在的区间进行衰减\",{\"1\":{\"421\":1}}],[\"在衰减阈值前\",{\"1\":{\"421\":1}}],[\"在野性之心时\",{\"1\":{\"417\":1}}],[\"在野性成长之后使用迅捷治愈\",{\"1\":{\"411\":1}}],[\"在车队配合很好的情况下\",{\"1\":{\"416\":1}}],[\"在高层丰饶下的愈合也很省蓝\",{\"1\":{\"492\":1}}],[\"在高层\",{\"1\":{\"431\":1}}],[\"在高额\",{\"1\":{\"416\":1,\"492\":1}}],[\"在高并发场景下会导致大量线程创建和销毁\",{\"1\":{\"114\":1}}],[\"在自己身上随便放点\",{\"1\":{\"415\":1}}],[\"在塞纳里奥结界持续的时间内他几乎是不会被持续性伤害打死的\",{\"1\":{\"413\":1}}],[\"在猫形态下输出\",{\"1\":{\"412\":1}}],[\"在猫形态下攻击\",{\"1\":{\"412\":1}}],[\"在持续时间小于\",{\"1\":{\"411\":1}}],[\"在小队移动的时候移动百花齐放的位置\",{\"1\":{\"411\":1}}],[\"在集群消费模式下\",{\"1\":{\"1096\":1}}],[\"在集中站位的地方保持百花齐放\",{\"1\":{\"411\":1}}],[\"在集合石环境下我的体验是丰饶会更好\",{\"1\":{\"403\":1}}],[\"在你切换到熊形态时短时间内提升生命值上限\",{\"1\":{\"406\":1}}],[\"在变为熊形态之后的\",{\"1\":{\"406\":1}}],[\"在仙林\",{\"1\":{\"403\":1}}],[\"在一台真实的mq上查看网络和磁盘\",{\"1\":{\"879\":1}}],[\"在一次删除过程中\",{\"1\":{\"870\":1}}],[\"在一个索引文件写满后\",{\"1\":{\"1411\":1}}],[\"在一个索引文件写满后调用\",{\"1\":{\"796\":1}}],[\"在一个进程中可以有多个\",{\"1\":{\"1235\":1}}],[\"在一个文件写满后调用\",{\"1\":{\"796\":1}}],[\"在一个独立函数调用中\",{\"1\":{\"317\":1}}],[\"在一条语句中\",{\"1\":{\"592\":1}}],[\"在一些可靠性要求非常高的场景下\",{\"1\":{\"1027\":1}}],[\"在一些类型运算中\",{\"1\":{\"504\":1}}],[\"在一些治疗缺口很大的本\",{\"1\":{\"403\":1}}],[\"在哈希环中已经存在的虚拟节点数量\",{\"1\":{\"396\":1}}],[\"在哈希环中为每个物理节点添加\",{\"1\":{\"396\":2}}],[\"在哈希环上顺时针最近的物理节点\",{\"1\":{\"396\":1}}],[\"在哈希环上查找下一个距离它最近的节点\",{\"1\":{\"387\":1}}],[\"在上面的\",{\"1\":{\"1453\":1}}],[\"在上述逻辑的基础上\",{\"1\":{\"1207\":1}}],[\"在上述概念之外\",{\"1\":{\"135\":1}}],[\"在上下游集群的队列都可以收到消息\",{\"1\":{\"639\":2}}],[\"在上游集群向\",{\"1\":{\"639\":2}}],[\"在上例中\",{\"1\":{\"520\":1}}],[\"在上图中\",{\"1\":{\"388\":1}}],[\"在访问这个系统时\",{\"1\":{\"384\":1}}],[\"在producer端设置消息为定时消息\",{\"1\":{\"835\":1}}],[\"在processortracker中判断是last\",{\"1\":{\"378\":1}}],[\"在pullmessageprocessor的executerequestwhenwakeup\",{\"1\":{\"820\":1}}],[\"在powerscheduleservice\",{\"1\":{\"379\":1}}],[\"在简单单机场景下就是开启多线程来同时处理一个大任务\",{\"1\":{\"371\":1}}],[\"在分级存储相关的\",{\"1\":{\"1419\":1}}],[\"在分级存储索引文件的\",{\"1\":{\"1417\":1}}],[\"在分级存储索引项刚开始构建时\",{\"1\":{\"1411\":1}}],[\"在分级存储的情况下\",{\"1\":{\"1390\":1}}],[\"在分析如何优化之前需要学习一些前置指示\",{\"1\":{\"723\":1}}],[\"在分布式系统\",{\"1\":{\"384\":1}}],[\"在分布式场景下需要基于db锁进行任务执行\",{\"1\":{\"371\":1}}],[\"在分区数达到450+时\",{\"1\":{\"285\":1}}],[\"在分区数量达到\",{\"1\":{\"285\":1}}],[\"在浏览器处理起来就十分容易\",{\"1\":{\"368\":1}}],[\"在node环境下\",{\"1\":{\"360\":1}}],[\"在normal模式下\",{\"1\":{\"145\":1}}],[\"在async\",{\"1\":{\"354\":1}}],[\"在查找变量时从自身函数定义开始\",{\"1\":{\"310\":1}}],[\"在实践中这两个值往往会设置成相同的\",{\"1\":{\"1238\":1}}],[\"在实际使用中\",{\"1\":{\"1100\":1}}],[\"在实际使用中通常会采用多个消费者共同消费同样的\",{\"1\":{\"1089\":1}}],[\"在实际情况下\",{\"1\":{\"388\":1}}],[\"在实现\",{\"1\":{\"925\":1}}],[\"在实现主从\",{\"1\":{\"131\":1}}],[\"在实验中我们还会统计在不同分区个数下消息收发的吞吐量\",{\"1\":{\"285\":1}}],[\"在已有的生产环境中\",{\"1\":{\"276\":1}}],[\"在要调用的方法上选择复制static\",{\"1\":{\"273\":1}}],[\"在爱立信内部用于构建容错式系统\",{\"1\":{\"262\":1}}],[\"在活动系统上运行它会增加\",{\"1\":{\"255\":1}}],[\"在运行于两台物理隔离计算机上的两个不同\",{\"1\":{\"238\":1}}],[\"在运行于同一台计算机上的两个不同\",{\"1\":{\"238\":1}}],[\"在运行期创建某个interface的实例\",{\"1\":{\"41\":1}}],[\"在运行期\",{\"1\":{\"28\":1}}],[\"在常规非分布式会话里编写和测试程序\",{\"1\":{\"238\":1}}],[\"在执行中抛出了异常错误\",{\"1\":{\"194\":1}}],[\"在中间插入\",{\"1\":{\"184\":1}}],[\"在打印列表时也要选择正确的格式惯例\",{\"1\":{\"178\":1}}],[\"在erlang里\",{\"1\":{\"172\":1,\"173\":1}}],[\"在visual模式下选择多行\",{\"1\":{\"161\":1}}],[\"在vimrc设置autoindent\",{\"1\":{\"156\":1}}],[\"在普通模式下录制到register寄存器\",{\"1\":{\"160\":1}}],[\"在复制前加上\",{\"1\":{\"158\":1}}],[\"在新标签页中打开\",{\"1\":{\"154\":1}}],[\"在段落间移动\",{\"1\":{\"145\":1}}],[\"在句子间移动\",{\"1\":{\"145\":1}}],[\"在主从同步复制的场景下\",{\"1\":{\"735\":1}}],[\"在主从复制逻辑中被用到\",{\"1\":{\"726\":1}}],[\"在主从\",{\"1\":{\"132\":1}}],[\"在这之前需要明确一些概念\",{\"1\":{\"1403\":1}}],[\"在这之前还上报心跳让\",{\"1\":{\"1128\":1}}],[\"在这之后\",{\"1\":{\"1403\":1}}],[\"在这显得有些多余\",{\"1\":{\"1116\":1}}],[\"在这篇文章中我将解析消息发送流程中生产者和\",{\"1\":{\"1024\":1}}],[\"在这期间的任何时刻\",{\"1\":{\"674\":1}}],[\"在这期间\",{\"1\":{\"674\":1}}],[\"在这样的背景下\",{\"1\":{\"276\":1,\"277\":1}}],[\"在这种情况下可以配置一致性哈希交换器基于消息头进行路由\",{\"1\":{\"714\":1}}],[\"在这种情况下\",{\"1\":{\"193\":1,\"627\":1}}],[\"在这里被调用只是为了创建队列的文件容器和持久化队列的元数据\",{\"1\":{\"1388\":1}}],[\"在这里就用来判断这个消息是否可能匹配某个消费组的过滤规则\",{\"1\":{\"1315\":1}}],[\"在这里\",{\"1\":{\"626\":1}}],[\"在这里先不设置感兴趣的事件\",{\"1\":{\"124\":1}}],[\"在这里是客户端连接事件\",{\"1\":{\"122\":1}}],[\"在这个\",{\"1\":{\"118\":1}}],[\"在单线程\",{\"1\":{\"120\":1,\"121\":1,\"127\":1}}],[\"在介绍\",{\"1\":{\"118\":1}}],[\"在每次拉取消息时\",{\"1\":{\"1136\":1}}],[\"在每次调用测试方法之前执行\",{\"1\":{\"9\":1}}],[\"在每条消息中有一个字段来存储消息的\",{\"1\":{\"935\":1}}],[\"在每个\",{\"1\":{\"1288\":1,\"1297\":1}}],[\"在每个节点上都有一个副本是不必要的\",{\"1\":{\"662\":1}}],[\"在每个线程中串行执行上述处理流程\",{\"1\":{\"111\":1}}],[\"在传统服务端设计中\",{\"1\":{\"111\":1}}],[\"在hibernate中\",{\"1\":{\"89\":1}}],[\"在目标类被装载到jvm时\",{\"1\":{\"85\":1}}],[\"在编译时\",{\"1\":{\"85\":1}}],[\"在sql语法中\",{\"1\":{\"1308\":1}}],[\"在server初始化时\",{\"1\":{\"374\":1}}],[\"在strict模式下运行的javascript代码\",{\"1\":{\"296\":1}}],[\"在static修饰符后面加一个<t>\",{\"1\":{\"47\":1}}],[\"在spring的ioc容器中\",{\"1\":{\"81\":1}}],[\"在javascript代码的第一行写上\",{\"1\":{\"296\":1}}],[\"在java平台上\",{\"1\":{\"85\":1}}],[\"在java中使用udp编程\",{\"1\":{\"71\":1}}],[\"在javac命令行中用参数\",{\"1\":{\"25\":1}}],[\"在jvm退出时自动删除该文件\",{\"1\":{\"52\":1}}],[\"在需要转型的时候\",{\"1\":{\"48\":1}}],[\"在代码中\",{\"1\":{\"20\":1}}],[\"在\",{\"0\":{\"243\":1,\"1520\":1},\"1\":{\"4\":1,\"8\":2,\"10\":1,\"81\":1,\"108\":1,\"112\":1,\"118\":2,\"122\":2,\"123\":1,\"124\":1,\"180\":1,\"230\":2,\"391\":1,\"395\":1,\"398\":1,\"401\":1,\"405\":1,\"417\":2,\"421\":1,\"454\":1,\"475\":1,\"492\":1,\"592\":1,\"613\":1,\"614\":1,\"623\":1,\"648\":2,\"668\":2,\"672\":2,\"673\":1,\"675\":1,\"692\":1,\"707\":1,\"711\":1,\"724\":1,\"741\":1,\"765\":1,\"773\":1,\"787\":1,\"797\":1,\"803\":1,\"827\":1,\"836\":1,\"840\":2,\"850\":3,\"853\":1,\"866\":1,\"883\":1,\"886\":3,\"890\":1,\"894\":1,\"903\":1,\"906\":1,\"908\":1,\"925\":1,\"932\":2,\"934\":1,\"942\":1,\"947\":1,\"949\":1,\"960\":2,\"967\":1,\"978\":1,\"988\":1,\"994\":1,\"1003\":1,\"1004\":1,\"1005\":1,\"1014\":2,\"1035\":2,\"1039\":1,\"1072\":1,\"1081\":1,\"1094\":1,\"1103\":1,\"1104\":1,\"1165\":1,\"1169\":1,\"1191\":1,\"1209\":1,\"1235\":1,\"1251\":1,\"1271\":1,\"1284\":1,\"1290\":3,\"1300\":2,\"1307\":1,\"1314\":1,\"1318\":1,\"1319\":1,\"1321\":1,\"1338\":2,\"1339\":1,\"1346\":1,\"1362\":1,\"1363\":1,\"1395\":1,\"1398\":1,\"1403\":1,\"1420\":2,\"1439\":1,\"1475\":2,\"1506\":2,\"1507\":1,\"1508\":1,\"1514\":1,\"1517\":1}}],[\"每过心跳超时\",{\"1\":{\"1479\":1}}],[\"每分钟扫描和清理过期文件\",{\"1\":{\"1421\":1}}],[\"每分钟都可以星涌术触发野心\",{\"1\":{\"403\":1}}],[\"每项都是一个槽位\",{\"1\":{\"1351\":1}}],[\"每两个步骤之间都使用了生产\",{\"1\":{\"1348\":1}}],[\"每页包装可消费消息数量\",{\"1\":{\"1194\":1}}],[\"每批次消费消息数量\",{\"1\":{\"1194\":1}}],[\"每端都有一个消费进度管理器\",{\"1\":{\"1183\":1}}],[\"每等待\",{\"1\":{\"1136\":1}}],[\"每等待一段时间就调用\",{\"1\":{\"815\":1}}],[\"每等待一段时间\",{\"1\":{\"810\":1}}],[\"每60s调整线程池\",{\"1\":{\"1048\":1}}],[\"每5s把消费者的offset持久化\",{\"1\":{\"1048\":1}}],[\"每5s判断一次消息是否到达\",{\"1\":{\"824\":1}}],[\"每30s向broker端发送心跳\",{\"1\":{\"1048\":1}}],[\"每小时加载下一个小时要投递的消息索引就好了\",{\"1\":{\"931\":1}}],[\"每执行一次删除方法减少一次\",{\"1\":{\"870\":1}}],[\"每1s判断一次消息是否到达\",{\"1\":{\"824\":1}}],[\"每创建一个新文件\",{\"1\":{\"793\":1}}],[\"每隔分区内的消息遵循先生产先消费的顺序\",{\"1\":{\"1028\":1}}],[\"每隔一定的时间\",{\"1\":{\"804\":1}}],[\"每隔一分钟探测是否需要加载新的worker\",{\"1\":{\"378\":1}}],[\"每隔1s检查一次\",{\"1\":{\"768\":1}}],[\"每隔\",{\"1\":{\"752\":1,\"769\":1,\"867\":1,\"868\":1,\"945\":3,\"952\":1,\"954\":1,\"956\":1,\"1039\":1,\"1098\":1,\"1140\":1,\"1427\":1}}],[\"每一格中的头尾消息索引\",{\"1\":{\"1362\":1}}],[\"每一次移动称为一个\",{\"1\":{\"931\":1}}],[\"每一个投票轮次中\",{\"1\":{\"1514\":1}}],[\"每一个\",{\"1\":{\"746\":1,\"877\":1,\"1142\":1}}],[\"每一个属性\",{\"1\":{\"742\":1}}],[\"每一轮测试称为一个迭代\",{\"1\":{\"4\":1}}],[\"每条消息都会被大量的客户端重复处理\",{\"1\":{\"1090\":1}}],[\"每条消息都会分别被存储\",{\"1\":{\"701\":1}}],[\"每条消息都需要被相同订阅逻辑的多台机器处理\",{\"1\":{\"1090\":1}}],[\"每条消息会被调用\",{\"1\":{\"906\":1}}],[\"每条消息的写入放大是\",{\"1\":{\"701\":1}}],[\"每条消息还会有额外的确认消息在集群间进行发送\",{\"1\":{\"668\":1}}],[\"每发一条消息就会将自己的信用值减一\",{\"1\":{\"624\":1}}],[\"每那么痛\",{\"1\":{\"431\":1}}],[\"每出一个地板就往场外\",{\"1\":{\"425\":1}}],[\"每波小怪都是灭点\",{\"1\":{\"422\":1}}],[\"每\",{\"1\":{\"421\":2,\"431\":1,\"446\":1,\"484\":1,\"955\":1,\"961\":2,\"1030\":1,\"1103\":1,\"1104\":1,\"1182\":1,\"1183\":2,\"1191\":2,\"1201\":1,\"1358\":1,\"1388\":1,\"1394\":1,\"1403\":2,\"1417\":1,\"1435\":1,\"1453\":1}}],[\"每秒追加日志速率\",{\"1\":{\"1519\":1}}],[\"每秒转发到\",{\"1\":{\"1519\":1}}],[\"每秒会向\",{\"1\":{\"1510\":1}}],[\"每秒可以处理数十万的消息\",{\"1\":{\"874\":1}}],[\"每秒都会在脚下绽开鲜花\",{\"1\":{\"407\":1}}],[\"每秒执行次数\",{\"1\":{\"9\":1}}],[\"每周打个海山或\",{\"1\":{\"399\":1}}],[\"每当新的分级存储文件句柄\",{\"1\":{\"1395\":1}}],[\"每当有新的\",{\"1\":{\"1395\":1}}],[\"每当配置更新一次\",{\"1\":{\"952\":1}}],[\"每当虚空碎片\",{\"1\":{\"439\":1}}],[\"每当你召唤一个林莽卫士\",{\"1\":{\"401\":1}}],[\"每当调用\",{\"1\":{\"207\":1}}],[\"每当收到一个客户端连接\",{\"1\":{\"120\":1}}],[\"每加载一种class\",{\"1\":{\"36\":1}}],[\"每次执行完状态维护方法后\",{\"1\":{\"1483\":1}}],[\"每次执行测试方法的超时时间为\",{\"1\":{\"11\":1}}],[\"每次预读消息量类似拥塞窗口采用加法增\",{\"1\":{\"1404\":1}}],[\"每次预热耗时\",{\"1\":{\"11\":1}}],[\"每次上传的数据量是有一个阈值的\",{\"1\":{\"1403\":1}}],[\"每次写入只会写入文件列表最后一个处于\",{\"1\":{\"1394\":1}}],[\"每次写入较大数据长度时\",{\"1\":{\"917\":1}}],[\"每次运算都需要传入这个数组运算函数\",{\"1\":{\"1323\":1}}],[\"每次从处理队列获取的一批消息数量\",{\"1\":{\"1230\":1}}],[\"每次拉取到的消息\",{\"1\":{\"1194\":1}}],[\"每次拉取完一次后将拉取请求重新放入拉取服务的等待队列\",{\"1\":{\"1137\":1}}],[\"每次重试消费失败后延迟等级会增加\",{\"1\":{\"1180\":1}}],[\"每次重新消费的时间间隔将会逐渐增加\",{\"1\":{\"1180\":1}}],[\"每次更新\",{\"1\":{\"967\":1}}],[\"每次扫描\",{\"1\":{\"954\":1}}],[\"每次收到心跳包时会替换该信息\",{\"1\":{\"949\":1}}],[\"每次投递时查询该集来判断是否要投递该消息\",{\"1\":{\"935\":1}}],[\"每次启动一个定时任务\",{\"1\":{\"932\":1}}],[\"每次发消息时\",{\"1\":{\"904\":1}}],[\"每次发送消息都会调用到这个方法\",{\"1\":{\"896\":1}}],[\"每次调用都会创建\",{\"1\":{\"900\":1}}],[\"每次插入新的消息\",{\"1\":{\"787\":1}}],[\"每次加解锁都只有\",{\"1\":{\"725\":1}}],[\"每次放水都可以变熊来减伤\",{\"1\":{\"471\":1}}],[\"每次打这个本我都能有\",{\"1\":{\"455\":1}}],[\"每次黑暗脉动的时候用万灵抬血\",{\"1\":{\"433\":1}}],[\"每次都会带有眩晕效果\",{\"1\":{\"428\":1}}],[\"每次仔细看都会有新的收获\",{\"1\":{\"399\":1}}],[\"每次由server去调度代价太大\",{\"1\":{\"374\":1}}],[\"每次迭代就自动回调该函数\",{\"1\":{\"303\":1}}],[\"每次迭代前后\",{\"1\":{\"4\":1}}],[\"每次代码变更都要重启一次项目\",{\"1\":{\"270\":1}}],[\"每次读取一个字符\",{\"1\":{\"125\":1}}],[\"每次需要操作数据库的时候\",{\"1\":{\"89\":1}}],[\"每次测试执行耗时\",{\"1\":{\"11\":1}}],[\"每次\",{\"1\":{\"9\":2,\"11\":2,\"433\":1,\"1273\":1}}],[\"每个投票轮次中\",{\"1\":{\"1514\":1}}],[\"每个状态会向\",{\"1\":{\"1510\":1}}],[\"每个槽位表示一个对应的投递时间窗\",{\"1\":{\"1346\":1}}],[\"每个拉取请求对应拉取一个消息队列的消息\",{\"1\":{\"1158\":1}}],[\"每个消息队列都可能会有一个锁\",{\"1\":{\"1212\":1}}],[\"每个消息队列会对应创建一个处理队列\",{\"1\":{\"1152\":1}}],[\"每个消费任务都持续消费一个队列\",{\"1\":{\"1217\":1}}],[\"每个消费任务消费\",{\"1\":{\"1104\":1}}],[\"每个消费组的消费应该隔离\",{\"1\":{\"1212\":1}}],[\"每个消费组中的消费者都收到全部的\",{\"1\":{\"1090\":1}}],[\"每个消费线程也最大程度上被使用\",{\"1\":{\"1206\":1}}],[\"每个消费请求将消费一批消息\",{\"1\":{\"1179\":1}}],[\"每个消费者分配\",{\"1\":{\"1267\":1}}],[\"每个消费者能消费所有队列\",{\"1\":{\"1267\":1}}],[\"每个消费者被负载了\",{\"1\":{\"1255\":1}}],[\"每个消费者都会有一个消费进度管理器\",{\"1\":{\"1191\":1}}],[\"每个消费者都要消费全量消息\",{\"1\":{\"1181\":1}}],[\"每个消费者都有一个消费线程池\",{\"1\":{\"1104\":1,\"1217\":1}}],[\"每个消费者持有一个重平衡实现\",{\"1\":{\"1129\":1}}],[\"每个消费者实例会收到全量的消息\",{\"1\":{\"1090\":1}}],[\"每个客户端进程一般只有一个\",{\"1\":{\"1129\":1}}],[\"每个客户端进程一般只有一个这玩意\",{\"1\":{\"1109\":1,\"1118\":1}}],[\"每个客户端连接都会创建一个线程\",{\"1\":{\"114\":1}}],[\"每个步骤都会用一篇文章来讲解\",{\"1\":{\"1086\":1}}],[\"每个角色有相应的权限集\",{\"1\":{\"976\":1}}],[\"每个指令都不一样\",{\"1\":{\"890\":1}}],[\"每个线程的消费任务是\",{\"1\":{\"1206\":1}}],[\"每个线程执行\",{\"1\":{\"858\":1,\"1055\":1}}],[\"每个线程中先执行预热\",{\"1\":{\"4\":1}}],[\"每个该类对应一个延迟等级的\",{\"1\":{\"841\":1}}],[\"每个延迟等级在\",{\"1\":{\"858\":1}}],[\"每个延迟等级都分配一个线程\",{\"1\":{\"855\":1}}],[\"每个延迟等级都有一个\",{\"1\":{\"834\":1}}],[\"每个延迟等级扫描的逻辑\",{\"1\":{\"840\":1}}],[\"每个类型的请求码对应一个业务处理器\",{\"1\":{\"1055\":1}}],[\"每个类关于定时消息的具体逻辑\",{\"0\":{\"838\":1}}],[\"每个类的具体逻辑\",{\"0\":{\"813\":1}}],[\"每个hash槽的值是最新写入的索引文件的逻辑下标\",{\"1\":{\"797\":1}}],[\"每个索引项包含如下信息\",{\"1\":{\"787\":1}}],[\"每个索引的长度也是固定的\",{\"1\":{\"787\":1}}],[\"每个索引的大小也更大\",{\"1\":{\"773\":1}}],[\"每个索引文件被设计为定长的\",{\"1\":{\"787\":1}}],[\"每个索引文件以其创建的时间命名\",{\"1\":{\"787\":1}}],[\"每个数组元素是一个索引项\",{\"1\":{\"755\":1}}],[\"每个文件也不宜太大\",{\"1\":{\"1319\":1}}],[\"每个文件删除间隔\",{\"1\":{\"870\":1}}],[\"每个文件有一个过期时间\",{\"1\":{\"866\":1}}],[\"每个文件的大小是固定的\",{\"1\":{\"780\":1}}],[\"每个文件大小固定\",{\"1\":{\"749\":1}}],[\"每个文件由大小和格式相同的索引项构成\",{\"1\":{\"746\":1}}],[\"每个副本都在不通的\",{\"1\":{\"695\":1}}],[\"每个仲裁队列都有多个副本\",{\"1\":{\"695\":1}}],[\"每个队列代表一个延迟等级\",{\"1\":{\"1342\":1}}],[\"每个队列也会被分配给多个消费者\",{\"1\":{\"1267\":1}}],[\"每个队列被\",{\"1\":{\"1255\":1}}],[\"每个队列就会被多个消费者消费\",{\"1\":{\"1255\":1}}],[\"每个队列都可以被一个消费者消费\",{\"1\":{\"1203\":1}}],[\"每个队列只会新建一个\",{\"1\":{\"1137\":1}}],[\"每个队列可能分布在不同\",{\"1\":{\"1029\":1}}],[\"每个队列可能占据哈希环上的一个或多个位置点\",{\"1\":{\"716\":1}}],[\"每个队列元素是一个消息的索引\",{\"1\":{\"836\":1}}],[\"每个队列在哈希环上对应多个虚拟节点\",{\"1\":{\"716\":1}}],[\"每个队列单独存储\",{\"1\":{\"687\":1}}],[\"每个队列仍只存在于一个节点\",{\"1\":{\"648\":1}}],[\"每个镜像队列都包含一个主节点\",{\"1\":{\"649\":1}}],[\"每个rabbitmq\",{\"1\":{\"621\":1}}],[\"每个激活的觅血缠藤使你的技能造成的上盖提高\",{\"1\":{\"401\":1}}],[\"每个激活的共生绽华使你的法术的治疗效果提高\",{\"1\":{\"401\":1}}],[\"每个节点会占用\",{\"1\":{\"1080\":1}}],[\"每个节点存储\",{\"1\":{\"700\":1}}],[\"每个节点可以承载多个主队列和从队列\",{\"1\":{\"693\":1}}],[\"每个节点都会监控位于自己左右两边的节点\",{\"1\":{\"673\":1}}],[\"每个节点\",{\"1\":{\"388\":1,\"716\":1}}],[\"每个节点在哈希环中的位置也是由\",{\"1\":{\"388\":1}}],[\"每个任务在每个执行器节点都会生成若干个\",{\"1\":{\"372\":1}}],[\"每个任务在每个执行器节点\",{\"1\":{\"372\":1}}],[\"每个任务每次只会产生一个\",{\"1\":{\"372\":1}}],[\"每个任务执行一个非阻塞操作\",{\"1\":{\"116\":1}}],[\"每个创建对象都有原型链\",{\"1\":{\"340\":1}}],[\"每个进程都保存为一个\",{\"1\":{\"623\":1}}],[\"每个进程都有自己的进程邮箱\",{\"1\":{\"611\":1}}],[\"每个进程都有它自己的内存\",{\"1\":{\"227\":1}}],[\"每个进程都带有一个进程邮箱\",{\"1\":{\"229\":1}}],[\"每个erlang进程都有一个被称为进程字典\",{\"1\":{\"217\":1}}],[\"每个窗口可以继续被无限分割\",{\"1\":{\"153\":1}}],[\"每个窗口也可以打开不同缓冲区\",{\"1\":{\"153\":1}}],[\"每个\",{\"1\":{\"135\":1,\"687\":1,\"755\":1,\"836\":2,\"867\":1,\"881\":1,\"882\":1,\"931\":1,\"941\":1,\"1094\":1,\"1168\":1,\"1383\":3,\"1393\":1,\"1508\":1}}],[\"每个版本的jvm\",{\"1\":{\"25\":1}}],[\"每个迭代中会根据基准测试的模式\",{\"1\":{\"4\":1}}],[\"如上面所述\",{\"1\":{\"1325\":1}}],[\"如上图粉色部分所示\",{\"1\":{\"1213\":1}}],[\"如上图所示\",{\"1\":{\"127\":1,\"755\":1,\"1353\":1,\"1402\":1}}],[\"如消费者异常退出\",{\"1\":{\"1212\":1}}],[\"如消息轨迹的处理逻辑就在这里进行处理\",{\"1\":{\"1042\":1}}],[\"如刷新应用中的缓存\",{\"1\":{\"1090\":1}}],[\"如发生变化\",{\"1\":{\"996\":1}}],[\"如发送消息\",{\"1\":{\"890\":1}}],[\"如此一来\",{\"1\":{\"976\":1}}],[\"如定时任务调度服务\",{\"1\":{\"923\":1}}],[\"如定时任务触发\",{\"1\":{\"921\":1,\"1337\":1}}],[\"如没有real\",{\"1\":{\"845\":1}}],[\"如1ms\",{\"1\":{\"804\":1}}],[\"如找到消息\",{\"1\":{\"762\":1}}],[\"如交换器间绑定\",{\"1\":{\"714\":1}}],[\"如有必要\",{\"1\":{\"712\":1}}],[\"如今达到了这个小目标也有信心把这个指南发出来了\",{\"1\":{\"399\":1}}],[\"如下所示\",{\"1\":{\"944\":1}}],[\"如下图\",{\"1\":{\"724\":1}}],[\"如下图所示\",{\"1\":{\"388\":1,\"825\":1,\"1090\":1,\"1342\":1,\"1393\":1}}],[\"如下代码\",{\"1\":{\"378\":1}}],[\"如图所示\",{\"1\":{\"387\":1,\"929\":1,\"1030\":1}}],[\"如图1所示\",{\"1\":{\"280\":1}}],[\"如用于探测是否存活的ping请求\",{\"1\":{\"374\":1}}],[\"如使用广播执行模式清理集群日志\",{\"1\":{\"371\":1}}],[\"如每天凌晨全量同步数据\",{\"1\":{\"371\":1}}],[\"如apache\",{\"1\":{\"286\":1}}],[\"如是否符合\",{\"1\":{\"283\":1}}],[\"如pub\",{\"1\":{\"278\":1}}],[\"如调试某个有问题的宏时\",{\"1\":{\"208\":1}}],[\"如一个tab管理所有python文件\",{\"1\":{\"154\":1}}],[\"如何使用\",{\"0\":{\"1246\":1}}],[\"如何将轨迹数据发送至存储\",{\"1\":{\"1010\":1}}],[\"如何存储轨迹数据\",{\"1\":{\"1010\":1}}],[\"如何采集轨迹数据\",{\"1\":{\"1010\":1}}],[\"如何在不重启的情况下感知\",{\"1\":{\"941\":1}}],[\"如何在mq中实现支持任意延迟的消息\",{\"1\":{\"938\":1}}],[\"如何知道要从哪个\",{\"1\":{\"941\":1}}],[\"如何解决某一时刻投递消息量太大导致的内存问题\",{\"1\":{\"932\":1}}],[\"如何解决排序问题\",{\"1\":{\"925\":1}}],[\"如何处理索引的加载和投递的触发就成为需要深思熟虑的问题\",{\"1\":{\"930\":1}}],[\"如何实现高性能消息读写\",{\"0\":{\"873\":1},\"1\":{\"1538\":1}}],[\"如何保证能够立刻消费到\",{\"1\":{\"806\":1}}],[\"如何进行轮询\",{\"0\":{\"804\":1}}],[\"如何查询消息\",{\"0\":{\"782\":1}}],[\"如何查看内核中的权重是否生效\",{\"1\":{\"711\":1}}],[\"如何构建\",{\"0\":{\"781\":1}}],[\"如何停止信息接收\",{\"1\":{\"625\":1}}],[\"如何通过flow状态识别进程的性能瓶颈\",{\"1\":{\"622\":1}}],[\"如何识别性能瓶颈\",{\"0\":{\"622\":1}}],[\"如何与外部程序通信\",{\"0\":{\"241\":1}}],[\"如何对调用方法进行拦截\",{\"1\":{\"85\":1}}],[\"如何把切面织入到核心逻辑中\",{\"1\":{\"85\":1}}],[\"如何按依赖顺序正确销毁\",{\"1\":{\"81\":1}}],[\"如何工作\",{\"0\":{\"4\":1}}],[\"如\",{\"1\":{\"23\":1,\"393\":1,\"917\":1,\"924\":1,\"1290\":1}}],[\"如果距上次打印时间超过\",{\"1\":{\"1521\":1}}],[\"如果响应码为\",{\"1\":{\"1519\":1}}],[\"如果挂起的\",{\"1\":{\"1519\":1}}],[\"如果挂起请求日志序号小于水位线\",{\"1\":{\"1519\":1}}],[\"如果准备\",{\"1\":{\"1519\":1}}],[\"如果下一个等待的\",{\"1\":{\"1519\":1}}],[\"如果触发流控\",{\"1\":{\"1519\":1}}],[\"如果复制组内只有一个节点\",{\"1\":{\"1518\":1}}],[\"如果日志序号已经仲裁成功\",{\"1\":{\"1521\":1}}],[\"如果日志开始序号没有初始化\",{\"1\":{\"1517\":1}}],[\"如果日志中涉及字符串拼接等操作\",{\"1\":{\"722\":1}}],[\"如果待处理请求已满\",{\"1\":{\"1516\":1}}],[\"如果成功找到下一个\",{\"1\":{\"1511\":1}}],[\"如果成功则直接返回\",{\"1\":{\"1259\":1,\"1260\":1}}],[\"如果对端节点的投票轮次小于发起投票的轮次\",{\"1\":{\"1497\":1}}],[\"如果对某些参数不感兴趣\",{\"1\":{\"303\":1}}],[\"如果请求的轮次大于当前轮次\",{\"1\":{\"1500\":1}}],[\"如果请求的节点不是当前的\",{\"1\":{\"1500\":1}}],[\"如果请求的节点是当前的\",{\"1\":{\"1500\":2}}],[\"如果请求拉票节点的\",{\"1\":{\"1492\":3}}],[\"如果请求节点不是当前节点的\",{\"1\":{\"1489\":1}}],[\"如果请求节点是当前节点的\",{\"1\":{\"1489\":1}}],[\"如果请求到锁才开始拉取\",{\"1\":{\"1209\":1}}],[\"如果半数以上\",{\"1\":{\"1488\":1}}],[\"如果半消息发送失败或本地事务执行失败告诉服务端删除半消息\",{\"1\":{\"1459\":1}}],[\"如果半消息发送成功\",{\"1\":{\"1449\":1}}],[\"如果其他\",{\"1\":{\"1480\":1}}],[\"如果其他文件要使用模块的接口\",{\"1\":{\"591\":1}}],[\"如果收到的响应的轮次大于当前轮次\",{\"1\":{\"1479\":1}}],[\"如果回查成功则写入操作消息\",{\"1\":{\"1468\":1}}],[\"如果回查次数多会导致写放大\",{\"1\":{\"1453\":1}}],[\"如果事务半消息的存储时间大于等于本次回查开始时间\",{\"1\":{\"1468\":1}}],[\"如果事务半消息\",{\"1\":{\"1468\":1}}],[\"如果为\",{\"1\":{\"1450\":1,\"1519\":1}}],[\"如果为空\",{\"1\":{\"1170\":1,\"1511\":1}}],[\"如果为空表示上次发送成功\",{\"1\":{\"1052\":1}}],[\"如果本次仲裁没有日志被成功追加\",{\"1\":{\"1521\":1}}],[\"如果本次消费任务执行时长超过\",{\"1\":{\"1230\":1}}],[\"如果本地事务执行状态为\",{\"1\":{\"1451\":3}}],[\"如果本地事务执行结果未知\",{\"1\":{\"1446\":1}}],[\"如果本地事务无法马上执行完\",{\"1\":{\"1446\":1}}],[\"如果执行本地事务的操作直接返回\",{\"1\":{\"1442\":1}}],[\"如果执行过程中worker下线\",{\"1\":{\"375\":1}}],[\"如果执行过程没有抛出异常错误\",{\"1\":{\"194\":1}}],[\"如果缓冲区的所有内容都已刷盘到二级存储\",{\"1\":{\"1435\":1}}],[\"如果缓存中没有读到\",{\"1\":{\"1409\":1,\"1431\":1}}],[\"如果等待提交的消息数量超过阈值\",{\"1\":{\"1427\":2}}],[\"如果指定了扩展\",{\"1\":{\"1425\":1}}],[\"如果写满则将索引文件状态置为\",{\"1\":{\"1414\":1}}],[\"如果预读缓存中没有消息\",{\"1\":{\"1409\":1}}],[\"如果长度超过阈值\",{\"1\":{\"1408\":1,\"1432\":1}}],[\"如果长轮询被启用\",{\"1\":{\"906\":1}}],[\"如果达到则将本地存储中的这批消息提交到分级存储\",{\"1\":{\"1403\":1}}],[\"如果达到阈值\",{\"1\":{\"1388\":1}}],[\"如果仍然以本地存储的方式将所有队列的\",{\"1\":{\"1402\":1}}],[\"如果仍然消费失败\",{\"1\":{\"1180\":1}}],[\"如果定时时间小于当前写\",{\"1\":{\"1356\":1,\"1371\":1}}],[\"如果定时消息和普通消息存在一起\",{\"1\":{\"926\":1}}],[\"如果返回\",{\"1\":{\"1333\":1,\"1442\":1}}],[\"如果返回false\",{\"1\":{\"797\":1}}],[\"如果带有\",{\"1\":{\"1321\":1}}],[\"如果过滤的\",{\"1\":{\"1329\":1}}],[\"如果过滤匹配的\",{\"1\":{\"1319\":1}}],[\"如果过滤规则\",{\"1\":{\"1314\":1}}],[\"如果过滤模式为类过滤\",{\"1\":{\"1171\":1}}],[\"如果属性中有\",{\"1\":{\"1294\":1}}],[\"如果将\",{\"1\":{\"1290\":1}}],[\"如果前面拉取普通消息之后\",{\"1\":{\"1269\":1}}],[\"如果匹配成功则更新\",{\"1\":{\"1253\":1}}],[\"如果匹配则放行\",{\"1\":{\"991\":1,\"1000\":1}}],[\"如果匹配则直接放行\",{\"1\":{\"991\":1,\"1000\":1}}],[\"如果订阅关系不一致会造成消息丢失\",{\"1\":{\"1239\":1}}],[\"如果获取的这批消息不为空\",{\"1\":{\"1230\":1}}],[\"如果获取不到\",{\"1\":{\"897\":1}}],[\"如果处理队列没有被锁定\",{\"1\":{\"1228\":1}}],[\"如果处理队列已经被锁定\",{\"1\":{\"1228\":1}}],[\"如果之前没有被锁定过\",{\"1\":{\"1228\":1}}],[\"如果加锁失败则跳过\",{\"1\":{\"1224\":1}}],[\"如果重试次数超过\",{\"1\":{\"1198\":1}}],[\"如果重试队列数量为\",{\"1\":{\"1198\":1}}],[\"如果重试的消息仍发往同一个\",{\"1\":{\"1032\":1}}],[\"如果知道\",{\"1\":{\"1197\":1}}],[\"如果发起拉票请求节点的\",{\"1\":{\"1503\":1}}],[\"如果发起拉票节点的\",{\"1\":{\"1503\":1}}],[\"如果发送失败\",{\"1\":{\"1449\":1}}],[\"如果发生变化\",{\"1\":{\"1331\":1}}],[\"如果发回失败\",{\"1\":{\"1195\":1}}],[\"如果发现到投递时间的消息\",{\"1\":{\"836\":1}}],[\"如果丢弃则不处理结果\",{\"1\":{\"1195\":1}}],[\"如果丢弃\",{\"1\":{\"1195\":1}}],[\"如果到了下一次拉票请求的时间\",{\"1\":{\"1486\":1}}],[\"如果到提交时间阈值或者缓冲区满或者强制刷盘\",{\"1\":{\"1427\":1}}],[\"如果到期则用生产\",{\"1\":{\"1364\":1}}],[\"如果到期则投递\",{\"1\":{\"1188\":1}}],[\"如果到达则投递到它本该去的\",{\"1\":{\"925\":1}}],[\"如果到达\",{\"1\":{\"861\":1}}],[\"如果msgfoundlist为空\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"如果mappedfilequeue中的mappedfile列表被删除\",{\"1\":{\"765\":1}}],[\"如果commitlog可用且当前节点为主节点\",{\"1\":{\"1173\":1}}],[\"如果consumer请求达到了超时时间\",{\"1\":{\"825\":1}}],[\"如果允许从slave拉数据\",{\"1\":{\"1173\":1}}],[\"如果拉取请求没有指定队列\",{\"1\":{\"1269\":1}}],[\"如果拉取成功才执行下述操作\",{\"1\":{\"1165\":1}}],[\"如果拉取远程镜像\",{\"1\":{\"1075\":1}}],[\"如果找到对应的\",{\"1\":{\"1262\":1}}],[\"如果找到消息\",{\"1\":{\"1163\":1}}],[\"如果找到了\",{\"1\":{\"327\":1}}],[\"如果查不到则请求\",{\"1\":{\"1160\":1}}],[\"如果查询不到\",{\"1\":{\"1030\":1}}],[\"如果查询失败\",{\"1\":{\"861\":1}}],[\"如果需要立即发起拉票\",{\"1\":{\"1497\":1}}],[\"如果需要覆盖的半消息不在页缓存\",{\"1\":{\"1453\":1}}],[\"如果需要回查\",{\"1\":{\"1453\":1}}],[\"如果需要分发到\",{\"1\":{\"1294\":1}}],[\"如果需要流控则延迟\",{\"1\":{\"1159\":1}}],[\"如果需要构建对象\",{\"1\":{\"266\":1}}],[\"如果reblance之后的mq集合包含该messagequeue\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"如果新分配到的消息队列集合中不含有老的消息队列\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"如果新提升为主节点的这个副本与原有的主节点并未完成数据的同步\",{\"1\":{\"659\":1}}],[\"如果变化则丢弃老队列\",{\"1\":{\"1130\":1}}],[\"如果变化则触发消费队列重平衡\",{\"1\":{\"1098\":1}}],[\"如果二次调用\",{\"1\":{\"1122\":1}}],[\"如果二阶段的处理速度跟不上一阶段\",{\"1\":{\"734\":1}}],[\"如果路由信息有变化\",{\"1\":{\"1120\":1}}],[\"如果路由信息没有找到\",{\"1\":{\"1051\":1}}],[\"如果我们自己来设计拉\",{\"1\":{\"1117\":1}}],[\"如果我们要执行一个jar包的class\",{\"1\":{\"24\":1}}],[\"如果正常消费和重试\",{\"1\":{\"1100\":1}}],[\"如果正常消费失败\",{\"1\":{\"1100\":1}}],[\"如果修改延迟等级时间的配置\",{\"1\":{\"1100\":1}}],[\"如果消费请求被消费成功\",{\"1\":{\"1191\":1}}],[\"如果消费失败\",{\"1\":{\"1179\":1,\"1188\":1,\"1218\":1}}],[\"如果消费的\",{\"1\":{\"1145\":1}}],[\"如果消费成功则会更新消费进度\",{\"1\":{\"1184\":1}}],[\"如果消费成功\",{\"1\":{\"1104\":1,\"1179\":1,\"1188\":1}}],[\"如果消费进度文件丢失\",{\"1\":{\"1090\":1}}],[\"如果消息属性中定义了免疫回查时长\",{\"1\":{\"1468\":1}}],[\"如果消息属性中也定义了免疫回查时长\",{\"1\":{\"1468\":1}}],[\"如果消息属性中包含定时属性\",{\"1\":{\"1354\":1}}],[\"如果消息之前没有重新消费过\",{\"1\":{\"1198\":1}}],[\"如果消息消费失败\",{\"1\":{\"1180\":1}}],[\"如果消息通过了\",{\"1\":{\"1174\":1}}],[\"如果消息重试次数超过最大重试次数\",{\"1\":{\"1056\":1}}],[\"如果消息重试次数超过允许的最大重试次数\",{\"1\":{\"1043\":1}}],[\"如果消息投递失败了且不做任何处理\",{\"1\":{\"934\":1}}],[\"如果消息到期则直接投递\",{\"1\":{\"932\":1}}],[\"如果消息到期\",{\"1\":{\"857\":1}}],[\"如果用本地打包的镜像\",{\"1\":{\"1079\":1}}],[\"如果你拉取的版本没有改\",{\"1\":{\"1075\":1}}],[\"如果你想知道你当前的法术队列窗口\",{\"1\":{\"420\":1}}],[\"如果自己修改了\",{\"1\":{\"1072\":1}}],[\"如果注册了发送钩子函数\",{\"1\":{\"1053\":2}}],[\"如果第一次没有查询到\",{\"1\":{\"1051\":1}}],[\"如果已经启动\",{\"1\":{\"1047\":1}}],[\"如果已经使用\",{\"1\":{\"8\":1}}],[\"如果状态为\",{\"1\":{\"1047\":1}}],[\"如果上一次投票结果是等待下一轮投票\",{\"1\":{\"1497\":1}}],[\"如果上一次刷盘失败\",{\"1\":{\"1427\":1}}],[\"如果上一次发送失败\",{\"1\":{\"1041\":1}}],[\"如果上一次发送成功\",{\"1\":{\"1041\":1}}],[\"如果上一次是异常退出\",{\"1\":{\"793\":1}}],[\"如果最终都没有拉取到\",{\"1\":{\"1039\":1}}],[\"如果最后一个文件存在并且未满\",{\"1\":{\"789\":1}}],[\"如果同步发送则等待消息保存成功后返回\",{\"1\":{\"1030\":1}}],[\"如果同时在\",{\"1\":{\"34\":1}}],[\"如果把一个\",{\"1\":{\"1028\":1}}],[\"如果把所有任务都加载到timer这个高精度时间轮\",{\"1\":{\"379\":1}}],[\"如果相差大于\",{\"1\":{\"954\":1}}],[\"如果连接的\",{\"1\":{\"941\":1}}],[\"如果多次投递失败会阻塞其他消息的投递\",{\"1\":{\"934\":1}}],[\"如果还未到期则该任务结束\",{\"1\":{\"932\":1}}],[\"如果继续优化时间轮的方案未尝不可\",{\"1\":{\"931\":1}}],[\"如果此时流控还没有解除\",{\"1\":{\"931\":1}}],[\"如果直接投递到\",{\"1\":{\"930\":1}}],[\"如果按照上述方案\",{\"1\":{\"931\":1}}],[\"如果按照上面的规则还无法确定类名\",{\"1\":{\"20\":1}}],[\"如果按\",{\"1\":{\"927\":1}}],[\"如果可以取消定时消息\",{\"1\":{\"921\":1,\"1337\":1}}],[\"如果想要固定时间投递\",{\"1\":{\"920\":1}}],[\"如果该序号的日志条目已存在\",{\"1\":{\"1520\":1}}],[\"如果该队列被丢弃\",{\"1\":{\"1170\":1}}],[\"如果该\",{\"1\":{\"1065\":1}}],[\"如果该主题为顺序消息\",{\"1\":{\"957\":1,\"973\":2}}],[\"如果该文件被其他线程占用\",{\"1\":{\"870\":1}}],[\"如果该hash槽的值有效则查找\",{\"1\":{\"797\":1}}],[\"如果超时\",{\"1\":{\"1519\":2,\"1521\":1}}],[\"如果超时则重新发送请求\",{\"1\":{\"1519\":1}}],[\"如果超出则流控\",{\"1\":{\"1519\":1}}],[\"如果超出该时间\",{\"1\":{\"870\":1}}],[\"如果超过检测次数\",{\"1\":{\"1467\":1}}],[\"如果超过滚动时间\",{\"1\":{\"1427\":1}}],[\"如果超过消息总大小阈值\",{\"1\":{\"1065\":1}}],[\"如果超过\",{\"1\":{\"927\":1,\"945\":1,\"1230\":1}}],[\"如果超过那么也会直接返回消费者\",{\"1\":{\"806\":1}}],[\"如果删了之后磁盘容量小于\",{\"1\":{\"866\":1}}],[\"如果符合删除条件\",{\"1\":{\"864\":1}}],[\"如果符号x在b里只出现了k次\",{\"1\":{\"212\":1}}],[\"如果阻塞队列中元素数量大于阈值则触发流控\",{\"1\":{\"860\":1}}],[\"如果全部投递成功\",{\"1\":{\"857\":1}}],[\"如果放入内存失败\",{\"1\":{\"1260\":1}}],[\"如果放入队列失败\",{\"1\":{\"857\":1}}],[\"如果放出来第一时间开减伤\",{\"1\":{\"461\":1}}],[\"如果放出来一个是能奶上来的\",{\"1\":{\"461\":1}}],[\"如果投递失败需要重试\",{\"1\":{\"1374\":1}}],[\"如果投递失败\",{\"1\":{\"1360\":1}}],[\"如果投递速度跟不上\",{\"1\":{\"932\":1}}],[\"如果投递速度能跟上\",{\"1\":{\"932\":1}}],[\"如果投递错误\",{\"1\":{\"858\":1}}],[\"如果投递中\",{\"1\":{\"858\":1}}],[\"如果投递成功\",{\"1\":{\"858\":1}}],[\"如果投递异常\",{\"1\":{\"855\":1}}],[\"如果投递任务已完成\",{\"1\":{\"855\":1}}],[\"如果某个任务处理慢了\",{\"1\":{\"852\":1}}],[\"如果某一时刻要调度的worker达到一定量级\",{\"1\":{\"380\":1}}],[\"如果所有对端节点都返回响应\",{\"1\":{\"1497\":1}}],[\"如果所有消息都已经被投递\",{\"1\":{\"845\":1}}],[\"如果所有模式都不匹配\",{\"1\":{\"187\":1}}],[\"如果现在还没到投递时间点\",{\"1\":{\"845\":2,\"860\":1}}],[\"如果现在已经到了投递时间点\",{\"1\":{\"845\":2,\"860\":1}}],[\"如果从缓存中读取到消息\",{\"1\":{\"1409\":1}}],[\"如果从缓存中读到消息\",{\"1\":{\"1391\":1}}],[\"如果从分级存储中找到\",{\"1\":{\"1405\":1}}],[\"如果从分级存储没有找到消息\",{\"1\":{\"1405\":1}}],[\"如果从消费队列中未找到新的可以拉取的消息\",{\"1\":{\"819\":1}}],[\"如果从存储中没有查询到消息\",{\"1\":{\"814\":1,\"819\":1}}],[\"如果未找到对应挂起的请求\",{\"1\":{\"1521\":1}}],[\"如果未找到消息则挂起\",{\"1\":{\"819\":1,\"1173\":1}}],[\"如果未开启内存匹配\",{\"1\":{\"1276\":1}}],[\"如果未被消费完则跳过拉取操作\",{\"1\":{\"1207\":1}}],[\"如果未达到则请求server获取最新的可用worker列表\",{\"1\":{\"378\":1}}],[\"如果条件成立则说明有新消息达到broker端\",{\"1\":{\"815\":1}}],[\"如果确实有新消息\",{\"1\":{\"812\":1}}],[\"如果检查到有新消息可以拉取\",{\"1\":{\"812\":1}}],[\"如果支持挂起\",{\"1\":{\"806\":1}}],[\"如果能找到\",{\"1\":{\"1446\":1}}],[\"如果能被\",{\"1\":{\"1257\":1}}],[\"如果能够拉取消息\",{\"1\":{\"806\":1}}],[\"如果能匹配\",{\"1\":{\"194\":1}}],[\"如果文件写满\",{\"1\":{\"1414\":1}}],[\"如果文件过期\",{\"1\":{\"870\":1}}],[\"如果文件列表为空或者最后一个文件写满了\",{\"1\":{\"793\":1}}],[\"如果文件不包含\",{\"1\":{\"591\":1}}],[\"如果创建了新文件\",{\"1\":{\"793\":1}}],[\"如果存在\",{\"1\":{\"793\":1}}],[\"如果存在main\",{\"1\":{\"24\":1}}],[\"如果集群触发了重新选举\",{\"1\":{\"1519\":1}}],[\"如果集群负载较高\",{\"1\":{\"1234\":1}}],[\"如果集群中有多个计数节点\",{\"1\":{\"657\":1}}],[\"如果集群中的可用节点数少于count\",{\"1\":{\"657\":1}}],[\"如果集合为空或者最后一个文件写满了\",{\"1\":{\"793\":2}}],[\"如果开关开启\",{\"1\":{\"1332\":1}}],[\"如果开启主从切换\",{\"1\":{\"1424\":1}}],[\"如果开启预读缓存功能\",{\"1\":{\"1391\":1}}],[\"如果开启了一些配置则也会用到\",{\"1\":{\"1318\":1}}],[\"如果开启则会在一段时间内都规避发送失败的\",{\"1\":{\"1029\":1}}],[\"如果开启消息轨迹\",{\"1\":{\"1019\":1}}],[\"如果开启监听\",{\"1\":{\"997\":1}}],[\"如果开启\",{\"1\":{\"789\":1,\"1403\":1,\"1427\":1}}],[\"如果开发者实现了\",{\"1\":{\"372\":1}}],[\"如果=0\",{\"1\":{\"769\":1}}],[\"如果小于\",{\"1\":{\"872\":1}}],[\"如果小于则直接退出\",{\"1\":{\"797\":1}}],[\"如果小于等于\",{\"1\":{\"769\":1}}],[\"如果小于60s\",{\"1\":{\"379\":1}}],[\"如果期望写入的位置\",{\"1\":{\"765\":1}}],[\"如果仲裁队列超过半数的副本永久丢失\",{\"1\":{\"703\":1}}],[\"如果生产和消费的速度能够基本匹配\",{\"1\":{\"693\":1}}],[\"如果生产者和消费者连接的是从节点\",{\"1\":{\"669\":1}}],[\"如果选择同步\",{\"1\":{\"693\":1}}],[\"如果希望消息直接被保存到磁盘中\",{\"1\":{\"681\":1}}],[\"如果b节点将消息发送给c后\",{\"1\":{\"674\":1}}],[\"如果节点c收到b发送的消息还未发送给d时异常结束了\",{\"1\":{\"674\":1}}],[\"如果节点a节点成为赢家\",{\"1\":{\"659\":1}}],[\"如果队列中等待上传的消息量超过\",{\"1\":{\"1403\":1}}],[\"如果队列中有\",{\"1\":{\"1371\":1}}],[\"如果队列满\",{\"1\":{\"1355\":1}}],[\"如果队列的堆积少\",{\"1\":{\"693\":1}}],[\"如果队列为非持久化\",{\"1\":{\"684\":1}}],[\"如果队列很小\",{\"1\":{\"658\":1}}],[\"如果队列名称符合\",{\"1\":{\"655\":1}}],[\"如果主队列挂掉\",{\"1\":{\"693\":1}}],[\"如果主队列在所有未同步的消息耗尽之前失败\",{\"1\":{\"658\":1}}],[\"如果主节点不可用\",{\"1\":{\"657\":1}}],[\"如果这个文件还没有被重排\",{\"1\":{\"1417\":1}}],[\"如果这个\",{\"1\":{\"1403\":1}}],[\"如果这个队列的分级存储\",{\"1\":{\"1403\":1}}],[\"如果这个异常错误没有被捕捉到\",{\"1\":{\"193\":1}}],[\"如果这批消息数量大于每批次可以消费的消息\",{\"1\":{\"1194\":1}}],[\"如果这\",{\"1\":{\"806\":1}}],[\"如果这些节点名中有任何一个不是集群的一部分\",{\"1\":{\"657\":1}}],[\"如果运行队列主服务器的节点变得不可用\",{\"1\":{\"657\":1}}],[\"如果信用值大于0\",{\"1\":{\"626\":1}}],[\"如果模块格式是\",{\"1\":{\"597\":1}}],[\"如果模式匹配\",{\"1\":{\"261\":1}}],[\"如果省略不写\",{\"1\":{\"575\":1}}],[\"如果省略了exceptiontype\",{\"1\":{\"194\":1}}],[\"如果类car有接口motovehicle没有的属性和方法\",{\"1\":{\"573\":1}}],[\"如果类型a的值可以赋值给类型b\",{\"1\":{\"520\":1}}],[\"如果不丢弃或跳过\",{\"1\":{\"1468\":1}}],[\"如果不进行流控直接写入\",{\"1\":{\"1344\":1}}],[\"如果不进行一些检查和监控\",{\"1\":{\"702\":1}}],[\"如果不启用长轮询\",{\"1\":{\"1173\":1}}],[\"如果不是则重试上次上传\",{\"1\":{\"1403\":1}}],[\"如果不是类过滤模式\",{\"1\":{\"1170\":1}}],[\"如果不是\",{\"1\":{\"1061\":2,\"1173\":1,\"1510\":1}}],[\"如果不手动修改\",{\"1\":{\"1036\":1}}],[\"如果不为空则需要注意删除文件原有数据\",{\"1\":{\"998\":1}}],[\"如果不在则返回错误\",{\"1\":{\"991\":1,\"1000\":1}}],[\"如果不使用\",{\"1\":{\"903\":1}}],[\"如果不用\",{\"1\":{\"903\":1}}],[\"如果不满足以上两个条件\",{\"1\":{\"825\":1}}],[\"如果不满足这些条件就会报错\",{\"1\":{\"570\":1}}],[\"如果不存在则跳过\",{\"1\":{\"1279\":1}}],[\"如果不存在则需要填入\",{\"1\":{\"797\":1}}],[\"如果不存在或者最后一个文件写满\",{\"1\":{\"793\":1}}],[\"如果不存在或者已经满了\",{\"1\":{\"789\":1}}],[\"如果不存在\",{\"1\":{\"789\":1}}],[\"如果不指定\",{\"1\":{\"135\":1}}],[\"如果初始值不是空数组\",{\"1\":{\"523\":1}}],[\"如果代码里面没有注明类型\",{\"1\":{\"514\":1}}],[\"如果无法推断出类型\",{\"1\":{\"502\":1}}],[\"如果无数据可读\",{\"1\":{\"116\":1}}],[\"如果影遁之前离他足够远\",{\"1\":{\"487\":1}}],[\"如果两波读条怪血都很多那么不要合\",{\"1\":{\"469\":1}}],[\"如果两台计算机位于同一个网络\",{\"1\":{\"67\":1}}],[\"如果被调用\",{\"1\":{\"812\":1}}],[\"如果被炽热弹雨点名并且铁钩拉人马上就要来了\",{\"1\":{\"464\":1}}],[\"如果被更新的映射组不包含键k\",{\"1\":{\"192\":1}}],[\"如果打断用完了\",{\"1\":{\"458\":1}}],[\"如果断不过来可以用一颗球\",{\"1\":{\"455\":1}}],[\"如果灵魂之箭没有打断很容易造成减员\",{\"1\":{\"451\":1}}],[\"如果团血不满不要变熊\",{\"1\":{\"434\":1}}],[\"如果点了\",{\"1\":{\"417\":1}}],[\"如果追求没有那么高\",{\"1\":{\"412\":1}}],[\"如果追求成为顶尖玩家\",{\"1\":{\"412\":1}}],[\"如果怪小于\",{\"1\":{\"412\":1}}],[\"如果没法近战\",{\"1\":{\"412\":2}}],[\"如果没有收到心跳的话在选举超时后会重新发起拉票请求\",{\"1\":{\"1491\":1}}],[\"如果没有达到半数以上\",{\"1\":{\"1488\":1}}],[\"如果没有投过票则返回投票\",{\"1\":{\"1478\":1}}],[\"如果没有读到消息\",{\"1\":{\"1391\":1}}],[\"如果没有被过滤\",{\"1\":{\"1332\":1}}],[\"如果没有到提交时间阈值\",{\"1\":{\"1427\":1}}],[\"如果没有到\",{\"1\":{\"1279\":1}}],[\"如果没有指定队列\",{\"1\":{\"1257\":1}}],[\"如果没有消息则不处理\",{\"1\":{\"1195\":1}}],[\"如果没有这个队列\",{\"1\":{\"1163\":1}}],[\"如果没有这个机制\",{\"1\":{\"420\":1}}],[\"如果没有可用的\",{\"1\":{\"1052\":1}}],[\"如果没有拉取到\",{\"1\":{\"1039\":1}}],[\"如果没有拉取到消息\",{\"1\":{\"806\":1}}],[\"如果没有填充值\",{\"1\":{\"882\":1}}],[\"如果没有则挂起轮询\",{\"1\":{\"1257\":1}}],[\"如果没有则进行结果处理\",{\"1\":{\"1188\":1}}],[\"如果没有则从服务端\",{\"1\":{\"1318\":1}}],[\"如果没有则从\",{\"1\":{\"1042\":1}}],[\"如果没有则等待\",{\"1\":{\"841\":1}}],[\"如果没有则继续循环扫描\",{\"1\":{\"834\":1}}],[\"如果没有则继续等待\",{\"1\":{\"806\":1}}],[\"如果没有查询到消息\",{\"1\":{\"812\":1}}],[\"如果没有新消息不会马上返回\",{\"1\":{\"914\":1}}],[\"如果没有新消息到达\",{\"1\":{\"806\":1}}],[\"如果没有新消息则立刻返回\",{\"1\":{\"804\":1}}],[\"如果没有索引文件或者最后一个索引文件满了\",{\"1\":{\"789\":1}}],[\"如果没有数据则调用\",{\"1\":{\"726\":1}}],[\"如果没有流控\",{\"1\":{\"611\":1}}],[\"如果没有设置\",{\"1\":{\"585\":1}}],[\"如果没有找到下一个\",{\"1\":{\"1511\":1}}],[\"如果没有找到\",{\"1\":{\"327\":1,\"1052\":1,\"1163\":1}}],[\"如果没有\",{\"1\":{\"87\":1}}],[\"如果受到持续的伤害\",{\"1\":{\"411\":1}}],[\"如果更注重治疗的稳定性\",{\"1\":{\"407\":1}}],[\"如果怕奶量不够还可以把变形大师换成森林再生\",{\"1\":{\"403\":1}}],[\"如果要读取的数据跨越了两个\",{\"1\":{\"1410\":1}}],[\"如果要开启则需要设置一下配置项\",{\"1\":{\"1315\":1}}],[\"如果要开启布隆过滤器进行双层过滤\",{\"1\":{\"1308\":1}}],[\"如果要使用\",{\"1\":{\"1308\":1}}],[\"如果要做到\",{\"1\":{\"1203\":1}}],[\"如果要再次消费\",{\"1\":{\"1188\":1}}],[\"如果要用分级存储\",{\"1\":{\"1382\":1}}],[\"如果要用\",{\"1\":{\"1079\":1}}],[\"如果要单独存储\",{\"1\":{\"928\":1}}],[\"如果要同步消息\",{\"1\":{\"678\":1}}],[\"如果要输出一个函数或数组\",{\"1\":{\"365\":1}}],[\"如果要输出一个键值对象\",{\"1\":{\"365\":1}}],[\"如果要加载一个abc\",{\"1\":{\"23\":1}}],[\"如果只设定第一个成员的值\",{\"1\":{\"583\":1}}],[\"如果只是调用\",{\"1\":{\"1300\":1}}],[\"如果只是单纯想要一个类型\",{\"1\":{\"564\":1}}],[\"如果只是想要记录里的单个字段\",{\"1\":{\"191\":1}}],[\"如果只写模块名\",{\"1\":{\"363\":1}}],[\"如果在免疫器则跳出回查循环\",{\"1\":{\"1453\":1}}],[\"如果在则表示该半消息已经提交或回滚\",{\"1\":{\"1453\":1}}],[\"如果在则表示该消息可能符合过滤条件\",{\"1\":{\"1319\":1}}],[\"如果在\",{\"1\":{\"1347\":1,\"1468\":1,\"1484\":1}}],[\"如果在写缓冲区中排队的字节数先超过了高水位线\",{\"1\":{\"1299\":1}}],[\"如果在写缓冲区中排队的字节数超过了高水位线\",{\"1\":{\"1299\":1}}],[\"如果在内存中找不到对应的\",{\"1\":{\"1253\":1}}],[\"如果在一段时间\",{\"1\":{\"1253\":1}}],[\"如果在一个周期内job要执行多次\",{\"1\":{\"374\":1}}],[\"如果在一个函数内部发生了错误\",{\"1\":{\"358\":1}}],[\"如果在重新消费次数阈值之内\",{\"1\":{\"1188\":1}}],[\"如果在声明队列时列表中的节点都不在线\",{\"1\":{\"657\":1}}],[\"如果在任务执行过程中增加了worker\",{\"1\":{\"375\":1}}],[\"如果在finally中抛出异常\",{\"1\":{\"34\":1}}],[\"如果一条消息消费不成功会一直重试\",{\"1\":{\"1241\":1}}],[\"如果一次轮询没有找到消息\",{\"1\":{\"806\":1}}],[\"如果一直没有新消息\",{\"1\":{\"804\":1}}],[\"如果一定要引用循环变量\",{\"1\":{\"330\":1}}],[\"如果一致\",{\"1\":{\"295\":1,\"1314\":1}}],[\"如果一个消费组内两个消费者的\",{\"1\":{\"1240\":1}}],[\"如果一个\",{\"1\":{\"1102\":1}}],[\"如果一个变量有多种类型\",{\"1\":{\"515\":1}}],[\"如果一个事务方法从threadlocal未取到事务\",{\"1\":{\"87\":1}}],[\"如果一个普通类没有业务接口\",{\"1\":{\"85\":1}}],[\"如果数据类型不一致\",{\"1\":{\"295\":1}}],[\"如果通过上面所有的过滤\",{\"1\":{\"1492\":1}}],[\"如果通过\",{\"1\":{\"271\":1}}],[\"如果\",{\"1\":{\"188\":1,\"194\":1,\"416\":1,\"441\":1,\"847\":1,\"902\":1,\"906\":1,\"916\":2,\"942\":1,\"954\":2,\"978\":1,\"1053\":1,\"1163\":1,\"1198\":1,\"1215\":1,\"1257\":2,\"1261\":1,\"1277\":1,\"1278\":1,\"1359\":1,\"1427\":3,\"1428\":1,\"1468\":1,\"1492\":2,\"1503\":1,\"1510\":3,\"1511\":1,\"1519\":2,\"1520\":4}}],[\"如果得到的值为\",{\"1\":{\"188\":1}}],[\"如果shell将某个整数列表打印成字符串\",{\"1\":{\"178\":1}}],[\"如果列表内的所有整数都代表可打印字符\",{\"1\":{\"178\":1}}],[\"如果t是一个列表\",{\"1\":{\"177\":1}}],[\"如果有记录超时的待追加日志序号\",{\"1\":{\"1520\":1}}],[\"如果有的话\",{\"1\":{\"1120\":1}}],[\"如果有需要的话对于消费失败的消息还需要发回\",{\"1\":{\"1117\":1}}],[\"如果有人再问你怎么实现分布式延时消息\",{\"1\":{\"938\":1}}],[\"如果有一个投递任务重试\",{\"1\":{\"860\":1}}],[\"如果有还未投递的消息\",{\"1\":{\"845\":1,\"860\":1}}],[\"如果有则解析该属性\",{\"1\":{\"1294\":1}}],[\"如果有则传输回客户端\",{\"1\":{\"1257\":1}}],[\"如果有则根据消费队列中的索引项\",{\"1\":{\"1153\":1}}],[\"如果有则将真正\",{\"1\":{\"1188\":1}}],[\"如果有则将到期的消息一个个同步投递\",{\"1\":{\"855\":1}}],[\"如果有则将到期消息都投递到\",{\"1\":{\"841\":1}}],[\"如果有则将消息真正的\",{\"1\":{\"834\":1}}],[\"如果有则将这条消息查出来\",{\"1\":{\"750\":1,\"781\":1}}],[\"如果有则执行拉取请求操作\",{\"1\":{\"823\":1}}],[\"如果有数据满足要求\",{\"1\":{\"815\":1,\"823\":1}}],[\"如果有数据需要发送\",{\"1\":{\"125\":1}}],[\"如果有新消息\",{\"1\":{\"806\":1}}],[\"如果有值说明这个hash\",{\"1\":{\"797\":1}}],[\"如果有镜像没有授予生产者信用\",{\"1\":{\"664\":1}}],[\"如果有复杂的类型运算\",{\"1\":{\"564\":1}}],[\"如果有持续的伤害\",{\"1\":{\"411\":1}}],[\"如果有\",{\"1\":{\"411\":2,\"834\":1}}],[\"如果有多个匿名类\",{\"1\":{\"22\":1}}],[\"如果读到换行符则结束读取\",{\"1\":{\"125\":1}}],[\"如果当前节点没有\",{\"1\":{\"1503\":1}}],[\"如果当前节点已存在\",{\"1\":{\"1503\":1}}],[\"如果当前节点已投票给请求节点\",{\"1\":{\"1503\":1}}],[\"如果当前节点已投票给请求的节点\",{\"1\":{\"1492\":1}}],[\"如果当前节点已投票给其他节点\",{\"1\":{\"1492\":1,\"1503\":1}}],[\"如果当前节点未投票\",{\"1\":{\"1492\":1,\"1503\":1}}],[\"如果当前节点还没有\",{\"1\":{\"1489\":1,\"1500\":1}}],[\"如果当前节点不是\",{\"1\":{\"1486\":1}}],[\"如果当前时间距离上次发送心跳的时间超过心跳周期\",{\"1\":{\"1485\":1}}],[\"如果当前\",{\"1\":{\"1427\":1}}],[\"如果当前槽为空\",{\"1\":{\"1372\":1}}],[\"如果当前没有消息\",{\"1\":{\"1173\":1}}],[\"如果当前没有事务\",{\"1\":{\"87\":1}}],[\"如果当前消费者被挂起\",{\"1\":{\"1170\":1}}],[\"如果当前发送次数小于异步发送重试次数\",{\"1\":{\"1040\":1}}],[\"如果当前有事务\",{\"1\":{\"87\":1}}],[\"如果当前已经有事务\",{\"1\":{\"87\":1}}],[\"如果客户端获得了bookservice的引用\",{\"1\":{\"85\":1}}],[\"如果标准插件无法满足需求\",{\"1\":{\"64\":1}}],[\"如果编译无误\",{\"1\":{\"21\":1}}],[\"如果是新集群\",{\"1\":{\"1510\":1}}],[\"如果是新\",{\"1\":{\"1510\":1}}],[\"如果是事务消息\",{\"1\":{\"1462\":2}}],[\"如果是事务消息的回滚消息\",{\"1\":{\"794\":1}}],[\"如果是则丢弃后继续查询下一条\",{\"1\":{\"1453\":1}}],[\"如果是则会发送一个通知\",{\"1\":{\"806\":1}}],[\"如果是从本地存储读取\",{\"1\":{\"1405\":1}}],[\"如果是从分级存储进行读取\",{\"1\":{\"1405\":1}}],[\"如果是读分级存储则调用分级存储\",{\"1\":{\"1401\":1}}],[\"如果是读本地存储\",{\"1\":{\"1401\":1}}],[\"如果是类过滤模式\",{\"1\":{\"1328\":1,\"1333\":1}}],[\"如果是slave\",{\"1\":{\"1297\":1}}],[\"如果是第一次锁定\",{\"1\":{\"1228\":1}}],[\"如果是顺序消费\",{\"1\":{\"1224\":1,\"1225\":1}}],[\"如果是单元化模式\",{\"1\":{\"1198\":1}}],[\"如果是重试消息且第一次重试\",{\"1\":{\"1188\":1}}],[\"如果是集群模式\",{\"1\":{\"1188\":1}}],[\"如果是集群消费模式\",{\"1\":{\"1103\":1}}],[\"如果是广播模式\",{\"1\":{\"1188\":1,\"1230\":1}}],[\"如果是子节点\",{\"1\":{\"1171\":1}}],[\"如果是启动状态\",{\"1\":{\"1168\":1}}],[\"如果是push\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"如果是才继续走启动流程\",{\"1\":{\"1120\":1}}],[\"如果是内存较小的机器则可以通过定义环境变量修改内存占用\",{\"1\":{\"1080\":1}}],[\"如果是采用远程拉取的镜像\",{\"1\":{\"1075\":1}}],[\"如果是异步发送则直接返回\",{\"1\":{\"1030\":1}}],[\"如果是异步刷盘\",{\"1\":{\"765\":1}}],[\"如果是定时消息\",{\"1\":{\"839\":1,\"843\":1}}],[\"如果是\",{\"1\":{\"837\":1,\"894\":1,\"971\":1,\"1061\":2,\"1198\":1,\"1278\":2,\"1510\":1}}],[\"如果是这样\",{\"1\":{\"665\":1}}],[\"如果是性能瓶颈\",{\"1\":{\"622\":1}}],[\"如果是简单类名\",{\"1\":{\"20\":1}}],[\"如果是完整类名\",{\"1\":{\"20\":1}}],[\"如果大于等于当前轮次\",{\"1\":{\"1480\":1}}],[\"如果大于重新消费次数阈值\",{\"1\":{\"1188\":1}}],[\"如果大于0\",{\"1\":{\"769\":1}}],[\"如果大于\",{\"1\":{\"9\":1}}],[\"如果使用分级存储\",{\"1\":{\"1405\":1}}],[\"如果使用java\",{\"1\":{\"25\":1}}],[\"如果使用\",{\"1\":{\"7\":1}}],[\"如果设置用多个进程执行\",{\"1\":{\"4\":1}}],[\"fsmcaller\",{\"1\":{\"1521\":6}}],[\"fs\",{\"1\":{\"595\":7}}],[\"fn\",{\"1\":{\"504\":1,\"535\":2}}],[\"fgb5zf\",{\"1\":{\"469\":1}}],[\"fcpmerjowtouyfrwexyvcxxyz4cyxs2j6jj9jnrt1knwld2ojnpdyawkakbfhbfbrc3aqtgm7colkepfapdaojajnsjyhf\",{\"1\":{\"455\":1}}],[\"fqy63gqnwb\",{\"1\":{\"436\":1}}],[\"fp8tieqwpe5y807lxxgmne9sigbfd4igfzbmhpc37odshf8nooukrmove9qcsf\",{\"1\":{\"436\":1}}],[\"fprof\",{\"1\":{\"255\":1}}],[\"fprof显示调用和被调用函数的时间\",{\"1\":{\"255\":1}}],[\"federate\",{\"1\":{\"636\":1}}],[\"federation\",{\"0\":{\"629\":1,\"632\":1,\"633\":1,\"634\":1,\"636\":1},\"1\":{\"629\":1,\"630\":4,\"632\":3,\"633\":1,\"634\":1,\"635\":2,\"636\":1,\"638\":4,\"640\":3,\"718\":1}}],[\"female\",{\"1\":{\"515\":1}}],[\"fetchmessagequeues\",{\"1\":{\"1468\":1}}],[\"fetchmessagethenputtocache\",{\"1\":{\"1409\":1,\"1431\":2}}],[\"fetchercache\",{\"1\":{\"1402\":1,\"1430\":1}}],[\"fetcher\",{\"1\":{\"1387\":1,\"1401\":1}}],[\"fetchlockobject\",{\"1\":{\"1230\":1}}],[\"fetchconsumeoffset\",{\"1\":{\"1117\":1,\"1468\":2}}],[\"fetchsubscribemessagequeues\",{\"1\":{\"1116\":1}}],[\"fetchnameserveraddr\",{\"1\":{\"1048\":3,\"1123\":1}}],[\"fetch\",{\"0\":{\"349\":1},\"1\":{\"349\":2,\"354\":2,\"1269\":1,\"1390\":4,\"1405\":4,\"1430\":1,\"1432\":1}}],[\"feature\",{\"1\":{\"692\":1}}],[\"feat\",{\"0\":{\"107\":1},\"1\":{\"138\":1}}],[\"f2\",{\"1\":{\"330\":2}}],[\"f2c488\",{\"1\":{\"266\":3,\"267\":1}}],[\"f4\",{\"1\":{\"192\":1}}],[\"f4=f1\",{\"1\":{\"192\":1}}],[\"f3\",{\"1\":{\"192\":2,\"330\":2}}],[\"f1\",{\"1\":{\"192\":2,\"330\":2,\"455\":1}}],[\"frequently\",{\"1\":{\"1519\":1}}],[\"fresh\",{\"1\":{\"1468\":1}}],[\"free\",{\"1\":{\"737\":1}}],[\"fred\",{\"1\":{\"253\":1}}],[\"fraction\",{\"1\":{\"688\":1}}],[\"frame\",{\"1\":{\"624\":9}}],[\"friday\",{\"1\":{\"587\":1}}],[\"friendactor和workerrequesthandler进行actor与handler方法的绑定\",{\"1\":{\"374\":1}}],[\"fruit\",{\"1\":{\"181\":2}}],[\"fromtransactioncheck\",{\"1\":{\"1017\":1}}],[\"from表示消息接受者的进程号\",{\"1\":{\"624\":1}}],[\"from\",{\"1\":{\"69\":1,\"92\":2,\"165\":1,\"171\":2,\"192\":2,\"253\":4,\"396\":1,\"591\":1,\"592\":3,\"595\":2,\"598\":4,\"624\":7,\"625\":3,\"626\":6,\"627\":3,\"767\":1,\"886\":1,\"913\":1,\"972\":6,\"985\":1,\"1007\":1,\"1021\":1,\"1048\":1,\"1056\":1,\"1123\":1,\"1145\":2,\"1170\":2,\"1174\":1,\"1228\":1,\"1248\":1,\"1280\":2,\"1333\":1,\"1372\":1,\"1430\":1,\"1436\":6,\"1444\":1,\"1497\":1,\"1519\":2,\"1520\":1,\"1521\":2}}],[\"f触发双字符搜索\",{\"1\":{\"167\":1}}],[\"f\",{\"0\":{\"184\":1,\"904\":1},\"1\":{\"145\":2,\"162\":1,\"171\":7,\"181\":6,\"182\":8,\"183\":3,\"184\":2,\"196\":1,\"200\":1,\"230\":2,\"253\":14,\"298\":2,\"329\":2,\"332\":7,\"342\":3,\"504\":4,\"536\":3,\"539\":1,\"541\":1,\"558\":7,\"625\":2,\"643\":1,\"742\":3,\"793\":5,\"794\":6,\"796\":6,\"872\":3,\"886\":1,\"890\":1,\"1300\":1}}],[\"flightcommitrequest\",{\"1\":{\"1428\":1}}],[\"flip\",{\"1\":{\"125\":2,\"737\":1,\"738\":1,\"765\":1,\"1435\":1}}],[\"flexable\",{\"1\":{\"918\":1}}],[\"flatfile\",{\"1\":{\"1427\":27,\"1430\":6,\"1431\":9,\"1432\":10}}],[\"flatfileinterface\",{\"1\":{\"1427\":2}}],[\"flatfilestore\",{\"1\":{\"1402\":1,\"1421\":2,\"1427\":4,\"1430\":1}}],[\"flatmessagefile\",{\"1\":{\"1386\":1,\"1402\":2,\"1403\":1,\"1420\":2,\"1421\":2,\"1427\":2,\"1430\":1,\"1431\":2,\"1432\":1}}],[\"flatconsumequeuefile\",{\"1\":{\"1386\":2,\"1402\":3}}],[\"flatcommitlogfile\",{\"1\":{\"1386\":3,\"1402\":4}}],[\"flatappendfile\",{\"0\":{\"1410\":1},\"1\":{\"1386\":2,\"1402\":1,\"1410\":1,\"1417\":1,\"1420\":1,\"1435\":9}}],[\"flame\",{\"1\":{\"886\":1}}],[\"flag=0\",{\"1\":{\"1445\":3}}],[\"flag\",{\"1\":{\"737\":2,\"738\":1,\"742\":2,\"890\":1,\"894\":1,\"935\":1,\"1005\":1,\"1035\":1,\"1053\":1,\"1372\":1}}],[\"flaglist\",{\"1\":{\"261\":3}}],[\"flags\",{\"1\":{\"150\":2}}],[\"flowcontroltimes=\",{\"1\":{\"1170\":3}}],[\"flow模块来追踪它已经向rabbit\",{\"1\":{\"624\":1}}],[\"flows\",{\"1\":{\"614\":2,\"621\":2}}],[\"flow\",{\"0\":{\"609\":1},\"1\":{\"609\":1,\"614\":3,\"618\":1,\"621\":2,\"623\":1,\"624\":12,\"625\":2,\"626\":5,\"627\":3,\"628\":4,\"718\":1,\"860\":2,\"1170\":6,\"1173\":1,\"1373\":3}}],[\"floor\",{\"1\":{\"253\":2}}],[\"flyable\",{\"1\":{\"571\":1}}],[\"flushnewmetadata\",{\"1\":{\"1434\":1,\"1435\":1}}],[\"flushdata\",{\"1\":{\"1021\":1}}],[\"flushdisktype\",{\"1\":{\"882\":3,\"1075\":2}}],[\"flushindexfilethread\",{\"1\":{\"793\":1}}],[\"flushthread\",{\"1\":{\"793\":3}}],[\"flushthisfile\",{\"1\":{\"793\":2}}],[\"flushconsumequeueleastpages\",{\"1\":{\"769\":5}}],[\"flushconsumequeueservice\",{\"0\":{\"769\":1},\"1\":{\"768\":1}}],[\"flushconsumequeuethoroughinterval\",{\"1\":{\"758\":1,\"769\":2}}],[\"flushcommitlogtimed\",{\"1\":{\"720\":1,\"732\":1,\"735\":2}}],[\"flush\",{\"1\":{\"54\":1,\"69\":3,\"70\":1,\"113\":2,\"171\":2,\"769\":2,\"789\":1,\"793\":1,\"796\":4,\"844\":1,\"882\":8,\"1075\":2,\"1273\":2,\"1300\":3,\"1459\":2}}],[\"fall\",{\"1\":{\"1520\":1}}],[\"fallbehind\",{\"1\":{\"1174\":2}}],[\"false\",{\"1\":{\"90\":7,\"118\":1,\"121\":1,\"124\":1,\"125\":2,\"133\":1,\"181\":6,\"186\":3,\"187\":1,\"272\":1,\"299\":2,\"332\":5,\"531\":1,\"591\":1,\"625\":1,\"626\":1,\"627\":1,\"665\":1,\"712\":2,\"714\":1,\"715\":1,\"735\":1,\"742\":2,\"762\":2,\"765\":1,\"769\":1,\"797\":2,\"819\":1,\"820\":1,\"844\":1,\"860\":2,\"890\":1,\"894\":2,\"915\":3,\"961\":2,\"967\":3,\"971\":1,\"972\":1,\"983\":2,\"1020\":2,\"1021\":2,\"1048\":1,\"1050\":2,\"1053\":4,\"1067\":1,\"1122\":1,\"1123\":1,\"1128\":1,\"1144\":1,\"1170\":2,\"1171\":2,\"1172\":2,\"1173\":5,\"1174\":2,\"1175\":1,\"1195\":2,\"1197\":1,\"1198\":2,\"1200\":1,\"1224\":1,\"1225\":1,\"1226\":1,\"1230\":3,\"1234\":1,\"1248\":1,\"1269\":2,\"1270\":1,\"1275\":5,\"1276\":7,\"1277\":2,\"1288\":1,\"1297\":3,\"1299\":3,\"1300\":2,\"1308\":1,\"1331\":2,\"1333\":2,\"1370\":7,\"1372\":1,\"1373\":1,\"1374\":2,\"1424\":1,\"1427\":8,\"1428\":4,\"1435\":2,\"1460\":1,\"1462\":1,\"1497\":4,\"1499\":4,\"1516\":1,\"1517\":1,\"1519\":3,\"1521\":1}}],[\"fastlistenport=10929\",{\"1\":{\"1075\":1}}],[\"fastencodeheader\",{\"1\":{\"894\":2}}],[\"fastjson\",{\"1\":{\"893\":2}}],[\"fastcodesheader\",{\"1\":{\"891\":1,\"894\":3}}],[\"fault\",{\"1\":{\"879\":1}}],[\"fanout\",{\"1\":{\"700\":1,\"701\":1}}],[\"factory\",{\"1\":{\"712\":3,\"1048\":2,\"1123\":2}}],[\"factor\",{\"1\":{\"695\":1}}],[\"facebook\",{\"1\":{\"298\":5}}],[\"faqurl\",{\"1\":{\"973\":2,\"1047\":4,\"1050\":2,\"1122\":4,\"1173\":8,\"1198\":2}}],[\"faq\",{\"1\":{\"640\":1}}],[\"fails\",{\"1\":{\"1427\":1}}],[\"failscheduleoffset\",{\"1\":{\"845\":3}}],[\"failover\",{\"1\":{\"665\":2}}],[\"failure设置为always\",{\"1\":{\"659\":2}}],[\"failure\",{\"1\":{\"659\":2}}],[\"fail\",{\"1\":{\"348\":2,\"543\":1,\"1276\":3,\"1277\":1,\"1297\":1,\"1464\":2}}],[\"failed\",{\"1\":{\"113\":1,\"797\":2,\"820\":2,\"823\":1,\"825\":2,\"845\":1,\"870\":1,\"999\":1,\"1000\":1,\"1019\":1,\"1047\":2,\"1048\":3,\"1122\":2,\"1123\":3,\"1143\":1,\"1144\":4,\"1170\":2,\"1173\":4,\"1174\":1,\"1195\":4,\"1198\":1,\"1224\":4,\"1226\":1,\"1228\":1,\"1230\":1,\"1266\":1,\"1297\":2,\"1431\":1,\"1432\":1,\"1459\":1,\"1468\":1,\"1469\":1,\"1471\":3,\"1472\":1,\"1497\":1,\"1499\":1,\"1516\":1,\"1519\":1}}],[\"farmer\",{\"1\":{\"253\":2}}],[\"foxiswho\",{\"1\":{\"1073\":1}}],[\"found\",{\"1\":{\"814\":1,\"819\":4,\"861\":1,\"1008\":1,\"1050\":1,\"1173\":7,\"1174\":4,\"1175\":2,\"1229\":1,\"1269\":1,\"1270\":2,\"1329\":1,\"1425\":1,\"1431\":2,\"1432\":3,\"1435\":1}}],[\"four\",{\"1\":{\"515\":1,\"585\":1}}],[\"focus\",{\"1\":{\"692\":1}}],[\"focal\",{\"1\":{\"643\":3,\"644\":2}}],[\"follower\",{\"0\":{\"1478\":1,\"1484\":1,\"1510\":1,\"1511\":1,\"1518\":2,\"1519\":1,\"1520\":1,\"1521\":1},\"1\":{\"649\":1,\"668\":7,\"672\":3,\"673\":2,\"674\":3,\"1477\":1,\"1479\":5,\"1480\":2,\"1482\":1,\"1488\":5,\"1489\":1,\"1491\":1,\"1497\":2,\"1499\":9,\"1500\":5,\"1507\":7,\"1508\":3,\"1509\":1,\"1510\":23,\"1511\":8,\"1512\":1,\"1514\":4,\"1516\":2,\"1518\":4,\"1519\":47,\"1520\":28}}],[\"following\",{\"1\":{\"103\":1,\"104\":1,\"643\":2,\"1267\":1,\"1444\":1}}],[\"foldl\",{\"1\":{\"192\":1}}],[\"footsize\",{\"1\":{\"176\":2}}],[\"foo\",{\"1\":{\"104\":2,\"143\":1,\"213\":2,\"309\":3,\"311\":1,\"313\":2,\"314\":1,\"331\":1,\"340\":1,\"365\":3,\"511\":1,\"512\":1,\"516\":3,\"518\":1,\"551\":2,\"553\":1,\"584\":4,\"586\":1,\"589\":1,\"591\":1,\"596\":1}}],[\"forname\",{\"1\":{\"1425\":1}}],[\"forward\",{\"1\":{\"1372\":1}}],[\"forbidden\",{\"1\":{\"1056\":1,\"1173\":2,\"1174\":2,\"1198\":2,\"1462\":1,\"1464\":1}}],[\"form\",{\"1\":{\"490\":2}}],[\"formatting\",{\"1\":{\"886\":1,\"907\":1}}],[\"format\",{\"0\":{\"258\":1},\"1\":{\"178\":2,\"224\":1,\"230\":1,\"235\":1,\"248\":1,\"258\":1,\"259\":2,\"266\":1,\"908\":1,\"998\":1,\"1000\":6,\"1173\":4,\"1195\":1,\"1198\":1,\"1230\":1,\"1436\":2}}],[\"foreach\",{\"1\":{\"248\":1,\"253\":2,\"303\":2,\"327\":1,\"894\":1,\"1427\":2,\"1436\":1}}],[\"forget\",{\"1\":{\"171\":2}}],[\"force\",{\"1\":{\"165\":1,\"882\":4,\"1382\":1,\"1390\":1,\"1405\":1,\"1427\":8}}],[\"for\",{\"0\":{\"182\":1},\"1\":{\"69\":2,\"70\":1,\"72\":1,\"103\":2,\"131\":1,\"171\":3,\"182\":6,\"253\":1,\"303\":5,\"311\":1,\"314\":2,\"330\":1,\"331\":1,\"332\":1,\"385\":1,\"396\":5,\"628\":1,\"712\":3,\"714\":1,\"715\":1,\"717\":1,\"720\":6,\"736\":2,\"742\":2,\"762\":2,\"763\":1,\"767\":1,\"769\":3,\"771\":1,\"793\":1,\"794\":2,\"797\":1,\"823\":1,\"825\":1,\"844\":1,\"845\":5,\"860\":6,\"861\":1,\"870\":1,\"871\":2,\"872\":1,\"882\":1,\"886\":2,\"906\":1,\"970\":1,\"971\":1,\"973\":1,\"984\":1,\"994\":2,\"995\":2,\"996\":1,\"998\":3,\"999\":2,\"1000\":8,\"1008\":1,\"1020\":2,\"1021\":3,\"1050\":1,\"1052\":2,\"1053\":1,\"1056\":2,\"1073\":2,\"1075\":1,\"1078\":1,\"1142\":1,\"1144\":1,\"1171\":1,\"1174\":1,\"1194\":3,\"1195\":3,\"1200\":2,\"1222\":2,\"1224\":1,\"1225\":1,\"1226\":1,\"1230\":1,\"1248\":1,\"1266\":4,\"1267\":2,\"1269\":3,\"1270\":1,\"1271\":1,\"1276\":1,\"1277\":1,\"1278\":1,\"1279\":1,\"1280\":1,\"1288\":1,\"1296\":2,\"1297\":3,\"1306\":1,\"1309\":1,\"1329\":1,\"1331\":1,\"1368\":4,\"1370\":1,\"1371\":2,\"1372\":5,\"1373\":2,\"1425\":1,\"1427\":2,\"1431\":1,\"1432\":1,\"1434\":2,\"1435\":1,\"1436\":2,\"1437\":3,\"1443\":1,\"1462\":1,\"1468\":1,\"1497\":2,\"1499\":1,\"1500\":1,\"1502\":1,\"1517\":1,\"1519\":4,\"1520\":2,\"1521\":6}}],[\"fork\",{\"1\":{\"4\":1,\"9\":1,\"11\":2}}],[\"futureentry\",{\"1\":{\"1521\":4}}],[\"futurelist\",{\"1\":{\"1436\":3}}],[\"future\",{\"1\":{\"820\":4,\"1173\":3,\"1436\":7,\"1497\":2,\"1499\":2,\"1507\":4,\"1509\":3,\"1512\":1,\"1516\":2,\"1518\":8,\"1520\":28,\"1521\":6}}],[\"fun2ms\",{\"1\":{\"261\":1}}],[\"fun<erl\",{\"1\":{\"181\":7,\"230\":1}}],[\"fun\",{\"0\":{\"181\":1},\"1\":{\"181\":11,\"182\":2,\"183\":1,\"187\":1,\"192\":1,\"210\":2,\"229\":2,\"230\":1,\"248\":1,\"253\":8,\"261\":1}}],[\"funcorexpressionseq\",{\"1\":{\"194\":1}}],[\"funcorexpessionseq\",{\"1\":{\"194\":1}}],[\"function内部\",{\"1\":{\"354\":1}}],[\"function可以定义一个异步函数\",{\"1\":{\"354\":1}}],[\"function和undefined\",{\"1\":{\"333\":1}}],[\"function\",{\"0\":{\"534\":1},\"1\":{\"171\":4,\"185\":1,\"192\":1,\"255\":1,\"256\":3,\"261\":1,\"303\":1,\"306\":2,\"309\":1,\"311\":1,\"313\":1,\"314\":1,\"316\":1,\"320\":1,\"323\":1,\"324\":1,\"325\":2,\"329\":4,\"330\":5,\"332\":1,\"338\":1,\"339\":3,\"340\":1,\"341\":5,\"342\":6,\"348\":3,\"349\":1,\"351\":6,\"352\":3,\"353\":3,\"354\":1,\"361\":1,\"364\":2,\"365\":2,\"369\":4,\"396\":3,\"504\":2,\"515\":1,\"518\":1,\"533\":3,\"534\":1,\"535\":1,\"536\":1,\"537\":1,\"538\":1,\"539\":2,\"540\":1,\"541\":1,\"543\":1,\"544\":1,\"545\":1,\"546\":1,\"547\":3,\"548\":1,\"558\":4,\"605\":1}}],[\"functionalinterface不强制继承关系\",{\"1\":{\"76\":1}}],[\"functionalinterface允许传入\",{\"1\":{\"76\":1}}],[\"functionalinterface\",{\"1\":{\"75\":4}}],[\"func\",{\"1\":{\"171\":2,\"196\":1,\"200\":1,\"213\":1,\"229\":2}}],[\"fully\",{\"1\":{\"643\":1}}],[\"full\",{\"1\":{\"11\":1,\"870\":1,\"1269\":3,\"1434\":3,\"1516\":3,\"1517\":1}}],[\"fib\",{\"1\":{\"261\":7,\"332\":3}}],[\"fixes\",{\"1\":{\"1437\":1}}],[\"fixed\",{\"1\":{\"374\":2,\"1144\":1}}],[\"fixme\",{\"1\":{\"1278\":1}}],[\"fix\",{\"1\":{\"191\":5,\"720\":1,\"736\":1,\"900\":1,\"1053\":1,\"1145\":1,\"1170\":1,\"1173\":1,\"1175\":1,\"1228\":1,\"1430\":1}}],[\"finish\",{\"1\":{\"1277\":3}}],[\"finished\",{\"1\":{\"882\":1}}],[\"findmappedfilebyoffset\",{\"1\":{\"1368\":1}}],[\"findsubscriptiondata\",{\"1\":{\"1173\":1}}],[\"findsubscriptiongroupconfig\",{\"1\":{\"1173\":1,\"1198\":1,\"1279\":1}}],[\"findbrokeraddressinsubscribe\",{\"1\":{\"1171\":2,\"1200\":2,\"1226\":1}}],[\"findbrokeraddressinpublish\",{\"1\":{\"1053\":2,\"1197\":1,\"1460\":1}}],[\"findbrokerresult\",{\"1\":{\"1171\":9,\"1200\":7,\"1226\":4}}],[\"findconsumeridlist\",{\"1\":{\"1143\":1}}],[\"findconsumequeue\",{\"1\":{\"764\":1,\"767\":1,\"845\":1,\"860\":1,\"1174\":2,\"1297\":1}}],[\"finding\",{\"1\":{\"628\":1}}],[\"findindex\",{\"1\":{\"327\":1}}],[\"find\",{\"1\":{\"145\":1,\"253\":2,\"327\":1,\"396\":1,\"845\":2,\"860\":2,\"1170\":1,\"1174\":3,\"1278\":2}}],[\"finalmsginner\",{\"1\":{\"1462\":2}}],[\"finalqueueidint\",{\"1\":{\"1462\":2}}],[\"finalbatchsize\",{\"1\":{\"1432\":3}}],[\"final\",{\"1\":{\"99\":2,\"112\":1,\"113\":5,\"121\":4,\"122\":3,\"123\":2,\"124\":5,\"126\":2,\"128\":1,\"129\":2,\"131\":2,\"133\":4,\"134\":1,\"396\":4,\"712\":3,\"737\":16,\"738\":4,\"757\":6,\"764\":1,\"765\":5,\"767\":6,\"771\":1,\"789\":1,\"790\":8,\"793\":2,\"794\":1,\"796\":1,\"797\":16,\"814\":1,\"819\":1,\"820\":3,\"822\":3,\"823\":1,\"825\":4,\"843\":2,\"870\":4,\"880\":2,\"882\":2,\"897\":1,\"904\":1,\"960\":4,\"970\":16,\"971\":8,\"973\":2,\"984\":2,\"985\":2,\"994\":1,\"996\":1,\"1017\":1,\"1019\":3,\"1021\":6,\"1047\":1,\"1050\":4,\"1051\":1,\"1052\":5,\"1053\":7,\"1056\":3,\"1116\":1,\"1117\":2,\"1142\":3,\"1143\":2,\"1144\":3,\"1168\":2,\"1170\":4,\"1171\":12,\"1172\":5,\"1173\":10,\"1174\":9,\"1194\":5,\"1195\":3,\"1197\":3,\"1198\":3,\"1200\":1,\"1201\":9,\"1222\":5,\"1224\":3,\"1226\":1,\"1228\":2,\"1230\":4,\"1248\":2,\"1266\":7,\"1267\":2,\"1269\":1,\"1271\":10,\"1273\":2,\"1296\":1,\"1297\":1,\"1299\":3,\"1329\":3,\"1331\":5,\"1367\":2,\"1430\":1,\"1458\":2,\"1459\":3,\"1460\":7,\"1462\":8,\"1464\":2,\"1469\":1,\"1471\":5,\"1472\":12,\"1497\":8,\"1499\":6,\"1514\":1,\"1521\":3}}],[\"finally抛出异常后\",{\"1\":{\"34\":1}}],[\"finally\",{\"1\":{\"34\":2,\"113\":1,\"355\":1,\"793\":1,\"794\":1,\"797\":2,\"845\":1,\"860\":1,\"872\":1,\"915\":1,\"970\":1,\"971\":1,\"972\":2,\"1053\":1,\"1174\":1,\"1197\":1,\"1222\":1,\"1225\":1,\"1230\":1,\"1270\":1,\"1370\":2,\"1372\":1,\"1373\":1,\"1374\":1,\"1427\":1,\"1434\":1,\"1435\":2,\"1436\":2,\"1497\":1,\"1499\":1}}],[\"firstentryindex\",{\"1\":{\"1520\":4}}],[\"firstelement\",{\"1\":{\"998\":2}}],[\"firstly\",{\"1\":{\"1468\":1}}],[\"firstoffset=\",{\"1\":{\"1432\":1}}],[\"firstcommitlogoffset\",{\"1\":{\"1432\":6}}],[\"firstreq\",{\"1\":{\"1371\":3}}],[\"firstrt\",{\"1\":{\"1278\":4}}],[\"firstpos\",{\"1\":{\"1367\":3,\"1371\":2}}],[\"firstprocess\",{\"1\":{\"860\":4}}],[\"firstmsgoffset\",{\"1\":{\"1175\":5,\"1229\":2}}],[\"firstname\",{\"1\":{\"551\":5}}],[\"firstkey\",{\"1\":{\"396\":2,\"1170\":3}}],[\"first\",{\"1\":{\"101\":1,\"124\":1,\"125\":1,\"844\":1,\"971\":1,\"985\":1,\"1007\":1,\"1170\":2,\"1173\":1,\"1228\":2,\"1280\":2,\"1351\":2,\"1371\":1,\"1432\":1,\"1444\":1,\"1500\":1}}],[\"firsttype\",{\"1\":{\"48\":2}}],[\"filatappendfile\",{\"1\":{\"1386\":1}}],[\"fillopremovemap\",{\"1\":{\"1453\":1,\"1468\":2}}],[\"fill\",{\"1\":{\"765\":1,\"1430\":1}}],[\"fillpreblank\",{\"1\":{\"765\":1}}],[\"filtertopic\",{\"1\":{\"1427\":1}}],[\"filter=\",{\"1\":{\"1333\":1}}],[\"filterdatas\",{\"1\":{\"1332\":5}}],[\"filterdatabytopic\",{\"1\":{\"1331\":2}}],[\"filterdatamapbytopic\",{\"1\":{\"1331\":8}}],[\"filterdata\",{\"1\":{\"1323\":3,\"1332\":9}}],[\"filterexpressiontype\",{\"1\":{\"1307\":1,\"1310\":1}}],[\"filterexpression\",{\"1\":{\"1307\":4,\"1310\":4}}],[\"filterapi\",{\"1\":{\"1173\":1}}],[\"filtermessagehooklist\",{\"1\":{\"1122\":1}}],[\"filterserverlist\",{\"1\":{\"970\":2,\"971\":4}}],[\"filterserver\",{\"1\":{\"944\":1,\"949\":1,\"950\":1,\"968\":1,\"971\":1,\"1334\":1}}],[\"filterservertable\",{\"1\":{\"944\":1,\"949\":1,\"950\":1,\"953\":1,\"957\":1,\"968\":3,\"971\":3,\"972\":1,\"973\":1}}],[\"filterbitmap\",{\"1\":{\"825\":2,\"828\":2,\"1332\":4,\"1333\":4}}],[\"filter模式可以在运行期动态增加功能\",{\"1\":{\"55\":1}}],[\"filter\",{\"0\":{\"55\":1,\"325\":1,\"1301\":1},\"1\":{\"181\":3,\"184\":1,\"187\":4,\"325\":2,\"767\":1,\"949\":1,\"950\":1,\"968\":1,\"971\":1,\"1170\":1,\"1171\":1,\"1173\":6,\"1174\":2,\"1301\":1,\"1318\":1,\"1332\":3,\"1333\":2,\"1430\":1,\"1538\":1}}],[\"filemaxlength\",{\"1\":{\"1435\":3}}],[\"filetype\",{\"1\":{\"1428\":2}}],[\"filenotfoundexception\",{\"1\":{\"1079\":1}}],[\"filename=\",{\"1\":{\"1428\":1}}],[\"filename应当包含一个绝对或相对路径\",{\"1\":{\"211\":1}}],[\"filename2\",{\"1\":{\"151\":1}}],[\"filename1\",{\"1\":{\"151\":1}}],[\"filename\",{\"1\":{\"143\":1,\"154\":4,\"211\":1,\"793\":2,\"880\":1,\"999\":5}}],[\"fileabsolutepath\",{\"1\":{\"999\":3}}],[\"filehome\",{\"1\":{\"998\":2}}],[\"filefullpath\",{\"1\":{\"997\":4}}],[\"filefromoffset\",{\"1\":{\"737\":2,\"738\":2}}],[\"filewatchservice\",{\"1\":{\"961\":10,\"990\":1,\"996\":1}}],[\"filewriter实现了文件字符流输出\",{\"1\":{\"58\":1}}],[\"filelastmodifiedtime中记录的时间进行比较\",{\"1\":{\"999\":1}}],[\"filelastmodifiedtime\",{\"1\":{\"999\":7}}],[\"filelist\",{\"1\":{\"872\":3,\"998\":10,\"999\":8}}],[\"filelock\",{\"1\":{\"797\":13}}],[\"filereadwritelock\",{\"1\":{\"1434\":2,\"1435\":2,\"1436\":2}}],[\"filereader实现了文件字符流输入\",{\"1\":{\"57\":1}}],[\"fileregion\",{\"1\":{\"1173\":3}}],[\"filereservedtime\",{\"1\":{\"866\":1,\"870\":4,\"1075\":2}}],[\"file2\",{\"1\":{\"498\":1,\"499\":2,\"1368\":1}}],[\"file1\",{\"1\":{\"498\":1,\"499\":2,\"1368\":1}}],[\"filestatus\",{\"1\":{\"1412\":1,\"1434\":2,\"1435\":1,\"1436\":4}}],[\"filesegmentlist\",{\"1\":{\"1435\":3}}],[\"filesegmentinputstreamfactory\",{\"1\":{\"1428\":1}}],[\"filesegmentinputstream\",{\"1\":{\"1428\":14}}],[\"filesegmenttype\",{\"1\":{\"1427\":1,\"1428\":1}}],[\"filesegment\",{\"0\":{\"1428\":1},\"1\":{\"1382\":3,\"1386\":3,\"1387\":2,\"1395\":2,\"1402\":10,\"1403\":4,\"1410\":9,\"1411\":1,\"1412\":1,\"1415\":2,\"1417\":3,\"1419\":1,\"1420\":2,\"1421\":3,\"1427\":1,\"1428\":1,\"1435\":6,\"1436\":3}}],[\"filesize\",{\"1\":{\"880\":3,\"882\":3,\"1428\":3}}],[\"files\",{\"1\":{\"137\":1,\"171\":2,\"499\":1,\"643\":1,\"645\":1,\"793\":4,\"870\":6,\"872\":5,\"880\":1,\"998\":2,\"1001\":1}}],[\"file的形式注入\",{\"1\":{\"83\":1}}],[\"fileoutputstream\",{\"1\":{\"54\":1}}],[\"fileinputstream\",{\"1\":{\"53\":1,\"960\":1,\"1079\":7}}],[\"file对象表示一个文件或者目录\",{\"1\":{\"52\":1}}],[\"file\",{\"0\":{\"52\":1},\"1\":{\"165\":1,\"171\":7,\"195\":8,\"211\":2,\"213\":1,\"256\":1,\"259\":4,\"771\":5,\"793\":7,\"797\":1,\"845\":1,\"860\":1,\"862\":1,\"870\":2,\"880\":1,\"960\":6,\"998\":3,\"999\":4,\"1079\":1,\"1174\":1,\"1394\":2,\"1412\":2,\"1417\":2,\"1427\":2,\"1428\":1,\"1430\":1,\"1434\":4,\"1435\":6,\"1436\":4}}],[\"filechannel\",{\"0\":{\"910\":1},\"1\":{\"2\":1,\"118\":2,\"137\":4,\"797\":2,\"870\":1,\"880\":5,\"883\":1,\"886\":1,\"910\":1,\"911\":1,\"912\":1,\"917\":2}}],[\"fieldcache\",{\"1\":{\"995\":2}}],[\"fieldname\",{\"1\":{\"742\":5}}],[\"fields\",{\"1\":{\"253\":3,\"742\":18,\"891\":5,\"995\":7}}],[\"field\",{\"1\":{\"38\":4,\"43\":1,\"44\":1,\"99\":2,\"273\":1,\"606\":1,\"742\":19,\"995\":10}}],[\"和本地事务执行接口\",{\"1\":{\"1449\":1}}],[\"和返回结果的\",{\"1\":{\"1430\":1,\"1432\":1}}],[\"和写数据的\",{\"1\":{\"1387\":1}}],[\"和时间轮\",{\"1\":{\"1371\":2}}],[\"和过滤信息\",{\"1\":{\"1312\":1}}],[\"和每隔一段时间\",{\"1\":{\"1312\":1}}],[\"和属性\",{\"1\":{\"1303\":1}}],[\"和其逻辑偏移量\",{\"1\":{\"1294\":1}}],[\"和其他编辑器差不多\",{\"1\":{\"156\":1}}],[\"和其他跑在\",{\"1\":{\"2\":1}}],[\"和被存到磁盘\",{\"1\":{\"1262\":1}}],[\"和队列\",{\"1\":{\"1253\":1,\"1318\":1,\"1451\":1,\"1453\":1}}],[\"和队列的设计\",{\"1\":{\"1203\":1}}],[\"和重平衡线程\",{\"1\":{\"1129\":1}}],[\"和重载一个文件的配置\",{\"1\":{\"998\":1}}],[\"和普通消息\",{\"1\":{\"1260\":1}}],[\"和普通\",{\"1\":{\"1095\":1}}],[\"和广播消费\",{\"1\":{\"1088\":1}}],[\"和大多数消息队列一样\",{\"1\":{\"1088\":1}}],[\"和一个\",{\"1\":{\"1075\":1}}],[\"和多种特殊消息\",{\"1\":{\"1025\":1}}],[\"和多个\",{\"1\":{\"380\":1}}],[\"和消息是否在内存中这些信息来判断是否要走二级存储读取\",{\"1\":{\"1391\":1}}],[\"和消息存储在\",{\"1\":{\"1017\":1}}],[\"和消息的\",{\"1\":{\"767\":1}}],[\"和用户权限accounts\",{\"1\":{\"998\":1}}],[\"和用户权限\",{\"1\":{\"998\":1}}],[\"和用户名密码参数打包\",{\"1\":{\"989\":1,\"995\":1}}],[\"和处理线程池\",{\"1\":{\"947\":1,\"960\":1}}],[\"和它们最后一次上报心跳的时间\",{\"1\":{\"944\":1}}],[\"和偏移量\",{\"1\":{\"899\":1}}],[\"和当前已经投递的\",{\"1\":{\"868\":1}}],[\"和统计数据\",{\"1\":{\"858\":2}}],[\"和延迟等级对应的\",{\"1\":{\"834\":1}}],[\"和延迟情况\",{\"1\":{\"285\":1}}],[\"和短轮询\",{\"1\":{\"804\":1}}],[\"和内存映射\",{\"1\":{\"728\":1}}],[\"和内存的规格\",{\"1\":{\"648\":1}}],[\"和主从复制的流程\",{\"1\":{\"727\":1}}],[\"和4\",{\"1\":{\"720\":1}}],[\"和接收一次消息的\",{\"1\":{\"668\":1}}],[\"和所有\",{\"1\":{\"668\":1}}],[\"和磁盘空间的使用\",{\"1\":{\"662\":1}}],[\"和若干个从节点\",{\"1\":{\"649\":1}}],[\"和rabbit\",{\"1\":{\"623\":1}}],[\"和存值器\",{\"1\":{\"567\":1}}],[\"和元组\",{\"1\":{\"521\":1}}],[\"和bigint\",{\"1\":{\"508\":1}}],[\"和心智贯透\",{\"1\":{\"475\":1}}],[\"和铁钩\",{\"1\":{\"468\":1}}],[\"和奶要扛小蜘蛛的伤害\",{\"1\":{\"425\":1}}],[\"和奶比较危险时\",{\"1\":{\"405\":1}}],[\"和精通层数\",{\"1\":{\"415\":1}}],[\"和结界的时间\",{\"1\":{\"413\":1}}],[\"和执行器\",{\"1\":{\"372\":1}}],[\"和匿名函数不同的是内部的this是词法作用域\",{\"1\":{\"331\":1}}],[\"和map\",{\"1\":{\"327\":1}}],[\"和对应规模下集群的性能\",{\"1\":{\"285\":1}}],[\"和文档\",{\"1\":{\"271\":1}}],[\"和业务操作\",{\"1\":{\"125\":1}}],[\"和print\",{\"1\":{\"114\":1}}],[\"和sql相比\",{\"1\":{\"92\":1}}],[\"和send\",{\"1\":{\"73\":1}}],[\"和not\",{\"1\":{\"87\":1}}],[\"和端口号\",{\"1\":{\"71\":1}}],[\"和inputstream的区别是\",{\"1\":{\"57\":1}}],[\"和\",{\"0\":{\"23\":1,\"246\":1,\"247\":1,\"300\":1,\"513\":1,\"741\":1,\"910\":1,\"1068\":1},\"1\":{\"4\":2,\"9\":2,\"29\":1,\"34\":1,\"52\":1,\"118\":1,\"124\":2,\"125\":1,\"128\":1,\"130\":1,\"132\":3,\"136\":1,\"193\":1,\"194\":1,\"195\":1,\"212\":1,\"247\":1,\"248\":1,\"283\":1,\"285\":2,\"288\":1,\"294\":1,\"300\":1,\"372\":1,\"374\":1,\"399\":1,\"416\":1,\"422\":1,\"443\":1,\"448\":1,\"453\":1,\"455\":1,\"506\":1,\"606\":1,\"622\":1,\"632\":1,\"633\":1,\"637\":2,\"659\":1,\"673\":1,\"726\":1,\"741\":2,\"750\":1,\"751\":1,\"756\":1,\"764\":1,\"767\":1,\"781\":1,\"786\":1,\"787\":2,\"811\":1,\"815\":1,\"816\":1,\"825\":1,\"834\":3,\"836\":3,\"839\":4,\"843\":4,\"857\":1,\"864\":2,\"869\":2,\"877\":1,\"878\":1,\"879\":1,\"880\":2,\"884\":1,\"894\":1,\"900\":1,\"906\":1,\"915\":1,\"917\":1,\"932\":1,\"941\":1,\"944\":1,\"947\":1,\"951\":1,\"960\":1,\"961\":1,\"978\":2,\"987\":1,\"988\":2,\"994\":3,\"997\":1,\"998\":1,\"1021\":1,\"1036\":2,\"1037\":1,\"1040\":1,\"1072\":1,\"1102\":1,\"1109\":1,\"1110\":1,\"1117\":1,\"1119\":1,\"1144\":2,\"1147\":1,\"1203\":1,\"1224\":2,\"1245\":1,\"1253\":1,\"1259\":1,\"1261\":1,\"1263\":1,\"1279\":1,\"1299\":1,\"1318\":2,\"1346\":1,\"1348\":1,\"1350\":1,\"1360\":1,\"1362\":1,\"1363\":1,\"1371\":2,\"1374\":1,\"1383\":1,\"1386\":1,\"1395\":1,\"1400\":1,\"1402\":2,\"1403\":3,\"1412\":1,\"1420\":1,\"1421\":1,\"1425\":1,\"1463\":2,\"1468\":1,\"1469\":1,\"1482\":3,\"1509\":2,\"1510\":2,\"1519\":2,\"1520\":2,\"1537\":1,\"1538\":1}}],[\"和硬件在基准测试时执行优化\",{\"1\":{\"3\":1}}],[\"你需要多少个仲裁队列\",{\"1\":{\"702\":1}}],[\"你需要根据你要的功能性来修改天赋\",{\"1\":{\"403\":1}}],[\"你就可以在不同的集群多次消费消息\",{\"1\":{\"633\":1}}],[\"你可能看到\",{\"1\":{\"622\":1}}],[\"你可以在消费消息时判断一下订单的状态以确定是否需要关闭\",{\"1\":{\"921\":1,\"1337\":1}}],[\"你可以等待自动生成连击点\",{\"1\":{\"417\":1}}],[\"你可以指定集群cpu平均占用的预期值为\",{\"1\":{\"285\":1}}],[\"你可以使用`self`获取当前\",{\"1\":{\"230\":1}}],[\"你可以使用pid向进程发送消息\",{\"1\":{\"230\":1}}],[\"你可以使用它提供的一系列注解轻松地编写基准测试代码\",{\"1\":{\"3\":1}}],[\"你对任何仍在战斗中的敌人造成的威胁值将恢复\",{\"1\":{\"487\":1}}],[\"你通常应该优先穿装等更高的装备\",{\"1\":{\"476\":1}}],[\"你和脆皮\",{\"1\":{\"441\":1}}],[\"你刚好可以一次用森林再生\",{\"1\":{\"431\":1}}],[\"你应该优先把生命绽放放在受到伤害的目标上\",{\"1\":{\"415\":1}}],[\"你会给每个队友身上铺很多\",{\"1\":{\"413\":1}}],[\"你只需要担心会秒杀他的尖刺伤害\",{\"1\":{\"413\":1}}],[\"你只需要记忆一种方法\",{\"1\":{\"365\":1}}],[\"你在其身上的周期性治疗效果有4\",{\"1\":{\"405\":1}}],[\"你在写\",{\"1\":{\"2\":1}}],[\"你的技能之间可能会有很大的间隔\",{\"1\":{\"420\":1}}],[\"你的治疗效果会在之后的\",{\"1\":{\"409\":1}}],[\"你的移动速度提高10\",{\"1\":{\"407\":1}}],[\"你的生命值和护甲提高15\",{\"1\":{\"406\":1}}],[\"你的生命绽放可以同时在两个目标身上生效\",{\"1\":{\"405\":1}}],[\"你的周期性治疗效果的治疗速度提高10\",{\"1\":{\"405\":1}}],[\"你的林莽卫士每\",{\"1\":{\"401\":1}}],[\"你的林莽卫士激活时使你的回春术\",{\"1\":{\"401\":1}}],[\"你造成的治疗效果提高\",{\"1\":{\"401\":1}}],[\"你每有一个激活的林莽卫士\",{\"1\":{\"401\":1}}],[\"你将获得以下增益\",{\"1\":{\"401\":1}}],[\"你今年$\",{\"1\":{\"297\":1}}],[\"你今年\",{\"1\":{\"297\":1}}],[\"你好\",{\"1\":{\"297\":1}}],[\"但在以下情况下\",{\"1\":{\"1520\":1}}],[\"但在体现的效果上确实相同的\",{\"1\":{\"1338\":1}}],[\"但小于\",{\"1\":{\"1519\":1}}],[\"但还不一定全部成功响应\",{\"1\":{\"1510\":1}}],[\"但成功的没有超过半数\",{\"1\":{\"1499\":1}}],[\"但存在\",{\"1\":{\"1404\":1}}],[\"但任意时间定时消息不可能无限制地增加延迟时长对应的队列数量\",{\"1\":{\"1342\":1}}],[\"但现在已经被标记为\",{\"1\":{\"1300\":1}}],[\"但保证消费线程池顺序消费就可以实现顺序消费了吗\",{\"1\":{\"1208\":1}}],[\"但同时最多只有一个线程真正在执行消费\",{\"1\":{\"1207\":1}}],[\"但即便延迟等级时间间隔配置不足\",{\"1\":{\"1100\":1}}],[\"但下次发送消息时还会继续尝试\",{\"1\":{\"1041\":1}}],[\"但可靠性不如同步发送\",{\"1\":{\"1027\":1}}],[\"但也会增加消息保存时构建索引的时间\",{\"1\":{\"1325\":1}}],[\"但也要考虑大消息量和高\",{\"1\":{\"935\":1}}],[\"但也有人用户不同步镜像\",{\"1\":{\"678\":1}}],[\"但也有局限\",{\"0\":{\"277\":1}}],[\"但整体还是从旧到新有序读\",{\"1\":{\"878\":1}}],[\"但整个实验中没有出现数据丢失\",{\"1\":{\"284\":1}}],[\"但目前还并未解决\",{\"1\":{\"786\":1}}],[\"但这些消息还需要同步到其他副本\",{\"1\":{\"1403\":1}}],[\"但这带来了另一个问题\",{\"1\":{\"915\":1}}],[\"但这并不表示消息会被立刻持久化到磁盘中\",{\"1\":{\"768\":1}}],[\"但这个\",{\"1\":{\"622\":1}}],[\"但实际没有命令能调用\",{\"1\":{\"866\":1}}],[\"但实践往往要比理论复杂得多\",{\"1\":{\"736\":1}}],[\"但实现起来非常复杂\",{\"1\":{\"87\":1}}],[\"但每次处理消息都会触发一个异步的刷盘请求\",{\"1\":{\"735\":1}}],[\"但队列中的消息会消失\",{\"1\":{\"684\":1}}],[\"但当时的版本还未达到生产可用\",{\"1\":{\"1380\":1}}],[\"但当队列很长或者消息总大小很大的时候\",{\"1\":{\"678\":1}}],[\"但当这部分代码作为较大程序的一部分时可能无法应用这些优化\",{\"1\":{\"3\":1}}],[\"但为空\",{\"1\":{\"677\":1}}],[\"但镜像队列存在很大的局限性\",{\"1\":{\"648\":1}}],[\"但没有任何一个对应的队列处于flow状态时\",{\"1\":{\"622\":1}}],[\"但字面量类型有更高的优先级\",{\"1\":{\"563\":1}}],[\"但必须打断\",{\"1\":{\"428\":1}}],[\"但生命绽放的治疗效果降低10\",{\"1\":{\"405\":1}}],[\"但看别人双回春在\",{\"1\":{\"403\":1}}],[\"但触发不那么稳定\",{\"1\":{\"401\":1}}],[\"但那时候太小\",{\"1\":{\"399\":1}}],[\"但某种程度上也是萌新\",{\"1\":{\"399\":1}}],[\"但某个\",{\"1\":{\"384\":1}}],[\"但执行起来是异步的\",{\"1\":{\"354\":1}}],[\"但代码却和同步写法类似\",{\"1\":{\"354\":1}}],[\"但不期望这条消息马上被投递\",{\"1\":{\"920\":2}}],[\"但不利于区分类型和正常接口\",{\"1\":{\"592\":1}}],[\"但不能是大整数\",{\"1\":{\"583\":1}}],[\"但不会返回新的数组\",{\"1\":{\"327\":1}}],[\"但不包括索引3\",{\"1\":{\"298\":1}}],[\"但不包括runtimeexception及其子类\",{\"1\":{\"33\":1}}],[\"但一律返回undefined\",{\"1\":{\"297\":1}}],[\"但有了\",{\"1\":{\"271\":1}}],[\"但我们想使用一个表达式序列\",{\"1\":{\"205\":1}}],[\"但大多数是用erlang虚拟机里的底层操作实现的\",{\"1\":{\"185\":1}}],[\"但\",{\"1\":{\"118\":1,\"422\":1,\"1520\":1}}],[\"但它只负责触发\",{\"1\":{\"1129\":1}}],[\"但它内部新建了一个\",{\"1\":{\"741\":1}}],[\"但它的逻辑其实很简单\",{\"1\":{\"736\":1}}],[\"但它不仅仅局限于\",{\"1\":{\"118\":1}}],[\"但它可以访问outer的private静态字段和静态方法\",{\"1\":{\"22\":1}}],[\"但他们是两套独立的端口\",{\"1\":{\"71\":1}}],[\"但运行时由jdk或某个服务器提供\",{\"1\":{\"60\":1}}],[\"但运行时需要用到\",{\"1\":{\"60\":1}}],[\"但操作更加简单\",{\"1\":{\"52\":1}}],[\"但是发起拉票节点的\",{\"1\":{\"1503\":1}}],[\"但是发送性能最差\",{\"1\":{\"1027\":1}}],[\"但是主节点宕机之后从节点只能读不能写\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"但是列表前面的文件在写入完毕后会经过压缩\",{\"1\":{\"1386\":1}}],[\"但是无法及时用\",{\"1\":{\"1510\":1}}],[\"但是无法确定\",{\"1\":{\"1322\":1}}],[\"但是无法消费消息\",{\"1\":{\"1249\":1}}],[\"但是对消费者来说看到的是多个消费队列\",{\"1\":{\"1291\":1}}],[\"但是对于这个分组的运行来说\",{\"1\":{\"380\":1}}],[\"但是我们在可见之前提前使用\",{\"1\":{\"1251\":1}}],[\"但是我运行时三个\",{\"1\":{\"1079\":1}}],[\"但是processqueue已经太久没有拉取数据\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"但是由\",{\"1\":{\"1130\":1}}],[\"但是由于线程池内部为无界队列\",{\"1\":{\"1238\":1}}],[\"但是由于第二个提交依赖第一个所以只能放到一起\",{\"1\":{\"889\":1}}],[\"但是由于\",{\"1\":{\"840\":1}}],[\"但是并不会重投消费失败的消息\",{\"1\":{\"1090\":1}}],[\"但是并不是每条消息都会经历所有的子队列以及对应的生命周期\",{\"1\":{\"690\":1}}],[\"但是与集群的网络不通\",{\"1\":{\"1077\":1}}],[\"但是为取消消息专门创建一个文件来存储又太多余\",{\"1\":{\"935\":1}}],[\"但是会有很多工作量\",{\"1\":{\"931\":1}}],[\"但是如何删除已经投递的定时消息成为一个问题\",{\"1\":{\"928\":1}}],[\"但是如果上一次发送失败\",{\"1\":{\"1029\":1}}],[\"但是如果队列的消息堆积量很大\",{\"1\":{\"693\":1}}],[\"但是如果极限冲层还是要堆全能\",{\"1\":{\"476\":1}}],[\"但是一直存着不删也不行\",{\"1\":{\"928\":1}}],[\"但是一旦会打就稳过\",{\"1\":{\"443\":1}}],[\"但是往往在精度\",{\"1\":{\"922\":1}}],[\"但是更好的方法可以是使用消息队列发送一个延迟消息\",{\"1\":{\"921\":1,\"1337\":1}}],[\"但是更安全\",{\"1\":{\"237\":1}}],[\"但是这个队列仍有消息正在被消费\",{\"1\":{\"1215\":1}}],[\"但是这个订单也不可能一直开着\",{\"1\":{\"921\":1,\"1337\":1}}],[\"但是这种方案在主从同步时会有消息顺序不同的问题\",{\"1\":{\"930\":1}}],[\"但是这样的结构组成文件之后\",{\"1\":{\"1393\":1}}],[\"但是这样的话会让消息丢失的风险增加\",{\"1\":{\"693\":1}}],[\"但是这样可能带来另一个问题\",{\"1\":{\"1363\":1}}],[\"但是这样做会有一次额外的数据库操作\",{\"1\":{\"921\":1,\"1337\":1}}],[\"但是在内存中匹配\",{\"1\":{\"1259\":1}}],[\"但是在容器中获取的是容器的\",{\"1\":{\"1075\":1}}],[\"但是在实际使用中效果是完全相同的\",{\"1\":{\"920\":1}}],[\"但是在写\",{\"1\":{\"912\":1}}],[\"但是仅支持几个固定的延迟时间\",{\"1\":{\"919\":1}}],[\"但是其中有一个\",{\"1\":{\"890\":1}}],[\"但是又无法删除文件\",{\"1\":{\"870\":1}}],[\"但是原本并没有复用代码\",{\"1\":{\"731\":1}}],[\"但是哈希算法并不保证节点均匀分配到哈希换上\",{\"1\":{\"716\":1}}],[\"但是延迟也可能更高\",{\"1\":{\"704\":1}}],[\"但是仍有这样的危险存在\",{\"1\":{\"703\":1}}],[\"但是相对的\",{\"1\":{\"694\":1}}],[\"但是上游生产者仍然不停生产消息\",{\"1\":{\"693\":1}}],[\"但是有时\",{\"1\":{\"1510\":1}}],[\"但是有时有些队列有时会存在大量堆积\",{\"1\":{\"693\":1}}],[\"但是有没有更\",{\"1\":{\"2\":1}}],[\"但是它仍存在一个致命的问题\",{\"1\":{\"925\":1}}],[\"但是它是空的\",{\"1\":{\"693\":1}}],[\"但是它有一些设计上的缺陷\",{\"1\":{\"692\":1}}],[\"但是它的时间轴也是固定的\",{\"1\":{\"446\":1}}],[\"但是多节点的集群并不意味着有更好的可靠性\",{\"1\":{\"648\":1}}],[\"但是此处仍处于rabbit\",{\"1\":{\"624\":1}}],[\"但是此时并不会直接让上游进程的信用值加一\",{\"1\":{\"619\":1}}],[\"但是通过生产者确认的方式可以让发送消息不丢失\",{\"1\":{\"615\":1}}],[\"但是也有长至几分钟的\",{\"1\":{\"614\":1}}],[\"但是必须写成import\",{\"1\":{\"593\":1}}],[\"但是type可以\",{\"1\":{\"564\":1}}],[\"但是每一个\",{\"1\":{\"531\":1}}],[\"但是反过来不行\",{\"1\":{\"520\":1}}],[\"但是返回的不是字符串\",{\"1\":{\"518\":1}}],[\"但是很容易死人的\",{\"1\":{\"468\":1}}],[\"但是配合寒冰箭的\",{\"1\":{\"461\":1}}],[\"但是都会打的话还好\",{\"1\":{\"449\":1}}],[\"但是要实现高性能的定时消息投递\",{\"1\":{\"930\":1}}],[\"但是要知道这个天赋是正式服大米开始前就给出来的\",{\"1\":{\"403\":1}}],[\"但是要用职业选手的方式去练习\",{\"1\":{\"399\":1}}],[\"但是最终还是想打到\",{\"1\":{\"399\":1}}],[\"但是当\",{\"1\":{\"910\":1}}],[\"但是当一些\",{\"1\":{\"413\":1}}],[\"但是当节点数量发生变化时\",{\"1\":{\"385\":1}}],[\"但是当遇到更复杂\",{\"1\":{\"2\":1}}],[\"但是http协议的请求\",{\"1\":{\"368\":1}}],[\"但是数据却可以不断地更新\",{\"1\":{\"347\":1}}],[\"但是\",{\"1\":{\"48\":1,\"93\":1,\"501\":1,\"509\":1,\"556\":1,\"558\":1,\"564\":1,\"580\":1,\"681\":1}}],[\"的创建\",{\"0\":{\"1531\":1}}],[\"的底层存储实现\",{\"0\":{\"1528\":1}}],[\"的底层都是\",{\"1\":{\"880\":1}}],[\"的头尾\",{\"1\":{\"1520\":1}}],[\"的最小日志序号\",{\"1\":{\"1519\":2}}],[\"的最大日志序号\",{\"1\":{\"1509\":1,\"1519\":1,\"1520\":1}}],[\"的最大index\",{\"1\":{\"1508\":1}}],[\"的最大投票\",{\"1\":{\"1488\":1}}],[\"的最大\",{\"1\":{\"812\":1,\"872\":1}}],[\"的复制执行\",{\"1\":{\"1519\":1}}],[\"的已确认\",{\"1\":{\"1512\":1}}],[\"的水位表\",{\"1\":{\"1512\":1}}],[\"的水位线\",{\"1\":{\"1300\":1}}],[\"的响应\",{\"1\":{\"1510\":2}}],[\"的执行逻辑如下\",{\"1\":{\"1510\":1}}],[\"的执行线程\",{\"1\":{\"121\":1}}],[\"的入口\",{\"1\":{\"1509\":1}}],[\"的两个字段是定时持久化的\",{\"1\":{\"1508\":1}}],[\"的含义\",{\"1\":{\"1508\":1}}],[\"的含义是对应队列的权重\",{\"1\":{\"711\":1}}],[\"的私有字段\",{\"1\":{\"1508\":1}}],[\"的私有数据存储区域\",{\"1\":{\"217\":1}}],[\"的推送请求\",{\"1\":{\"1511\":1}}],[\"的推送的日志\",{\"1\":{\"1507\":1}}],[\"的推荐路线\",{\"1\":{\"462\":1}}],[\"的日志条目\",{\"1\":{\"1520\":1}}],[\"的日志条目接收器扫描待处理队列中的请求\",{\"1\":{\"1507\":1}}],[\"的日志超过了当前\",{\"1\":{\"1519\":1}}],[\"的日志带宽配额\",{\"1\":{\"1519\":1}}],[\"的日志序号\",{\"1\":{\"1519\":3}}],[\"的日志追加逻辑\",{\"1\":{\"1509\":1}}],[\"的日志追加实现类\",{\"1\":{\"1481\":1}}],[\"的日志转发线程将日志转发到\",{\"1\":{\"1507\":1}}],[\"的日志转发线程感知到日志转发请求完成后\",{\"1\":{\"1507\":1}}],[\"的日志转发请求\",{\"1\":{\"1507\":1}}],[\"的起始\",{\"1\":{\"1497\":1}}],[\"的起始偏移量\",{\"1\":{\"1270\":1}}],[\"的心跳\",{\"1\":{\"1497\":1}}],[\"的心跳请求后变为\",{\"1\":{\"1488\":1,\"1491\":1}}],[\"的心跳未断\",{\"1\":{\"1249\":1}}],[\"的选主逻辑与\",{\"1\":{\"1483\":1}}],[\"的选择\",{\"1\":{\"917\":1}}],[\"的主从同步主要是实现了\",{\"1\":{\"1477\":1}}],[\"的语义\",{\"1\":{\"1453\":1}}],[\"的服务线程\",{\"1\":{\"1453\":1}}],[\"的事务执行状态回查请求\",{\"1\":{\"1451\":1}}],[\"的事务执行结果处理逻辑会在以下两个情况下触发\",{\"1\":{\"1451\":1}}],[\"的事务实现方式为二阶段提交\",{\"1\":{\"1446\":1}}],[\"的事务消息在普通消息基础上\",{\"1\":{\"1439\":1}}],[\"的事件类型\",{\"1\":{\"125\":1}}],[\"的刷盘\",{\"1\":{\"1427\":1}}],[\"的跳表\",{\"1\":{\"1417\":1}}],[\"的形式存在\",{\"1\":{\"1411\":1}}],[\"的形式存储\",{\"1\":{\"1402\":1}}],[\"的形式存储了每个消息\",{\"1\":{\"927\":1}}],[\"的问题\",{\"1\":{\"1404\":2}}],[\"的缓存\",{\"1\":{\"1403\":1}}],[\"的元数据来构造\",{\"1\":{\"1421\":1}}],[\"的元数据和额外属性\",{\"1\":{\"1402\":1}}],[\"的元数据会被创建和持久化\",{\"1\":{\"1395\":1}}],[\"的元数据会上报到\",{\"1\":{\"1290\":1}}],[\"的偏移量\",{\"1\":{\"1402\":1}}],[\"的封装\",{\"1\":{\"1386\":2}}],[\"的浪潮下\",{\"1\":{\"1378\":1}}],[\"的演进目标之一是云原生化\",{\"1\":{\"1378\":1}}],[\"的污染\",{\"1\":{\"1364\":1}}],[\"的为定时消息投递的线程和队列\",{\"1\":{\"1353\":1}}],[\"的为定时消息保存的线程和队列\",{\"1\":{\"1353\":1}}],[\"的指针\",{\"1\":{\"1351\":1}}],[\"的延迟\",{\"1\":{\"1342\":1}}],[\"的延迟消息的原理简单来说是\",{\"1\":{\"1342\":1}}],[\"的延迟消息是两套实现机制\",{\"1\":{\"1338\":1}}],[\"的延迟消息性能被优化\",{\"1\":{\"1338\":1}}],[\"的延迟消息有很大的局限性\",{\"1\":{\"1338\":1}}],[\"的延迟消息\",{\"1\":{\"1100\":1}}],[\"的客户端中\",{\"1\":{\"1339\":1}}],[\"的不太一样\",{\"1\":{\"1323\":1}}],[\"的不同队列按照算法尽可能平均地分配给消费者组中的所有消费者\",{\"1\":{\"1097\":1}}],[\"的布隆过滤器实现与\",{\"1\":{\"1323\":1}}],[\"的二层过滤中\",{\"1\":{\"1322\":1}}],[\"的判断\",{\"1\":{\"1318\":2}}],[\"的有过滤条件的消费组\",{\"1\":{\"1315\":1}}],[\"的在\",{\"1\":{\"1300\":1}}],[\"的包\",{\"1\":{\"1300\":1}}],[\"的发送缓冲区\",{\"1\":{\"1300\":1}}],[\"的大小到达这个值后\",{\"1\":{\"1300\":1}}],[\"的大小由\",{\"1\":{\"1300\":1}}],[\"的大致流程\",{\"1\":{\"1300\":1}}],[\"的大部分准备工作\",{\"1\":{\"736\":1}}],[\"的文档\",{\"1\":{\"1299\":2}}],[\"的文件会修改读写指针\",{\"1\":{\"1520\":1}}],[\"的文件\",{\"1\":{\"872\":1,\"1413\":1}}],[\"的文件结构可以看作是一个可以无限扩展的数组\",{\"1\":{\"755\":1}}],[\"的文件里\",{\"1\":{\"180\":1}}],[\"的配置项\",{\"1\":{\"1308\":1}}],[\"的配置\",{\"1\":{\"1299\":1}}],[\"的场景\",{\"1\":{\"1290\":1}}],[\"的多级主题和\",{\"1\":{\"1284\":1}}],[\"的多种流控机制\",{\"0\":{\"612\":1}}],[\"的位\",{\"1\":{\"1278\":1}}],[\"的位置\",{\"1\":{\"426\":1}}],[\"的唤醒时间差大于\",{\"1\":{\"1278\":1}}],[\"的唤醒时间与第一个\",{\"1\":{\"1278\":1}}],[\"的概率拉取重试消息\",{\"1\":{\"1269\":1}}],[\"的概念\",{\"1\":{\"135\":1,\"339\":1,\"902\":1,\"1300\":1}}],[\"的开关默认是关闭的\",{\"1\":{\"1259\":1}}],[\"的随机整数\",{\"1\":{\"1257\":1}}],[\"的磁盘存储实际上就是\",{\"1\":{\"1253\":1}}],[\"的存在目的是与\",{\"1\":{\"1253\":1}}],[\"的存储实现\",{\"1\":{\"1397\":1}}],[\"的存储项是定长结构\",{\"1\":{\"1319\":1}}],[\"的存储\",{\"1\":{\"930\":1}}],[\"的存储文件主要分三种\",{\"1\":{\"863\":1}}],[\"的存储模型\",{\"1\":{\"701\":1}}],[\"的存储可以被分为两个部分\",{\"1\":{\"687\":1}}],[\"的存储设计与\",{\"1\":{\"681\":1}}],[\"的机制\",{\"1\":{\"1251\":1}}],[\"的一个队列\",{\"1\":{\"1259\":1}}],[\"的一个消费组可以订阅多个\",{\"1\":{\"1239\":1}}],[\"的一些验证和匹配逻辑\",{\"1\":{\"903\":1}}],[\"的情况\",{\"1\":{\"1237\":1,\"1520\":1}}],[\"的情况下你可以用万灵打伤害\",{\"1\":{\"405\":1}}],[\"的状态会被切换为\",{\"1\":{\"1510\":1}}],[\"的状态\",{\"1\":{\"1219\":1,\"1510\":1}}],[\"的做法是如果队列有消息正被消费\",{\"1\":{\"1215\":1}}],[\"的做成了懒初始化\",{\"1\":{\"736\":1}}],[\"的后面的数据都是处理失败的\",{\"1\":{\"1195\":1}}],[\"的哈希码过滤\",{\"1\":{\"1174\":1}}],[\"的变量\",{\"1\":{\"1168\":1}}],[\"的变量的方法\",{\"1\":{\"272\":1}}],[\"的映射关系\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"的订阅信息\",{\"1\":{\"1142\":1}}],[\"的订阅信息添加到\",{\"1\":{\"1120\":1,\"1122\":1}}],[\"的地方\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"的地方只有一个\",{\"1\":{\"1137\":1}}],[\"的地址列表\",{\"1\":{\"950\":1,\"968\":1}}],[\"的地址及文件长度\",{\"1\":{\"882\":1}}],[\"的基础上新实现了推模式和拉模式的重平衡实现\",{\"1\":{\"1129\":1}}],[\"的基本类型\",{\"1\":{\"506\":1}}],[\"的重平衡触发流程\",{\"1\":{\"1136\":1}}],[\"的重平衡在客户端\",{\"1\":{\"1131\":1}}],[\"的重平衡在消费端完成\",{\"1\":{\"1128\":1}}],[\"的重平衡流程在消费者端完成\",{\"1\":{\"1130\":1}}],[\"的重平衡大致实现方式为\",{\"1\":{\"1127\":1}}],[\"的重要组件之一\",{\"1\":{\"941\":1}}],[\"的容器中\",{\"1\":{\"1122\":1}}],[\"的启动流程如下\",{\"1\":{\"1120\":1}}],[\"的启动方法执行的动作如下\",{\"1\":{\"1120\":1}}],[\"的启动方法\",{\"1\":{\"1120\":1}}],[\"的启动方法内部实际是调用其代理类\",{\"1\":{\"1120\":1}}],[\"的启动类\",{\"1\":{\"960\":1}}],[\"的代理\",{\"1\":{\"1118\":1}}],[\"的代码并不多\",{\"1\":{\"944\":1}}],[\"的默认实现\",{\"1\":{\"1118\":1}}],[\"的拉取偏移量更新后再次调用\",{\"1\":{\"1119\":1}}],[\"的拉取请求唤醒\",{\"1\":{\"814\":1}}],[\"的拉\",{\"1\":{\"1117\":1}}],[\"的轻量化\",{\"1\":{\"1095\":1}}],[\"的业务逻辑中最复杂的一块\",{\"1\":{\"1086\":1}}],[\"的业务处理过程拆分到单独的\",{\"1\":{\"127\":1}}],[\"的控制台\",{\"1\":{\"1076\":1}}],[\"的监听端口\",{\"1\":{\"1075\":1}}],[\"的监控机制\",{\"1\":{\"372\":1}}],[\"的源码为例\",{\"1\":{\"1295\":1}}],[\"的源码\",{\"1\":{\"1072\":1,\"1235\":1}}],[\"的镜像\",{\"1\":{\"1071\":1}}],[\"的部署和配置较为复杂\",{\"1\":{\"1069\":1}}],[\"的网络地址\",{\"1\":{\"1053\":1}}],[\"的sendmessageasync\",{\"1\":{\"1040\":1}}],[\"的对象封装为任务放入\",{\"1\":{\"1300\":1}}],[\"的对象在javascript中称为\",{\"1\":{\"351\":1}}],[\"的对应关系\",{\"1\":{\"1036\":1}}],[\"的三个组件\",{\"1\":{\"1030\":1}}],[\"的具体队列\",{\"1\":{\"1029\":1}}],[\"的具体使用方式\",{\"1\":{\"1025\":1}}],[\"的停止状态\",{\"1\":{\"1021\":1}}],[\"的负载\",{\"1\":{\"1012\":1}}],[\"的负载过高从而导致了此种情形\",{\"1\":{\"622\":1}}],[\"的官方\",{\"1\":{\"1009\":1}}],[\"的现象\",{\"1\":{\"1003\":1}}],[\"的字段含义\",{\"0\":{\"997\":1}}],[\"的字节\",{\"1\":{\"882\":1}}],[\"的属性进行排序\",{\"1\":{\"995\":1}}],[\"的抽象基类\",{\"1\":{\"988\":1,\"994\":1}}],[\"的访问权限配置\",{\"1\":{\"979\":1}}],[\"的操作\",{\"1\":{\"978\":1}}],[\"的操作落在相同的节点上\",{\"1\":{\"384\":1}}],[\"的权限控制由客户端和\",{\"1\":{\"979\":1}}],[\"的权限\",{\"1\":{\"978\":1}}],[\"的返回体\",{\"1\":{\"973\":1}}],[\"的初始化\",{\"1\":{\"960\":1}}],[\"的连接\",{\"1\":{\"954\":1,\"972\":1}}],[\"的过程中可能会耗费额外的\",{\"1\":{\"1364\":1}}],[\"的过滤信息\",{\"1\":{\"1323\":1,\"1331\":1}}],[\"的过滤语法规则如下\",{\"1\":{\"1308\":1}}],[\"的过滤器\",{\"1\":{\"953\":1,\"971\":1}}],[\"的过期文件清理也由\",{\"1\":{\"872\":1}}],[\"的过期文件删除逻辑由一个线程统一处理\",{\"1\":{\"864\":1}}],[\"的过期文件删除机制会定期删除已经过期的存储文件\",{\"1\":{\"863\":1}}],[\"的所有数据\",{\"1\":{\"1519\":1}}],[\"的所有消息\",{\"1\":{\"1279\":1,\"1280\":1}}],[\"的所有消息队列\",{\"1\":{\"1137\":1}}],[\"的所有\",{\"1\":{\"1130\":1}}],[\"的所有队列\",{\"1\":{\"1453\":1,\"1468\":1}}],[\"的所有队列给第一个消费者\",{\"1\":{\"1097\":1}}],[\"的所有队列信息\",{\"1\":{\"952\":1}}],[\"的所有实现类\",{\"1\":{\"990\":1,\"996\":1}}],[\"的所有表达式都应该有值\",{\"1\":{\"188\":1}}],[\"的请求是否超时\",{\"1\":{\"1519\":2}}],[\"的请求处理线程接收和保存\",{\"1\":{\"1507\":1}}],[\"的请求处理方法\",{\"1\":{\"1482\":1}}],[\"的请求处理器\",{\"1\":{\"944\":1}}],[\"的请求\",{\"1\":{\"951\":1,\"978\":1,\"1519\":1}}],[\"的名称\",{\"1\":{\"949\":1}}],[\"的核心控制器\",{\"1\":{\"947\":1}}],[\"的实例\",{\"1\":{\"947\":1}}],[\"的实现大体可以分为两个部分\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"的实现思想是减少数据的重复存储\",{\"1\":{\"1291\":1}}],[\"的实现非常轻量级\",{\"1\":{\"942\":1}}],[\"的实现类\",{\"1\":{\"132\":1,\"729\":1}}],[\"的实现\",{\"1\":{\"131\":1,\"396\":1,\"874\":1,\"1382\":1}}],[\"的路由表\",{\"1\":{\"949\":1}}],[\"的路由信息\",{\"1\":{\"945\":2,\"972\":1,\"1029\":1,\"1053\":1}}],[\"的路径\",{\"1\":{\"272\":1}}],[\"的依赖移除\",{\"1\":{\"942\":1}}],[\"的动态注册与发现\",{\"1\":{\"941\":1}}],[\"的动作是同步的\",{\"1\":{\"850\":1}}],[\"的信息集\",{\"1\":{\"935\":1}}],[\"的信用值也将会耗尽\",{\"1\":{\"622\":1}}],[\"的信用值就会先一步耗尽\",{\"1\":{\"622\":1}}],[\"的普通消息存储\",{\"1\":{\"930\":1}}],[\"的和延迟\",{\"1\":{\"928\":1}}],[\"的精度我认为太差\",{\"1\":{\"927\":1}}],[\"的修改\",{\"1\":{\"913\":1}}],[\"的调用从\",{\"0\":{\"913\":1}}],[\"的长度\",{\"1\":{\"906\":1}}],[\"的扩容\",{\"1\":{\"906\":1}}],[\"的零拷贝\",{\"1\":{\"894\":1}}],[\"的性能\",{\"0\":{\"898\":1},\"1\":{\"894\":1}}],[\"的性能表现\",{\"1\":{\"874\":1}}],[\"的协议\",{\"1\":{\"893\":1}}],[\"的火焰图采样\",{\"1\":{\"887\":1}}],[\"的压力会比较大\",{\"1\":{\"883\":1}}],[\"的压力\",{\"1\":{\"883\":1}}],[\"的逻辑\",{\"0\":{\"989\":1,\"995\":1}}],[\"的逻辑会把这个\",{\"1\":{\"988\":1,\"994\":1}}],[\"的逻辑是\",{\"1\":{\"879\":1}}],[\"的逻辑还是与\",{\"1\":{\"123\":1}}],[\"的手段\",{\"0\":{\"875\":1}}],[\"的几种设计和原理\",{\"1\":{\"874\":1}}],[\"的设计是将它保存到\",{\"1\":{\"1450\":1}}],[\"的设计\",{\"1\":{\"874\":1}}],[\"的投递时间提前\",{\"1\":{\"1253\":1}}],[\"的投递\",{\"1\":{\"871\":1}}],[\"的条件检查逻辑\",{\"1\":{\"870\":1}}],[\"的清理方法\",{\"1\":{\"869\":1}}],[\"的内部类存在\",{\"1\":{\"1508\":1}}],[\"的内部类\",{\"1\":{\"869\":1}}],[\"的每个\",{\"1\":{\"867\":1,\"890\":1,\"1257\":1}}],[\"的删除比较复杂\",{\"1\":{\"864\":1}}],[\"的检查每\",{\"1\":{\"864\":1}}],[\"的消费位点\",{\"1\":{\"1253\":1}}],[\"的消费者的消费模式为\",{\"1\":{\"1248\":1}}],[\"的消费者组成了消费者组\",{\"1\":{\"1089\":1}}],[\"的消费还分并发消费和顺序消费\",{\"1\":{\"1177\":1}}],[\"的消费主要分推和拉两个模式\",{\"1\":{\"1147\":1}}],[\"的消费进度\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"的消费流程大致分成\",{\"1\":{\"1086\":1}}],[\"的消费可以算是\",{\"1\":{\"1086\":1}}],[\"的消费队列中专门开辟了\",{\"1\":{\"1319\":1}}],[\"的消费队列\",{\"1\":{\"836\":1}}],[\"的消息生产请求处理器\",{\"1\":{\"1450\":1}}],[\"的消息被分发到分级存储\",{\"1\":{\"1395\":1}}],[\"的消息加入时间轮\",{\"1\":{\"1371\":1}}],[\"的消息是有老化时间的\",{\"1\":{\"1343\":1}}],[\"的消息过滤逻辑\",{\"1\":{\"1318\":1}}],[\"的消息过滤接口messagefilter\",{\"1\":{\"1313\":1}}],[\"的消息分发构建消费索引时会构建\",{\"1\":{\"1293\":1}}],[\"的消息也作为\",{\"1\":{\"1277\":1}}],[\"的消息找到内存\",{\"1\":{\"1276\":1}}],[\"的消息偏移量\",{\"1\":{\"1270\":1}}],[\"的消息数量\",{\"1\":{\"1270\":1}}],[\"的消息数达到morecreditafter\",{\"1\":{\"621\":1}}],[\"的消息的逻辑偏移量\",{\"1\":{\"1270\":1}}],[\"的消息没有满\",{\"1\":{\"1257\":1}}],[\"的消息匹配\",{\"1\":{\"1253\":2}}],[\"的消息只要被消费者组中的一个消费者消费即可\",{\"1\":{\"1103\":1}}],[\"的消息进行重试\",{\"1\":{\"1263\":1}}],[\"的消息进行匹配和重试\",{\"1\":{\"1263\":1}}],[\"的消息进行\",{\"1\":{\"1053\":1}}],[\"的消息体中\",{\"1\":{\"1044\":1}}],[\"的消息执行\",{\"1\":{\"1042\":1}}],[\"的消息发送流程图如下图所示\",{\"1\":{\"1038\":1}}],[\"的消息时\",{\"1\":{\"927\":1}}],[\"的消息不是连续的\",{\"1\":{\"878\":1}}],[\"的消息重新转发\",{\"1\":{\"811\":1}}],[\"的消息在\",{\"1\":{\"747\":1}}],[\"的消息都保存在\",{\"1\":{\"747\":1}}],[\"的消息路由到相同的队列\",{\"1\":{\"708\":1}}],[\"的消息以队列维度存储\",{\"1\":{\"681\":1}}],[\"的消息\",{\"1\":{\"663\":1,\"674\":1,\"755\":1,\"921\":1,\"1188\":1,\"1251\":1,\"1270\":1,\"1279\":1,\"1280\":2,\"1307\":1,\"1337\":1}}],[\"的消息给rabbit\",{\"1\":{\"626\":1}}],[\"的索引文件\",{\"1\":{\"927\":1,\"1346\":1,\"1394\":1}}],[\"的索引\",{\"1\":{\"789\":1,\"794\":1}}],[\"的索引和消息\",{\"1\":{\"789\":1,\"794\":1}}],[\"的时间戳\",{\"1\":{\"1519\":1}}],[\"的时间间隔来执行其核心逻辑\",{\"1\":{\"999\":1}}],[\"的时间跨度\",{\"1\":{\"927\":1}}],[\"的时间占比大大减少\",{\"1\":{\"912\":1}}],[\"的时间\",{\"1\":{\"787\":1,\"1253\":1,\"1356\":1,\"1371\":1,\"1519\":1}}],[\"的时候效率就很高了\",{\"1\":{\"897\":1}}],[\"的时候直接就指定好\",{\"1\":{\"741\":1}}],[\"的时候是一个线程在写\",{\"1\":{\"733\":1}}],[\"的时候开减伤\",{\"1\":{\"467\":1}}],[\"的时候注意奶腐败之水点名的队友\",{\"1\":{\"467\":1}}],[\"的时候减伤\",{\"1\":{\"461\":1}}],[\"的时候尽量少移动\",{\"1\":{\"453\":1}}],[\"的时候要强刷中\",{\"1\":{\"448\":1}}],[\"的时候用\",{\"1\":{\"447\":1}}],[\"的时候奶过去\",{\"1\":{\"447\":1}}],[\"的时候你身上还有虚空腐蚀\",{\"1\":{\"441\":1}}],[\"的时候和\",{\"1\":{\"431\":1}}],[\"的时候性能达到最优\",{\"1\":{\"285\":1}}],[\"的时候\",{\"1\":{\"29\":1,\"425\":1,\"729\":1,\"1251\":1}}],[\"的结果\",{\"0\":{\"1521\":1}}],[\"的结果后就将结果返回给上层客户端\",{\"1\":{\"1509\":1}}],[\"的结果后返回给客户端\",{\"1\":{\"1507\":1}}],[\"的结果仲裁线程仲裁日志在所有节点保存的状态\",{\"1\":{\"1507\":1}}],[\"的结果距离最近的节点作为哈希的结果\",{\"1\":{\"387\":1}}],[\"的结构\",{\"1\":{\"786\":1}}],[\"的格式存储在\",{\"1\":{\"1420\":1}}],[\"的格式\",{\"1\":{\"773\":1,\"1412\":1}}],[\"的新消息被保存到\",{\"1\":{\"765\":1}}],[\"的物理偏移量\",{\"1\":{\"765\":1}}],[\"的保存方法\",{\"1\":{\"764\":1}}],[\"的构建入口是reputmessageservice\",{\"1\":{\"761\":1}}],[\"的构造函数中会调用\",{\"1\":{\"1421\":1}}],[\"的构造函数\",{\"1\":{\"342\":1}}],[\"的某个\",{\"1\":{\"747\":1}}],[\"的目的主要是适应消息的检索需求\",{\"1\":{\"747\":1}}],[\"的目标\",{\"1\":{\"1348\":1,\"1357\":1}}],[\"的目标规划和使用你的治疗手牌\",{\"1\":{\"426\":1}}],[\"的目标释放愈合\",{\"1\":{\"411\":1}}],[\"的目标队列\",{\"1\":{\"396\":1}}],[\"的作用是在收到消息时提醒消费者\",{\"1\":{\"914\":1}}],[\"的作用\",{\"0\":{\"747\":1}}],[\"的通信协议定义了各种指令\",{\"1\":{\"742\":1,\"890\":1}}],[\"的计算方法\",{\"1\":{\"738\":1}}],[\"的生成方法和使用可以看丁威老师的\",{\"1\":{\"899\":1}}],[\"的生成涉及很多编解码和数据复制工作\",{\"1\":{\"736\":1}}],[\"的生命值\",{\"1\":{\"421\":1}}],[\"的引用\",{\"1\":{\"724\":1,\"1405\":1}}],[\"的分级存储文件\",{\"1\":{\"1421\":1}}],[\"的分布式数据库\",{\"1\":{\"716\":1}}],[\"的分区从\",{\"1\":{\"285\":1}}],[\"的队列都拆分单独一组的\",{\"1\":{\"1383\":1}}],[\"的队列都单独有\",{\"1\":{\"1383\":1}}],[\"的队列上锁\",{\"1\":{\"1258\":1}}],[\"的队列数设为\",{\"1\":{\"1203\":1}}],[\"的队列数量设为\",{\"1\":{\"1028\":1}}],[\"的队列进行重平衡\",{\"1\":{\"1142\":1}}],[\"的队列和它们所在的\",{\"1\":{\"1029\":1}}],[\"的队列\",{\"1\":{\"954\":1,\"972\":2,\"1271\":1,\"1284\":1,\"1453\":1}}],[\"的队列列表\",{\"1\":{\"950\":1}}],[\"的队列信息\",{\"1\":{\"944\":1}}],[\"的队列只能存在于一个节点\",{\"1\":{\"707\":1}}],[\"的队列消费消息\",{\"1\":{\"669\":1}}],[\"的中断或者变慢可能导致多个队列消息堆积\",{\"1\":{\"702\":1}}],[\"的仲裁队列将会有\",{\"1\":{\"695\":1}}],[\"的进程中\",{\"1\":{\"668\":1}}],[\"的进程\",{\"1\":{\"668\":1}}],[\"的进程号\",{\"1\":{\"624\":1,\"626\":1}}],[\"的标志\",{\"1\":{\"665\":1}}],[\"的标签页\",{\"1\":{\"154\":1}}],[\"的匹配规则\",{\"1\":{\"655\":1}}],[\"的吞吐量\",{\"1\":{\"648\":1}}],[\"的版本\",{\"1\":{\"644\":1}}],[\"的版本代号\",{\"1\":{\"644\":1}}],[\"的阻塞解除\",{\"1\":{\"627\":1}}],[\"的处理线程池中处理异步请求完成的回调\",{\"1\":{\"1165\":1}}],[\"的处理流程\",{\"1\":{\"1024\":1}}],[\"的处理\",{\"1\":{\"736\":1}}],[\"的处理进程\",{\"1\":{\"621\":4}}],[\"的处理能够跟上生产速度\",{\"1\":{\"611\":1}}],[\"的module\",{\"1\":{\"596\":1}}],[\"的专用模块格式\",{\"1\":{\"594\":1}}],[\"的合并\",{\"0\":{\"584\":1}}],[\"的定时消息\",{\"1\":{\"1370\":1}}],[\"的定时消息实现为我们提供了很好的参照\",{\"1\":{\"932\":1}}],[\"的定时消息也是取舍之后的产物\",{\"1\":{\"925\":1}}],[\"的定时消息之前\",{\"1\":{\"925\":1}}],[\"的定时消息受到\",{\"1\":{\"833\":1}}],[\"的定位是\",{\"1\":{\"582\":1}}],[\"的定义\",{\"1\":{\"191\":1}}],[\"的异同\",{\"0\":{\"564\":1}}],[\"的异常\",{\"0\":{\"33\":1},\"1\":{\"34\":1}}],[\"的继承\",{\"0\":{\"559\":1}}],[\"的数据\",{\"1\":{\"1410\":1,\"1420\":1,\"1519\":1}}],[\"的数据与\",{\"1\":{\"1379\":1}}],[\"的数据版本号发生变更\",{\"1\":{\"945\":1}}],[\"的数据不会丢失\",{\"1\":{\"883\":1}}],[\"的数组所有成员类型必须相同\",{\"1\":{\"522\":1}}],[\"的数量\",{\"1\":{\"118\":1}}],[\"的特殊性\",{\"0\":{\"513\":1}}],[\"的特性和工具\",{\"1\":{\"118\":1}}],[\"的8种类型之中\",{\"1\":{\"508\":1}}],[\"的编译\",{\"0\":{\"497\":1}}],[\"的编码是0x31\",{\"1\":{\"27\":1}}],[\"的编码是0x41\",{\"1\":{\"27\":1}}],[\"的界面截图\",{\"1\":{\"491\":1}}],[\"的神话装备\",{\"1\":{\"484\":1}}],[\"的狂暴状态\",{\"1\":{\"458\":1}}],[\"的球留给老二\",{\"1\":{\"455\":1}}],[\"的人\",{\"1\":{\"448\":2}}],[\"的血\",{\"1\":{\"445\":1}}],[\"的效果是消息的负载均衡\",{\"1\":{\"634\":1}}],[\"的效果\",{\"1\":{\"421\":1}}],[\"的效果对周围一名受伤的盟友施放滋养\",{\"1\":{\"405\":1}}],[\"的提升会直接增加当前你属性\",{\"1\":{\"421\":1}}],[\"的预铺手法是如下\",{\"1\":{\"411\":1}}],[\"的星涌和愤怒\",{\"1\":{\"403\":1}}],[\"的经验来看都是奶的过去的\",{\"1\":{\"401\":1}}],[\"的治疗效果加成\",{\"1\":{\"401\":1}}],[\"的治疗\",{\"1\":{\"401\":1}}],[\"的玩家了\",{\"1\":{\"399\":1}}],[\"的阶段是负反馈最多的阶段\",{\"1\":{\"399\":1}}],[\"的打法到\",{\"1\":{\"399\":1}}],[\"的低保\",{\"1\":{\"399\":1}}],[\"的范围\",{\"1\":{\"387\":1}}],[\"的范围中\",{\"1\":{\"387\":1}}],[\"的任务\",{\"1\":{\"372\":1}}],[\"的职责\",{\"1\":{\"372\":1}}],[\"的原型指向对象\",{\"1\":{\"339\":1}}],[\"的全局对象\",{\"1\":{\"312\":1}}],[\"的组件单独创建用户\",{\"1\":{\"635\":1}}],[\"的组合\",{\"1\":{\"294\":1}}],[\"的组织将实施混沌工程实践\",{\"1\":{\"276\":1}}],[\"的上下文进行调用才是我们想要的\",{\"1\":{\"272\":1}}],[\"的触发入口一层一层调用过来\",{\"1\":{\"270\":1}}],[\"的前身\",{\"1\":{\"255\":1}}],[\"的系统负载\",{\"1\":{\"255\":1}}],[\"的键\",{\"1\":{\"217\":1}}],[\"的表达式时会展开这个宏\",{\"1\":{\"213\":1}}],[\"的副本\",{\"1\":{\"191\":1}}],[\"的简称\",{\"1\":{\"191\":1}}],[\"的写是不可扩展的\",{\"1\":{\"942\":1}}],[\"的写入\",{\"0\":{\"1532\":1},\"1\":{\"912\":1}}],[\"的写入和\",{\"1\":{\"912\":1}}],[\"的写法是\",{\"1\":{\"184\":1}}],[\"的写方法\",{\"1\":{\"135\":1}}],[\"的函数\",{\"1\":{\"181\":1}}],[\"的模块加载方法\",{\"1\":{\"600\":1}}],[\"的模式相匹配\",{\"1\":{\"173\":1}}],[\"的模拟\",{\"1\":{\"118\":1}}],[\"的值超过\",{\"1\":{\"688\":1}}],[\"的值就通过执行匹配模式之后的表达式序列得出\",{\"1\":{\"194\":1}}],[\"的值\",{\"1\":{\"173\":1}}],[\"的真正意思是\",{\"1\":{\"173\":1}}],[\"的运行结果\",{\"1\":{\"497\":1}}],[\"的运行逻辑\",{\"1\":{\"132\":1}}],[\"的运转架构\",{\"1\":{\"136\":1}}],[\"的线程来执行\",{\"1\":{\"135\":1}}],[\"的注册信息发生变化\",{\"1\":{\"124\":1}}],[\"的注解\",{\"1\":{\"6\":1}}],[\"的附加属性中\",{\"1\":{\"124\":1}}],[\"的类型声明方法是\",{\"1\":{\"547\":1}}],[\"的类型是\",{\"1\":{\"514\":2}}],[\"的类型设计\",{\"1\":{\"506\":1}}],[\"的类型\",{\"1\":{\"121\":1}}],[\"的顺序串行处理\",{\"1\":{\"116\":1}}],[\"的方向走一步\",{\"1\":{\"425\":1}}],[\"的方式再次哈希\",{\"1\":{\"797\":1}}],[\"的方式来触发定时消息的取消\",{\"1\":{\"935\":1}}],[\"的方式来指定消息整体大小小于某个值时会只保存到队列索引中\",{\"1\":{\"687\":1}}],[\"的方式来处理连接\",{\"1\":{\"114\":1}}],[\"的方式可以将消息设置为持久化的\",{\"1\":{\"685\":1}}],[\"的方式可以将队列设置为持久化\",{\"1\":{\"684\":1}}],[\"的方式指定\",{\"1\":{\"660\":1}}],[\"的方式监听阻塞和阻塞解除的事件\",{\"1\":{\"613\":1}}],[\"的方式启动项目\",{\"1\":{\"273\":1}}],[\"的方式启动\",{\"1\":{\"224\":1}}],[\"的方法将客户端\",{\"1\":{\"899\":1}}],[\"的方法中\",{\"1\":{\"730\":1}}],[\"的方法\",{\"1\":{\"118\":1,\"915\":1,\"1136\":1,\"1187\":1}}],[\"的方法会被进行基准测试\",{\"1\":{\"9\":1}}],[\"的加载\",{\"1\":{\"44\":1}}],[\"的本质是数据类型\",{\"1\":{\"36\":1}}],[\"的gb2312编码是0xd6d0\",{\"1\":{\"27\":1}}],[\"的\",{\"0\":{\"602\":1,\"603\":1,\"1084\":1,\"1521\":1},\"1\":{\"10\":1,\"108\":1,\"118\":1,\"122\":1,\"124\":2,\"128\":2,\"133\":2,\"135\":2,\"252\":1,\"266\":1,\"271\":1,\"298\":1,\"372\":1,\"405\":1,\"412\":1,\"428\":1,\"443\":1,\"593\":1,\"636\":2,\"638\":1,\"707\":1,\"726\":1,\"728\":1,\"746\":1,\"755\":1,\"756\":1,\"786\":1,\"787\":1,\"793\":1,\"797\":2,\"805\":2,\"812\":1,\"814\":1,\"840\":1,\"850\":1,\"871\":1,\"877\":1,\"878\":1,\"887\":1,\"890\":1,\"894\":5,\"896\":1,\"897\":1,\"935\":1,\"941\":1,\"942\":1,\"952\":1,\"953\":1,\"954\":1,\"971\":2,\"976\":1,\"983\":1,\"988\":1,\"990\":1,\"991\":2,\"994\":1,\"1017\":2,\"1025\":1,\"1029\":1,\"1043\":1,\"1053\":1,\"1069\":1,\"1077\":1,\"1081\":1,\"1119\":1,\"1126\":1,\"1155\":1,\"1188\":3,\"1191\":3,\"1195\":1,\"1203\":1,\"1253\":1,\"1271\":1,\"1277\":1,\"1278\":1,\"1284\":1,\"1300\":4,\"1317\":1,\"1318\":1,\"1319\":2,\"1331\":1,\"1395\":1,\"1402\":3,\"1403\":3,\"1405\":1,\"1410\":2,\"1415\":1,\"1421\":1,\"1427\":1,\"1430\":1,\"1432\":1,\"1436\":2,\"1440\":1,\"1446\":2,\"1449\":1,\"1450\":1,\"1451\":2,\"1463\":1,\"1509\":1,\"1511\":7,\"1512\":1,\"1517\":1,\"1519\":3,\"1520\":3,\"1521\":1}}],[\"的意义\",{\"0\":{\"3\":1}}],[\"的缩写\",{\"1\":{\"2\":1,\"118\":1}}],[\"的工具\",{\"1\":{\"2\":1}}],[\"是正常情况\",{\"1\":{\"1520\":1}}],[\"是日志最后写入时的投票轮次\",{\"1\":{\"1492\":1}}],[\"是日志存储类\",{\"1\":{\"1481\":1}}],[\"是基于\",{\"1\":{\"1475\":1,\"1506\":1}}],[\"是事务消息\",{\"1\":{\"1462\":1}}],[\"是事务消息二阶段处理线程大小\",{\"1\":{\"734\":1}}],[\"是创建时间\",{\"1\":{\"1412\":1}}],[\"是分级存储\",{\"1\":{\"1410\":1}}],[\"是分级存储消息分发器的实现\",{\"1\":{\"1403\":1}}],[\"是分级存储中文件的句柄\",{\"1\":{\"1386\":1}}],[\"是可写的\",{\"1\":{\"1402\":1}}],[\"是可视化的分割区域\",{\"1\":{\"153\":1}}],[\"是零个或多个定长\",{\"1\":{\"1402\":1}}],[\"是以队列维度保存的\",{\"1\":{\"1402\":1}}],[\"是该队列的分级存储文件\",{\"1\":{\"1402\":1}}],[\"是该队列挂起的所有拉取请求\",{\"1\":{\"815\":1}}],[\"是队列\",{\"1\":{\"1402\":1}}],[\"是头插法构造成的一个链表\",{\"1\":{\"1386\":1}}],[\"是由所有队列的消息数据构成的文件\",{\"1\":{\"1386\":1}}],[\"是由一组\",{\"1\":{\"876\":1}}],[\"是时间轮的抽象\",{\"1\":{\"1346\":1}}],[\"是时间戳\",{\"1\":{\"1346\":1}}],[\"是主要的解析器类\",{\"1\":{\"1321\":1}}],[\"是因为\",{\"1\":{\"1319\":1}}],[\"是资源密集型的\",{\"1\":{\"1290\":1}}],[\"是第一次拉取\",{\"1\":{\"1228\":1}}],[\"是定时消息文件\",{\"1\":{\"1346\":1}}],[\"是定时消息\",{\"1\":{\"1188\":1}}],[\"是消息在队列中的逻辑偏移量\",{\"1\":{\"1155\":1}}],[\"是消费队列文件\",{\"1\":{\"867\":1}}],[\"是拉取到的消息\",{\"1\":{\"1155\":1}}],[\"是拉取请求的队列\",{\"1\":{\"815\":1}}],[\"是拉消费者接口\",{\"1\":{\"1118\":1}}],[\"是不可能达成\",{\"1\":{\"1102\":1}}],[\"是需要构建的\",{\"1\":{\"1072\":1}}],[\"是发送消息处理线程池\",{\"1\":{\"1055\":1}}],[\"是为自动创建主题运用的\",{\"1\":{\"1039\":1}}],[\"是为了根据\",{\"1\":{\"1393\":1}}],[\"是为了修复在slave中consumequeue异常恢复慢的问题\",{\"1\":{\"1297\":1}}],[\"是为了防止全局配置在未解析完全的情况下被读取\",{\"1\":{\"998\":1}}],[\"是为了提供按照\",{\"1\":{\"778\":1}}],[\"是与\",{\"1\":{\"1036\":1}}],[\"是存储内部使用的\",{\"1\":{\"1035\":1}}],[\"是专门用来异步发送轨迹消息的异步转发器\",{\"1\":{\"1021\":1}}],[\"是最佳的选择\",{\"1\":{\"1010\":1}}],[\"是文件中包含的权限配置\",{\"1\":{\"997\":1}}],[\"是文件路径\",{\"1\":{\"997\":1}}],[\"是用来保存事务半消息的操作结果的\",{\"1\":{\"1453\":1}}],[\"是用来管理配置的\",{\"1\":{\"1190\":1}}],[\"是用来监听文件变化执行回调函数的\",{\"1\":{\"961\":1}}],[\"是用来与\",{\"1\":{\"950\":1}}],[\"是用于列表添加和移除的中缀操作符\",{\"1\":{\"212\":1}}],[\"是用于增强模式匹配的结构\",{\"1\":{\"186\":1}}],[\"是用于处理客户端连接的组件\",{\"1\":{\"118\":1}}],[\"是除了\",{\"1\":{\"941\":1}}],[\"是组成\",{\"1\":{\"941\":1}}],[\"是有机会在其投递之前\",{\"1\":{\"935\":1}}],[\"是阿里孵化的\",{\"1\":{\"919\":1}}],[\"是弱一致的\",{\"1\":{\"915\":1}}],[\"是利用\",{\"1\":{\"912\":1}}],[\"是协议头\",{\"1\":{\"890\":1}}],[\"是操作系统的特性\",{\"1\":{\"879\":1}}],[\"是如何做到这么高的性能的呢\",{\"1\":{\"874\":1}}],[\"是满足删除文件的时间\",{\"1\":{\"870\":1}}],[\"是索引文件操作的入口\",{\"1\":{\"789\":1}}],[\"是类似\",{\"1\":{\"786\":1}}],[\"是数量可无限扩展的映射文件\",{\"1\":{\"749\":1}}],[\"是非常低效的\",{\"1\":{\"747\":1}}],[\"是什么\",{\"0\":{\"746\":1,\"941\":1}}],[\"是个拼接出来的字符串\",{\"1\":{\"736\":1}}],[\"是异步刷盘\",{\"1\":{\"735\":1}}],[\"是内存映射文件\",{\"1\":{\"728\":1,\"1319\":1}}],[\"是完全自定义的\",{\"1\":{\"890\":1}}],[\"是完全合理的\",{\"1\":{\"662\":1}}],[\"是完全可以奶的\",{\"1\":{\"403\":1}}],[\"是特殊的类方法\",{\"1\":{\"567\":1}}],[\"是object类型的简写形式\",{\"1\":{\"511\":1}}],[\"是堆全能\",{\"1\":{\"476\":1}}],[\"是比较适合输出的一个本\",{\"1\":{\"455\":1}}],[\"是没有点萌芽之叶\",{\"1\":{\"455\":1}}],[\"是来不及预铺的\",{\"1\":{\"448\":1}}],[\"是在\",{\"1\":{\"1212\":1}}],[\"是在原来持续时间的基础上延长\",{\"1\":{\"419\":1}}],[\"是在本地还是远程\",{\"1\":{\"372\":1}}],[\"是虚拟节点\",{\"1\":{\"391\":1}}],[\"是长整型\",{\"1\":{\"391\":1}}],[\"是每一个执行器节点中负责具体执行任务的角色\",{\"1\":{\"372\":1}}],[\"是每一个执行器节点中负责执行器管理的角色\",{\"1\":{\"372\":1}}],[\"是每一个任务的主节点\",{\"1\":{\"372\":1}}],[\"是匿名函数的一种简写\",{\"1\":{\"331\":1}}],[\"是执行的流程的基本单元\",{\"1\":{\"280\":1}}],[\"是两个系统模块\",{\"1\":{\"247\":1}}],[\"是指单一或一系列的关卡\",{\"1\":{\"186\":1}}],[\"是指应用程序的组件无需实现spring的特定接口\",{\"1\":{\"81\":1}}],[\"是值才为\",{\"1\":{\"186\":1}}],[\"是自动导入的\",{\"1\":{\"185\":1}}],[\"是那些作为erlang语言定义一部分的函数\",{\"1\":{\"185\":1}}],[\"是中缀插入操作符\",{\"1\":{\"184\":1}}],[\"是任一表达式\",{\"1\":{\"184\":1}}],[\"是无需使用fun\",{\"1\":{\"184\":1}}],[\"是函数式编程语言\",{\"1\":{\"181\":1}}],[\"是否自身发送的投票请求\",{\"1\":{\"1503\":1}}],[\"是否已经存在\",{\"1\":{\"1497\":1}}],[\"是否已被消费者\",{\"1\":{\"687\":1}}],[\"是否已被交付给消费者\",{\"1\":{\"687\":1}}],[\"是否已被注册\",{\"1\":{\"234\":1}}],[\"是否大于等于\",{\"1\":{\"1403\":1}}],[\"是否取到消息\",{\"1\":{\"1370\":1}}],[\"是否通过过滤\",{\"1\":{\"1333\":1}}],[\"是否启用布隆过滤器\",{\"0\":{\"1325\":1}}],[\"是否启动内存\",{\"1\":{\"1067\":1}}],[\"是否需要分发\",{\"1\":{\"1297\":1}}],[\"是否要截断\",{\"1\":{\"1510\":1}}],[\"是否要从内存中移除\",{\"1\":{\"1277\":1}}],[\"是否要将数据同步到这个队列\",{\"1\":{\"693\":1}}],[\"是否匹配成功\",{\"1\":{\"1276\":1}}],[\"是否添加成功\",{\"1\":{\"1275\":1}}],[\"是否是取消定时消息\",{\"1\":{\"1371\":1}}],[\"是否是重试\",{\"1\":{\"1270\":1}}],[\"是否是内存\",{\"1\":{\"1061\":2,\"1066\":1}}],[\"是否继续本次消费请求的消费任务\",{\"1\":{\"1230\":1}}],[\"是否锁定成功\",{\"1\":{\"1226\":1}}],[\"是否顺序消费\",{\"1\":{\"1224\":1}}],[\"是否仍由该消费者负载该队列\",{\"1\":{\"1218\":1}}],[\"是否丢弃\",{\"1\":{\"1195\":1}}],[\"是否挂起\",{\"1\":{\"1173\":1}}],[\"是否存在\",{\"1\":{\"1030\":1,\"1198\":1,\"1279\":1,\"1499\":1,\"1520\":1}}],[\"是否存在key\",{\"1\":{\"301\":1}}],[\"是否发生变化\",{\"1\":{\"999\":1}}],[\"是否监听\",{\"1\":{\"997\":1}}],[\"是否在用户维度的白名单中\",{\"1\":{\"991\":1,\"1000\":1}}],[\"是否在全局白名单中\",{\"1\":{\"991\":1,\"1000\":1}}],[\"是否管理员账户\",{\"1\":{\"983\":1}}],[\"是否还存活\",{\"1\":{\"941\":1}}],[\"是否支持取消\",{\"1\":{\"922\":1}}],[\"是否支持挂起和是否开启长轮询来判断是否要进行轮询以及进行哪种轮询\",{\"1\":{\"806\":1}}],[\"是否合法\",{\"1\":{\"904\":1,\"1047\":1}}],[\"是否使用\",{\"1\":{\"903\":1}}],[\"是否初始化\",{\"1\":{\"903\":1}}],[\"是否强制删除文件\",{\"1\":{\"870\":1}}],[\"是否立即强制删除文件\",{\"1\":{\"870\":1}}],[\"是否有推送消息的时间戳\",{\"1\":{\"1520\":1}}],[\"是否有\",{\"1\":{\"837\":1}}],[\"是否有一种更为现代化的工具\",{\"1\":{\"276\":1}}],[\"是否成立\",{\"1\":{\"815\":1}}],[\"是否成功\",{\"1\":{\"765\":1,\"1371\":1}}],[\"是否写满\",{\"1\":{\"793\":1}}],[\"是否同步镜像\",{\"1\":{\"677\":1}}],[\"是否断开连接\",{\"1\":{\"125\":1}}],[\"是否准备好进行读取或写入\",{\"1\":{\"118\":1}}],[\"是一种轻量级进程\",{\"1\":{\"619\":1}}],[\"是一种全局唯一的erlang数据类型\",{\"1\":{\"218\":1}}],[\"是一种结构\",{\"1\":{\"186\":1}}],[\"是一种设计模式\",{\"1\":{\"119\":1}}],[\"是一次性赋值变量\",{\"1\":{\"173\":1}}],[\"是一个服务线程\",{\"1\":{\"1402\":1}}],[\"是一个能生成语法和词法分析器的生成程序\",{\"1\":{\"1321\":1}}],[\"是一个简单的\",{\"1\":{\"941\":1}}],[\"是一个低延迟\",{\"1\":{\"874\":1,\"1529\":1}}],[\"是一个\",{\"1\":{\"746\":1}}],[\"是一个可以动态增加自身数据长度的类\",{\"1\":{\"741\":1}}],[\"是一个由多个\",{\"1\":{\"866\":1}}],[\"是一个由\",{\"1\":{\"623\":1}}],[\"是一个非官方的\",{\"1\":{\"500\":1}}],[\"是一个基于\",{\"1\":{\"372\":1}}],[\"是一个3节点\",{\"1\":{\"284\":1}}],[\"是一个开启或关闭跟踪的布尔值\",{\"1\":{\"261\":1}}],[\"是一个空列表\",{\"1\":{\"177\":1}}],[\"是一个模式匹配操作符\",{\"1\":{\"173\":1}}],[\"是一个线程\",{\"1\":{\"119\":1}}],[\"是一个或多个输入事件的处理模式\",{\"1\":{\"119\":1}}],[\"是双向的\",{\"1\":{\"118\":1}}],[\"是实现\",{\"1\":{\"118\":1}}],[\"是\",{\"1\":{\"2\":2,\"118\":1,\"398\":2,\"443\":1,\"531\":1,\"594\":1,\"624\":1,\"626\":1,\"729\":1,\"736\":1,\"746\":1,\"777\":1,\"1036\":1,\"1065\":2,\"1095\":1,\"1168\":1,\"1300\":1,\"1346\":1,\"1386\":1,\"1403\":1,\"1407\":2,\"1420\":1,\"1472\":1,\"1481\":1}}],[\"独特的场景时可能就需要自己进行性能压测\",{\"1\":{\"2\":1}}],[\"a<>\",{\"1\":{\"1308\":1}}],[\"aynscconsumersendmsgback\",{\"1\":{\"1188\":1}}],[\"ayiw\",{\"1\":{\"157\":1}}],[\"a7d0e64c5335\",{\"1\":{\"1075\":1}}],[\"ago\",{\"1\":{\"1072\":1,\"1075\":3,\"1077\":1,\"1079\":10}}],[\"again\",{\"1\":{\"825\":1,\"1269\":1}}],[\"age\",{\"1\":{\"294\":1,\"297\":3,\"316\":2,\"338\":4,\"517\":3,\"527\":1,\"552\":3}}],[\"a为master节点\",{\"1\":{\"674\":1}}],[\"a需要重启\",{\"1\":{\"659\":1}}],[\"a定位到\",{\"1\":{\"591\":1}}],[\"a210d64eddb5\",{\"1\":{\"1075\":1}}],[\"a2\",{\"1\":{\"524\":1}}],[\"a1\",{\"1\":{\"524\":1}}],[\"ax4udgn01bm4zavq9qkmseniv4dbmuhmxxbfkn4dzsa6jfozl\",{\"1\":{\"455\":1}}],[\"aqhp8rzr3f\",{\"1\":{\"455\":1}}],[\"ak\",{\"1\":{\"995\":2,\"1277\":2}}],[\"akt7a6brfomonozacwz7x9xble3qywrtoq2za8tae1\",{\"1\":{\"443\":1}}],[\"akka\",{\"1\":{\"372\":5}}],[\"ajax请求是异步执行的\",{\"1\":{\"347\":1}}],[\"ajax\",{\"0\":{\"347\":1}}],[\"amend\",{\"1\":{\"1278\":1}}],[\"american\",{\"1\":{\"27\":1}}],[\"amazon\",{\"1\":{\"922\":1}}],[\"amqqueue\",{\"1\":{\"621\":1,\"671\":2,\"672\":2}}],[\"amqpqueue\",{\"1\":{\"689\":1}}],[\"amqp\",{\"1\":{\"621\":2,\"635\":1,\"714\":2,\"715\":2,\"1284\":2,\"1290\":2,\"1291\":1}}],[\"amd64\",{\"1\":{\"643\":3}}],[\"amd\",{\"1\":{\"597\":1}}],[\"amounts\",{\"1\":{\"396\":1}}],[\"amount\",{\"1\":{\"396\":1,\"579\":2}}],[\"am\",{\"1\":{\"345\":1}}],[\"aoeiggywj0jgk2uydfq2mo8dbwg9ysmimljkzxj0jiaquhsezqdujtjdwdto2dgw3a5pxhrrwgcolrw76syko7a72g7io7i2ssx2rhlsrft8hnf6ax5qdidglrp46qgusknofk49i4qqwlz1h7uzgmsaxbxsoxxqgmngngjk48moilrc2cvreukcmshr9duudtvzho0bgcfly\",{\"1\":{\"436\":1}}],[\"aoe\",{\"1\":{\"399\":3,\"401\":2,\"403\":2,\"411\":5,\"412\":2,\"413\":1,\"415\":1,\"416\":1,\"417\":1,\"421\":1,\"425\":2,\"426\":1,\"428\":3,\"431\":3,\"432\":1,\"433\":1,\"434\":3,\"438\":2,\"439\":1,\"440\":2,\"442\":2,\"443\":1,\"446\":6,\"447\":3,\"448\":4,\"454\":1,\"455\":2,\"457\":1,\"459\":1,\"460\":1,\"461\":1,\"465\":2,\"466\":1,\"467\":1,\"468\":2,\"472\":1,\"475\":1,\"482\":1,\"485\":1,\"491\":1,\"492\":3}}],[\"aol\",{\"1\":{\"298\":2}}],[\"aop把系统分解为不同的关注点\",{\"1\":{\"85\":1}}],[\"aop\",{\"0\":{\"85\":1}}],[\"adjustthreadpool\",{\"1\":{\"1048\":2}}],[\"adam\",{\"1\":{\"301\":7}}],[\"admintools\",{\"1\":{\"1248\":1}}],[\"adminbrokerprocessor\",{\"1\":{\"1214\":1}}],[\"admin\",{\"1\":{\"273\":1,\"983\":4,\"1000\":2,\"1415\":1}}],[\"addfirst\",{\"1\":{\"1372\":1,\"1424\":1}}],[\"addmetric\",{\"1\":{\"1371\":1,\"1374\":1}}],[\"addmessageext\",{\"1\":{\"1432\":1}}],[\"addmessage\",{\"1\":{\"1174\":1,\"1270\":1}}],[\"addbuffersuc\",{\"1\":{\"1271\":2}}],[\"addblockedlistener\",{\"1\":{\"613\":1}}],[\"adddiff\",{\"1\":{\"1271\":1}}],[\"addckjustoffset\",{\"1\":{\"1271\":1}}],[\"addckmock\",{\"1\":{\"1270\":1}}],[\"addck\",{\"0\":{\"1275\":1},\"1\":{\"1262\":1,\"1271\":1,\"1275\":1}}],[\"addak\",{\"0\":{\"1276\":1},\"1\":{\"1262\":1,\"1273\":1,\"1276\":1}}],[\"addall\",{\"1\":{\"998\":1,\"1143\":2,\"1266\":2,\"1267\":1}}],[\"addandget\",{\"1\":{\"880\":1,\"1462\":2,\"1464\":2}}],[\"addextfield\",{\"1\":{\"995\":3}}],[\"added\",{\"1\":{\"396\":1}}],[\"addshutdownhook\",{\"1\":{\"960\":1}}],[\"addscheduletask\",{\"1\":{\"869\":1}}],[\"addsuppressed\",{\"1\":{\"34\":1}}],[\"addrolechangehandler\",{\"1\":{\"1424\":1}}],[\"addretrytopicifnoexit\",{\"1\":{\"1280\":1}}],[\"address=9555\",{\"1\":{\"1080\":1}}],[\"address不是变量\",{\"1\":{\"316\":1}}],[\"address\",{\"1\":{\"316\":4,\"882\":3,\"1017\":3,\"1048\":1,\"1123\":1,\"1444\":1}}],[\"addr\",{\"1\":{\"897\":1,\"994\":6,\"1000\":2,\"1172\":3,\"1444\":1,\"1471\":2,\"1472\":3}}],[\"addr=namesrv\",{\"1\":{\"1075\":1,\"1078\":1,\"1080\":3,\"1081\":1}}],[\"addr=\",{\"1\":{\"845\":1,\"860\":1,\"1174\":1}}],[\"addpullrequest\",{\"1\":{\"822\":1,\"825\":1}}],[\"addlistener\",{\"1\":{\"820\":1,\"1173\":1}}],[\"additional\",{\"1\":{\"643\":2}}],[\"addinitializer\",{\"1\":{\"606\":3}}],[\"addnode\",{\"1\":{\"396\":2}}],[\"add\",{\"1\":{\"9\":2,\"102\":2,\"223\":2,\"253\":2,\"396\":1,\"498\":1,\"550\":1,\"566\":1,\"722\":1,\"793\":2,\"797\":1,\"815\":1,\"825\":1,\"860\":1,\"870\":1,\"872\":1,\"970\":1,\"971\":2,\"994\":1,\"995\":1,\"998\":2,\"999\":1,\"1020\":1,\"1021\":2,\"1144\":4,\"1174\":3,\"1194\":2,\"1195\":1,\"1200\":1,\"1222\":4,\"1224\":4,\"1226\":1,\"1267\":1,\"1271\":1,\"1275\":3,\"1276\":4,\"1329\":1,\"1371\":2,\"1372\":2,\"1373\":1,\"1427\":1,\"1436\":3,\"1464\":2,\"1468\":1,\"1502\":1}}],[\"afk\",{\"1\":{\"399\":2}}],[\"af6bfa23\",{\"1\":{\"215\":1}}],[\"afterwards\",{\"1\":{\"1373\":1}}],[\"after\",{\"1\":{\"99\":1,\"142\":1,\"194\":1,\"232\":1,\"643\":1,\"988\":1,\"994\":1,\"1014\":1,\"1468\":1}}],[\"a+10\",{\"1\":{\"213\":2}}],[\"author\",{\"1\":{\"204\":1}}],[\"automated\",{\"1\":{\"1073\":1}}],[\"automatic\",{\"1\":{\"652\":2,\"653\":1,\"654\":1,\"658\":1}}],[\"autoload\",{\"1\":{\"165\":1}}],[\"autowired\",{\"1\":{\"82\":1,\"89\":1}}],[\"autodetect=false\",{\"1\":{\"11\":1}}],[\"auto\",{\"1\":{\"11\":1,\"30\":2,\"89\":1,\"646\":2,\"886\":1,\"906\":1,\"1039\":1}}],[\"await\",{\"1\":{\"349\":1,\"354\":1,\"915\":1,\"970\":1,\"1497\":1,\"1499\":1}}],[\"aw\",{\"1\":{\"155\":1}}],[\"alt\",{\"1\":{\"1481\":1}}],[\"along\",{\"1\":{\"1458\":1}}],[\"alpine\",{\"1\":{\"1072\":3,\"1083\":1}}],[\"alpha\",{\"1\":{\"690\":2}}],[\"alreadyhasleader=\",{\"1\":{\"1497\":1}}],[\"alreadyhasleader\",{\"1\":{\"1497\":5}}],[\"already\",{\"1\":{\"1047\":1,\"1122\":1,\"1144\":1,\"1224\":1,\"1277\":1,\"1497\":2,\"1503\":2,\"1520\":1}}],[\"almost\",{\"1\":{\"886\":1,\"1276\":1}}],[\"always\",{\"1\":{\"657\":1,\"659\":2}}],[\"algorithm\",{\"1\":{\"396\":1}}],[\"alert\",{\"1\":{\"341\":2,\"342\":1,\"344\":1,\"345\":1,\"348\":1,\"356\":3}}],[\"aliyun\",{\"1\":{\"272\":2,\"381\":1}}],[\"alibaba\",{\"1\":{\"268\":1}}],[\"also\",{\"1\":{\"125\":1,\"624\":1,\"1145\":1,\"1174\":1}}],[\"allnum=\",{\"1\":{\"1497\":1,\"1499\":1}}],[\"allnum\",{\"1\":{\"1497\":4,\"1499\":4}}],[\"allsucc\",{\"1\":{\"1371\":4}}],[\"allwaitforrunning\",{\"1\":{\"726\":1}}],[\"allof\",{\"1\":{\"1436\":1}}],[\"allow\",{\"1\":{\"624\":1}}],[\"allowed\",{\"1\":{\"171\":1}}],[\"allocation\",{\"1\":{\"171\":2}}],[\"allocate4pop\",{\"0\":{\"1267\":1},\"1\":{\"1266\":1,\"1267\":1}}],[\"allocateresultset\",{\"1\":{\"1143\":6}}],[\"allocateresult\",{\"1\":{\"1143\":4,\"1266\":5,\"1267\":7}}],[\"allocaterequest\",{\"1\":{\"881\":2}}],[\"allocatemessagequeuebymachineroom\",{\"1\":{\"1138\":1}}],[\"allocatemessagequeuebyconfig\",{\"1\":{\"1138\":1}}],[\"allocatemessagequeueconsistenthash\",{\"1\":{\"1138\":1}}],[\"allocatemessagequeuestrategyname=\",{\"1\":{\"1143\":2}}],[\"allocatemessagequeuestrategy\",{\"1\":{\"1019\":4,\"1133\":1,\"1143\":3,\"1266\":5,\"1267\":5}}],[\"allocatemessagequeueaveragelybycircle\",{\"1\":{\"1138\":1}}],[\"allocatemessagequeueaveragely\",{\"1\":{\"985\":1,\"1138\":1}}],[\"allocatemappedfileservice\",{\"1\":{\"881\":2}}],[\"allocatedirect\",{\"1\":{\"883\":1}}],[\"allocated\",{\"1\":{\"396\":1}}],[\"allocate\",{\"1\":{\"124\":2,\"738\":1,\"1143\":2,\"1266\":2,\"1267\":3,\"1368\":1,\"1432\":1}}],[\"all\",{\"0\":{\"352\":1},\"1\":{\"97\":1,\"171\":9,\"230\":1,\"235\":1,\"253\":1,\"261\":1,\"352\":1,\"498\":1,\"618\":1,\"645\":3,\"652\":1,\"657\":1,\"960\":1,\"972\":1,\"983\":1,\"1266\":1,\"1267\":1,\"1269\":2,\"1328\":1}}],[\"attempt\",{\"1\":{\"1427\":1}}],[\"attributekey<string>\",{\"1\":{\"897\":1}}],[\"attributekey\",{\"1\":{\"897\":5}}],[\"attributes\",{\"1\":{\"204\":1,\"253\":3,\"1427\":3}}],[\"attach\",{\"1\":{\"118\":1,\"121\":1,\"124\":1,\"133\":1}}],[\"attachment\",{\"1\":{\"118\":1,\"122\":1}}],[\"atomicreference<>\",{\"1\":{\"1519\":1}}],[\"atomicreference<pushentryrequest\",{\"1\":{\"1519\":1}}],[\"atomicinteger\",{\"1\":{\"1442\":2,\"1497\":10,\"1499\":6}}],[\"atomicboolean\",{\"1\":{\"726\":1,\"1021\":2,\"1258\":1,\"1497\":2,\"1499\":2}}],[\"atomic\",{\"1\":{\"253\":1}}],[\"atomiclong>\",{\"1\":{\"1200\":1}}],[\"atomiclong\",{\"1\":{\"2\":1,\"1021\":1,\"1200\":1,\"1497\":2,\"1499\":2}}],[\"atomtag\",{\"1\":{\"202\":1}}],[\"atom\",{\"1\":{\"186\":2,\"200\":1,\"234\":1}}],[\"at\",{\"1\":{\"97\":1,\"283\":1,\"345\":1,\"625\":1,\"972\":1,\"1079\":6,\"1277\":1,\"1432\":1,\"1518\":1,\"1519\":2}}],[\"abnormal\",{\"1\":{\"1500\":1}}],[\"able\",{\"1\":{\"1195\":1,\"1230\":4}}],[\"absindexpos\",{\"1\":{\"797\":10}}],[\"absslotpos\",{\"1\":{\"797\":8}}],[\"abstracttransactionalmessagechecklistener\",{\"0\":{\"1469\":1},\"1\":{\"1468\":1,\"1469\":1}}],[\"abstractpluginmessagestore\",{\"1\":{\"1397\":2,\"1425\":1}}],[\"abstractstateservice\",{\"1\":{\"1373\":4,\"1374\":4}}],[\"abstract\",{\"1\":{\"579\":2}}],[\"abstractentity\",{\"1\":{\"92\":1}}],[\"abs\",{\"1\":{\"306\":2,\"1052\":2,\"1269\":1}}],[\"abort\",{\"1\":{\"248\":1,\"253\":1}}],[\"about\",{\"1\":{\"171\":17,\"1075\":6}}],[\"above\",{\"1\":{\"142\":1}}],[\"abc为字符串\",{\"1\":{\"1308\":1}}],[\"abcabc\",{\"1\":{\"500\":1}}],[\"abc\",{\"1\":{\"23\":3,\"34\":1,\"103\":1,\"178\":1,\"256\":1,\"500\":1,\"515\":1,\"523\":1,\"538\":2,\"1308\":3}}],[\"acquire\",{\"1\":{\"1428\":1}}],[\"acquire方法\",{\"1\":{\"380\":1}}],[\"acl实现机制\",{\"1\":{\"1001\":1}}],[\"acl使用指南\",{\"1\":{\"1001\":1}}],[\"aclwatcherservice\",{\"1\":{\"999\":1}}],[\"acl配置文件的数量\",{\"1\":{\"999\":1}}],[\"aclfilename\",{\"1\":{\"999\":2,\"1000\":2}}],[\"aclfilesnum和filelist\",{\"1\":{\"999\":1}}],[\"aclfilesnum\",{\"1\":{\"999\":9}}],[\"aclfilewatchservice\",{\"1\":{\"999\":8}}],[\"aclfilepath\",{\"1\":{\"998\":2,\"999\":2}}],[\"aclexception\",{\"1\":{\"998\":1,\"1000\":6}}],[\"aclenable=true\",{\"1\":{\"983\":1}}],[\"aclpath\",{\"1\":{\"999\":3}}],[\"aclplainaccessresourcemap是个map类型\",{\"1\":{\"997\":1}}],[\"aclplainaccessresourcemap\",{\"1\":{\"997\":2,\"998\":4,\"1000\":1}}],[\"aclproducertest\",{\"1\":{\"984\":1}}],[\"aclutils\",{\"1\":{\"995\":2,\"998\":1,\"1000\":1}}],[\"aclconstants\",{\"1\":{\"998\":2}}],[\"aclconsumertest\",{\"1\":{\"985\":1}}],[\"aclclienthook\",{\"1\":{\"984\":2,\"985\":2}}],[\"aclclientrpchook\",{\"0\":{\"987\":1,\"988\":1,\"989\":1,\"993\":1,\"994\":1,\"995\":1},\"1\":{\"980\":2,\"981\":1,\"984\":2,\"985\":1,\"986\":1,\"987\":1,\"988\":2,\"994\":1}}],[\"acl\",{\"0\":{\"975\":1,\"990\":1,\"996\":1},\"1\":{\"975\":1,\"976\":5,\"978\":3,\"979\":1,\"980\":1,\"983\":3,\"984\":5,\"985\":4,\"986\":2,\"987\":1,\"990\":5,\"996\":7,\"997\":4,\"998\":9,\"999\":2,\"1000\":1,\"1001\":3,\"1538\":1}}],[\"ac\",{\"1\":{\"286\":1}}],[\"activity\",{\"1\":{\"806\":1}}],[\"activemq\",{\"1\":{\"1321\":1}}],[\"actively\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"active\",{\"1\":{\"625\":3,\"967\":1}}],[\"action\",{\"1\":{\"266\":3}}],[\"actor\",{\"1\":{\"372\":8}}],[\"actor并发模型\",{\"1\":{\"230\":1}}],[\"actually=\",{\"1\":{\"1432\":1}}],[\"actually\",{\"1\":{\"103\":1}}],[\"accounts\",{\"1\":{\"983\":2,\"998\":6}}],[\"according\",{\"1\":{\"396\":1,\"1430\":1}}],[\"accesschannel\",{\"1\":{\"1021\":3}}],[\"accessskey\",{\"1\":{\"998\":1}}],[\"accessvalidatormap\",{\"1\":{\"996\":1}}],[\"accessvalidators\",{\"1\":{\"996\":4}}],[\"accessvalidator文件中配置的访问验证器plainaccessvalidator\",{\"1\":{\"996\":1}}],[\"accessvalidator\",{\"1\":{\"990\":2,\"996\":8}}],[\"accesskey=\",{\"1\":{\"1000\":2}}],[\"accesskeytable是个map类型\",{\"1\":{\"997\":1}}],[\"accesskeytable\",{\"1\":{\"997\":2,\"998\":5,\"1000\":2}}],[\"accesskey\",{\"1\":{\"978\":1,\"983\":3,\"987\":1,\"995\":3,\"997\":3,\"998\":2,\"1000\":2}}],[\"accessing\",{\"1\":{\"624\":1}}],[\"access\",{\"1\":{\"575\":1,\"606\":2,\"976\":1,\"983\":2,\"984\":2,\"985\":2,\"995\":2,\"1174\":1}}],[\"accessor\",{\"1\":{\"567\":1,\"606\":1}}],[\"acceptednum=\",{\"1\":{\"1497\":1}}],[\"acceptednum\",{\"1\":{\"1497\":7}}],[\"acceptor\",{\"0\":{\"123\":1},\"1\":{\"118\":3,\"119\":1,\"120\":2,\"121\":5,\"122\":2,\"123\":3,\"132\":1,\"133\":2,\"135\":1}}],[\"accept\",{\"1\":{\"69\":1,\"112\":2,\"114\":1,\"118\":1,\"121\":2,\"122\":1,\"123\":1,\"130\":1,\"132\":2,\"133\":3,\"368\":1,\"1497\":1,\"1503\":1}}],[\"acc\",{\"1\":{\"189\":5}}],[\"acknum++\",{\"1\":{\"1521\":1}}],[\"acknum\",{\"1\":{\"1521\":3}}],[\"acknowledge\",{\"1\":{\"671\":1}}],[\"ackoffsetbyindex\",{\"1\":{\"1280\":1}}],[\"acktimeinterval\",{\"1\":{\"1278\":1,\"1279\":1}}],[\"acked\",{\"1\":{\"1263\":1}}],[\"ackmessagerequestheader\",{\"1\":{\"1273\":3}}],[\"ackmessageprocessor\",{\"0\":{\"1273\":1},\"1\":{\"1260\":1}}],[\"ackmsg\",{\"0\":{\"1261\":1,\"1274\":1},\"1\":{\"1259\":2,\"1261\":1,\"1263\":2,\"1273\":14,\"1276\":15,\"1278\":10}}],[\"ackindex\",{\"1\":{\"1195\":15}}],[\"ack了多少条消息\",{\"1\":{\"626\":1}}],[\"ack\",{\"0\":{\"1260\":1,\"1272\":1,\"1518\":1},\"1\":{\"72\":1,\"621\":3,\"626\":2,\"668\":2,\"674\":3,\"687\":1,\"1251\":3,\"1252\":1,\"1253\":7,\"1258\":1,\"1260\":6,\"1261\":1,\"1262\":3,\"1263\":2,\"1270\":1,\"1271\":1,\"1273\":8,\"1276\":10,\"1277\":5,\"1278\":13,\"1279\":3,\"1280\":3,\"1446\":1,\"1514\":1,\"1516\":4,\"1518\":1,\"1519\":2,\"1520\":3,\"1521\":3}}],[\"apt\",{\"0\":{\"644\":1},\"1\":{\"643\":1,\"644\":4,\"645\":1,\"646\":2}}],[\"appears\",{\"1\":{\"690\":1}}],[\"appendasfollower\",{\"1\":{\"1520\":1}}],[\"appendasleader\",{\"1\":{\"1509\":1,\"1516\":2,\"1517\":1}}],[\"appendhooks\",{\"1\":{\"1517\":1}}],[\"appendhook\",{\"1\":{\"1517\":1}}],[\"appendfuture<>\",{\"1\":{\"1518\":1}}],[\"appendfuture<appendentryresponse>\",{\"1\":{\"1518\":1}}],[\"appendfuture\",{\"1\":{\"1516\":2,\"1518\":1,\"1521\":1}}],[\"appendentryresponse\",{\"1\":{\"1516\":10,\"1518\":2,\"1521\":4}}],[\"appendentryrequest\",{\"1\":{\"1516\":1}}],[\"appenderqueue\",{\"1\":{\"1021\":1}}],[\"appenders\",{\"1\":{\"1008\":1}}],[\"appendposition\",{\"1\":{\"1428\":1}}],[\"append=\",{\"1\":{\"1428\":1}}],[\"appendconsumequeue\",{\"1\":{\"1427\":1}}],[\"appendcommitlog\",{\"1\":{\"1427\":1}}],[\"appendcheckpoint\",{\"0\":{\"1271\":1},\"1\":{\"1270\":1,\"1271\":1}}],[\"appendresult\",{\"1\":{\"1427\":3,\"1434\":15}}],[\"appendmessagecallback\",{\"1\":{\"1296\":1}}],[\"appendmessages\",{\"1\":{\"1296\":1}}],[\"appendmessagestatus\",{\"1\":{\"737\":2,\"738\":1,\"1280\":1}}],[\"appendmessage\",{\"1\":{\"765\":1,\"768\":1,\"1368\":2}}],[\"appendmessageresult\",{\"1\":{\"737\":3,\"738\":4}}],[\"append\",{\"0\":{\"1516\":1},\"1\":{\"125\":1,\"142\":3,\"1020\":2,\"1235\":5,\"1346\":1,\"1352\":1,\"1368\":3,\"1371\":1,\"1403\":4,\"1427\":1,\"1428\":2,\"1435\":1,\"1510\":7,\"1511\":8,\"1512\":2,\"1514\":1,\"1516\":5,\"1517\":3,\"1519\":44,\"1520\":18,\"1521\":3}}],[\"app\",{\"1\":{\"498\":5,\"499\":2}}],[\"appid3等\",{\"1\":{\"380\":1}}],[\"appid2\",{\"1\":{\"380\":1}}],[\"appliedindex=\",{\"1\":{\"1521\":1}}],[\"application\",{\"1\":{\"618\":1}}],[\"applicationcontextprovider\",{\"1\":{\"272\":1}}],[\"applicationcontext\",{\"1\":{\"266\":3,\"272\":1}}],[\"apply\",{\"0\":{\"200\":1,\"318\":1},\"1\":{\"195\":1,\"200\":1,\"229\":1,\"318\":1,\"319\":2,\"320\":1,\"653\":3,\"973\":1,\"1173\":2}}],[\"apple1\",{\"1\":{\"253\":2}}],[\"apples\",{\"1\":{\"177\":7,\"253\":1}}],[\"apple\",{\"1\":{\"177\":1,\"181\":4,\"253\":6,\"298\":4,\"325\":2}}],[\"approaches\",{\"1\":{\"97\":1}}],[\"appconfig\",{\"1\":{\"89\":1}}],[\"apacherocketmq\",{\"1\":{\"1072\":1,\"1073\":1,\"1075\":1,\"1077\":3,\"1078\":1,\"1079\":1,\"1081\":1}}],[\"apache\",{\"1\":{\"64\":2,\"286\":1,\"743\":1,\"852\":1,\"882\":2,\"919\":1,\"990\":1,\"996\":2,\"1025\":1,\"1053\":1,\"1070\":1,\"1073\":5,\"1075\":6,\"1079\":9,\"1080\":3,\"1284\":1,\"1297\":1,\"1382\":5,\"1425\":2,\"1504\":1,\"1522\":1}}],[\"api│\",{\"1\":{\"78\":1}}],[\"api\",{\"0\":{\"349\":1,\"654\":1,\"1053\":1},\"1\":{\"44\":1,\"60\":1,\"78\":1,\"118\":1,\"248\":1,\"348\":1,\"349\":2,\"370\":1,\"654\":1,\"879\":1,\"994\":1,\"1025\":2,\"1027\":1,\"1029\":1,\"1036\":1,\"1053\":1,\"1094\":1,\"1136\":1,\"1160\":1,\"1188\":1,\"1226\":1,\"1338\":1,\"1339\":1,\"1459\":1,\"1472\":2}}],[\"a\",{\"0\":{\"438\":1,\"888\":1},\"1\":{\"27\":1,\"46\":5,\"97\":3,\"98\":1,\"103\":4,\"104\":3,\"122\":1,\"142\":4,\"155\":2,\"161\":1,\"171\":9,\"178\":2,\"184\":6,\"186\":12,\"192\":6,\"193\":5,\"194\":5,\"195\":5,\"212\":2,\"213\":4,\"248\":10,\"256\":5,\"294\":1,\"298\":14,\"303\":7,\"309\":5,\"332\":4,\"396\":7,\"425\":1,\"503\":3,\"511\":2,\"512\":2,\"516\":2,\"518\":7,\"520\":2,\"527\":4,\"535\":1,\"538\":3,\"548\":1,\"553\":1,\"558\":4,\"562\":2,\"576\":7,\"579\":4,\"580\":6,\"584\":2,\"586\":3,\"591\":3,\"592\":7,\"605\":2,\"614\":4,\"621\":2,\"624\":1,\"627\":3,\"674\":3,\"742\":3,\"835\":1,\"845\":4,\"860\":5,\"861\":1,\"886\":1,\"890\":1,\"891\":2,\"961\":1,\"1075\":7,\"1079\":1,\"1144\":2,\"1224\":2,\"1225\":1,\"1230\":3,\"1287\":1,\"1308\":16,\"1309\":1,\"1310\":2,\"1371\":1,\"1383\":1,\"1420\":5,\"1427\":1,\"1441\":1,\"1445\":13,\"1519\":1}}],[\"another\",{\"1\":{\"1047\":1,\"1075\":1,\"1122\":1,\"1173\":1,\"1372\":1}}],[\"angular\",{\"1\":{\"598\":1}}],[\"animalconstructor\",{\"1\":{\"548\":2}}],[\"animal\",{\"1\":{\"548\":4,\"563\":12}}],[\"analyse\",{\"1\":{\"255\":1}}],[\"anatom\",{\"1\":{\"234\":7}}],[\"any类型除了关闭类型检查\",{\"1\":{\"502\":1}}],[\"any和unknown\",{\"1\":{\"501\":1}}],[\"any\",{\"0\":{\"501\":1,\"502\":1},\"1\":{\"171\":1,\"235\":2,\"502\":1,\"503\":2,\"522\":1,\"523\":1,\"527\":1,\"547\":2,\"605\":2,\"624\":1,\"978\":1}}],[\"anystring\",{\"1\":{\"101\":1,\"102\":2}}],[\"ank\",{\"1\":{\"155\":1,\"156\":1}}],[\"andalso\",{\"1\":{\"219\":1,\"626\":1}}],[\"and\",{\"0\":{\"97\":1,\"98\":1,\"398\":1},\"1\":{\"92\":2,\"98\":2,\"103\":1,\"104\":2,\"171\":2,\"186\":1,\"189\":6,\"206\":1,\"253\":2,\"347\":1,\"608\":1,\"624\":1,\"628\":1,\"643\":2,\"645\":1,\"720\":2,\"845\":2,\"886\":2,\"907\":1,\"910\":1,\"961\":1,\"972\":1,\"1000\":1,\"1048\":1,\"1053\":1,\"1056\":1,\"1106\":1,\"1123\":1,\"1173\":2,\"1174\":1,\"1266\":1,\"1269\":1,\"1277\":1,\"1287\":2,\"1297\":2,\"1308\":13,\"1310\":5,\"1372\":1,\"1437\":2,\"1500\":2,\"1516\":1,\"1519\":1,\"1520\":1,\"1521\":1}}],[\"an\",{\"1\":{\"46\":2,\"97\":1,\"98\":1,\"720\":1,\"1000\":1,\"1500\":1,\"1503\":1,\"1520\":2}}],[\"annotated\",{\"1\":{\"97\":2}}],[\"annotations\",{\"1\":{\"98\":1}}],[\"annotation\",{\"1\":{\"44\":1,\"742\":3}}],[\"annprocess<\",{\"1\":{\"8\":1}}],[\"ansi\",{\"1\":{\"27\":1}}],[\"ascending\",{\"1\":{\"793\":1}}],[\"ascii\",{\"1\":{\"27\":1,\"215\":1}}],[\"astate\",{\"1\":{\"624\":2}}],[\"asyncconsumersendmsgback\",{\"1\":{\"1198\":1}}],[\"asyncputhalfmessage\",{\"1\":{\"1463\":1}}],[\"asyncputmessagefuture\",{\"1\":{\"1462\":4}}],[\"asyncputmessages\",{\"1\":{\"731\":2,\"1296\":1}}],[\"asyncputmessage\",{\"0\":{\"737\":1},\"1\":{\"720\":2,\"731\":2,\"736\":2,\"839\":1,\"843\":2,\"1056\":1,\"1198\":1,\"1462\":1,\"1463\":1}}],[\"asyncpreparemessage\",{\"1\":{\"1056\":1,\"1462\":1}}],[\"asyncsendmessage\",{\"1\":{\"1043\":1,\"1056\":2}}],[\"asyncrunnable\",{\"1\":{\"1021\":1}}],[\"asyncappenderrequest\",{\"1\":{\"1021\":4}}],[\"asynctracedispatcher处理\",{\"1\":{\"1015\":1}}],[\"asynctracedispatcher\",{\"1\":{\"1014\":1,\"1019\":2,\"1021\":5}}],[\"asyncnettyrequestprocessor\",{\"1\":{\"944\":1}}],[\"asyncdeliver\",{\"1\":{\"860\":2}}],[\"async\",{\"0\":{\"354\":1},\"1\":{\"349\":1,\"354\":2,\"1027\":1,\"1050\":1,\"1053\":2,\"1075\":4,\"1170\":1,\"1172\":1,\"1173\":1,\"1502\":1}}],[\"asynchronous\",{\"1\":{\"347\":1,\"860\":2}}],[\"asvetliakov\",{\"1\":{\"167\":1}}],[\"aslist\",{\"1\":{\"106\":1,\"1288\":1,\"1443\":1}}],[\"assignlmqoffset\",{\"1\":{\"1296\":1}}],[\"assigner\",{\"1\":{\"1296\":1}}],[\"assignedqueueset\",{\"1\":{\"1266\":6}}],[\"assigned\",{\"1\":{\"1266\":2,\"1267\":2}}],[\"assignoffset\",{\"1\":{\"1296\":1}}],[\"assignqueueoffset\",{\"1\":{\"1294\":1,\"1296\":2}}],[\"assignmentmanager\",{\"1\":{\"1267\":1}}],[\"assignment\",{\"1\":{\"1266\":4}}],[\"assignnewone\",{\"1\":{\"998\":2}}],[\"assert\",{\"1\":{\"1053\":1,\"1172\":2,\"1173\":4}}],[\"assertthat\",{\"1\":{\"105\":3,\"106\":3}}],[\"assertthrows\",{\"1\":{\"101\":1,\"102\":1}}],[\"assembler\",{\"1\":{\"624\":1}}],[\"assures\",{\"1\":{\"104\":1}}],[\"assumes\",{\"1\":{\"11\":2}}],[\"aspectj就扩展了java编译器\",{\"1\":{\"85\":1}}],[\"aspect\",{\"1\":{\"85\":1}}],[\"as\",{\"1\":{\"46\":1,\"103\":1,\"167\":1,\"192\":1,\"568\":1,\"589\":3,\"595\":2,\"598\":1,\"1021\":1,\"1287\":1,\"1436\":2,\"1517\":1}}],[\"available\",{\"1\":{\"1174\":1,\"1273\":1,\"1428\":1,\"1459\":1,\"1464\":1}}],[\"avoid\",{\"1\":{\"870\":1,\"886\":1,\"907\":1,\"1371\":1}}],[\"avg\",{\"1\":{\"11\":2,\"1091\":1,\"1097\":3}}],[\"average\",{\"1\":{\"11\":2}}],[\"arbitrary\",{\"1\":{\"1375\":3}}],[\"arrived\",{\"1\":{\"1468\":1}}],[\"arriving\",{\"0\":{\"828\":1},\"1\":{\"762\":1,\"827\":2,\"828\":1}}],[\"arr变为\",{\"1\":{\"298\":3}}],[\"arr\",{\"1\":{\"298\":47,\"323\":2,\"324\":2,\"325\":4,\"329\":2,\"330\":4,\"333\":1,\"340\":1,\"522\":5,\"523\":5,\"524\":4,\"529\":2,\"540\":2,\"547\":1}}],[\"arrayblockingqueue<pair<pushentryrequest\",{\"1\":{\"1520\":1}}],[\"arrayblockingqueue<>\",{\"1\":{\"1443\":1}}],[\"arrayblockingqueue<runnable>\",{\"1\":{\"1021\":1}}],[\"arrayblockingqueue<tracecontext>\",{\"1\":{\"1021\":1}}],[\"arraycopy\",{\"1\":{\"900\":1}}],[\"array<number|string>\",{\"1\":{\"522\":1}}],[\"array<number>\",{\"1\":{\"522\":1}}],[\"arraysum\",{\"1\":{\"540\":1}}],[\"arrays\",{\"1\":{\"106\":1,\"793\":1,\"1288\":1,\"1443\":1}}],[\"array\",{\"0\":{\"327\":1},\"1\":{\"46\":2,\"294\":1,\"298\":1,\"303\":3,\"309\":2,\"340\":1,\"521\":1,\"522\":1,\"720\":1,\"727\":1,\"738\":1,\"765\":1,\"1368\":1,\"1371\":1,\"1517\":2}}],[\"arraylist<popcheckpoint>\",{\"1\":{\"1279\":1}}],[\"arraylist<pullrequest>\",{\"1\":{\"825\":1,\"1144\":1,\"1224\":1}}],[\"arraylist<messageext>\",{\"1\":{\"1194\":1,\"1195\":1,\"1329\":1}}],[\"arraylist<messagequeue>\",{\"1\":{\"1143\":1,\"1266\":1}}],[\"arraylist<mappedfile>\",{\"1\":{\"870\":1}}],[\"arraylist<tracetransferbean>\",{\"1\":{\"1021\":1}}],[\"arraylist<tracecontext>\",{\"1\":{\"1021\":1}}],[\"arraylist<tracebean>\",{\"1\":{\"1020\":1}}],[\"arraylist<rpchook>\",{\"1\":{\"994\":1}}],[\"arraylist<long>\",{\"1\":{\"794\":1}}],[\"arraylist<indexfile>\",{\"1\":{\"789\":1,\"872\":1}}],[\"arraylist<integer>\",{\"1\":{\"9\":1}}],[\"arraylist<string>\",{\"1\":{\"741\":2}}],[\"arraylist<>\",{\"1\":{\"9\":1,\"997\":1,\"998\":2,\"1267\":1,\"1371\":1,\"1436\":5,\"1468\":1,\"1502\":1}}],[\"arraylist\",{\"1\":{\"2\":1,\"9\":5,\"741\":1,\"815\":1}}],[\"article\",{\"1\":{\"274\":1,\"381\":2}}],[\"articles\",{\"1\":{\"265\":1}}],[\"artifactid>\",{\"1\":{\"8\":2,\"64\":1,\"95\":1,\"712\":1}}],[\"arthas\",{\"0\":{\"263\":1,\"264\":1},\"1\":{\"263\":1,\"268\":1,\"271\":1,\"272\":7,\"273\":5,\"608\":1}}],[\"armstring\",{\"1\":{\"204\":1}}],[\"armstrong\",{\"1\":{\"176\":1}}],[\"arity2\",{\"1\":{\"203\":1}}],[\"arity1\",{\"1\":{\"203\":1}}],[\"arity\",{\"1\":{\"171\":7,\"210\":2}}],[\"around\",{\"1\":{\"147\":2,\"155\":1}}],[\"arg\",{\"1\":{\"1442\":1,\"1458\":3,\"1459\":4}}],[\"argn这些参数上\",{\"1\":{\"200\":1}}],[\"argn\",{\"1\":{\"200\":2}}],[\"arg2\",{\"1\":{\"200\":3}}],[\"arg1\",{\"1\":{\"200\":2}}],[\"arguments类似array但它不是一个array\",{\"1\":{\"308\":1}}],[\"arguments\",{\"0\":{\"106\":1,\"308\":1},\"1\":{\"308\":1,\"320\":1}}],[\"argument\",{\"0\":{\"105\":1},\"1\":{\"192\":1,\"1458\":1,\"1520\":4}}],[\"args\",{\"1\":{\"34\":1,\"41\":3,\"69\":1,\"70\":1,\"113\":1,\"126\":1,\"129\":1,\"134\":1,\"224\":1,\"229\":2,\"261\":1,\"539\":1,\"665\":3,\"712\":1,\"714\":3,\"715\":3,\"960\":2,\"984\":1,\"985\":1,\"1248\":1,\"1331\":7,\"1443\":1,\"1444\":1}}],[\"area\",{\"1\":{\"180\":11,\"230\":1}}],[\"are\",{\"1\":{\"98\":1,\"171\":2,\"624\":2,\"627\":1,\"1427\":1,\"1516\":1}}],[\"archives\",{\"1\":{\"643\":1}}],[\"archetype\",{\"1\":{\"7\":2}}],[\"archtype\",{\"0\":{\"7\":1},\"1\":{\"7\":3,\"8\":1,\"9\":1,\"10\":1}}],[\"更适合开源与非公有云场景\",{\"1\":{\"1385\":1}}],[\"更适用于\",{\"1\":{\"1097\":1}}],[\"更直接的降低存储成本\",{\"1\":{\"1385\":1}}],[\"更具体一点\",{\"1\":{\"1091\":1}}],[\"更详细的消息轨迹使用方法请参考官方文档\",{\"1\":{\"1004\":1}}],[\"更高的可靠性意味着消息同步投递\",{\"1\":{\"924\":1}}],[\"更高层可能就不对了\",{\"1\":{\"399\":1}}],[\"更多思考\",{\"0\":{\"772\":1,\"846\":1}}],[\"更多地是支持单机场景的调度\",{\"1\":{\"371\":1}}],[\"更容易进行节点的滚动升级\",{\"1\":{\"696\":1}}],[\"更容易理解\",{\"1\":{\"184\":1}}],[\"更好的数据安全性\",{\"1\":{\"696\":1}}],[\"更严格的类型系统\",{\"1\":{\"495\":1}}],[\"更改后的协议就是upgrade\",{\"1\":{\"368\":1}}],[\"更新到\",{\"1\":{\"1520\":1}}],[\"更新到本地\",{\"1\":{\"1511\":2}}],[\"更新日志转发器状态\",{\"1\":{\"1519\":1}}],[\"更新日志水位\",{\"1\":{\"1507\":1}}],[\"更新待追加日志序号\",{\"1\":{\"1519\":1}}],[\"更新当前节点已追加日志序号为\",{\"1\":{\"1519\":1}}],[\"更新当前节点\",{\"1\":{\"1517\":1}}],[\"更新当前读取的队列偏移量\",{\"1\":{\"1370\":1}}],[\"更新集群水位表\",{\"1\":{\"1510\":1}}],[\"更新集群水位表中\",{\"1\":{\"1509\":1}}],[\"更新集群信息表\",{\"1\":{\"971\":1}}],[\"更新集群信息\",{\"1\":{\"953\":1,\"971\":1}}],[\"更新节点水位表\",{\"1\":{\"1507\":1}}],[\"更新上次仲裁成功的日志序号\",{\"1\":{\"1521\":1}}],[\"更新上次收到\",{\"1\":{\"1500\":2}}],[\"更新上次成功心跳时间戳\",{\"1\":{\"1499\":1}}],[\"更新自身投票轮次\",{\"1\":{\"1497\":1}}],[\"更新自己需要拉取的处理队列\",{\"1\":{\"1137\":1}}],[\"更新心跳时间戳\",{\"1\":{\"1489\":1}}],[\"更新投票轮次和\",{\"1\":{\"1519\":1}}],[\"更新投票轮次\",{\"1\":{\"1478\":1,\"1486\":1}}],[\"更新操作队列的消费进度\",{\"1\":{\"1468\":1}}],[\"更新事务半消息消费队列的回查进度\",{\"1\":{\"1468\":1}}],[\"更新半消息的回查次数\",{\"1\":{\"1453\":1}}],[\"更新索引文件\",{\"1\":{\"1434\":1}}],[\"更新索引文件头\",{\"1\":{\"797\":1}}],[\"更新新文件的头信息\",{\"1\":{\"1417\":1}}],[\"更新分级存储的统计信息\",{\"1\":{\"1405\":1}}],[\"更新分发的偏移量为当前分发消息的起始偏移量\",{\"1\":{\"762\":1}}],[\"更新过滤信息\",{\"1\":{\"1331\":1}}],[\"更新下一个要检查的事务操作消息的偏移量\",{\"1\":{\"1468\":1}}],[\"更新下一次拉取的偏移量\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"更新下次从哪个节点拉取消息\",{\"1\":{\"1329\":1}}],[\"更新和存储消费者的过滤信息\",{\"1\":{\"1312\":1}}],[\"更新偏移量\",{\"1\":{\"1270\":1}}],[\"更新加锁时间和客户端\",{\"1\":{\"1214\":1}}],[\"更新消费进度\",{\"1\":{\"1195\":1}}],[\"更新消费进度缓存\",{\"1\":{\"1191\":1}}],[\"更新消息消费偏移量\",{\"1\":{\"1117\":1}}],[\"更新消息中间件的源码解析和最新动态\",{\"1\":{\"0\":1,\"15\":1,\"95\":1,\"106\":1,\"136\":1,\"137\":1,\"167\":1,\"262\":1,\"274\":1,\"286\":1,\"290\":1,\"369\":1,\"381\":1,\"397\":1,\"492\":1,\"607\":1,\"628\":1,\"640\":1,\"646\":1,\"679\":1,\"691\":1,\"704\":1,\"717\":1,\"743\":1,\"774\":1,\"798\":1,\"829\":1,\"848\":1,\"861\":1,\"872\":1,\"884\":1,\"917\":1,\"938\":1,\"974\":1,\"1001\":1,\"1022\":1,\"1057\":1,\"1067\":1,\"1084\":1,\"1105\":1,\"1123\":1,\"1145\":1,\"1175\":1,\"1201\":1,\"1230\":1,\"1242\":1,\"1281\":1,\"1298\":1,\"1300\":1,\"1334\":1,\"1375\":1,\"1437\":1,\"1473\":1,\"1504\":1,\"1522\":1,\"1523\":1,\"1527\":1,\"1537\":1}}],[\"更新内存缓存表\",{\"1\":{\"1183\":1}}],[\"更新统计数据\",{\"1\":{\"1165\":1,\"1188\":1,\"1195\":1,\"1230\":1,\"1270\":1,\"1280\":1}}],[\"更新队列订阅关系\",{\"1\":{\"1137\":1}}],[\"更新订阅数据版本号\",{\"1\":{\"1137\":1}}],[\"更新失败条目\",{\"1\":{\"1050\":1}}],[\"更新主备信息\",{\"1\":{\"971\":1}}],[\"更新之后保存到\",{\"1\":{\"956\":1}}],[\"更新路由信息\",{\"1\":{\"956\":1,\"1122\":1}}],[\"更新为当前投递消息的\",{\"1\":{\"857\":1}}],[\"更新文件头\",{\"1\":{\"797\":1}}],[\"更新checkpoint中consumequeue最新刷盘时间\",{\"1\":{\"769\":1}}],[\"更新最大可用偏移量\",{\"1\":{\"753\":1}}],[\"更新\",{\"1\":{\"626\":1,\"769\":1,\"858\":1,\"945\":1,\"952\":1,\"953\":8,\"971\":12,\"1120\":2,\"1171\":1,\"1278\":1,\"1279\":1,\"1371\":2,\"1428\":1,\"1434\":1,\"1435\":1,\"1509\":1,\"1512\":2,\"1521\":1}}],[\"更新jobinfo\",{\"1\":{\"374\":1}}],[\"更新或设值\",{\"1\":{\"192\":1}}],[\"更换配色\",{\"0\":{\"163\":1}}],[\"更方便\",{\"1\":{\"29\":1}}],[\"更快\",{\"1\":{\"2\":2,\"883\":1}}],[\"lday\",{\"1\":{\"1527\":1}}],[\"lru\",{\"1\":{\"879\":1}}],[\"lksctp\",{\"1\":{\"643\":1}}],[\"lkb\",{\"1\":{\"469\":1}}],[\"l895xvo9gce62lpjwfqw1s5nhmeqcswxkjm\",{\"1\":{\"436\":1}}],[\"lg2b4mgrihwffwixmcizqfb0onw6cyllmfbkdtj\",{\"1\":{\"429\":1}}],[\"lvvtytnpm0zt3z\",{\"1\":{\"423\":1}}],[\"lf用符号\",{\"1\":{\"288\":1}}],[\"lf\",{\"1\":{\"288\":2}}],[\"lhs\",{\"1\":{\"173\":2}}],[\"lc$^0\",{\"1\":{\"195\":2}}],[\"lc\",{\"1\":{\"171\":1,\"960\":3}}],[\"lmq\",{\"0\":{\"1294\":1,\"1296\":1,\"1297\":1},\"1\":{\"1174\":1,\"1284\":2,\"1286\":3,\"1287\":8,\"1288\":5,\"1291\":1,\"1293\":8,\"1294\":15,\"1296\":1,\"1298\":2}}],[\"lm\",{\"1\":{\"171\":1}}],[\"l\",{\"0\":{\"184\":1},\"1\":{\"145\":1,\"153\":2,\"162\":1,\"171\":1,\"177\":1,\"181\":4,\"183\":2,\"184\":4,\"189\":2,\"266\":1,\"742\":2,\"1074\":1}}],[\"llight\",{\"1\":{\"1298\":1}}],[\"ll\",{\"1\":{\"102\":1}}],[\"layer\",{\"1\":{\"1520\":1}}],[\"lag=\",{\"1\":{\"1431\":2,\"1432\":1}}],[\"label\",{\"1\":{\"1427\":3,\"1464\":3}}],[\"large\",{\"1\":{\"1427\":1}}],[\"larger\",{\"1\":{\"1170\":1,\"1228\":1,\"1500\":1,\"1503\":1}}],[\"launches\",{\"1\":{\"767\":1,\"1174\":1,\"1430\":1}}],[\"launchedurlclassloader\",{\"1\":{\"266\":1}}],[\"latency\",{\"1\":{\"1464\":1}}],[\"latencyfaulttolerance\",{\"1\":{\"1052\":3}}],[\"later\",{\"1\":{\"737\":2,\"1056\":2,\"1170\":2,\"1195\":3,\"1228\":1,\"1230\":2,\"1468\":2}}],[\"latest\",{\"1\":{\"96\":1,\"104\":1,\"1173\":6,\"1500\":1,\"1503\":1}}],[\"latch\",{\"1\":{\"613\":1,\"1371\":3,\"1499\":1}}],[\"la86\",{\"1\":{\"469\":1}}],[\"lazy\",{\"1\":{\"329\":2,\"1174\":2}}],[\"lastappliedindex\",{\"1\":{\"1521\":2}}],[\"lastcheckfastforwardtimems\",{\"1\":{\"1520\":3}}],[\"lastcheckleaktimems\",{\"1\":{\"1519\":3,\"1521\":5}}],[\"lastcommitlogoffset\",{\"1\":{\"1432\":4}}],[\"lastquorumindex\",{\"1\":{\"1508\":2,\"1512\":1,\"1521\":4}}],[\"lastsuccheartbeattime=\",{\"1\":{\"1499\":1}}],[\"lastsuccheartbeattime\",{\"1\":{\"1499\":3}}],[\"lastsendheartbeattime\",{\"1\":{\"1496\":2,\"1499\":1}}],[\"lastvotecost\",{\"1\":{\"1497\":2}}],[\"lastleader=\",{\"1\":{\"1495\":1}}],[\"lastleaderheartbeattime\",{\"1\":{\"1495\":4,\"1500\":2}}],[\"lastoffset=\",{\"1\":{\"1432\":1}}],[\"lastentryindex\",{\"1\":{\"1520\":4}}],[\"lastenqueuebutexpiredstoretime\",{\"1\":{\"1370\":1}}],[\"lastenqueuebutexpiredtime\",{\"1\":{\"1370\":1}}],[\"lastexitok\",{\"1\":{\"793\":3}}],[\"lastprintwatermarktimems\",{\"1\":{\"1521\":3}}],[\"lastpushcommittimems\",{\"1\":{\"1519\":5}}],[\"lastparseresult\",{\"1\":{\"1497\":3}}],[\"lastpos\",{\"1\":{\"1367\":3,\"1371\":1,\"1372\":1}}],[\"lastphysicalminoffset\",{\"1\":{\"871\":2,\"872\":1}}],[\"lastkey\",{\"1\":{\"1170\":3}}],[\"lastbrokername\",{\"1\":{\"1050\":2,\"1052\":7}}],[\"lastmodified\",{\"1\":{\"999\":2}}],[\"lastfile\",{\"1\":{\"794\":3}}],[\"lastflushtimestamp\",{\"1\":{\"769\":2}}],[\"lastupdatetimestamp\",{\"1\":{\"954\":1,\"967\":2}}],[\"lastupdateindextimestamp\",{\"1\":{\"793\":3}}],[\"lastupdateendphyoffset\",{\"1\":{\"793\":3}}],[\"lastname\",{\"1\":{\"551\":5}}],[\"last\",{\"1\":{\"165\":1,\"771\":2,\"1021\":1,\"1248\":1,\"1280\":2,\"1351\":2,\"1370\":1,\"1428\":1,\"1432\":1,\"1516\":1,\"1520\":4}}],[\"lambda表达式\",{\"1\":{\"76\":1}}],[\"lambda表达式的参数和返回值均可由编译器自动推断\",{\"1\":{\"75\":1}}],[\"lambda\",{\"0\":{\"75\":1}}],[\"languagecode\",{\"1\":{\"894\":1}}],[\"language\",{\"1\":{\"742\":1,\"890\":1,\"894\":1}}],[\"lang\",{\"1\":{\"36\":1}}],[\"lang包是否包含这个class\",{\"1\":{\"20\":1}}],[\"lost\",{\"1\":{\"1427\":1}}],[\"lossed\",{\"1\":{\"1372\":1}}],[\"loss\",{\"1\":{\"1370\":1}}],[\"lose\",{\"1\":{\"154\":1}}],[\"low\",{\"1\":{\"1299\":3,\"1300\":1}}],[\"look\",{\"1\":{\"1198\":1}}],[\"looking\",{\"1\":{\"1048\":1,\"1123\":1}}],[\"lookup\",{\"1\":{\"886\":1,\"888\":1}}],[\"lookmessagebyoffset\",{\"1\":{\"845\":1,\"860\":1,\"861\":1,\"1198\":1}}],[\"loop\",{\"1\":{\"195\":1,\"235\":4,\"741\":1,\"1372\":1}}],[\"lockkey\",{\"1\":{\"1270\":6}}],[\"lockok\",{\"1\":{\"1226\":3}}],[\"lockbatchmq\",{\"1\":{\"1226\":2}}],[\"lockbatchrequestbody\",{\"1\":{\"1226\":2}}],[\"lockentry>\",{\"1\":{\"1222\":1}}],[\"lockentry>>\",{\"1\":{\"1222\":2}}],[\"lockentry\",{\"1\":{\"1212\":1,\"1214\":3,\"1222\":13}}],[\"lockedmq\",{\"1\":{\"1226\":3}}],[\"lockedmqs\",{\"1\":{\"1222\":5}}],[\"locked\",{\"1\":{\"1170\":1,\"1228\":1,\"1230\":1}}],[\"lockinterruptibly\",{\"1\":{\"971\":1,\"972\":2,\"1222\":1}}],[\"lock\",{\"1\":{\"720\":7,\"723\":3,\"736\":4,\"790\":1,\"793\":2,\"794\":1,\"797\":8,\"872\":1,\"971\":2,\"972\":4,\"1144\":2,\"1217\":1,\"1222\":4,\"1224\":2,\"1226\":2,\"1230\":2,\"1427\":1,\"1428\":1,\"1434\":1,\"1435\":2,\"1436\":2,\"1500\":1,\"1503\":1}}],[\"locks\",{\"1\":{\"137\":1}}],[\"locator\",{\"1\":{\"660\":4}}],[\"location\",{\"1\":{\"316\":1,\"960\":1}}],[\"localindexbuffer\",{\"1\":{\"1517\":1}}],[\"localtransactionlistener\",{\"1\":{\"1459\":5}}],[\"localtransactionstate\",{\"1\":{\"1017\":1,\"1442\":12,\"1459\":16,\"1460\":5,\"1472\":10}}],[\"localtrans\",{\"1\":{\"1442\":3}}],[\"localbuffer\",{\"1\":{\"1367\":12}}],[\"localfileoffsetstore\",{\"1\":{\"1103\":1,\"1120\":1,\"1122\":1,\"1190\":1}}],[\"localfunc\",{\"1\":{\"210\":1}}],[\"localdispatcher\",{\"1\":{\"1020\":2}}],[\"local\",{\"1\":{\"660\":1,\"964\":19,\"965\":2,\"966\":1,\"968\":4,\"1017\":3,\"1021\":1,\"1279\":1,\"1444\":1,\"1458\":1,\"1459\":1,\"1516\":1,\"1519\":2,\"1520\":2}}],[\"localappdata\",{\"1\":{\"165\":1}}],[\"localentrybuffer\",{\"1\":{\"1517\":1}}],[\"localexception\",{\"1\":{\"1459\":3,\"1460\":3}}],[\"locale\",{\"1\":{\"113\":1,\"125\":1,\"601\":1}}],[\"localsessionfactorybean\",{\"1\":{\"89\":2}}],[\"localhost\",{\"1\":{\"70\":1,\"73\":1,\"273\":1,\"368\":3,\"369\":1,\"712\":1,\"1441\":1}}],[\"logs\",{\"1\":{\"1075\":2,\"1079\":1,\"1080\":6}}],[\"logback\",{\"1\":{\"960\":2}}],[\"logger\",{\"1\":{\"960\":1,\"1008\":2,\"1270\":2,\"1273\":1,\"1275\":3,\"1276\":5,\"1277\":2,\"1278\":7,\"1279\":3,\"1280\":4,\"1370\":3,\"1371\":5,\"1372\":3,\"1373\":5,\"1374\":4,\"1464\":3,\"1469\":3,\"1471\":3,\"1495\":1,\"1497\":5,\"1499\":2,\"1500\":3,\"1503\":2,\"1514\":2,\"1516\":1,\"1517\":2,\"1518\":1,\"1519\":14,\"1520\":14,\"1521\":9}}],[\"loggerfactory\",{\"1\":{\"960\":1,\"1514\":1}}],[\"loggercontext\",{\"1\":{\"960\":2}}],[\"loggername\",{\"1\":{\"960\":2}}],[\"logging\",{\"1\":{\"60\":1}}],[\"logicoffset\",{\"1\":{\"828\":2}}],[\"logicsmsgtimestamp\",{\"1\":{\"769\":4}}],[\"logical\",{\"1\":{\"767\":1,\"1174\":1,\"1430\":1}}],[\"logic\",{\"1\":{\"765\":1,\"871\":2,\"1173\":1,\"1174\":5,\"1175\":1,\"1266\":1,\"1270\":1,\"1427\":1,\"1430\":2}}],[\"login\",{\"1\":{\"92\":3}}],[\"log\",{\"1\":{\"303\":4,\"309\":3,\"332\":1,\"338\":1,\"339\":2,\"351\":7,\"352\":1,\"353\":1,\"361\":1,\"364\":1,\"369\":5,\"529\":1,\"533\":3,\"538\":1,\"541\":1,\"544\":1,\"575\":1,\"577\":1,\"587\":1,\"605\":1,\"720\":1,\"722\":3,\"737\":4,\"765\":4,\"771\":5,\"787\":1,\"793\":1,\"794\":4,\"797\":5,\"820\":7,\"823\":1,\"824\":4,\"825\":2,\"844\":1,\"845\":5,\"860\":7,\"861\":8,\"870\":2,\"872\":1,\"886\":1,\"915\":1,\"960\":4,\"961\":3,\"970\":2,\"971\":2,\"972\":9,\"996\":2,\"998\":2,\"999\":7,\"1019\":1,\"1021\":1,\"1047\":1,\"1048\":6,\"1052\":1,\"1122\":2,\"1123\":1,\"1140\":2,\"1142\":1,\"1143\":6,\"1144\":7,\"1145\":3,\"1168\":4,\"1170\":12,\"1173\":15,\"1174\":5,\"1175\":5,\"1195\":5,\"1197\":2,\"1200\":3,\"1201\":2,\"1222\":1,\"1224\":5,\"1225\":2,\"1226\":2,\"1228\":4,\"1230\":8,\"1266\":5,\"1271\":1,\"1297\":9,\"1332\":6,\"1333\":6,\"1346\":1,\"1352\":1,\"1368\":8,\"1372\":1,\"1383\":4,\"1424\":1,\"1427\":9,\"1428\":1,\"1431\":3,\"1432\":3,\"1434\":3,\"1435\":11,\"1436\":6,\"1459\":4,\"1467\":4,\"1468\":14,\"1472\":6,\"1497\":2,\"1505\":1,\"1509\":3,\"1523\":1}}],[\"loadsslcontext\",{\"1\":{\"961\":1}}],[\"loadconsumequeue\",{\"1\":{\"759\":1}}],[\"loader\",{\"1\":{\"266\":1}}],[\"loaded\",{\"1\":{\"171\":1}}],[\"load\",{\"0\":{\"998\":1},\"1\":{\"91\":2,\"171\":5,\"364\":2,\"793\":3,\"844\":1,\"882\":1,\"960\":2,\"961\":2,\"996\":3,\"998\":6,\"999\":6,\"1122\":1,\"1266\":1,\"1420\":1,\"1421\":4,\"1424\":1}}],[\"long>\",{\"1\":{\"844\":1,\"999\":1,\"1201\":2,\"1468\":1}}],[\"longpollingenable=true\",{\"1\":{\"805\":1}}],[\"longpollingenable=false\",{\"1\":{\"805\":1}}],[\"longpollingenable\",{\"1\":{\"805\":1}}],[\"longpolling\",{\"1\":{\"799\":1}}],[\"longcanonicalname2\",{\"1\":{\"742\":1}}],[\"longcanonicalname1\",{\"1\":{\"742\":1}}],[\"longer\",{\"1\":{\"165\":1}}],[\"longadder\",{\"1\":{\"2\":1}}],[\"long\",{\"1\":{\"2\":1,\"90\":2,\"387\":1,\"390\":2,\"396\":5,\"712\":1,\"722\":1,\"737\":3,\"738\":2,\"742\":3,\"757\":1,\"765\":5,\"767\":3,\"769\":2,\"771\":5,\"789\":2,\"790\":4,\"793\":2,\"794\":7,\"795\":1,\"796\":1,\"797\":13,\"806\":1,\"812\":1,\"819\":2,\"823\":1,\"824\":2,\"825\":4,\"828\":3,\"840\":1,\"844\":2,\"845\":9,\"860\":10,\"870\":4,\"871\":1,\"872\":3,\"882\":2,\"915\":1,\"970\":1,\"971\":1,\"972\":1,\"994\":1,\"999\":1,\"1017\":2,\"1050\":6,\"1053\":4,\"1144\":1,\"1145\":1,\"1169\":1,\"1170\":6,\"1171\":5,\"1172\":1,\"1173\":4,\"1174\":20,\"1175\":4,\"1195\":3,\"1200\":1,\"1201\":3,\"1224\":1,\"1228\":1,\"1229\":4,\"1230\":4,\"1269\":2,\"1270\":4,\"1271\":3,\"1275\":3,\"1276\":2,\"1277\":4,\"1278\":9,\"1279\":1,\"1280\":1,\"1288\":1,\"1296\":3,\"1297\":5,\"1314\":1,\"1318\":2,\"1328\":1,\"1331\":1,\"1332\":2,\"1333\":1,\"1367\":6,\"1368\":3,\"1370\":4,\"1371\":5,\"1372\":5,\"1373\":1,\"1427\":11,\"1428\":1,\"1430\":1,\"1431\":2,\"1432\":4,\"1434\":4,\"1435\":1,\"1436\":10,\"1464\":1,\"1467\":3,\"1468\":17,\"1496\":1,\"1497\":5,\"1499\":2,\"1502\":3,\"1514\":1,\"1516\":3,\"1517\":4,\"1519\":17,\"1520\":15,\"1521\":10}}],[\"ledgerbegin=\",{\"1\":{\"1521\":2}}],[\"ledgerbeginindex\",{\"1\":{\"1517\":2,\"1519\":1}}],[\"ledgerterm\",{\"1\":{\"1497\":2}}],[\"ledger\",{\"1\":{\"1497\":3,\"1503\":3,\"1509\":1}}],[\"ledgerend=\",{\"1\":{\"1521\":2}}],[\"ledgerendindex=\",{\"1\":{\"1520\":3}}],[\"ledgerendindex++\",{\"1\":{\"1517\":1}}],[\"ledgerendindex\",{\"1\":{\"1492\":2,\"1497\":6,\"1502\":3,\"1503\":3,\"1508\":2,\"1509\":1,\"1517\":3,\"1519\":1,\"1520\":2}}],[\"ledgerendterm\",{\"1\":{\"1492\":6,\"1497\":3,\"1502\":3,\"1503\":5,\"1509\":1,\"1517\":2}}],[\"less\",{\"1\":{\"1201\":1,\"1519\":2}}],[\"leftnow\",{\"1\":{\"1519\":4}}],[\"left\",{\"1\":{\"585\":2,\"1436\":3}}],[\"let替代var可以申明一个块级作用域的变量\",{\"1\":{\"314\":1}}],[\"let\",{\"1\":{\"167\":1,\"314\":1,\"316\":3,\"349\":2,\"354\":2,\"369\":1,\"372\":1,\"502\":2,\"503\":6,\"504\":3,\"511\":1,\"512\":1,\"514\":1,\"515\":6,\"516\":1,\"517\":1,\"518\":2,\"519\":2,\"520\":2,\"522\":5,\"527\":1,\"531\":2,\"545\":1,\"551\":4,\"582\":5,\"589\":2,\"591\":1,\"596\":1,\"1503\":2}}],[\"lead\",{\"1\":{\"1145\":1}}],[\"leadership\",{\"1\":{\"1497\":1,\"1503\":1}}],[\"leaderid\",{\"1\":{\"1496\":3,\"1499\":2,\"1500\":1,\"1503\":1,\"1519\":11}}],[\"leader\",{\"0\":{\"1474\":1,\"1479\":1,\"1485\":1,\"1509\":1,\"1510\":1,\"1512\":1,\"1515\":1,\"1519\":1,\"1520\":1,\"1521\":1},\"1\":{\"649\":1,\"668\":5,\"672\":4,\"673\":4,\"674\":4,\"677\":1,\"1474\":1,\"1475\":2,\"1477\":3,\"1478\":1,\"1479\":2,\"1480\":5,\"1482\":1,\"1488\":2,\"1489\":6,\"1491\":3,\"1492\":4,\"1497\":11,\"1499\":9,\"1500\":17,\"1503\":8,\"1506\":2,\"1507\":7,\"1508\":5,\"1509\":3,\"1510\":12,\"1511\":5,\"1512\":1,\"1514\":3,\"1516\":8,\"1517\":8,\"1518\":3,\"1519\":30,\"1520\":28,\"1521\":2,\"1538\":1}}],[\"leaving\",{\"1\":{\"643\":1}}],[\"least\",{\"1\":{\"283\":1,\"1432\":1}}],[\"lea\",{\"0\":{\"107\":1},\"1\":{\"108\":1,\"138\":1}}],[\"learnjava\",{\"1\":{\"64\":1,\"89\":1}}],[\"length=\",{\"1\":{\"737\":2}}],[\"length\",{\"1\":{\"72\":1,\"73\":2,\"90\":3,\"125\":1,\"131\":1,\"297\":1,\"298\":3,\"331\":1,\"503\":1,\"563\":1,\"737\":10,\"794\":3,\"823\":1,\"870\":1,\"872\":1,\"886\":1,\"894\":2,\"906\":2,\"972\":1,\"1021\":1,\"1296\":2,\"1297\":5,\"1306\":2,\"1309\":1,\"1331\":3,\"1333\":1,\"1425\":2,\"1432\":5,\"1435\":5,\"1443\":1,\"1517\":1}}],[\"len\",{\"1\":{\"53\":1,\"625\":1,\"1368\":6}}],[\"level\",{\"1\":{\"9\":2,\"43\":1,\"720\":1,\"722\":1,\"840\":1,\"844\":3,\"1053\":1,\"1459\":1}}],[\"ljava\",{\"1\":{\"36\":1}}],[\"lsuvqp\",{\"1\":{\"455\":1}}],[\"ls\",{\"1\":{\"21\":1,\"152\":1,\"171\":2,\"252\":1,\"1074\":1}}],[\"li>\",{\"1\":{\"1435\":3}}],[\"light\",{\"0\":{\"1282\":1},\"1\":{\"1282\":1,\"1284\":1,\"1297\":2,\"1538\":1}}],[\"lightweight\",{\"1\":{\"1281\":1}}],[\"limit\",{\"1\":{\"722\":2,\"765\":1,\"1432\":5,\"1435\":1,\"1468\":2}}],[\"lives\",{\"1\":{\"1504\":1,\"1522\":1}}],[\"livemaxtimestamp\",{\"1\":{\"870\":2}}],[\"liveinfoparam\",{\"1\":{\"266\":1}}],[\"live\",{\"1\":{\"266\":2,\"1333\":1}}],[\"livecoreservice\",{\"1\":{\"266\":1}}],[\"libc\",{\"1\":{\"882\":3}}],[\"libc继承自com\",{\"1\":{\"882\":1}}],[\"libtinfo5\",{\"1\":{\"643\":2}}],[\"libsctp1\",{\"1\":{\"643\":4}}],[\"libwxgtk3\",{\"1\":{\"643\":8}}],[\"libwxgtk2\",{\"1\":{\"643\":2}}],[\"libwxbase3\",{\"1\":{\"643\":6}}],[\"libwxbase2\",{\"1\":{\"643\":2}}],[\"libncurses5\",{\"1\":{\"643\":4}}],[\"library\",{\"1\":{\"211\":1,\"882\":1}}],[\"lib\",{\"1\":{\"182\":2,\"211\":1,\"253\":1,\"256\":2}}],[\"lifecycle\",{\"1\":{\"62\":2}}],[\"lifecycle相当于java的package\",{\"1\":{\"61\":1}}],[\"list<indexitem>\",{\"1\":{\"1436\":3}}],[\"list<indexfile>\",{\"1\":{\"872\":1}}],[\"list<completablefuture<voteresponse>>\",{\"1\":{\"1497\":1,\"1502\":2}}],[\"list<completablefuture<void>>\",{\"1\":{\"1436\":1}}],[\"list<channel>\",{\"1\":{\"1331\":2}}],[\"list<filesegment>\",{\"1\":{\"1435\":1}}],[\"list<selectbufferresult>\",{\"1\":{\"1432\":1}}],[\"list<selectmappedbufferresult>\",{\"1\":{\"1431\":1}}],[\"list<string>\",{\"1\":{\"949\":1,\"950\":1,\"968\":1,\"970\":2,\"971\":1,\"1143\":1,\"1266\":1,\"1267\":1}}],[\"list<bytebuffer>\",{\"1\":{\"1428\":1}}],[\"list<brokerdata>\",{\"1\":{\"950\":1,\"968\":1}}],[\"list<timerrequest>\",{\"1\":{\"1371\":1,\"1372\":2,\"1373\":1}}],[\"list<tracetransferbean>\",{\"1\":{\"1021\":1}}],[\"list<tracetransferbean>>\",{\"1\":{\"1021\":3}}],[\"list<tracecontext>\",{\"1\":{\"1021\":2}}],[\"list<tracebean>\",{\"1\":{\"1017\":1,\"1020\":1}}],[\"list<dataversion>\",{\"1\":{\"998\":1}}],[\"list<plainaccessconfig>\",{\"1\":{\"998\":1}}],[\"list<pullrequest>\",{\"1\":{\"825\":2,\"1144\":1,\"1224\":1}}],[\"list<accessvalidator>\",{\"1\":{\"996\":1}}],[\"list<remoteaddressstrategy>>\",{\"1\":{\"997\":1,\"998\":1}}],[\"list<remoteaddressstrategy>\",{\"1\":{\"997\":1,\"998\":2}}],[\"list<registerbrokerresult>\",{\"1\":{\"970\":2}}],[\"list<rpchook>\",{\"1\":{\"994\":1}}],[\"list<message\",{\"1\":{\"1346\":1}}],[\"list<messagequeue>\",{\"1\":{\"1143\":2,\"1266\":2,\"1267\":4}}],[\"list<message>\",{\"1\":{\"1044\":1}}],[\"list<messageext>\",{\"1\":{\"985\":1,\"1007\":1,\"1194\":2,\"1195\":1,\"1230\":1,\"1278\":1,\"1288\":1,\"1329\":2,\"1444\":1,\"1468\":1}}],[\"list<mappedfile>\",{\"1\":{\"771\":1,\"870\":1}}],[\"list<queuedata>\",{\"1\":{\"950\":1,\"968\":1,\"972\":1}}],[\"list<queuedata>>>\",{\"1\":{\"972\":1}}],[\"list<queuedata>>\",{\"1\":{\"949\":1,\"972\":1}}],[\"list<long>\",{\"1\":{\"790\":1,\"794\":1,\"797\":2,\"1431\":2,\"1468\":1,\"1521\":1}}],[\"list<user>\",{\"1\":{\"92\":2}}],[\"listener\",{\"1\":{\"961\":2,\"999\":3,\"1104\":1,\"1117\":1,\"1195\":2,\"1468\":5}}],[\"listenport=10931\",{\"1\":{\"1075\":1}}],[\"listenport\",{\"1\":{\"960\":1}}],[\"listening\",{\"1\":{\"112\":1}}],[\"listexp\",{\"1\":{\"184\":1}}],[\"listexpr\",{\"1\":{\"184\":1}}],[\"lists\",{\"1\":{\"181\":5,\"184\":3,\"192\":2,\"248\":1,\"253\":1,\"256\":1,\"643\":1}}],[\"listfiles\",{\"1\":{\"52\":1,\"793\":1}}],[\"list\",{\"1\":{\"52\":1,\"92\":6,\"165\":2,\"171\":4,\"184\":1,\"185\":1,\"200\":1,\"248\":2,\"256\":1,\"289\":2,\"644\":1,\"976\":1,\"1143\":1,\"1266\":1,\"1267\":1,\"1288\":4,\"1432\":1}}],[\"liaoxuefeng\",{\"1\":{\"16\":1,\"291\":1,\"1299\":1}}],[\"linebreaker\",{\"1\":{\"287\":1}}],[\"line\",{\"1\":{\"142\":4,\"147\":2,\"192\":2,\"195\":8,\"213\":1,\"253\":1,\"1444\":1}}],[\"links\",{\"1\":{\"1075\":1,\"1078\":1}}],[\"linkedblockingqueue<pullrequest>\",{\"1\":{\"1168\":2}}],[\"linkedblockingqueue<putresultprocess>\",{\"1\":{\"861\":1}}],[\"linkedlist<selectmappedbufferresult>\",{\"1\":{\"1372\":1}}],[\"linkedlist<timerrequest>\",{\"1\":{\"1372\":2}}],[\"linkedlist<>\",{\"1\":{\"9\":1,\"1372\":3}}],[\"linkedlist<integer>\",{\"1\":{\"9\":1}}],[\"linkedlist\",{\"1\":{\"2\":1,\"9\":5}}],[\"link\",{\"1\":{\"132\":1,\"765\":1,\"1021\":1,\"1080\":3,\"1081\":1,\"1169\":1,\"1425\":2,\"1427\":1,\"1428\":1,\"1514\":1,\"1520\":3,\"1521\":1}}],[\"linux内核page\",{\"1\":{\"1527\":1}}],[\"linux中普通文件和块设备文件的区别\",{\"1\":{\"1527\":1}}],[\"linux\",{\"1\":{\"7\":1,\"288\":1,\"1074\":1,\"1527\":1}}],[\"lxf\",{\"1\":{\"16\":1,\"291\":1}}],[\"ibarr5f3z\",{\"1\":{\"469\":1}}],[\"iul1be9b4\",{\"1\":{\"469\":1}}],[\"ijyyjx\",{\"1\":{\"443\":1}}],[\"i4bch4vap\",{\"1\":{\"436\":1}}],[\"iquhbq00n9c0dw36eb6fq9wucajrs5xyymkap8wdaswm9jrzq9\",{\"1\":{\"423\":1}}],[\"illustration\",{\"1\":{\"420\":1}}],[\"illegalaccessexception\",{\"1\":{\"742\":1}}],[\"illegalargumentexception\",{\"1\":{\"34\":1,\"396\":1,\"960\":1}}],[\"illegal\",{\"1\":{\"396\":1,\"737\":1,\"1173\":1,\"1175\":2,\"1432\":2,\"1464\":2,\"1468\":3}}],[\"illegalstateexception\",{\"1\":{\"102\":2}}],[\"i=1\",{\"1\":{\"330\":1}}],[\"i=0\",{\"1\":{\"311\":1,\"314\":1,\"331\":1}}],[\"i<rest\",{\"1\":{\"331\":1}}],[\"i<=3\",{\"1\":{\"330\":1}}],[\"i<100\",{\"1\":{\"311\":1,\"314\":1}}],[\"i<i>\",{\"1\":{\"155\":1}}],[\"ih\",{\"1\":{\"171\":1}}],[\"iwr\",{\"1\":{\"165\":1}}],[\"iw\",{\"1\":{\"155\":1}}],[\"immunity\",{\"1\":{\"1468\":1}}],[\"immediately\",{\"1\":{\"1173\":6,\"1427\":1,\"1431\":1,\"1497\":1,\"1500\":1,\"1516\":1}}],[\"improving\",{\"1\":{\"1437\":1}}],[\"improve\",{\"1\":{\"720\":2,\"723\":1,\"736\":1,\"849\":1,\"886\":3,\"889\":1,\"892\":1,\"898\":1}}],[\"improvements\",{\"1\":{\"886\":1}}],[\"improvement\",{\"1\":{\"719\":1,\"885\":1,\"1437\":1}}],[\"importsnotusedasvalues\",{\"0\":{\"593\":1}}],[\"important\",{\"1\":{\"253\":1}}],[\"import\",{\"0\":{\"592\":1,\"595\":1},\"1\":{\"203\":1,\"253\":1,\"591\":3,\"592\":6,\"593\":4,\"595\":3,\"597\":1,\"598\":7,\"712\":3}}],[\"implementation\",{\"1\":{\"135\":1,\"1437\":1}}],[\"implementation=\",{\"1\":{\"64\":1}}],[\"implements\",{\"0\":{\"570\":1},\"1\":{\"112\":1,\"113\":1,\"121\":1,\"123\":1,\"124\":1,\"128\":1,\"133\":1,\"396\":2,\"570\":2,\"571\":2,\"573\":1,\"742\":1,\"828\":1,\"1017\":1,\"1021\":2,\"1442\":1}}],[\"img\",{\"1\":{\"135\":1,\"374\":1,\"387\":3,\"388\":2,\"446\":1,\"716\":2,\"1300\":1,\"1322\":1}}],[\"images\",{\"1\":{\"1072\":1}}],[\"image\",{\"1\":{\"135\":1,\"375\":1,\"376\":1,\"378\":3,\"379\":5,\"380\":2,\"399\":1,\"400\":2,\"402\":1,\"403\":3,\"407\":1,\"423\":1,\"425\":2,\"426\":1,\"427\":1,\"428\":4,\"429\":1,\"431\":2,\"432\":2,\"433\":1,\"434\":2,\"435\":4,\"436\":1,\"438\":2,\"439\":1,\"440\":1,\"441\":2,\"442\":4,\"443\":2,\"446\":2,\"447\":1,\"448\":4,\"449\":1,\"453\":2,\"454\":9,\"455\":3,\"457\":1,\"458\":1,\"459\":2,\"460\":1,\"461\":3,\"462\":1,\"465\":1,\"466\":1,\"468\":4,\"469\":1,\"471\":1,\"473\":1,\"475\":5,\"482\":2,\"483\":3,\"484\":1,\"485\":14,\"711\":5,\"878\":1,\"888\":1,\"896\":1,\"897\":1,\"899\":1,\"900\":3,\"902\":1,\"903\":1,\"904\":1,\"906\":1,\"909\":1,\"912\":4,\"1072\":6,\"1073\":2,\"1075\":3,\"1077\":1,\"1078\":1,\"1079\":2,\"1318\":1,\"1321\":1}}],[\"i++\",{\"1\":{\"131\":1,\"311\":1,\"314\":1,\"330\":1,\"331\":1,\"396\":2,\"712\":1,\"714\":1,\"715\":1,\"769\":1,\"794\":1,\"870\":1,\"872\":1,\"984\":1,\"998\":1,\"999\":2,\"1021\":1,\"1052\":2,\"1194\":1,\"1195\":2,\"1267\":1,\"1269\":3,\"1277\":1,\"1296\":1,\"1297\":3,\"1306\":1,\"1309\":1,\"1373\":1,\"1431\":1,\"1434\":1,\"1435\":1,\"1436\":1,\"1443\":1,\"1468\":3}}],[\"ignored\",{\"1\":{\"871\":1,\"1168\":1,\"1468\":1}}],[\"ignore\",{\"1\":{\"125\":1,\"1278\":1,\"1370\":1,\"1459\":1,\"1497\":1,\"1519\":1}}],[\"i\",{\"0\":{\"125\":1,\"907\":1},\"1\":{\"114\":1,\"118\":6,\"124\":1,\"125\":1,\"127\":1,\"130\":3,\"131\":3,\"137\":1,\"142\":2,\"155\":2,\"162\":1,\"171\":4,\"178\":1,\"182\":6,\"194\":2,\"195\":3,\"311\":1,\"314\":2,\"330\":1,\"331\":2,\"345\":1,\"396\":6,\"436\":1,\"443\":1,\"622\":2,\"643\":2,\"645\":2,\"646\":1,\"662\":2,\"712\":4,\"714\":3,\"715\":3,\"720\":1,\"722\":3,\"742\":3,\"767\":3,\"769\":2,\"771\":4,\"794\":8,\"845\":5,\"860\":5,\"870\":4,\"872\":3,\"879\":1,\"882\":6,\"886\":1,\"890\":1,\"917\":1,\"924\":1,\"984\":2,\"998\":8,\"999\":6,\"1008\":1,\"1021\":2,\"1052\":4,\"1174\":5,\"1194\":2,\"1195\":6,\"1267\":2,\"1269\":9,\"1277\":6,\"1287\":1,\"1296\":4,\"1297\":10,\"1300\":1,\"1306\":4,\"1309\":5,\"1339\":1,\"1370\":7,\"1373\":3,\"1425\":4,\"1431\":5,\"1434\":2,\"1435\":5,\"1436\":2,\"1443\":5,\"1453\":1,\"1468\":17,\"1521\":6,\"1527\":2}}],[\"id作为处理依据\",{\"1\":{\"1237\":1}}],[\"id对应的消息内容可能相同\",{\"1\":{\"1237\":1}}],[\"idle\",{\"1\":{\"972\":1}}],[\"id=a表示消息的发送者为节点\",{\"1\":{\"674\":1}}],[\"idempotentrelease\",{\"1\":{\"1371\":2,\"1373\":5,\"1374\":1}}],[\"identity\",{\"1\":{\"90\":1}}],[\"idea\",{\"0\":{\"264\":1},\"1\":{\"6\":1,\"7\":2,\"10\":1,\"271\":1,\"272\":2}}],[\"id\",{\"1\":{\"90\":1,\"91\":2,\"253\":4,\"316\":2,\"364\":1,\"398\":1,\"554\":3,\"579\":2,\"715\":5,\"736\":1,\"767\":1,\"843\":1,\"899\":9,\"935\":1,\"971\":3,\"996\":1,\"1008\":1,\"1017\":3,\"1042\":1,\"1047\":1,\"1053\":5,\"1072\":1,\"1075\":1,\"1077\":1,\"1079\":2,\"1120\":1,\"1137\":2,\"1143\":2,\"1173\":3,\"1174\":1,\"1188\":1,\"1198\":2,\"1200\":2,\"1212\":1,\"1214\":1,\"1222\":1,\"1226\":1,\"1266\":1,\"1267\":2,\"1270\":3,\"1271\":2,\"1273\":1,\"1293\":1,\"1364\":1,\"1370\":1,\"1427\":2,\"1430\":1,\"1459\":1,\"1460\":4,\"1463\":3,\"1464\":1,\"1468\":1,\"1469\":2,\"1471\":1,\"1472\":1,\"1499\":6,\"1500\":1,\"1502\":3,\"1514\":1,\"1519\":2}}],[\"iptoipv4str\",{\"1\":{\"1017\":1}}],[\"ipv6\",{\"1\":{\"720\":1,\"736\":2}}],[\"ip协议把数据传输到网络\",{\"1\":{\"68\":1}}],[\"ip\",{\"1\":{\"67\":2,\"71\":1,\"237\":1,\"899\":1,\"971\":3,\"976\":1,\"978\":2,\"983\":1,\"991\":2,\"997\":2,\"998\":1,\"1000\":2,\"1017\":6,\"1075\":7,\"1080\":3,\"1240\":1,\"1287\":2,\"1288\":2}}],[\"isquorum\",{\"1\":{\"1497\":6,\"1499\":4}}],[\"isnotempty\",{\"1\":{\"1471\":1}}],[\"isnotifyconsumeridschangedenable\",{\"1\":{\"1331\":1}}],[\"isneedcheck\",{\"1\":{\"1468\":2}}],[\"isrunningdequeue\",{\"1\":{\"1372\":3,\"1374\":2}}],[\"isrunningenqueue\",{\"1\":{\"1370\":3}}],[\"isreadaheadcacheenable\",{\"1\":{\"1430\":1}}],[\"isreadable\",{\"1\":{\"1173\":2,\"1174\":1}}],[\"isrejecttransactionmessage\",{\"1\":{\"1056\":1,\"1462\":1}}],[\"isretry\",{\"1\":{\"1270\":6}}],[\"isretryanotherbrokerwhennotstoreok\",{\"1\":{\"1050\":1}}],[\"isretrytopic\",{\"1\":{\"1000\":1}}],[\"ismessageindexenable\",{\"1\":{\"1427\":1}}],[\"ismsginlive\",{\"1\":{\"1333\":1}}],[\"ismatchedbycommitlog的调用层级\",{\"1\":{\"1318\":1}}],[\"ismatchedbycommitlog\",{\"1\":{\"825\":1,\"1174\":1,\"1318\":3,\"1324\":1,\"1333\":1}}],[\"ismatchedbyconsumequeue\",{\"1\":{\"767\":1,\"825\":1,\"1174\":1,\"1318\":5,\"1319\":1,\"1324\":1,\"1328\":1,\"1333\":1}}],[\"ishit\",{\"1\":{\"1323\":1,\"1333\":1}}],[\"ishavetopicrouterinfo\",{\"1\":{\"1051\":1}}],[\"isjustoffset\",{\"1\":{\"1276\":1,\"1277\":2}}],[\"isindisk\",{\"1\":{\"1174\":2}}],[\"isdone\",{\"1\":{\"1521\":1}}],[\"isdebugenabled\",{\"1\":{\"1517\":1}}],[\"isdelete\",{\"1\":{\"1371\":4}}],[\"isdiskfull\",{\"1\":{\"1517\":1}}],[\"isdiskfallrecorded\",{\"1\":{\"1174\":1}}],[\"isdropped\",{\"1\":{\"1170\":1,\"1195\":3,\"1230\":4}}],[\"isleader\",{\"1\":{\"1496\":1,\"1516\":1,\"1517\":2,\"1519\":2,\"1521\":1}}],[\"islmqconsumequeuenumexceeded\",{\"1\":{\"1174\":1}}],[\"islmq\",{\"1\":{\"1174\":1,\"1296\":1,\"1297\":1}}],[\"islockexpired\",{\"1\":{\"1230\":2}}],[\"islocked\",{\"1\":{\"1170\":1,\"1222\":2,\"1228\":1,\"1230\":2}}],[\"islongpollingenable\",{\"1\":{\"762\":1,\"819\":1,\"824\":1,\"827\":1,\"1173\":1}}],[\"isok\",{\"1\":{\"1462\":1}}],[\"isoneway\",{\"1\":{\"1200\":2}}],[\"isoffsetcheckinslave\",{\"1\":{\"1173\":1}}],[\"isorder\",{\"1\":{\"1142\":2,\"1143\":3,\"1144\":3,\"1224\":3,\"1269\":4,\"1270\":4}}],[\"isordermessageenable\",{\"1\":{\"973\":1}}],[\"ispresent\",{\"1\":{\"1521\":2}}],[\"ispreviouslylocked\",{\"1\":{\"1170\":1,\"1228\":1}}],[\"ispendingfull\",{\"1\":{\"1516\":1}}],[\"ispeermember\",{\"1\":{\"1500\":1,\"1503\":1}}],[\"ispostsubscriptionwhenpull\",{\"1\":{\"1170\":1}}],[\"ispause\",{\"1\":{\"1170\":1}}],[\"ispullexpired\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"isunitmode=\",{\"1\":{\"1122\":1}}],[\"isunitmode\",{\"1\":{\"1053\":1,\"1122\":2,\"1198\":1}}],[\"isual\",{\"1\":{\"155\":1,\"156\":1}}],[\"isbatch\",{\"1\":{\"1520\":3}}],[\"isbatchwait\",{\"1\":{\"1518\":4}}],[\"isblank\",{\"1\":{\"1021\":1,\"1197\":1,\"1198\":2,\"1235\":1,\"1296\":1,\"1297\":2,\"1434\":2}}],[\"isbrokertopicconfigchanged\",{\"1\":{\"971\":1}}],[\"isgroup\",{\"1\":{\"1000\":4}}],[\"iswritable\",{\"1\":{\"1299\":3}}],[\"iswriteable\",{\"1\":{\"1198\":2,\"1300\":2}}],[\"iswritefull\",{\"1\":{\"793\":1,\"796\":1}}],[\"iswaitstoremsgok\",{\"1\":{\"1056\":1}}],[\"iswatchstart\",{\"1\":{\"997\":1,\"999\":1}}],[\"isasyncsendenable\",{\"1\":{\"1462\":1}}],[\"isavailable\",{\"1\":{\"1052\":1}}],[\"isadmin\",{\"1\":{\"1000\":2}}],[\"isaclenable\",{\"1\":{\"996\":1}}],[\"isarray\",{\"1\":{\"333\":1}}],[\"iscandidate\",{\"1\":{\"1497\":1}}],[\"iscqwriteable\",{\"1\":{\"1297\":2}}],[\"isckdoneforfinish\",{\"1\":{\"1277\":2}}],[\"isckdone\",{\"1\":{\"1277\":2}}],[\"isckstored\",{\"1\":{\"1277\":4}}],[\"isconsumeorderly\",{\"1\":{\"1225\":1}}],[\"isconsumebroadcastenable\",{\"1\":{\"1173\":1}}],[\"isconsumeenable\",{\"1\":{\"1173\":1}}],[\"iscommitlogavailable\",{\"1\":{\"762\":1}}],[\"isclassfiltermode\",{\"1\":{\"1170\":2,\"1328\":1,\"1329\":1,\"1333\":2}}],[\"iscleanfileforciblyenable\",{\"1\":{\"870\":1}}],[\"istakingleadership\",{\"1\":{\"1503\":1}}],[\"istagtype\",{\"1\":{\"1171\":1,\"1173\":3,\"1328\":1,\"1331\":1,\"1333\":2}}],[\"istagscodelegal\",{\"1\":{\"767\":1,\"1174\":3}}],[\"istieredstoregroupcommit\",{\"1\":{\"1427\":1}}],[\"istimeout\",{\"1\":{\"1520\":1}}],[\"istimerwheelenable\",{\"1\":{\"1424\":1}}],[\"istimerstopdequeue\",{\"1\":{\"1372\":1}}],[\"istimerstopenqueue\",{\"1\":{\"1370\":1}}],[\"istimerskipunknownerror\",{\"1\":{\"1370\":1,\"1371\":2,\"1372\":1,\"1373\":1,\"1374\":1}}],[\"istimetodelete\",{\"1\":{\"870\":1}}],[\"istimematched\",{\"1\":{\"794\":1}}],[\"isthebatchfull\",{\"1\":{\"1174\":1}}],[\"istransfermsgbyheap\",{\"1\":{\"1173\":1}}],[\"istrans\",{\"1\":{\"1053\":3}}],[\"isfollower\",{\"1\":{\"1495\":1,\"1520\":1}}],[\"isflatfileinit\",{\"1\":{\"1427\":1}}],[\"isfull\",{\"1\":{\"1368\":1}}],[\"isfiltersupportretry\",{\"1\":{\"1173\":1}}],[\"isfirstcreateinqueue\",{\"1\":{\"765\":1}}],[\"isfruit\",{\"1\":{\"181\":4}}],[\"isserverloadbalancerenable\",{\"1\":{\"1266\":1}}],[\"issendmessagewithvipchannel\",{\"1\":{\"1047\":1,\"1053\":1}}],[\"isslavereadenable\",{\"1\":{\"1173\":2}}],[\"isslave\",{\"1\":{\"1171\":1}}],[\"issynthetic\",{\"1\":{\"995\":1}}],[\"isspacetodelete\",{\"1\":{\"870\":1}}],[\"isstarted\",{\"1\":{\"860\":1,\"861\":2,\"1021\":1}}],[\"isstatic\",{\"1\":{\"742\":1}}],[\"isstopped\",{\"1\":{\"824\":1,\"999\":1,\"1140\":1,\"1168\":1,\"1371\":2,\"1373\":2,\"1374\":3,\"1427\":1,\"1435\":1,\"1467\":1}}],[\"issucc\",{\"1\":{\"1371\":1}}],[\"issuccess\",{\"1\":{\"762\":1,\"820\":1,\"1017\":1,\"1020\":1,\"1173\":1}}],[\"issuggestpullingfromslave\",{\"1\":{\"1173\":2}}],[\"issue\",{\"1\":{\"720\":1,\"786\":1,\"886\":1,\"1299\":2,\"1380\":1}}],[\"issues\",{\"1\":{\"268\":1,\"852\":1,\"1053\":1,\"1504\":1,\"1522\":1}}],[\"isvirtualnodeof\",{\"1\":{\"396\":3}}],[\"isenablebatchpush\",{\"1\":{\"1519\":3}}],[\"isenablerocksdbstore\",{\"1\":{\"1424\":1}}],[\"isenablecalcfilterbitmap\",{\"1\":{\"1322\":1,\"1332\":1}}],[\"isenabledlegercommitlog\",{\"1\":{\"1297\":1,\"1424\":1}}],[\"isenablelmq\",{\"1\":{\"1296\":1,\"1297\":1}}],[\"isenablemultidispatch\",{\"1\":{\"1296\":1,\"1297\":1}}],[\"isenablepoplog\",{\"1\":{\"1275\":2,\"1276\":3,\"1277\":1,\"1278\":2,\"1280\":1}}],[\"isenablepopbuffermerge\",{\"1\":{\"1275\":1,\"1276\":1}}],[\"isenablepropertyfilter\",{\"1\":{\"1173\":1}}],[\"isexpired\",{\"1\":{\"1222\":1}}],[\"isextwriteenable\",{\"1\":{\"1297\":1}}],[\"isextreadenable\",{\"1\":{\"771\":1}}],[\"isextaddr\",{\"1\":{\"771\":1,\"845\":1,\"860\":1,\"1174\":1,\"1297\":1}}],[\"isequalto\",{\"1\":{\"105\":3}}],[\"isempty\",{\"1\":{\"92\":1,\"396\":2,\"771\":1,\"793\":1,\"794\":1,\"825\":1,\"872\":1,\"894\":2,\"971\":1,\"972\":3,\"996\":1,\"998\":5,\"1020\":2,\"1021\":1,\"1175\":1,\"1195\":3,\"1200\":2,\"1222\":1,\"1229\":1,\"1230\":1,\"1269\":1,\"1270\":1,\"1278\":1,\"1288\":1,\"1297\":1,\"1329\":1,\"1332\":1,\"1371\":1,\"1427\":1,\"1432\":1,\"1434\":2,\"1436\":1,\"1463\":1,\"1520\":1}}],[\"is\",{\"1\":{\"46\":2,\"69\":1,\"101\":1,\"103\":1,\"104\":2,\"112\":1,\"186\":10,\"316\":2,\"339\":3,\"396\":1,\"605\":2,\"640\":1,\"643\":9,\"645\":1,\"737\":1,\"742\":11,\"825\":1,\"835\":1,\"845\":1,\"860\":1,\"882\":1,\"886\":2,\"901\":1,\"906\":1,\"960\":1,\"983\":1,\"995\":1,\"998\":3,\"1000\":5,\"1005\":1,\"1020\":2,\"1056\":2,\"1144\":1,\"1145\":2,\"1170\":1,\"1173\":6,\"1174\":4,\"1195\":1,\"1198\":3,\"1200\":1,\"1225\":1,\"1267\":1,\"1270\":5,\"1277\":1,\"1278\":3,\"1279\":1,\"1280\":4,\"1287\":1,\"1308\":12,\"1310\":3,\"1333\":1,\"1370\":1,\"1371\":1,\"1372\":1,\"1427\":3,\"1432\":1,\"1435\":2,\"1458\":1,\"1459\":1,\"1462\":1,\"1464\":2,\"1468\":3,\"1469\":1,\"1472\":1,\"1500\":1,\"1503\":2,\"1516\":1,\"1519\":8,\"1520\":3}}],[\"ifconfig\",{\"1\":{\"243\":1}}],[\"ifndef\",{\"1\":{\"214\":1}}],[\"ifdef\",{\"1\":{\"214\":1}}],[\"if表达式必须至少有一个关卡的执行结果为true\",{\"1\":{\"188\":1}}],[\"if\",{\"0\":{\"188\":1},\"1\":{\"34\":1,\"41\":1,\"48\":1,\"69\":1,\"70\":1,\"91\":1,\"97\":3,\"101\":1,\"102\":1,\"122\":1,\"123\":1,\"125\":11,\"128\":1,\"131\":1,\"133\":1,\"167\":1,\"180\":1,\"186\":1,\"188\":3,\"253\":2,\"289\":1,\"306\":2,\"338\":1,\"348\":2,\"351\":1,\"356\":2,\"369\":1,\"396\":6,\"503\":2,\"504\":2,\"518\":1,\"519\":1,\"547\":1,\"558\":3,\"624\":1,\"626\":2,\"722\":2,\"737\":8,\"738\":1,\"742\":16,\"762\":4,\"765\":6,\"767\":7,\"769\":4,\"771\":7,\"793\":7,\"794\":12,\"796\":3,\"797\":17,\"819\":2,\"820\":2,\"822\":2,\"823\":1,\"824\":2,\"825\":8,\"827\":1,\"843\":3,\"844\":4,\"845\":11,\"860\":13,\"861\":4,\"870\":10,\"871\":2,\"872\":5,\"882\":4,\"891\":4,\"893\":1,\"894\":6,\"915\":2,\"960\":7,\"961\":7,\"970\":2,\"971\":12,\"972\":12,\"973\":2,\"983\":1,\"994\":3,\"995\":6,\"996\":2,\"998\":10,\"999\":4,\"1000\":13,\"1005\":1,\"1019\":1,\"1020\":10,\"1021\":7,\"1047\":3,\"1048\":3,\"1050\":7,\"1051\":2,\"1052\":8,\"1053\":19,\"1056\":6,\"1122\":5,\"1123\":2,\"1142\":2,\"1143\":8,\"1144\":9,\"1145\":3,\"1170\":17,\"1171\":5,\"1173\":31,\"1174\":25,\"1175\":5,\"1194\":2,\"1195\":17,\"1198\":17,\"1200\":7,\"1201\":2,\"1222\":6,\"1224\":9,\"1225\":2,\"1226\":2,\"1228\":4,\"1229\":3,\"1230\":19,\"1235\":1,\"1266\":9,\"1267\":3,\"1269\":12,\"1270\":10,\"1271\":1,\"1273\":3,\"1275\":7,\"1276\":10,\"1277\":15,\"1278\":15,\"1279\":6,\"1280\":10,\"1287\":1,\"1288\":1,\"1296\":3,\"1297\":11,\"1328\":5,\"1329\":4,\"1331\":7,\"1332\":6,\"1333\":14,\"1367\":1,\"1368\":7,\"1370\":11,\"1371\":13,\"1372\":15,\"1373\":8,\"1374\":4,\"1424\":3,\"1425\":1,\"1427\":22,\"1428\":9,\"1430\":6,\"1431\":4,\"1432\":6,\"1434\":10,\"1435\":7,\"1436\":13,\"1442\":1,\"1458\":1,\"1459\":7,\"1460\":1,\"1462\":8,\"1463\":1,\"1464\":10,\"1468\":22,\"1469\":2,\"1471\":5,\"1472\":4,\"1495\":2,\"1496\":2,\"1497\":16,\"1499\":10,\"1500\":10,\"1502\":1,\"1503\":11,\"1516\":4,\"1517\":2,\"1518\":4,\"1519\":38,\"1520\":16,\"1521\":15}}],[\"itqueuedata\",{\"1\":{\"972\":4}}],[\"ittopicqueuetable\",{\"1\":{\"972\":4}}],[\"itbrokeraddrtable\",{\"1\":{\"972\":4}}],[\"itbrokerlivetable\",{\"1\":{\"972\":3}}],[\"itself\",{\"1\":{\"690\":1,\"1296\":1}}],[\"itl0\",{\"1\":{\"429\":1}}],[\"iterable\",{\"0\":{\"303\":1}}],[\"iteratefilesegment\",{\"1\":{\"1421\":1}}],[\"iterator<byte\",{\"1\":{\"1516\":1}}],[\"iterator<consumerfilterdata>\",{\"1\":{\"1332\":1}}],[\"iterator<map\",{\"1\":{\"1277\":1}}],[\"iterator<queuedata>\",{\"1\":{\"972\":1}}],[\"iterator<entry<messagequeue\",{\"1\":{\"1144\":1,\"1224\":1}}],[\"iterator<entry<string\",{\"1\":{\"972\":4}}],[\"iterator<entry<long\",{\"1\":{\"971\":1,\"972\":1}}],[\"iterator<long>\",{\"1\":{\"396\":1}}],[\"iterator<selectionkey>\",{\"1\":{\"122\":1}}],[\"iterator\",{\"1\":{\"118\":1,\"122\":4,\"303\":1,\"396\":1,\"971\":1,\"972\":6,\"1144\":1,\"1224\":1,\"1277\":6,\"1332\":4,\"1516\":4}}],[\"iterations\",{\"1\":{\"9\":2,\"11\":3}}],[\"iteration\",{\"1\":{\"4\":1,\"9\":2,\"11\":21}}],[\"itembuffer\",{\"1\":{\"1436\":5}}],[\"itemlist\",{\"1\":{\"1436\":2}}],[\"itemindex\",{\"1\":{\"1434\":4}}],[\"item=name\",{\"1\":{\"253\":1}}],[\"item\",{\"1\":{\"253\":13,\"755\":2,\"787\":1,\"971\":3,\"1434\":2,\"1435\":7,\"1436\":9}}],[\"it\",{\"1\":{\"97\":4,\"104\":2,\"372\":1,\"396\":4,\"845\":2,\"971\":4,\"972\":9,\"983\":2,\"1000\":1,\"1020\":2,\"1056\":3,\"1077\":1,\"1144\":6,\"1195\":2,\"1224\":5,\"1225\":1,\"1230\":4,\"1266\":1,\"1267\":1,\"1270\":1,\"1287\":1,\"1371\":1,\"1373\":1,\"1468\":2,\"1500\":1,\"1503\":2,\"1516\":1,\"1519\":1}}],[\"itranswarp\",{\"1\":{\"21\":5,\"64\":1,\"89\":1}}],[\"in=\",{\"1\":{\"1468\":2}}],[\"invisibletime\",{\"1\":{\"1251\":1}}],[\"invalid\",{\"1\":{\"845\":1,\"860\":2,\"1266\":1,\"1276\":1,\"1278\":1,\"1434\":1,\"1435\":1,\"1436\":2}}],[\"invalidindex\",{\"1\":{\"797\":5}}],[\"invocations\",{\"1\":{\"104\":1}}],[\"invocation\",{\"1\":{\"103\":1}}],[\"invocationhandler\",{\"1\":{\"41\":2}}],[\"invoked\",{\"1\":{\"1056\":2,\"1333\":1,\"1468\":1}}],[\"invokeid\",{\"1\":{\"1050\":1}}],[\"invokesync\",{\"1\":{\"994\":1}}],[\"invoke\",{\"1\":{\"4\":1,\"41\":1,\"273\":1}}],[\"indoors\",{\"1\":{\"490\":3}}],[\"index=\",{\"1\":{\"1518\":1,\"1519\":1,\"1520\":2,\"1521\":2}}],[\"indexpos\",{\"1\":{\"1517\":2}}],[\"indexposition\",{\"1\":{\"1436\":3}}],[\"indexbuffer\",{\"1\":{\"1517\":5}}],[\"indextotalsize\",{\"1\":{\"1436\":3}}],[\"indexitem>\",{\"1\":{\"1436\":1}}],[\"indexitem\",{\"1\":{\"1434\":6,\"1435\":1,\"1436\":17}}],[\"indexitemmaxcount\",{\"1\":{\"1434\":2}}],[\"indexitemcount\",{\"1\":{\"1434\":3,\"1435\":1,\"1436\":1}}],[\"indexstatusenum\",{\"1\":{\"1434\":1,\"1435\":2}}],[\"indexstoreservice\",{\"0\":{\"1434\":1,\"1435\":1,\"1436\":1},\"1\":{\"1402\":1,\"1412\":1,\"1413\":1,\"1414\":1,\"1415\":1,\"1417\":2,\"1434\":2,\"1435\":6,\"1436\":1}}],[\"indexstorefile\",{\"0\":{\"1434\":1,\"1435\":1,\"1436\":1},\"1\":{\"1386\":2,\"1402\":2,\"1412\":3,\"1417\":2,\"1434\":3,\"1435\":7,\"1436\":7}}],[\"indexsize\",{\"1\":{\"797\":2}}],[\"indexservice\",{\"0\":{\"789\":1,\"792\":1},\"1\":{\"786\":1,\"793\":1,\"872\":1,\"1412\":1}}],[\"indexlastupdatephyoffset\",{\"1\":{\"794\":3}}],[\"indexlastupdatetimestamp\",{\"1\":{\"794\":3}}],[\"indexheader\",{\"1\":{\"793\":1,\"797\":22}}],[\"indexnum\",{\"1\":{\"793\":2,\"797\":2}}],[\"indexmsgtimestamp\",{\"1\":{\"789\":2,\"793\":1,\"796\":4}}],[\"indexcount\",{\"1\":{\"787\":1}}],[\"indexkeyhashmethod\",{\"1\":{\"786\":2,\"797\":2}}],[\"index++\",{\"1\":{\"771\":1,\"1052\":1,\"1267\":1,\"1516\":1}}],[\"indexfile>\",{\"1\":{\"1436\":2}}],[\"indexfilesegmenttable\",{\"1\":{\"1402\":1,\"1420\":1}}],[\"indexfile是消息索引文件\",{\"1\":{\"868\":1}}],[\"indexfile和indexservice\",{\"1\":{\"798\":1}}],[\"indexfilelist\",{\"1\":{\"789\":2,\"793\":5,\"794\":4,\"872\":3,\"1517\":1}}],[\"indexfile\",{\"0\":{\"775\":1,\"790\":1,\"797\":1,\"868\":1,\"872\":1},\"1\":{\"750\":1,\"756\":1,\"775\":1,\"777\":2,\"780\":1,\"781\":1,\"785\":2,\"786\":3,\"789\":3,\"793\":15,\"794\":12,\"796\":1,\"811\":1,\"816\":1,\"839\":1,\"863\":1,\"864\":2,\"868\":2,\"869\":1,\"871\":1,\"872\":6,\"927\":2,\"1080\":1,\"1346\":1,\"1386\":4,\"1400\":1,\"1402\":2,\"1403\":3,\"1411\":1,\"1412\":1,\"1421\":1,\"1435\":25,\"1538\":1}}],[\"indexofack\",{\"1\":{\"1276\":4,\"1278\":4}}],[\"indexof\",{\"1\":{\"325\":1,\"741\":2,\"1267\":1}}],[\"index\",{\"0\":{\"773\":1},\"1\":{\"303\":4,\"325\":2,\"687\":2,\"690\":1,\"755\":2,\"771\":6,\"787\":2,\"794\":2,\"797\":7,\"848\":1,\"1052\":3,\"1195\":4,\"1267\":5,\"1276\":1,\"1278\":1,\"1383\":3,\"1394\":2,\"1412\":2,\"1417\":2,\"1427\":2,\"1428\":1,\"1434\":1,\"1435\":8,\"1436\":7,\"1437\":1,\"1497\":3,\"1502\":1,\"1503\":1,\"1508\":8,\"1509\":1,\"1510\":8,\"1511\":11,\"1512\":3,\"1516\":1,\"1517\":1,\"1519\":32,\"1520\":11,\"1521\":2}}],[\"inherits\",{\"1\":{\"342\":2}}],[\"inherited\",{\"1\":{\"43\":1}}],[\"in判断一个属性存在\",{\"1\":{\"299\":1}}],[\"incgroupacknums\",{\"1\":{\"1273\":1}}],[\"incgroupgetlatency\",{\"1\":{\"1173\":1}}],[\"incgroupgetsize\",{\"1\":{\"1173\":1,\"1270\":1}}],[\"incgroupgetnums\",{\"1\":{\"1173\":1,\"1270\":1}}],[\"incbrokeracknums\",{\"1\":{\"1273\":1}}],[\"incbrokergetnums\",{\"1\":{\"1173\":1,\"1270\":1}}],[\"inctimerdequeuecount\",{\"1\":{\"1374\":1}}],[\"inctimerenqueuecount\",{\"1\":{\"1371\":1}}],[\"inctryunlocktimes\",{\"1\":{\"1225\":1}}],[\"inctopicputsize\",{\"1\":{\"1198\":1}}],[\"inctopicputnums\",{\"1\":{\"1198\":1}}],[\"incsendbacknums\",{\"1\":{\"1198\":1}}],[\"incsearch\",{\"1\":{\"143\":1}}],[\"incqueueputsize\",{\"1\":{\"1198\":1}}],[\"incqueueputnums\",{\"1\":{\"1198\":1}}],[\"incconsumefailedtps\",{\"1\":{\"1195\":2}}],[\"incconsumeoktps\",{\"1\":{\"1195\":1}}],[\"incconsumert\",{\"1\":{\"1195\":1,\"1230\":1}}],[\"incpulltps\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"incpullrt\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"incvalue\",{\"1\":{\"1173\":2}}],[\"inconsistent\",{\"1\":{\"1499\":1,\"1500\":2,\"1510\":1,\"1511\":3,\"1519\":3,\"1520\":16}}],[\"inconsistency\",{\"1\":{\"1145\":1}}],[\"inconsistleader=\",{\"1\":{\"1499\":1}}],[\"inconsistleader\",{\"1\":{\"1499\":4}}],[\"incompatible\",{\"1\":{\"995\":1}}],[\"incrementandget\",{\"1\":{\"880\":1,\"1052\":3,\"1275\":1,\"1434\":2,\"1497\":5,\"1499\":3}}],[\"increase\",{\"1\":{\"861\":1,\"1497\":1}}],[\"incindexcount\",{\"1\":{\"797\":1}}],[\"inchashslotcount\",{\"1\":{\"797\":1}}],[\"inc\",{\"1\":{\"330\":4}}],[\"included\",{\"1\":{\"253\":1}}],[\"include\",{\"1\":{\"147\":1,\"191\":1,\"211\":3,\"253\":2}}],[\"inetsocketaddress\",{\"1\":{\"121\":1,\"133\":1}}],[\"inetaddress\",{\"1\":{\"73\":1,\"888\":1}}],[\"initoffset\",{\"1\":{\"1427\":1}}],[\"initresult\",{\"1\":{\"960\":2}}],[\"initialacl\",{\"1\":{\"996\":1}}],[\"initialization\",{\"1\":{\"737\":2}}],[\"initializemessagestore\",{\"0\":{\"1424\":1},\"1\":{\"1398\":1,\"1424\":1}}],[\"initializer\",{\"1\":{\"606\":1}}],[\"initialize\",{\"1\":{\"62\":1,\"98\":1,\"947\":1,\"960\":1,\"961\":2,\"1008\":1,\"1201\":1,\"1424\":1,\"1425\":1}}],[\"initialcredit\",{\"1\":{\"618\":1,\"624\":2,\"626\":1}}],[\"initial\",{\"1\":{\"330\":2,\"1270\":1}}],[\"init\",{\"1\":{\"171\":2,\"224\":3,\"252\":1,\"880\":1,\"1019\":1,\"1106\":1,\"1174\":2,\"1230\":1,\"1469\":1}}],[\"initmocks\",{\"1\":{\"98\":1}}],[\"inject\",{\"1\":{\"98\":1}}],[\"injects\",{\"1\":{\"98\":1}}],[\"injectmocks\",{\"0\":{\"98\":1},\"1\":{\"98\":1}}],[\"insert模式复制粘贴\",{\"1\":{\"156\":1}}],[\"insert插入模式\",{\"0\":{\"142\":1}}],[\"insert\",{\"1\":{\"91\":1,\"142\":2,\"248\":4}}],[\"instead\",{\"1\":{\"97\":1,\"886\":1,\"910\":1}}],[\"instantiationexception\",{\"1\":{\"742\":1}}],[\"instancename=\",{\"1\":{\"1170\":1}}],[\"instancename\",{\"1\":{\"1036\":1,\"1047\":1}}],[\"instancetimewheelservice类中定义了两个时间轮\",{\"1\":{\"379\":1}}],[\"instances\",{\"1\":{\"266\":3,\"396\":1}}],[\"instance\",{\"1\":{\"98\":2,\"99\":10,\"396\":7,\"882\":2,\"1287\":1}}],[\"instanceof\",{\"1\":{\"48\":2,\"341\":1,\"356\":2,\"894\":2,\"1053\":2,\"1122\":2,\"1332\":1,\"1333\":1,\"1516\":1,\"1519\":1}}],[\"installation\",{\"1\":{\"644\":1,\"960\":1}}],[\"installed\",{\"1\":{\"643\":14,\"645\":2}}],[\"install\",{\"1\":{\"62\":1,\"165\":2,\"369\":1,\"498\":1,\"500\":1,\"641\":1,\"643\":2,\"644\":1,\"645\":1}}],[\"institute\",{\"1\":{\"27\":1}}],[\"in\",{\"0\":{\"107\":1},\"1\":{\"70\":1,\"97\":2,\"104\":1,\"108\":1,\"122\":1,\"136\":1,\"138\":1,\"165\":1,\"171\":12,\"185\":1,\"191\":5,\"192\":3,\"299\":3,\"303\":1,\"351\":1,\"396\":1,\"614\":2,\"624\":1,\"720\":10,\"723\":4,\"727\":1,\"731\":1,\"736\":4,\"741\":1,\"819\":1,\"870\":1,\"886\":6,\"888\":1,\"904\":1,\"906\":1,\"913\":1,\"960\":4,\"971\":2,\"972\":1,\"973\":1,\"998\":2,\"1053\":1,\"1056\":1,\"1170\":1,\"1173\":1,\"1174\":2,\"1175\":1,\"1228\":1,\"1247\":1,\"1267\":4,\"1269\":1,\"1270\":3,\"1277\":1,\"1308\":2,\"1310\":2,\"1325\":1,\"1332\":2,\"1333\":3,\"1370\":4,\"1371\":1,\"1372\":2,\"1373\":1,\"1374\":1,\"1382\":3,\"1390\":3,\"1405\":3,\"1427\":1,\"1430\":1,\"1468\":1,\"1497\":1,\"1499\":1,\"1519\":3,\"1520\":1,\"1521\":2}}],[\"inputshutdown\",{\"1\":{\"967\":1}}],[\"inputstringbuilder\",{\"1\":{\"124\":1,\"125\":5}}],[\"inputstreamreader\",{\"1\":{\"69\":1,\"70\":1,\"113\":1}}],[\"inputstream是一个字节流\",{\"1\":{\"57\":1}}],[\"inputstream提供了两个重载方法来支持读取多个字节\",{\"1\":{\"53\":1}}],[\"inputstream\",{\"0\":{\"53\":1},\"1\":{\"53\":2,\"69\":2,\"70\":2,\"960\":1}}],[\"inputiscomplete\",{\"1\":{\"125\":2,\"128\":1}}],[\"input\",{\"1\":{\"69\":4,\"70\":4,\"113\":3,\"118\":1,\"124\":3,\"125\":7,\"128\":2}}],[\"infinity表示无限大\",{\"1\":{\"294\":1}}],[\"infinity\",{\"1\":{\"294\":1}}],[\"info=\",{\"1\":{\"860\":1,\"861\":4}}],[\"information\",{\"1\":{\"171\":16,\"643\":1}}],[\"info\",{\"1\":{\"43\":1,\"171\":1,\"231\":1,\"253\":3,\"722\":1,\"765\":1,\"771\":5,\"824\":3,\"861\":6,\"870\":1,\"961\":2,\"970\":1,\"971\":1,\"972\":7,\"973\":1,\"996\":2,\"998\":1,\"999\":5,\"1047\":1,\"1048\":1,\"1050\":2,\"1122\":2,\"1123\":1,\"1140\":2,\"1143\":2,\"1144\":4,\"1145\":3,\"1168\":2,\"1170\":4,\"1173\":5,\"1195\":1,\"1200\":2,\"1224\":3,\"1226\":1,\"1228\":3,\"1275\":1,\"1277\":1,\"1278\":6,\"1279\":1,\"1280\":2,\"1297\":2,\"1371\":2,\"1373\":2,\"1374\":3,\"1427\":4,\"1432\":1,\"1435\":2,\"1459\":1,\"1467\":4,\"1468\":6,\"1495\":1,\"1497\":4,\"1499\":1,\"1517\":1,\"1519\":6,\"1520\":1,\"1521\":4}}],[\"inf\",{\"1\":{\"24\":1}}],[\"inner\",{\"1\":{\"22\":4,\"155\":1,\"1047\":1,\"1287\":3,\"1296\":2,\"1297\":4}}],[\"inline\",{\"1\":{\"11\":1,\"104\":1}}],[\"intvalue\",{\"1\":{\"1328\":1}}],[\"introduced\",{\"1\":{\"624\":1,\"720\":1,\"736\":1}}],[\"introduce\",{\"1\":{\"624\":1}}],[\"intro\",{\"1\":{\"381\":1}}],[\"into\",{\"1\":{\"98\":1}}],[\"intpair\",{\"1\":{\"48\":1}}],[\"intersect\",{\"1\":{\"1519\":1}}],[\"intervalforcibly\",{\"1\":{\"866\":1,\"870\":3}}],[\"interval这类任务\",{\"1\":{\"374\":1}}],[\"interval\",{\"1\":{\"374\":1,\"861\":1,\"915\":2,\"999\":2,\"1230\":2,\"1427\":2,\"1468\":1}}],[\"interpreter\",{\"1\":{\"171\":1}}],[\"internalloggerfactory\",{\"1\":{\"960\":2}}],[\"internallogger\",{\"1\":{\"960\":1}}],[\"internals\",{\"1\":{\"628\":1}}],[\"internal\",{\"1\":{\"171\":1,\"267\":1,\"1008\":1,\"1519\":2}}],[\"interestops\",{\"1\":{\"118\":1,\"124\":4,\"125\":2,\"128\":1,\"133\":1}}],[\"interruptedexception\",{\"1\":{\"613\":1,\"861\":1,\"870\":1,\"871\":1,\"915\":1,\"970\":1,\"1021\":1,\"1050\":2,\"1053\":1,\"1168\":2,\"1171\":2,\"1172\":1,\"1197\":2,\"1200\":1,\"1222\":1,\"1297\":2,\"1443\":1,\"1444\":1,\"1460\":1}}],[\"interrupted\",{\"1\":{\"112\":1,\"122\":1,\"915\":1}}],[\"interfere\",{\"1\":{\"104\":1}}],[\"interface灵活性比较高\",{\"1\":{\"564\":1}}],[\"interface无法表达某些复杂类型\",{\"1\":{\"564\":1}}],[\"interface不能包含属性映射\",{\"1\":{\"564\":1}}],[\"interface可以继承其他类型\",{\"1\":{\"564\":1}}],[\"interface\",{\"0\":{\"557\":1,\"559\":1,\"560\":2,\"561\":1,\"562\":1,\"564\":1,\"569\":1},\"1\":{\"41\":1,\"43\":1,\"171\":1,\"396\":1,\"558\":3,\"560\":2,\"561\":1,\"562\":1,\"563\":6,\"564\":3,\"570\":3,\"573\":1}}],[\"integration\",{\"1\":{\"62\":3}}],[\"integer>>\",{\"1\":{\"1519\":1}}],[\"integer>\",{\"1\":{\"1442\":1}}],[\"integercanonicalname2\",{\"1\":{\"742\":1}}],[\"integercanonicalname1\",{\"1\":{\"742\":1}}],[\"integer\",{\"1\":{\"34\":1,\"48\":1,\"742\":13,\"780\":1,\"797\":2,\"823\":1,\"844\":1,\"891\":1,\"960\":1,\"1053\":2,\"1195\":1,\"1198\":1,\"1241\":1,\"1273\":1,\"1299\":2,\"1435\":1,\"1442\":1,\"1469\":1}}],[\"int\",{\"1\":{\"2\":1,\"43\":1,\"48\":1,\"53\":5,\"54\":1,\"112\":2,\"113\":1,\"118\":1,\"121\":1,\"124\":4,\"125\":4,\"126\":1,\"128\":2,\"129\":1,\"131\":3,\"133\":1,\"134\":1,\"385\":4,\"396\":11,\"616\":1,\"712\":2,\"714\":1,\"715\":1,\"737\":9,\"738\":3,\"757\":2,\"762\":2,\"764\":1,\"765\":1,\"767\":3,\"769\":4,\"771\":4,\"789\":1,\"790\":1,\"794\":5,\"797\":16,\"815\":1,\"819\":1,\"822\":1,\"823\":1,\"825\":1,\"828\":1,\"843\":2,\"845\":2,\"860\":5,\"870\":8,\"871\":2,\"872\":2,\"880\":1,\"882\":5,\"894\":13,\"900\":4,\"970\":2,\"984\":1,\"998\":2,\"999\":3,\"1017\":4,\"1020\":2,\"1021\":4,\"1050\":2,\"1052\":7,\"1053\":1,\"1056\":1,\"1145\":5,\"1170\":1,\"1171\":3,\"1173\":4,\"1174\":6,\"1194\":3,\"1195\":5,\"1197\":2,\"1198\":4,\"1201\":2,\"1230\":1,\"1267\":3,\"1269\":12,\"1270\":3,\"1271\":3,\"1273\":1,\"1275\":1,\"1276\":2,\"1277\":2,\"1278\":2,\"1280\":1,\"1296\":1,\"1297\":8,\"1299\":4,\"1306\":1,\"1309\":1,\"1323\":3,\"1367\":6,\"1368\":2,\"1370\":3,\"1371\":3,\"1372\":5,\"1373\":1,\"1425\":1,\"1427\":1,\"1428\":1,\"1430\":2,\"1431\":3,\"1432\":6,\"1434\":13,\"1435\":8,\"1436\":14,\"1442\":2,\"1443\":1,\"1462\":1,\"1467\":1,\"1468\":4,\"1516\":1,\"1517\":1,\"1519\":1,\"1520\":1,\"1521\":1}}],[\"iops\",{\"1\":{\"1393\":1,\"1402\":1,\"1411\":1,\"1418\":1}}],[\"iot\",{\"1\":{\"1284\":1,\"1290\":1}}],[\"ioc\",{\"0\":{\"80\":1,\"81\":1},\"1\":{\"81\":3}}],[\"ioe\",{\"1\":{\"69\":1}}],[\"ioexception\",{\"1\":{\"69\":3,\"70\":2,\"112\":2,\"113\":3,\"121\":1,\"122\":1,\"124\":1,\"125\":6,\"126\":2,\"128\":3,\"129\":2,\"131\":1,\"132\":1,\"133\":1,\"134\":2,\"712\":2,\"797\":2,\"880\":1,\"960\":1,\"1424\":1,\"1425\":1,\"1435\":2,\"1516\":2}}],[\"io包提供了所有同步io的功能\",{\"1\":{\"53\":1}}],[\"io\",{\"0\":{\"51\":1,\"107\":1,\"137\":1,\"258\":1,\"875\":1},\"1\":{\"1\":1,\"16\":1,\"52\":1,\"53\":1,\"54\":1,\"65\":1,\"96\":2,\"104\":1,\"107\":1,\"108\":1,\"109\":7,\"113\":1,\"116\":5,\"118\":1,\"119\":6,\"121\":1,\"122\":2,\"123\":1,\"124\":5,\"126\":1,\"127\":2,\"128\":1,\"130\":1,\"132\":2,\"133\":1,\"135\":6,\"136\":1,\"137\":3,\"138\":1,\"139\":1,\"168\":1,\"178\":2,\"224\":1,\"230\":1,\"235\":1,\"248\":1,\"258\":1,\"259\":2,\"263\":1,\"267\":2,\"275\":1,\"287\":1,\"291\":1,\"370\":1,\"382\":1,\"398\":1,\"399\":1,\"403\":1,\"455\":1,\"493\":1,\"609\":1,\"629\":1,\"641\":1,\"647\":1,\"680\":1,\"692\":1,\"705\":1,\"712\":1,\"719\":1,\"728\":2,\"735\":1,\"744\":1,\"775\":1,\"799\":1,\"830\":1,\"849\":1,\"862\":1,\"873\":2,\"874\":2,\"880\":1,\"885\":1,\"917\":1,\"918\":1,\"939\":1,\"975\":1,\"1002\":1,\"1004\":1,\"1008\":1,\"1012\":2,\"1023\":1,\"1058\":1,\"1068\":1,\"1079\":5,\"1085\":1,\"1106\":1,\"1124\":1,\"1146\":1,\"1176\":1,\"1202\":1,\"1231\":1,\"1243\":1,\"1282\":1,\"1299\":1,\"1301\":1,\"1335\":1,\"1376\":1,\"1385\":1,\"1393\":2,\"1438\":1,\"1474\":1,\"1505\":1,\"1523\":1,\"1524\":1,\"1528\":1}}],[\"背景\",{\"0\":{\"2\":1,\"108\":1,\"276\":1,\"288\":1,\"383\":1,\"648\":1,\"681\":1,\"706\":1,\"863\":1,\"874\":1,\"919\":1,\"976\":1,\"1003\":1,\"1024\":1,\"1059\":1,\"1069\":1,\"1086\":1,\"1107\":1,\"1125\":1,\"1147\":1,\"1177\":1,\"1203\":1,\"1244\":1,\"1283\":1,\"1302\":1,\"1336\":1,\"1377\":1,\"1439\":1,\"1475\":1,\"1506\":1,\"1525\":1,\"1529\":1}}],[\"hub\",{\"1\":{\"1070\":1,\"1071\":1,\"1072\":1,\"1079\":2}}],[\"hurting\",{\"1\":{\"624\":1}}],[\"hdrs\",{\"1\":{\"714\":3}}],[\"hgl\",{\"1\":{\"429\":1}}],[\"h7g4t9pye1qco\",{\"1\":{\"429\":1}}],[\"hfmbnd9ef\",{\"1\":{\"423\":1}}],[\"hps\",{\"1\":{\"401\":1,\"416\":1,\"441\":2}}],[\"hrl\",{\"1\":{\"191\":1,\"211\":2,\"253\":1}}],[\"hrl`的文件中\",{\"1\":{\"191\":1}}],[\"h|evens\",{\"1\":{\"189\":1}}],[\"h|odds\",{\"1\":{\"189\":1}}],[\"h|filter\",{\"1\":{\"187\":1}}],[\"h|t\",{\"1\":{\"177\":1,\"187\":1,\"189\":1}}],[\"hook\",{\"1\":{\"1019\":1}}],[\"holdmomentforunknownerror\",{\"1\":{\"1370\":1,\"1371\":2,\"1373\":1,\"1374\":1}}],[\"hold\",{\"1\":{\"797\":1,\"814\":1,\"823\":1,\"824\":1,\"1427\":1,\"1436\":1,\"1500\":1,\"1503\":1}}],[\"hof\",{\"1\":{\"624\":1}}],[\"hot\",{\"0\":{\"419\":1},\"1\":{\"401\":1,\"405\":1,\"411\":1,\"413\":2,\"415\":1,\"419\":1,\"445\":1,\"448\":1,\"465\":1,\"492\":1}}],[\"hostconsumer\",{\"1\":{\"1021\":1}}],[\"hostproducer\",{\"1\":{\"1021\":1}}],[\"host\",{\"1\":{\"368\":1,\"1077\":1,\"1078\":1,\"1197\":1,\"1270\":1,\"1279\":1}}],[\"hostname\",{\"1\":{\"316\":1,\"657\":1}}],[\"hours\",{\"1\":{\"870\":1,\"1072\":1,\"1427\":1,\"1435\":1}}],[\"hour\",{\"1\":{\"316\":1,\"1382\":2}}],[\"hour=0\",{\"1\":{\"316\":1}}],[\"house\",{\"1\":{\"253\":2}}],[\"however\",{\"1\":{\"643\":4,\"645\":1}}],[\"how\",{\"1\":{\"171\":3,\"261\":2,\"646\":1}}],[\"home\",{\"1\":{\"165\":2,\"252\":1,\"960\":1,\"983\":1,\"1075\":5,\"1077\":1,\"1080\":6,\"1290\":1,\"1395\":1}}],[\"hcb\",{\"1\":{\"171\":3}}],[\"h\",{\"0\":{\"906\":1},\"1\":{\"145\":1,\"153\":3,\"154\":1,\"171\":7,\"183\":4,\"187\":1,\"189\":1,\"230\":2,\"297\":1,\"396\":4,\"498\":1,\"742\":3,\"886\":1,\"890\":1,\"922\":1}}],[\"hjkl\",{\"1\":{\"145\":1}}],[\"hls\",{\"1\":{\"143\":1}}],[\"heartbeatresponse\",{\"1\":{\"1499\":1,\"1500\":9}}],[\"heartbeatrequest\",{\"1\":{\"1499\":9,\"1500\":1}}],[\"heartbeattimeout\",{\"1\":{\"1495\":1}}],[\"heartbeattimeintervalms\",{\"1\":{\"1495\":4,\"1496\":1,\"1497\":1,\"1499\":2}}],[\"heartbeat\",{\"1\":{\"1479\":1,\"1499\":3}}],[\"heading\",{\"1\":{\"266\":1}}],[\"headerencode\",{\"1\":{\"893\":1}}],[\"headersize\",{\"1\":{\"894\":5}}],[\"headers\",{\"1\":{\"714\":1}}],[\"header\",{\"0\":{\"714\":1,\"739\":1,\"889\":1},\"1\":{\"211\":1,\"714\":5,\"742\":4,\"787\":4,\"797\":4,\"886\":1,\"889\":1,\"890\":5,\"893\":1,\"894\":3,\"989\":1,\"995\":9,\"1418\":1,\"1434\":1,\"1435\":3,\"1472\":3}}],[\"height\",{\"1\":{\"176\":1,\"180\":4,\"339\":2,\"563\":1}}],[\"help\",{\"1\":{\"143\":3,\"171\":14,\"489\":15,\"490\":5}}],[\"hellogithub\",{\"1\":{\"381\":1}}],[\"hello这个类时\",{\"1\":{\"23\":1}}],[\"hello的类\",{\"1\":{\"23\":1}}],[\"hello\",{\"1\":{\"21\":1,\"23\":3,\"24\":1,\"41\":7,\"69\":1,\"73\":1,\"177\":1,\"178\":3,\"185\":2,\"200\":2,\"224\":10,\"294\":1,\"297\":2,\"316\":3,\"341\":7,\"342\":2,\"344\":2,\"361\":4,\"364\":3,\"369\":1,\"502\":1,\"503\":1,\"508\":1,\"509\":4,\"514\":2,\"516\":1,\"519\":1,\"533\":6,\"541\":1,\"545\":3,\"558\":1,\"578\":1,\"595\":1,\"984\":1,\"1006\":1,\"1287\":1,\"1306\":1,\"1309\":1,\"1339\":1,\"1443\":1}}],[\"here\",{\"1\":{\"103\":1,\"165\":1,\"624\":2,\"1200\":1,\"1278\":1,\"1370\":1,\"1427\":1,\"1435\":1,\"1436\":1}}],[\"hql使用类名和属性名\",{\"1\":{\"92\":1}}],[\"hql\",{\"0\":{\"92\":1}}],[\"hsqldialect\",{\"1\":{\"89\":1}}],[\"hscarb\",{\"1\":{\"1\":1,\"16\":1,\"96\":1,\"107\":1,\"110\":1,\"137\":1,\"139\":1,\"168\":1,\"263\":1,\"275\":1,\"287\":1,\"291\":1,\"370\":1,\"382\":1,\"398\":1,\"493\":1,\"609\":1,\"629\":1,\"641\":1,\"647\":1,\"680\":1,\"692\":1,\"705\":1,\"719\":1,\"744\":1,\"756\":1,\"775\":1,\"799\":1,\"806\":1,\"812\":1,\"830\":1,\"849\":1,\"862\":1,\"873\":1,\"885\":1,\"918\":1,\"939\":1,\"975\":1,\"1002\":1,\"1023\":1,\"1058\":1,\"1068\":1,\"1085\":1,\"1106\":1,\"1124\":1,\"1146\":1,\"1176\":1,\"1202\":1,\"1231\":1,\"1243\":1,\"1282\":1,\"1299\":1,\"1301\":1,\"1335\":1,\"1376\":1,\"1438\":1,\"1474\":1,\"1505\":1,\"1523\":1,\"1524\":1,\"1528\":1}}],[\"hbm2ddl\",{\"1\":{\"89\":1}}],[\"hit\",{\"1\":{\"1431\":1}}],[\"high\",{\"1\":{\"717\":2,\"873\":1,\"1299\":3,\"1300\":1}}],[\"higher\",{\"1\":{\"546\":1}}],[\"highlight\",{\"1\":{\"143\":1}}],[\"hi\",{\"1\":{\"511\":1,\"512\":1,\"575\":1,\"605\":1}}],[\"hicode\",{\"1\":{\"265\":1}}],[\"history\",{\"1\":{\"171\":2}}],[\"hibernate\",{\"0\":{\"88\":1},\"1\":{\"89\":4}}],[\"hint\",{\"1\":{\"11\":1}}],[\"happened\",{\"1\":{\"1500\":1,\"1519\":3}}],[\"happen\",{\"1\":{\"1500\":1}}],[\"haclient\",{\"1\":{\"729\":2}}],[\"halistenport=10932\",{\"1\":{\"1075\":1}}],[\"halfoffset\",{\"1\":{\"1468\":11}}],[\"half\",{\"1\":{\"720\":1,\"722\":2,\"845\":1,\"860\":1,\"964\":1,\"1053\":1,\"1446\":1,\"1450\":1,\"1451\":1,\"1453\":1,\"1463\":2,\"1464\":4,\"1468\":4}}],[\"halt\",{\"1\":{\"171\":1}}],[\"ha\",{\"1\":{\"652\":6,\"653\":3,\"654\":5,\"657\":3,\"658\":1,\"659\":4,\"665\":2,\"720\":1,\"727\":1,\"967\":1,\"971\":1}}],[\"harm\",{\"1\":{\"489\":8,\"490\":3}}],[\"harness\",{\"1\":{\"2\":1,\"15\":2}}],[\"hang\",{\"1\":{\"1095\":1,\"1131\":1,\"1249\":1,\"1250\":1}}],[\"hanged\",{\"1\":{\"1225\":1}}],[\"hange\",{\"1\":{\"155\":1}}],[\"handling设置为autoheal\",{\"1\":{\"659\":1}}],[\"handling处理策略的影响\",{\"1\":{\"659\":1}}],[\"handling\",{\"1\":{\"112\":1,\"113\":1}}],[\"handlepush\",{\"1\":{\"1511\":1,\"1520\":1}}],[\"handleputmessageresult\",{\"1\":{\"1462\":2}}],[\"handleputmessageresultfuture\",{\"1\":{\"1056\":1}}],[\"handleputresulttask\",{\"1\":{\"858\":2,\"861\":3}}],[\"handleappend\",{\"1\":{\"1509\":1,\"1516\":2,\"1521\":1}}],[\"handlevote\",{\"0\":{\"1503\":1},\"1\":{\"1492\":1,\"1502\":1,\"1503\":4}}],[\"handleheartbeat\",{\"0\":{\"1500\":1},\"1\":{\"1489\":1,\"1500\":3}}],[\"handlecommitexception\",{\"1\":{\"1428\":1}}],[\"handleexecutorservice\",{\"1\":{\"858\":1,\"861\":1}}],[\"handledobatchappend\",{\"1\":{\"1520\":1}}],[\"handledotruncate\",{\"1\":{\"1520\":4}}],[\"handledocommit\",{\"1\":{\"1520\":3}}],[\"handledocompare\",{\"1\":{\"1520\":3}}],[\"handledowrite\",{\"1\":{\"1520\":1}}],[\"handledoappend\",{\"1\":{\"1520\":2}}],[\"handled\",{\"1\":{\"171\":1}}],[\"handle\",{\"1\":{\"69\":2,\"70\":2,\"624\":2,\"626\":2,\"1331\":1,\"1428\":1,\"1516\":1}}],[\"handleretryanddlq\",{\"1\":{\"1056\":1}}],[\"handleresult\",{\"1\":{\"861\":1}}],[\"handlerclass\",{\"1\":{\"121\":4,\"123\":1,\"132\":1,\"133\":5}}],[\"handler\",{\"0\":{\"113\":1,\"124\":1,\"125\":1,\"128\":1},\"1\":{\"41\":2,\"69\":3,\"112\":2,\"119\":1,\"120\":2,\"121\":3,\"122\":1,\"123\":4,\"124\":7,\"125\":2,\"127\":5,\"128\":2,\"130\":1,\"132\":1,\"133\":1,\"135\":8,\"1300\":1}}],[\"hasexception\",{\"1\":{\"1195\":3,\"1230\":3}}],[\"haserver\",{\"1\":{\"971\":1}}],[\"haserveraddr\",{\"1\":{\"967\":2,\"970\":2,\"971\":3}}],[\"haservice\",{\"1\":{\"720\":1,\"723\":1}}],[\"hasconsumemessagehook\",{\"1\":{\"1173\":1,\"1198\":1}}],[\"hascommitoffsetflag\",{\"1\":{\"1173\":3}}],[\"hasclassfilterflag\",{\"1\":{\"1171\":1}}],[\"hascar\",{\"1\":{\"294\":1}}],[\"hassubscriptionflag\",{\"1\":{\"1173\":3}}],[\"hassuspendflag\",{\"1\":{\"819\":1,\"1173\":4}}],[\"hassendmessagehook\",{\"1\":{\"1053\":2}}],[\"hasoption\",{\"1\":{\"960\":2}}],[\"hasownproperty\",{\"1\":{\"299\":2}}],[\"hasnotified\",{\"1\":{\"726\":2,\"915\":3}}],[\"hasnext\",{\"1\":{\"122\":1,\"396\":1,\"971\":1,\"972\":6,\"1144\":1,\"1224\":1,\"1277\":1,\"1332\":1,\"1516\":1}}],[\"has\",{\"1\":{\"301\":1,\"712\":1,\"720\":2,\"722\":2,\"731\":1,\"824\":1,\"999\":1,\"1047\":1,\"1048\":1,\"1053\":1,\"1122\":1,\"1123\":1,\"1174\":1,\"1332\":2,\"1468\":1,\"1497\":2,\"1500\":1,\"1503\":1,\"1519\":3,\"1520\":1}}],[\"hashtopicformetrics\",{\"1\":{\"1371\":1}}],[\"hashto\",{\"1\":{\"1323\":2,\"1332\":1}}],[\"hashook\",{\"1\":{\"1195\":3,\"1230\":3}}],[\"hashset<long>>\",{\"1\":{\"1468\":2}}],[\"hashset<>\",{\"1\":{\"1288\":1}}],[\"hashset<messagequeue>\",{\"1\":{\"1143\":1,\"1200\":2,\"1222\":2,\"1266\":1}}],[\"hashset<string>\",{\"1\":{\"971\":1}}],[\"hashslotmaxcount\",{\"1\":{\"1434\":2,\"1435\":2,\"1436\":2}}],[\"hashslotsize\",{\"1\":{\"797\":6}}],[\"hashslotnum\",{\"1\":{\"793\":2,\"797\":5}}],[\"hashslotcount\",{\"1\":{\"787\":1,\"1434\":1}}],[\"hash值计算\",{\"1\":{\"797\":1}}],[\"hash槽中存储的索引逻辑下标\",{\"1\":{\"797\":1}}],[\"hash槽的绝对位置\",{\"1\":{\"797\":1}}],[\"hash槽的值\",{\"1\":{\"797\":1}}],[\"hash槽指向最新创建的索引的逻辑下标\",{\"1\":{\"797\":1}}],[\"hash槽对应的链表头部插入索引\",{\"1\":{\"797\":1}}],[\"hash槽对应的最新的索引的逻辑下标\",{\"1\":{\"797\":1}}],[\"hash槽绝对位置\",{\"1\":{\"797\":1}}],[\"hash槽\",{\"1\":{\"787\":1}}],[\"hash冲突时\",{\"1\":{\"780\":1}}],[\"hashcode\",{\"1\":{\"755\":1,\"767\":1,\"797\":1,\"897\":1,\"1371\":1,\"1415\":2,\"1434\":5,\"1436\":17}}],[\"hashval\",{\"1\":{\"396\":2}}],[\"hashfunction\",{\"1\":{\"396\":11}}],[\"hashmap<long\",{\"1\":{\"971\":1,\"1468\":3}}],[\"hashmap<>\",{\"1\":{\"714\":2,\"715\":1,\"997\":4,\"998\":5,\"999\":1,\"1427\":1,\"1468\":1,\"1514\":1}}],[\"hashmap<string\",{\"1\":{\"665\":1,\"742\":1,\"891\":1,\"894\":1,\"949\":5,\"950\":1,\"964\":1,\"965\":1,\"966\":1,\"967\":1,\"968\":1,\"1021\":1,\"1195\":1,\"1230\":1,\"1278\":1,\"1280\":1}}],[\"hashmap\",{\"1\":{\"391\":2,\"777\":1,\"780\":2,\"786\":1,\"927\":1,\"944\":2,\"949\":1,\"1065\":1,\"1278\":2,\"1386\":1,\"1393\":1}}],[\"hash\",{\"1\":{\"266\":1,\"382\":1,\"387\":2,\"388\":1,\"396\":16,\"705\":1,\"707\":1,\"710\":1,\"711\":2,\"712\":2,\"714\":7,\"715\":3,\"717\":1,\"749\":1,\"780\":1,\"786\":4,\"787\":7,\"797\":1,\"1314\":4,\"1318\":1,\"1319\":4,\"1322\":2,\"1323\":3,\"1332\":1,\"1352\":1,\"1386\":1,\"1393\":6,\"1415\":2,\"1417\":2,\"1418\":8,\"1435\":9,\"1436\":8}}],[\"hasremaining\",{\"1\":{\"125\":2}}],[\"have\",{\"1\":{\"97\":1,\"720\":1,\"886\":1,\"971\":1}}],[\"ht\",{\"1\":{\"171\":3}}],[\"html\",{\"1\":{\"1\":1,\"16\":1,\"96\":1,\"104\":1,\"107\":1,\"137\":1,\"139\":1,\"168\":1,\"263\":1,\"265\":1,\"272\":2,\"275\":1,\"287\":1,\"291\":1,\"370\":1,\"382\":1,\"398\":1,\"493\":1,\"609\":1,\"629\":1,\"641\":1,\"642\":1,\"647\":1,\"654\":1,\"680\":1,\"692\":2,\"705\":1,\"719\":1,\"744\":1,\"775\":1,\"799\":1,\"830\":1,\"849\":1,\"862\":1,\"873\":1,\"885\":1,\"918\":1,\"939\":1,\"975\":1,\"1002\":1,\"1023\":1,\"1058\":1,\"1068\":1,\"1085\":1,\"1106\":1,\"1124\":1,\"1146\":1,\"1176\":1,\"1202\":1,\"1231\":1,\"1243\":1,\"1282\":1,\"1299\":1,\"1301\":1,\"1335\":1,\"1376\":1,\"1438\":1,\"1474\":1,\"1505\":1,\"1523\":1,\"1524\":1,\"1528\":1}}],[\"http和https不同\",{\"1\":{\"350\":1}}],[\"http请求还在继续\",{\"1\":{\"348\":1}}],[\"https\",{\"1\":{\"16\":1,\"96\":2,\"104\":1,\"110\":1,\"165\":2,\"166\":1,\"264\":1,\"265\":1,\"266\":1,\"268\":1,\"272\":3,\"274\":2,\"286\":1,\"291\":1,\"381\":3,\"398\":1,\"493\":1,\"514\":3,\"515\":2,\"642\":2,\"644\":1,\"645\":2,\"646\":1,\"654\":1,\"692\":1,\"756\":1,\"806\":1,\"812\":1,\"852\":1,\"1025\":1,\"1053\":1,\"1070\":1,\"1284\":1,\"1297\":1,\"1299\":1,\"1504\":1,\"1522\":1}}],[\"http\",{\"0\":{\"654\":1},\"1\":{\"1\":1,\"16\":1,\"78\":2,\"96\":1,\"107\":1,\"137\":1,\"139\":1,\"168\":1,\"263\":1,\"270\":1,\"271\":1,\"273\":1,\"275\":1,\"287\":1,\"291\":1,\"368\":3,\"370\":1,\"372\":1,\"382\":1,\"398\":1,\"493\":1,\"515\":2,\"598\":1,\"609\":1,\"629\":1,\"641\":1,\"647\":1,\"680\":1,\"692\":1,\"705\":1,\"719\":1,\"744\":1,\"775\":1,\"799\":1,\"830\":1,\"849\":1,\"862\":1,\"873\":1,\"885\":1,\"896\":1,\"897\":1,\"918\":1,\"939\":1,\"975\":1,\"1002\":1,\"1023\":1,\"1058\":1,\"1068\":1,\"1085\":1,\"1106\":1,\"1124\":1,\"1146\":1,\"1176\":1,\"1202\":1,\"1231\":1,\"1243\":1,\"1282\":1,\"1299\":1,\"1301\":1,\"1335\":1,\"1376\":1,\"1438\":1,\"1474\":1,\"1505\":1,\"1523\":1,\"1524\":1,\"1528\":1}}],[\"jj\",{\"1\":{\"1321\":3}}],[\"jit\",{\"1\":{\"904\":1}}],[\"jna\",{\"1\":{\"882\":2}}],[\"j++\",{\"1\":{\"882\":1,\"998\":1,\"1280\":1}}],[\"jquery\",{\"1\":{\"598\":1,\"601\":3}}],[\"jtaqjtnpbgc3p13jq2l16pd9mnn\",{\"1\":{\"455\":1}}],[\"jvdmiea\",{\"1\":{\"443\":1}}],[\"jvm在执行java程序的时候\",{\"1\":{\"37\":1}}],[\"jvm在第一次读取到一种class类型时\",{\"1\":{\"36\":1}}],[\"jvm为每一种基本类型如int也创建了class实例\",{\"1\":{\"36\":1}}],[\"jvm就为其创建一个class类型的实例\",{\"1\":{\"36\":1}}],[\"jvm会自动读取这个manifest\",{\"1\":{\"24\":1}}],[\"jvm根本不依赖classpath加载核心库\",{\"1\":{\"23\":1}}],[\"jvm需要知道\",{\"1\":{\"23\":1}}],[\"jvm\",{\"1\":{\"2\":2,\"3\":2,\"372\":1,\"947\":1,\"960\":3,\"1382\":1,\"1406\":1}}],[\"j3lr9tj2jket186phzh46v3q0v4gnshzxrkajzzxu4gdm52b3rub4ezxnhguswludkjxiq434lyeug\",{\"1\":{\"423\":1}}],[\"jdk\",{\"1\":{\"786\":1}}],[\"jdk中\",{\"1\":{\"777\":1}}],[\"jdk9\",{\"1\":{\"8\":2}}],[\"jdotb\",{\"1\":{\"403\":1}}],[\"jpa所支持的关系型数据库\",{\"1\":{\"371\":1}}],[\"js代码结束\",{\"1\":{\"364\":1}}],[\"js代码\",{\"1\":{\"364\":1}}],[\"js文件就称之为一个模块\",{\"1\":{\"361\":1}}],[\"js\",{\"0\":{\"360\":1},\"1\":{\"291\":1,\"294\":2,\"312\":1,\"351\":1,\"360\":1,\"361\":1,\"363\":1,\"498\":1,\"499\":2,\"594\":1,\"600\":1}}],[\"jsonarray\",{\"1\":{\"998\":3}}],[\"jsonobject\",{\"1\":{\"998\":2}}],[\"json文件里面\",{\"1\":{\"601\":1}}],[\"json\",{\"0\":{\"336\":1,\"499\":1},\"1\":{\"266\":1,\"337\":2,\"338\":6,\"349\":2,\"354\":1,\"369\":1,\"499\":1,\"890\":1,\"893\":1,\"1273\":1,\"1278\":2,\"1395\":1,\"1420\":2,\"1497\":1,\"1521\":2}}],[\"jrebel\",{\"1\":{\"271\":2,\"273\":2}}],[\"jeo\",{\"1\":{\"204\":1}}],[\"jodie\",{\"1\":{\"1007\":1,\"1248\":1,\"1445\":3}}],[\"joranconfigurator\",{\"1\":{\"960\":2}}],[\"joranexception\",{\"1\":{\"960\":1}}],[\"job等\",{\"1\":{\"371\":1}}],[\"job\",{\"1\":{\"273\":2}}],[\"joe\",{\"1\":{\"176\":3,\"191\":5,\"252\":3,\"253\":1}}],[\"joining\",{\"1\":{\"1436\":1}}],[\"joinnumbers\",{\"1\":{\"539\":1}}],[\"join\",{\"1\":{\"29\":1,\"253\":1,\"298\":2,\"547\":1,\"1296\":1,\"1435\":1}}],[\"j跳转到任意位置\",{\"1\":{\"167\":1}}],[\"j\",{\"0\":{\"910\":1},\"1\":{\"153\":2,\"742\":3,\"882\":2,\"886\":1,\"890\":1,\"913\":2,\"998\":3,\"1280\":4}}],[\"jul\",{\"1\":{\"1074\":13}}],[\"juejin\",{\"1\":{\"266\":1,\"274\":1}}],[\"jumptoanywhere\",{\"1\":{\"167\":1}}],[\"junegunn\",{\"1\":{\"165\":2}}],[\"junit\",{\"1\":{\"9\":2,\"60\":1,\"98\":2}}],[\"just\",{\"1\":{\"97\":1,\"1037\":1,\"1047\":4,\"1048\":1,\"1122\":2,\"1123\":1,\"1277\":2,\"1297\":1,\"1371\":1,\"1503\":1,\"1519\":3}}],[\"juc学习笔记\",{\"1\":{\"15\":1}}],[\"jan\",{\"1\":{\"316\":1}}],[\"jane\",{\"1\":{\"253\":1}}],[\"jar包还可以包含一个特殊的\",{\"1\":{\"24\":1}}],[\"jar包实际上就是一个zip格式的压缩文件\",{\"1\":{\"24\":1}}],[\"jar\",{\"0\":{\"23\":1,\"24\":1},\"1\":{\"7\":2,\"10\":3,\"23\":1,\"24\":2,\"64\":1,\"372\":2}}],[\"javascript语言本身是完善的函数式语言\",{\"1\":{\"360\":1}}],[\"javascript引擎是一个事件驱动的执行引擎\",{\"1\":{\"359\":1}}],[\"javascript有一个标准的error对象表示错误\",{\"1\":{\"356\":1}}],[\"javascript也不例外\",{\"1\":{\"355\":1}}],[\"javascript在发送ajax请求时\",{\"1\":{\"350\":1}}],[\"javascript的原型继承实现方式就是\",{\"1\":{\"342\":1}}],[\"javascript的原型链和java的class区别在于它没有\",{\"1\":{\"339\":1}}],[\"javascript的函数会先扫描整个函数体的语句\",{\"1\":{\"311\":1}}],[\"javascript的函数调用不要求参数必须一致\",{\"1\":{\"303\":1}}],[\"javascript不区分类和实例的概念\",{\"1\":{\"339\":1}}],[\"javascript内置了json的解析\",{\"1\":{\"336\":1}}],[\"javascript\",{\"0\":{\"291\":1},\"1\":{\"316\":3,\"347\":1,\"497\":2,\"498\":2,\"506\":3,\"508\":1,\"512\":1,\"518\":1,\"521\":1,\"524\":1,\"556\":1,\"580\":1,\"582\":1,\"593\":1,\"608\":1}}],[\"javadoc\",{\"1\":{\"96\":1,\"104\":1}}],[\"java标准库提供了serversocket来实现对指定ip和指定端口的监听\",{\"1\":{\"69\":1}}],[\"java标准库的\",{\"1\":{\"53\":1}}],[\"java标准库的java\",{\"1\":{\"52\":1,\"54\":1}}],[\"java的io标准库使用filter模式为inputstream和outputstream增加功能\",{\"1\":{\"55\":1}}],[\"java的泛型是由编译器在编译时实现的\",{\"1\":{\"48\":1}}],[\"java的数据类型分两种\",{\"1\":{\"30\":1}}],[\"java编译器直接把int变为integer的赋值写法\",{\"1\":{\"30\":1}}],[\"java编译器会将每个匿名类依次命名为outer$1\",{\"1\":{\"22\":1}}],[\"java编译器最终编译出的\",{\"1\":{\"20\":1}}],[\"java文件\",{\"1\":{\"21\":2}}],[\"java表示src目录下的所有\",{\"1\":{\"21\":1}}],[\"javacc\",{\"1\":{\"1321\":3}}],[\"javac\",{\"1\":{\"21\":2,\"25\":2}}],[\"java\",{\"0\":{\"1\":1,\"16\":1,\"26\":1,\"33\":1,\"46\":1,\"107\":2,\"118\":1,\"137\":1,\"138\":1,\"396\":1,\"712\":1},\"1\":{\"1\":1,\"2\":3,\"7\":1,\"10\":1,\"15\":4,\"16\":2,\"21\":6,\"24\":1,\"25\":3,\"53\":2,\"96\":1,\"107\":2,\"108\":1,\"110\":1,\"116\":1,\"118\":7,\"119\":1,\"122\":1,\"136\":3,\"137\":3,\"138\":4,\"272\":2,\"381\":1,\"391\":1,\"395\":1,\"613\":1,\"712\":4,\"737\":2,\"738\":1,\"742\":1,\"840\":1,\"880\":2,\"890\":1,\"891\":1,\"893\":1,\"894\":3,\"912\":1,\"917\":1,\"970\":1,\"994\":3,\"997\":1,\"999\":2,\"1020\":1,\"1025\":1,\"1047\":1,\"1050\":1,\"1051\":1,\"1052\":2,\"1053\":1,\"1056\":1,\"1077\":1,\"1079\":10,\"1080\":23,\"1123\":1,\"1145\":1,\"1175\":1,\"1194\":1,\"1195\":2,\"1197\":2,\"1198\":1,\"1200\":2,\"1224\":1,\"1225\":1,\"1226\":1,\"1230\":1,\"1248\":1,\"1296\":1,\"1299\":2,\"1321\":3,\"1328\":1,\"1329\":1,\"1331\":2,\"1332\":1,\"1333\":1,\"1434\":2,\"1435\":2,\"1436\":2,\"1440\":1,\"1458\":1,\"1459\":1,\"1460\":1,\"1462\":1,\"1463\":1,\"1464\":1,\"1467\":1,\"1468\":1,\"1469\":1,\"1471\":1,\"1472\":1,\"1495\":1,\"1496\":1,\"1497\":1,\"1499\":1,\"1500\":1,\"1502\":1,\"1503\":1}}],[\"jmh<\",{\"1\":{\"8\":2}}],[\"jmh\",{\"0\":{\"1\":1,\"3\":1,\"4\":1},\"1\":{\"1\":1,\"2\":3,\"3\":1,\"4\":2,\"6\":2,\"7\":1,\"8\":1,\"11\":1,\"12\":1,\"15\":6,\"138\":1}}],[\"mlock\",{\"1\":{\"882\":5}}],[\"mpr\",{\"1\":{\"822\":6,\"825\":4}}],[\"mb\",{\"1\":{\"643\":1,\"1519\":2}}],[\"mbnzy1skupt6\",{\"1\":{\"443\":1}}],[\"mnupchq3f604whmnv0nogqsog1n6s2ujt9uvikxou\",{\"1\":{\"455\":1}}],[\"mnesia的速度极快\",{\"1\":{\"251\":1}}],[\"mnesia是一种用erlang编写的数据库\",{\"1\":{\"251\":1}}],[\"mnesia\",{\"0\":{\"251\":1},\"1\":{\"252\":6,\"253\":37,\"255\":4,\"673\":1,\"716\":1}}],[\"mz9cl12\",{\"1\":{\"423\":1}}],[\"md\",{\"1\":{\"1025\":1,\"1437\":1}}],[\"mdt\",{\"1\":{\"423\":1,\"429\":1,\"436\":1,\"443\":1,\"455\":1,\"469\":1}}],[\"md5hash\",{\"1\":{\"396\":3}}],[\"md5\",{\"1\":{\"390\":1,\"396\":3}}],[\"mmqq\",{\"1\":{\"1226\":2}}],[\"mmapfilestore\",{\"1\":{\"1519\":2}}],[\"mmap\",{\"0\":{\"880\":1,\"910\":1},\"1\":{\"728\":2,\"880\":4,\"882\":1,\"886\":1,\"912\":2,\"917\":2,\"1386\":1,\"1519\":1}}],[\"mm\",{\"1\":{\"171\":1}}],[\"m\",{\"1\":{\"145\":1,\"171\":6,\"174\":2,\"200\":1,\"301\":9,\"303\":2,\"398\":1,\"720\":1,\"723\":1,\"736\":1,\"742\":2,\"1247\":2,\"1248\":1}}],[\"much\",{\"1\":{\"1427\":1,\"1436\":1}}],[\"mui\",{\"1\":{\"491\":1}}],[\"mult\",{\"1\":{\"181\":2}}],[\"multiqueueoffset\",{\"1\":{\"1297\":4}}],[\"multidispatchqueue\",{\"1\":{\"1296\":3,\"1297\":4}}],[\"multidispatchlmqqueue\",{\"1\":{\"1294\":1,\"1297\":2}}],[\"multidispatch\",{\"1\":{\"1294\":2}}],[\"multiple\",{\"1\":{\"998\":2,\"1001\":1,\"1287\":1}}],[\"multiplier\",{\"1\":{\"546\":2}}],[\"multicast\",{\"0\":{\"673\":1}}],[\"multi\",{\"1\":{\"525\":1,\"1287\":3,\"1296\":4,\"1297\":6}}],[\"multireactorbootstrap\",{\"1\":{\"133\":3,\"134\":1,\"135\":1}}],[\"multithreadniohandler\",{\"1\":{\"128\":2,\"129\":1,\"135\":1}}],[\"must\",{\"1\":{\"98\":2,\"253\":1,\"971\":1,\"1267\":1,\"1287\":1}}],[\"mvc\",{\"1\":{\"93\":1}}],[\"mvn\",{\"1\":{\"7\":1,\"10\":1,\"62\":1,\"65\":1}}],[\"myenum\",{\"1\":{\"586\":2}}],[\"mycountry\",{\"1\":{\"570\":1}}],[\"myclass\",{\"1\":{\"568\":1,\"577\":4}}],[\"mypoint\",{\"1\":{\"555\":2}}],[\"myobj\",{\"1\":{\"550\":1,\"553\":2}}],[\"myfunc\",{\"1\":{\"533\":2,\"558\":5}}],[\"mythic\",{\"1\":{\"398\":2}}],[\"mygrade\",{\"1\":{\"345\":1}}],[\"myvar\",{\"1\":{\"333\":3}}],[\"myapp\",{\"1\":{\"313\":5}}],[\"my\",{\"1\":{\"135\":1,\"196\":1,\"665\":1}}],[\"mydictionary\",{\"1\":{\"101\":2,\"102\":2}}],[\"mysql\",{\"1\":{\"60\":1,\"371\":1}}],[\"mybenchmark\",{\"1\":{\"9\":2,\"11\":6}}],[\"moment\",{\"1\":{\"1230\":3}}],[\"movereadtime\",{\"1\":{\"1372\":3}}],[\"moved\",{\"1\":{\"964\":1,\"1173\":7}}],[\"move\",{\"1\":{\"886\":1,\"913\":1,\"1278\":1,\"1372\":1}}],[\"most\",{\"1\":{\"720\":1,\"1056\":1}}],[\"more\",{\"1\":{\"1468\":1}}],[\"morecredit\",{\"1\":{\"626\":4}}],[\"morecreditafter\",{\"1\":{\"618\":1,\"624\":1,\"626\":4}}],[\"morning\",{\"1\":{\"41\":4}}],[\"motorvehicle\",{\"1\":{\"571\":1,\"573\":3}}],[\"motion\",{\"1\":{\"167\":2}}],[\"mouseover\",{\"1\":{\"489\":13,\"490\":3}}],[\"monitor\",{\"1\":{\"1518\":1,\"1520\":1}}],[\"monotonic\",{\"1\":{\"625\":1}}],[\"monday\",{\"1\":{\"587\":1}}],[\"months\",{\"1\":{\"1079\":2}}],[\"month\",{\"1\":{\"316\":3}}],[\"monkey\",{\"1\":{\"276\":1}}],[\"mobile\",{\"1\":{\"294\":1}}],[\"mocking\",{\"0\":{\"100\":1,\"104\":1}}],[\"mockitoexception\",{\"1\":{\"103\":1}}],[\"mockitoextension\",{\"1\":{\"98\":1}}],[\"mockitojunitrunner\",{\"1\":{\"98\":1,\"99\":1}}],[\"mockito\",{\"0\":{\"96\":1},\"1\":{\"96\":5,\"98\":1,\"103\":1,\"104\":5,\"105\":1,\"106\":1,\"138\":1}}],[\"mockstatic\",{\"1\":{\"105\":1,\"106\":1}}],[\"mocks\",{\"1\":{\"98\":2,\"104\":1}}],[\"mock\",{\"0\":{\"98\":1,\"99\":1},\"1\":{\"97\":3,\"98\":3,\"99\":1,\"101\":1,\"102\":1,\"104\":3}}],[\"mockedstatic<staticutils>\",{\"1\":{\"105\":1,\"106\":1}}],[\"mocked\",{\"1\":{\"97\":2,\"104\":1}}],[\"modifier\",{\"1\":{\"742\":1}}],[\"modifiers\",{\"1\":{\"143\":1,\"575\":1}}],[\"modified\",{\"1\":{\"171\":2}}],[\"modulename\",{\"1\":{\"203\":1}}],[\"module\",{\"0\":{\"180\":1,\"365\":1},\"1\":{\"171\":22,\"180\":2,\"203\":1,\"208\":1,\"213\":1,\"230\":1,\"235\":2,\"248\":1,\"253\":1,\"261\":1,\"361\":2,\"364\":6,\"365\":2,\"591\":1,\"597\":2,\"1437\":1}}],[\"modules\",{\"1\":{\"96\":1,\"171\":4,\"600\":1,\"601\":1}}],[\"mod\",{\"1\":{\"171\":11,\"200\":1,\"203\":1,\"210\":2,\"229\":2,\"598\":1}}],[\"mode模式需要用到的参数\",{\"1\":{\"652\":1}}],[\"model\",{\"1\":{\"280\":5}}],[\"mode\",{\"1\":{\"9\":1,\"11\":4,\"248\":3,\"652\":4,\"653\":2,\"654\":2,\"657\":1,\"658\":1,\"720\":1,\"723\":1,\"736\":1,\"741\":1,\"1247\":3,\"1267\":1,\"1464\":1}}],[\"mfslength\",{\"1\":{\"870\":3}}],[\"mfs\",{\"1\":{\"870\":5}}],[\"mfa\",{\"1\":{\"261\":1}}],[\"mf是纯文本\",{\"1\":{\"24\":1}}],[\"mf文件\",{\"1\":{\"24\":2}}],[\"me\",{\"1\":{\"845\":2,\"1173\":2,\"1297\":2}}],[\"messageresultext\",{\"1\":{\"1430\":4}}],[\"messagerequestmode\",{\"1\":{\"1248\":1,\"1266\":1}}],[\"messagefetcher\",{\"1\":{\"1431\":3,\"1432\":3}}],[\"messageformatutil\",{\"1\":{\"1427\":5,\"1432\":12}}],[\"messagefilter\",{\"1\":{\"757\":2,\"767\":5,\"819\":1,\"1173\":6,\"1174\":7,\"1269\":4,\"1270\":4,\"1318\":1,\"1430\":5}}],[\"messageevaluationcontext\",{\"1\":{\"1332\":2,\"1333\":2}}],[\"messageextbatch\",{\"1\":{\"1296\":4}}],[\"messageextbrokerinner\",{\"1\":{\"737\":3,\"738\":1,\"843\":1,\"845\":1,\"860\":2,\"861\":1,\"1035\":1,\"1056\":2,\"1065\":1,\"1198\":3,\"1273\":2,\"1280\":2,\"1296\":1,\"1374\":1,\"1462\":1,\"1463\":4,\"1464\":1}}],[\"messageexts\",{\"1\":{\"1278\":5}}],[\"messageext\",{\"0\":{\"888\":1},\"1\":{\"738\":1,\"845\":1,\"860\":1,\"861\":1,\"886\":1,\"888\":2,\"1020\":1,\"1035\":1,\"1195\":3,\"1197\":2,\"1198\":1,\"1278\":12,\"1280\":17,\"1288\":3,\"1329\":1,\"1370\":1,\"1371\":7,\"1373\":1,\"1442\":1,\"1445\":3,\"1468\":1,\"1469\":2,\"1471\":9,\"1472\":2}}],[\"messagenum\",{\"1\":{\"1296\":3}}],[\"messagemodel\",{\"1\":{\"1122\":1,\"1143\":1,\"1170\":1,\"1173\":1,\"1225\":2,\"1230\":6,\"1266\":4}}],[\"messagemodel=\",{\"1\":{\"1122\":1}}],[\"messagelistener\",{\"1\":{\"1119\":2,\"1187\":1,\"1188\":1,\"1195\":1,\"1230\":1}}],[\"messagelistenerorderly\",{\"1\":{\"1102\":1,\"1122\":2}}],[\"messagelistenerconcurrently\",{\"1\":{\"985\":1,\"1007\":1,\"1102\":1,\"1122\":2,\"1195\":1,\"1248\":1,\"1444\":1}}],[\"messagebatch\",{\"1\":{\"1044\":2,\"1053\":3}}],[\"messagetopic\",{\"1\":{\"1459\":2}}],[\"messagetotalsize\",{\"1\":{\"1065\":1}}],[\"messagetype\",{\"1\":{\"1017\":1,\"1053\":2}}],[\"messagetimeup\",{\"1\":{\"845\":2,\"860\":2,\"861\":1}}],[\"messagecloned\",{\"1\":{\"1053\":4}}],[\"messageclientidsetter\",{\"1\":{\"1017\":1,\"1053\":1,\"1373\":1}}],[\"messageconst\",{\"1\":{\"794\":1,\"843\":2,\"1020\":2,\"1053\":5,\"1056\":5,\"1197\":2,\"1198\":3,\"1273\":1,\"1280\":2,\"1296\":2,\"1297\":4,\"1371\":1,\"1373\":2,\"1427\":2,\"1459\":4,\"1462\":3,\"1463\":3,\"1464\":3,\"1468\":3,\"1469\":4,\"1471\":2,\"1472\":1}}],[\"messagecount\",{\"1\":{\"712\":1,\"1432\":2}}],[\"messageaccessor\",{\"1\":{\"843\":2,\"1053\":6,\"1056\":2,\"1195\":1,\"1197\":7,\"1198\":4,\"1280\":1,\"1296\":1,\"1459\":3,\"1463\":3,\"1464\":1}}],[\"messagearrivinglistener\",{\"1\":{\"762\":2,\"827\":2,\"828\":1,\"1424\":3}}],[\"messageinner\",{\"1\":{\"1463\":4}}],[\"messageindexsafe\",{\"1\":{\"789\":1}}],[\"messageid\",{\"0\":{\"738\":1},\"1\":{\"715\":1,\"736\":1,\"738\":3,\"1460\":1}}],[\"messagekey\",{\"1\":{\"786\":1}}],[\"messagequeues\",{\"1\":{\"1266\":1,\"1267\":1}}],[\"messagequeuelock\",{\"1\":{\"1230\":1}}],[\"messagequeuelistener\",{\"1\":{\"1117\":1}}],[\"messagequeuelist\",{\"1\":{\"1052\":3}}],[\"messagequeue=messagequeue\",{\"1\":{\"1445\":10}}],[\"messagequeue=\",{\"1\":{\"1195\":1}}],[\"messagequeuechanged\",{\"0\":{\"1145\":1},\"1\":{\"1137\":1,\"1143\":3,\"1145\":1}}],[\"messagequeuechange\",{\"1\":{\"1134\":1}}],[\"messagequeuemap\",{\"1\":{\"1065\":1}}],[\"messagequeue\",{\"1\":{\"722\":1,\"1041\":1,\"1050\":2,\"1052\":7,\"1053\":3,\"1117\":1,\"1143\":2,\"1144\":7,\"1145\":1,\"1168\":1,\"1169\":3,\"1171\":1,\"1173\":2,\"1194\":5,\"1195\":7,\"1200\":3,\"1222\":2,\"1224\":7,\"1225\":1,\"1226\":2,\"1230\":16,\"1267\":5,\"1288\":2,\"1329\":1,\"1421\":1,\"1427\":1,\"1430\":1,\"1431\":2,\"1432\":1,\"1468\":16}}],[\"messageproperties2string\",{\"1\":{\"720\":1,\"741\":2,\"843\":1,\"1053\":1,\"1056\":2,\"1198\":2,\"1273\":1,\"1280\":1,\"1463\":1}}],[\"messagedispatcher\",{\"1\":{\"1427\":6}}],[\"messagedigest\",{\"1\":{\"396\":2}}],[\"messagedelaylevel\",{\"1\":{\"833\":1,\"1241\":1}}],[\"messagedecoder\",{\"1\":{\"720\":1,\"737\":4,\"843\":1,\"1053\":1,\"1056\":3,\"1198\":2,\"1273\":1,\"1280\":1,\"1329\":1,\"1333\":1,\"1460\":2,\"1463\":1,\"1471\":1}}],[\"message\",{\"0\":{\"1282\":1},\"1\":{\"229\":2,\"297\":2,\"356\":1,\"369\":7,\"545\":3,\"558\":1,\"614\":3,\"619\":1,\"621\":2,\"690\":3,\"712\":6,\"715\":4,\"720\":4,\"736\":1,\"737\":12,\"757\":1,\"766\":1,\"767\":3,\"773\":2,\"778\":2,\"780\":2,\"782\":1,\"787\":2,\"789\":1,\"819\":1,\"830\":1,\"835\":3,\"845\":1,\"849\":1,\"861\":4,\"868\":1,\"886\":2,\"905\":1,\"906\":1,\"918\":1,\"984\":2,\"1006\":2,\"1008\":1,\"1021\":2,\"1023\":1,\"1035\":4,\"1044\":1,\"1050\":1,\"1052\":1,\"1053\":4,\"1055\":3,\"1056\":2,\"1146\":1,\"1168\":1,\"1170\":5,\"1171\":1,\"1172\":1,\"1173\":8,\"1174\":10,\"1175\":2,\"1176\":1,\"1195\":2,\"1197\":3,\"1198\":3,\"1226\":1,\"1228\":3,\"1230\":6,\"1252\":1,\"1266\":1,\"1269\":1,\"1270\":2,\"1273\":1,\"1282\":1,\"1284\":1,\"1287\":8,\"1296\":2,\"1297\":2,\"1298\":1,\"1306\":2,\"1309\":2,\"1333\":4,\"1339\":8,\"1346\":1,\"1370\":2,\"1371\":1,\"1372\":1,\"1427\":8,\"1430\":4,\"1431\":1,\"1432\":2,\"1438\":1,\"1442\":6,\"1443\":3,\"1445\":3,\"1446\":1,\"1451\":2,\"1458\":2,\"1459\":5,\"1460\":3,\"1462\":2,\"1463\":1,\"1464\":3,\"1467\":2,\"1468\":7,\"1469\":2,\"1471\":2,\"1472\":8,\"1538\":1}}],[\"messagesdispatchtotal\",{\"1\":{\"1427\":1}}],[\"messagestoreexecutor\",{\"1\":{\"1427\":1,\"1436\":1}}],[\"messagestorefactory\",{\"0\":{\"1425\":1},\"1\":{\"1424\":1}}],[\"messagestorefetcherimpl\",{\"0\":{\"1430\":1,\"1431\":1,\"1432\":1},\"1\":{\"1405\":1,\"1407\":1}}],[\"messagestorefetcher\",{\"0\":{\"1407\":1},\"1\":{\"1402\":1}}],[\"messagestoredispatcherimpl\",{\"0\":{\"1427\":1},\"1\":{\"1403\":1,\"1414\":1}}],[\"messagestoredispatcher\",{\"1\":{\"1402\":1}}],[\"messagestoreplugincontext\",{\"1\":{\"1424\":2,\"1425\":2}}],[\"messagestoreplugin\",{\"1\":{\"1382\":1,\"1425\":1}}],[\"messagestoreplugin=org\",{\"1\":{\"1382\":1}}],[\"messagestore\",{\"1\":{\"1263\":1,\"1296\":2,\"1297\":10,\"1318\":1,\"1370\":1,\"1382\":1,\"1387\":1,\"1397\":1,\"1405\":2,\"1424\":2,\"1425\":13}}],[\"messagestoreconfig\",{\"1\":{\"789\":1,\"869\":1,\"1174\":2,\"1424\":6,\"1523\":1}}],[\"messageselector\",{\"1\":{\"1117\":2,\"1310\":1}}],[\"messagesysflag\",{\"1\":{\"738\":1,\"764\":5,\"794\":5,\"843\":3,\"1053\":2,\"1460\":3,\"1463\":2,\"1464\":3,\"1472\":3}}],[\"messages\",{\"1\":{\"171\":1,\"624\":1,\"712\":2,\"767\":2,\"985\":1,\"1007\":1,\"1020\":1,\"1044\":1,\"1145\":1,\"1170\":1,\"1174\":3,\"1248\":1,\"1270\":1,\"1372\":1,\"1375\":3,\"1427\":2,\"1430\":2,\"1431\":1,\"1437\":1,\"1444\":1,\"1445\":3,\"1464\":2}}],[\"mem\",{\"1\":{\"1382\":1,\"1390\":1,\"1405\":1}}],[\"membernum=\",{\"1\":{\"1497\":1}}],[\"memberstate\",{\"1\":{\"1482\":1,\"1495\":5,\"1496\":4,\"1497\":19,\"1499\":14,\"1500\":18,\"1502\":4,\"1503\":27,\"1514\":2,\"1516\":11,\"1517\":10,\"1518\":4,\"1519\":13,\"1520\":2,\"1521\":15}}],[\"member\",{\"1\":{\"181\":1,\"1500\":3,\"1503\":1,\"1516\":1}}],[\"memorymaxsize\",{\"1\":{\"1430\":1}}],[\"memorymessagestore\",{\"0\":{\"1065\":1},\"1\":{\"1061\":2,\"1065\":1}}],[\"memoryfilesegment\",{\"1\":{\"1382\":2}}],[\"memorytopicenable\",{\"1\":{\"1067\":1}}],[\"memory\",{\"0\":{\"1058\":1},\"1\":{\"137\":1,\"171\":4,\"880\":1,\"1058\":1,\"1066\":1,\"1170\":1,\"1174\":3,\"1538\":1}}],[\"means\",{\"1\":{\"1266\":2,\"1430\":1,\"1462\":1,\"1519\":2}}],[\"meaning\",{\"1\":{\"102\":1}}],[\"measurement\",{\"1\":{\"4\":2,\"9\":1,\"11\":1,\"280\":1}}],[\"mergeandrevive\",{\"0\":{\"1279\":1},\"1\":{\"1263\":2,\"1279\":1}}],[\"merge\",{\"1\":{\"91\":1}}],[\"metrics\",{\"1\":{\"280\":2,\"1462\":2}}],[\"methods\",{\"0\":{\"104\":1},\"1\":{\"97\":1,\"886\":1}}],[\"method\",{\"0\":{\"105\":1,\"106\":1},\"1\":{\"39\":4,\"41\":4,\"43\":1,\"44\":1,\"97\":3,\"101\":1,\"102\":1,\"103\":2,\"104\":2,\"273\":1,\"396\":1,\"606\":1,\"624\":7,\"720\":1,\"731\":1,\"886\":1,\"906\":1,\"1079\":1,\"1168\":1,\"1468\":1}}],[\"metadata\",{\"1\":{\"1382\":1}}],[\"metainf\",{\"1\":{\"990\":1,\"996\":1}}],[\"meta\",{\"1\":{\"24\":1}}],[\"ms0klyqculicdrvacwtztmlioqirrbubo0nxxdhlsdyk2lgll7wtrlrdbuydcpqcbhrqcxxgoskwhy5fukrjdlv5irb21grloykdaje0ul1iiogbxojatg2arqvezwresocuwawulj84fikpefihvx1wtb2obrtbjs6lsrizx1rvtaenvebogivxtdqin4qwca7qostbn5lxmob1tznmvbr0ugikqqutk1om1iidcw45\",{\"1\":{\"423\":1}}],[\"msgqueues\",{\"1\":{\"1468\":4}}],[\"msgqueueoffset\",{\"1\":{\"1271\":2}}],[\"msglistfilteragain\",{\"1\":{\"1329\":3}}],[\"msglist\",{\"1\":{\"1329\":4,\"1431\":2}}],[\"msglen\",{\"1\":{\"737\":10,\"738\":1}}],[\"msgoffsetdiff=\",{\"1\":{\"1468\":1}}],[\"msgoffset=\",{\"1\":{\"1468\":3}}],[\"msgoffset\",{\"1\":{\"1280\":3}}],[\"msgoffsetinfo\",{\"1\":{\"1269\":5,\"1270\":3}}],[\"msgbuffer\",{\"1\":{\"1318\":2,\"1333\":4,\"1432\":2}}],[\"msgbackfailed\",{\"1\":{\"1195\":5}}],[\"msgbody\",{\"1\":{\"1053\":1}}],[\"msgbodycompressed\",{\"1\":{\"1053\":3}}],[\"msgtimedelayinms=\",{\"1\":{\"1468\":1}}],[\"msgtime=\",{\"1\":{\"1468\":1}}],[\"msgtime\",{\"1\":{\"1468\":3}}],[\"msgthis\",{\"1\":{\"1194\":4}}],[\"msgtype\",{\"1\":{\"1017\":1}}],[\"msgfoundlist为空的情况\",{\"1\":{\"1175\":1,\"1229\":1}}],[\"msg=true\",{\"1\":{\"1445\":3}}],[\"msg=\",{\"1\":{\"845\":1,\"860\":1}}],[\"msgext=\",{\"1\":{\"845\":1}}],[\"msgext里面的内容不完整\",{\"1\":{\"845\":1}}],[\"msgext\",{\"1\":{\"845\":6,\"860\":5,\"861\":3,\"1198\":25,\"1370\":6,\"1373\":7,\"1468\":17,\"1469\":17}}],[\"msginner\",{\"1\":{\"737\":36,\"738\":4,\"845\":5,\"860\":8,\"861\":2,\"1056\":21,\"1198\":23,\"1273\":14,\"1280\":19,\"1462\":10,\"1463\":14,\"1464\":11}}],[\"msgid=\",{\"1\":{\"1464\":2}}],[\"msgid=7f00000100002a9f000000104a169ced\",{\"1\":{\"1445\":1}}],[\"msgid=7f00000100002a9f000000104a1699a5\",{\"1\":{\"1445\":1}}],[\"msgid=7f00000100002a9f000000104a169b49\",{\"1\":{\"1445\":1}}],[\"msgid=c0a80109803418b4aac25d18022b0009\",{\"1\":{\"1445\":1}}],[\"msgid=c0a80109803418b4aac25d18021d0008\",{\"1\":{\"1445\":1}}],[\"msgid=c0a80109803418b4aac25d18020f0007\",{\"1\":{\"1445\":1}}],[\"msgid=c0a80109803418b4aac25d1802020006\",{\"1\":{\"1445\":1}}],[\"msgid=c0a80109803418b4aac25d1801f50005\",{\"1\":{\"1445\":1}}],[\"msgid=c0a80109803418b4aac25d1801e70004\",{\"1\":{\"1445\":1}}],[\"msgid=c0a80109803418b4aac25d1801da0003\",{\"1\":{\"1445\":1}}],[\"msgid=c0a80109803418b4aac25d1801cd0002\",{\"1\":{\"1445\":1}}],[\"msgid=c0a80109803418b4aac25d1801be0001\",{\"1\":{\"1445\":1}}],[\"msgid=c0a80109803418b4aac25d18010d0000\",{\"1\":{\"1445\":1}}],[\"msgid与offsetmsgid释疑\",{\"1\":{\"899\":1}}],[\"msgid懒加载\",{\"1\":{\"738\":1}}],[\"msgidbuffer\",{\"1\":{\"738\":5}}],[\"msgidlen\",{\"1\":{\"738\":3}}],[\"msgidsupplier\",{\"1\":{\"738\":4}}],[\"msgid\",{\"1\":{\"720\":2,\"736\":2,\"738\":3,\"789\":1,\"794\":2,\"845\":1,\"860\":2,\"1017\":1}}],[\"msgs=\",{\"1\":{\"1195\":1}}],[\"msgstoretime\",{\"1\":{\"825\":2,\"828\":2,\"845\":2,\"860\":2}}],[\"msgstoreitemmemory\",{\"1\":{\"737\":21}}],[\"msgs\",{\"1\":{\"687\":1,\"985\":2,\"1007\":2,\"1194\":9,\"1195\":11,\"1230\":10,\"1248\":2,\"1444\":2}}],[\"msg\",{\"1\":{\"103\":1,\"229\":2,\"543\":2,\"621\":1,\"626\":5,\"627\":2,\"687\":3,\"737\":5,\"794\":7,\"835\":6,\"843\":16,\"845\":2,\"860\":2,\"984\":2,\"1005\":1,\"1006\":2,\"1019\":1,\"1020\":12,\"1050\":8,\"1053\":33,\"1055\":1,\"1056\":3,\"1174\":1,\"1175\":2,\"1195\":9,\"1197\":21,\"1271\":1,\"1273\":1,\"1278\":1,\"1280\":5,\"1287\":2,\"1296\":7,\"1306\":3,\"1309\":3,\"1329\":4,\"1371\":2,\"1372\":4,\"1373\":3,\"1374\":3,\"1431\":4,\"1432\":2,\"1442\":4,\"1443\":3,\"1445\":3,\"1449\":1,\"1450\":1,\"1458\":5,\"1459\":23,\"1460\":4,\"1468\":4,\"1472\":4}}],[\"ms\",{\"1\":{\"11\":24,\"371\":1,\"824\":1,\"1332\":1,\"1370\":1,\"1382\":1,\"1435\":3,\"1436\":2,\"1519\":1}}],[\"mib\",{\"1\":{\"1170\":3}}],[\"missed\",{\"1\":{\"1520\":2}}],[\"miss\",{\"1\":{\"1145\":1,\"1370\":1,\"1373\":1,\"1431\":2,\"1468\":5}}],[\"misc\",{\"1\":{\"182\":2,\"256\":2}}],[\"mixall\",{\"1\":{\"960\":8,\"971\":3,\"1020\":1,\"1047\":1,\"1053\":2,\"1142\":1,\"1143\":1,\"1173\":3,\"1174\":1,\"1175\":1,\"1195\":1,\"1197\":1,\"1198\":2,\"1200\":2,\"1226\":1,\"1230\":1,\"1266\":1,\"1280\":1,\"1296\":3,\"1297\":3}}],[\"mirrored\",{\"1\":{\"679\":1}}],[\"mirror位于节点b上\",{\"1\":{\"659\":1}}],[\"mirroring\",{\"1\":{\"648\":1,\"679\":1}}],[\"mirror\",{\"1\":{\"647\":1,\"652\":1,\"653\":1,\"655\":2,\"672\":3,\"692\":1}}],[\"might\",{\"1\":{\"624\":1}}],[\"michael\",{\"1\":{\"301\":2,\"361\":2}}],[\"microseconds\",{\"1\":{\"1435\":2}}],[\"microsoft\",{\"1\":{\"298\":4}}],[\"microbenchmark\",{\"1\":{\"2\":1,\"15\":2}}],[\"middle\",{\"1\":{\"299\":4,\"316\":2,\"870\":1}}],[\"middleware\",{\"1\":{\"0\":1,\"15\":1,\"95\":1,\"106\":1,\"136\":1,\"137\":1,\"167\":1,\"262\":1,\"274\":1,\"286\":1,\"290\":1,\"369\":1,\"381\":1,\"397\":1,\"492\":1,\"607\":1,\"628\":1,\"640\":1,\"646\":1,\"679\":1,\"691\":1,\"704\":1,\"717\":1,\"743\":1,\"774\":1,\"798\":1,\"829\":1,\"848\":1,\"861\":1,\"872\":1,\"884\":1,\"917\":1,\"938\":1,\"974\":1,\"1001\":1,\"1022\":1,\"1057\":1,\"1067\":1,\"1084\":1,\"1105\":1,\"1123\":1,\"1145\":1,\"1175\":1,\"1201\":1,\"1230\":1,\"1242\":1,\"1281\":1,\"1298\":1,\"1300\":1,\"1334\":1,\"1375\":1,\"1437\":1,\"1473\":1,\"1504\":1,\"1522\":1,\"1523\":1,\"1527\":1,\"1537\":1}}],[\"millis\",{\"1\":{\"1170\":2}}],[\"milliseconds\",{\"1\":{\"9\":1,\"861\":1,\"869\":1,\"915\":1,\"970\":1,\"1021\":1,\"1048\":4,\"1201\":1,\"1225\":1,\"1371\":2,\"1373\":1,\"1374\":1,\"1435\":1,\"1436\":1,\"1497\":1,\"1499\":1}}],[\"mills\",{\"1\":{\"1170\":4}}],[\"milk\",{\"1\":{\"177\":7}}],[\"minfastforwardindex\",{\"1\":{\"1520\":6}}],[\"minioffset\",{\"1\":{\"1468\":1}}],[\"minimum\",{\"1\":{\"1468\":1}}],[\"minus\",{\"1\":{\"1464\":2}}],[\"minutes\",{\"1\":{\"961\":1,\"1048\":1,\"1077\":2,\"1427\":1}}],[\"minute\",{\"1\":{\"316\":1,\"1075\":6}}],[\"minute=0\",{\"1\":{\"316\":1}}],[\"minoffsetinqueue\",{\"1\":{\"1370\":1,\"1427\":9}}],[\"minoffset=\",{\"1\":{\"1170\":3}}],[\"minoffset\",{\"1\":{\"871\":4,\"872\":3,\"1174\":9,\"1420\":1,\"1430\":1,\"1432\":1}}],[\"minlogicoffset\",{\"1\":{\"765\":1}}],[\"min\",{\"1\":{\"11\":3,\"660\":2,\"733\":1,\"794\":1,\"861\":1,\"1174\":3,\"1368\":2,\"1427\":1,\"1430\":3,\"1432\":2,\"1436\":2,\"1445\":3}}],[\"may\",{\"1\":{\"1145\":1,\"1173\":1,\"1333\":1,\"1370\":1,\"1427\":1}}],[\"maybemovewritetime\",{\"1\":{\"1371\":2}}],[\"maybe\",{\"1\":{\"765\":2,\"1019\":1,\"1047\":1,\"1122\":1,\"1175\":1,\"1225\":1,\"1270\":1,\"1520\":2}}],[\"mark\",{\"0\":{\"1300\":1},\"1\":{\"1299\":6,\"1300\":5,\"1372\":1}}],[\"markbitcas\",{\"1\":{\"1276\":1,\"1277\":1}}],[\"markprotocoltype\",{\"1\":{\"894\":1}}],[\"markresponsetype\",{\"1\":{\"820\":1}}],[\"madv\",{\"1\":{\"882\":1}}],[\"madvise\",{\"1\":{\"882\":2}}],[\"magic\",{\"1\":{\"737\":2,\"1352\":2,\"1367\":3,\"1368\":1,\"1370\":1,\"1371\":11,\"1372\":4,\"1517\":3}}],[\"magiccode\",{\"1\":{\"737\":2}}],[\"male\",{\"1\":{\"316\":2,\"515\":1}}],[\"machine\",{\"1\":{\"1173\":1}}],[\"mac\",{\"1\":{\"288\":1}}],[\"macro1\",{\"1\":{\"213\":2}}],[\"macronname\",{\"1\":{\"213\":1}}],[\"macro\",{\"0\":{\"159\":1},\"1\":{\"214\":3,\"624\":1}}],[\"match\",{\"1\":{\"825\":5,\"886\":1,\"904\":1,\"960\":1,\"1000\":2}}],[\"matched\",{\"1\":{\"767\":1,\"1173\":2,\"1174\":4,\"1175\":2,\"1270\":2,\"1333\":1,\"1430\":2,\"1432\":1,\"1468\":1}}],[\"matchspec是一个模式\",{\"1\":{\"261\":1}}],[\"matchspec\",{\"1\":{\"261\":1}}],[\"math\",{\"1\":{\"196\":1,\"319\":2,\"351\":1,\"794\":1,\"861\":1,\"1052\":2,\"1145\":2,\"1174\":1,\"1269\":1,\"1427\":2,\"1432\":2,\"1435\":1,\"1436\":2}}],[\"matter\",{\"1\":{\"97\":1}}],[\"maptoint\",{\"1\":{\"1428\":1}}],[\"mapedbuffer\",{\"1\":{\"1270\":2}}],[\"map类型\",{\"1\":{\"999\":1}}],[\"map<long\",{\"1\":{\"971\":1,\"1346\":1,\"1514\":2}}],[\"map<string\",{\"1\":{\"665\":1,\"714\":2,\"715\":1,\"825\":1,\"828\":1,\"964\":1,\"997\":5,\"998\":6,\"999\":1,\"1000\":2,\"1020\":1,\"1021\":1,\"1056\":1,\"1142\":1,\"1297\":2,\"1318\":2,\"1333\":2,\"1427\":1,\"1514\":1,\"1521\":1}}],[\"maplenindex\",{\"1\":{\"894\":3}}],[\"mapmode\",{\"1\":{\"880\":1}}],[\"map的key如果为空\",{\"1\":{\"822\":1}}],[\"mappingcontext\",{\"1\":{\"1462\":3}}],[\"mapping\",{\"1\":{\"396\":1,\"564\":1}}],[\"mappedcommitlogoffset\",{\"1\":{\"1427\":2}}],[\"mappedfileoffset\",{\"1\":{\"771\":6}}],[\"mappedfilesize\",{\"1\":{\"771\":1}}],[\"mappedfilesizelogics\",{\"1\":{\"771\":3}}],[\"mappedfiles\",{\"1\":{\"771\":6}}],[\"mappedfile\",{\"0\":{\"1528\":1,\"1531\":1,\"1532\":1,\"1533\":1},\"1\":{\"765\":11,\"768\":1,\"771\":11,\"787\":1,\"790\":3,\"797\":2,\"870\":8,\"880\":2,\"882\":5,\"912\":1,\"1296\":1,\"1368\":22,\"1386\":3,\"1402\":1,\"1412\":1,\"1436\":3,\"1528\":1}}],[\"mappedfilequeue\",{\"0\":{\"1528\":1},\"1\":{\"746\":1,\"765\":3,\"771\":4,\"870\":1,\"1368\":4,\"1386\":3,\"1402\":1}}],[\"mapped\",{\"1\":{\"137\":1,\"396\":1,\"771\":1,\"880\":2,\"1368\":2,\"1436\":2}}],[\"mappedbytebuffer的一点优化\",{\"1\":{\"137\":1}}],[\"mappedbytebuffer\",{\"1\":{\"2\":1,\"137\":3,\"736\":1,\"797\":11,\"880\":1,\"882\":5,\"910\":1,\"1435\":1}}],[\"mapreduce以及秒级任务会起一个定时线程\",{\"1\":{\"378\":1}}],[\"mapreduce动态分片\",{\"0\":{\"378\":1}}],[\"mapreduce任务\",{\"1\":{\"375\":1}}],[\"mapreduce\",{\"1\":{\"372\":1}}],[\"mapreduce就是一个任务切分多个子任务并行处理\",{\"1\":{\"371\":1}}],[\"mapreduce处理器完成任务的分发\",{\"1\":{\"371\":1}}],[\"mapreduce处理器能使开发者寥寥数行代码便获得集群分布式计算的能力\",{\"1\":{\"371\":1}}],[\"mapreduce四种执行模式\",{\"1\":{\"371\":1}}],[\"map和set都属于iterable类型\",{\"1\":{\"303\":1}}],[\"maps\",{\"1\":{\"192\":2,\"769\":2,\"871\":2}}],[\"map或filter就能创建列表的表达式\",{\"1\":{\"184\":1}}],[\"map\",{\"0\":{\"183\":1,\"190\":1,\"192\":1,\"300\":1,\"301\":1,\"322\":1,\"323\":1,\"741\":1},\"1\":{\"181\":3,\"183\":5,\"190\":1,\"192\":2,\"217\":1,\"300\":1,\"301\":2,\"303\":1,\"323\":1,\"371\":1,\"391\":1,\"740\":2,\"741\":3,\"742\":1,\"825\":1,\"844\":1,\"880\":2,\"894\":4,\"904\":2,\"971\":1,\"995\":6,\"997\":1,\"1000\":1,\"1021\":2,\"1120\":1,\"1142\":1,\"1200\":1,\"1201\":6,\"1212\":1,\"1248\":1,\"1253\":2,\"1263\":4,\"1277\":1,\"1278\":7,\"1332\":4,\"1333\":1,\"1402\":3,\"1436\":3,\"1468\":1,\"1507\":1,\"1521\":1}}],[\"makelogicsqueueerror\",{\"1\":{\"1297\":1}}],[\"makecustomheadertonet\",{\"1\":{\"893\":1,\"894\":2}}],[\"makefile\",{\"0\":{\"225\":1}}],[\"maketest\",{\"1\":{\"181\":2}}],[\"make\",{\"1\":{\"104\":1,\"218\":1,\"1267\":1,\"1435\":1,\"1500\":1}}],[\"maker\",{\"1\":{\"104\":1}}],[\"makesurestateok\",{\"1\":{\"1050\":1,\"1170\":1}}],[\"makes\",{\"1\":{\"97\":1}}],[\"massive\",{\"1\":{\"1437\":1}}],[\"massage\",{\"1\":{\"1053\":1}}],[\"masteraddr\",{\"1\":{\"971\":4}}],[\"master将查找到的数据发送给slave\",{\"1\":{\"729\":1}}],[\"master查询开始位置对应的mappedfile\",{\"1\":{\"729\":1}}],[\"master收到后确认给slave发送数据的开始位置\",{\"1\":{\"729\":1}}],[\"master发布的消息是依次经过所有slave节点\",{\"1\":{\"674\":1}}],[\"masters\",{\"1\":{\"660\":2}}],[\"master\",{\"1\":{\"96\":1,\"165\":1,\"272\":1,\"372\":2,\"381\":1,\"660\":4,\"672\":1,\"729\":2,\"730\":1,\"853\":1,\"965\":1,\"971\":5,\"1075\":2,\"1173\":5,\"1200\":3,\"1226\":1,\"1372\":2}}],[\"mask\",{\"1\":{\"67\":2}}],[\"manager\",{\"1\":{\"947\":1,\"961\":1,\"1332\":2}}],[\"manualdeletefileseveraltimes\",{\"1\":{\"870\":4}}],[\"manualdelete\",{\"1\":{\"870\":3}}],[\"manual\",{\"1\":{\"658\":1}}],[\"manually\",{\"1\":{\"652\":2}}],[\"manymessagetransfer\",{\"1\":{\"1173\":1}}],[\"manypullrequest\",{\"1\":{\"815\":2,\"822\":3,\"825\":1}}],[\"many\",{\"1\":{\"171\":2,\"720\":1,\"731\":1,\"1173\":2,\"1427\":1}}],[\"mandatory\",{\"1\":{\"87\":1}}],[\"manifestresourcetransformer\",{\"1\":{\"64\":1}}],[\"manifest\",{\"1\":{\"24\":2}}],[\"maxterm\",{\"1\":{\"1499\":5}}],[\"maxterm=\",{\"1\":{\"1497\":1,\"1499\":1}}],[\"maxvoteintervalms\",{\"1\":{\"1497\":2}}],[\"maxheartbeatleak\",{\"1\":{\"1495\":2,\"1497\":1,\"1499\":2}}],[\"maxhashslotnum\",{\"1\":{\"787\":1}}],[\"maxopoffset\",{\"1\":{\"1468\":2}}],[\"maxoffsetinqueue\",{\"1\":{\"1427\":16}}],[\"maxoffsetpy\",{\"1\":{\"1174\":4}}],[\"maxoffset=\",{\"1\":{\"1170\":3}}],[\"maxoffset\",{\"1\":{\"825\":3,\"1174\":9,\"1288\":1,\"1403\":1,\"1420\":1,\"1430\":1,\"1431\":1,\"1432\":1}}],[\"maxcount=\",{\"1\":{\"1431\":2}}],[\"maxcount\",{\"1\":{\"1409\":1,\"1430\":4,\"1431\":5,\"1436\":24}}],[\"maxlmqconsumequeuenum\",{\"1\":{\"1174\":1}}],[\"maxspan=\",{\"1\":{\"1170\":1}}],[\"maxdirectmemorysize=15g\",{\"1\":{\"1080\":1}}],[\"maxretries\",{\"1\":{\"1297\":9}}],[\"maxreconsumetimes\",{\"1\":{\"1053\":3,\"1198\":4}}],[\"maxroll\",{\"1\":{\"398\":1}}],[\"maxpendingsize\",{\"1\":{\"1519\":5}}],[\"maxpendinglimit=\",{\"1\":{\"860\":1}}],[\"maxpendinglimit\",{\"1\":{\"860\":3}}],[\"maxphyoffsetpulling\",{\"1\":{\"767\":1,\"1174\":4}}],[\"maxphysicoffset=\",{\"1\":{\"765\":1}}],[\"maxphysicoffset\",{\"1\":{\"765\":3,\"771\":1}}],[\"maxnums\",{\"1\":{\"1117\":1,\"1171\":3}}],[\"maxnum\",{\"1\":{\"789\":1,\"790\":1,\"794\":8,\"797\":4,\"1164\":1}}],[\"maxindexnum\",{\"1\":{\"787\":1}}],[\"maximum\",{\"1\":{\"737\":2,\"767\":1,\"1174\":1,\"1430\":1,\"1468\":1}}],[\"maxextaddr\",{\"1\":{\"771\":4}}],[\"maxfiltermessagecount\",{\"1\":{\"767\":1,\"1174\":2}}],[\"maxmsgoffset\",{\"1\":{\"1468\":2}}],[\"maxmsgsize\",{\"1\":{\"1021\":1}}],[\"maxmsgnums\",{\"1\":{\"757\":1,\"767\":2,\"1174\":5}}],[\"maxmessagesize\",{\"1\":{\"737\":6}}],[\"maxblank\",{\"1\":{\"737\":1,\"738\":1}}],[\"max=\",{\"1\":{\"722\":1,\"1468\":1}}],[\"max\",{\"1\":{\"11\":2,\"124\":4,\"182\":5,\"186\":2,\"188\":1,\"319\":2,\"332\":2,\"722\":2,\"737\":2,\"771\":1,\"797\":3,\"870\":1,\"1053\":1,\"1145\":2,\"1170\":1,\"1173\":1,\"1174\":1,\"1175\":1,\"1195\":1,\"1229\":1,\"1230\":1,\"1241\":1,\"1275\":1,\"1403\":4,\"1427\":2,\"1430\":7,\"1435\":1,\"1436\":1,\"1445\":3,\"1468\":4,\"1520\":2}}],[\"maven已经内置了一些常用的标准插件\",{\"1\":{\"64\":1}}],[\"maven本身其实并不知道如何执行compile\",{\"1\":{\"64\":1}}],[\"maven先执行clean生命周期并运行到clean这个phase\",{\"1\":{\"62\":1}}],[\"maven的\",{\"1\":{\"62\":1}}],[\"maven通过lifecycle\",{\"1\":{\"61\":1}}],[\"maven\",{\"0\":{\"7\":1,\"59\":1,\"65\":1},\"1\":{\"7\":2,\"62\":1,\"64\":2,\"65\":1,\"712\":1}}],[\"maintainer\",{\"1\":{\"1500\":1}}],[\"maintainascandidate\",{\"0\":{\"1497\":1},\"1\":{\"1497\":1}}],[\"maintainasleader\",{\"0\":{\"1496\":1},\"1\":{\"1496\":1}}],[\"maintainasfollower\",{\"0\":{\"1495\":1},\"1\":{\"1484\":1,\"1495\":1}}],[\"maintainstate\",{\"1\":{\"1483\":1}}],[\"mainthread\",{\"1\":{\"113\":3}}],[\"mainloop\",{\"1\":{\"625\":3}}],[\"mainreactorgroup\",{\"1\":{\"133\":5,\"134\":2}}],[\"mainreactor\",{\"1\":{\"122\":1}}],[\"mainclass>\",{\"1\":{\"64\":1}}],[\"main<\",{\"1\":{\"64\":1}}],[\"main\",{\"1\":{\"2\":1,\"21\":4,\"25\":2,\"34\":2,\"41\":2,\"69\":1,\"70\":1,\"113\":2,\"126\":2,\"129\":2,\"132\":3,\"133\":1,\"134\":2,\"224\":1,\"272\":2,\"712\":1,\"756\":1,\"806\":1,\"812\":1,\"947\":1,\"984\":1,\"985\":1,\"1079\":1,\"1248\":1,\"1443\":1,\"1444\":1}}],[\"mqtt\",{\"1\":{\"1284\":3,\"1290\":1,\"1291\":1}}],[\"mqtracecontext\",{\"1\":{\"1056\":3}}],[\"mqtrace\",{\"1\":{\"1019\":1}}],[\"mqlocktable\",{\"1\":{\"1212\":1,\"1214\":1,\"1222\":3}}],[\"mqs\",{\"1\":{\"1200\":5,\"1222\":5}}],[\"mqset\",{\"1\":{\"1143\":13,\"1144\":4,\"1224\":4,\"1266\":4}}],[\"mqselected\",{\"1\":{\"1050\":3}}],[\"mqdivided\",{\"1\":{\"1145\":2}}],[\"mqallsize=\",{\"1\":{\"1143\":1}}],[\"mqall\",{\"1\":{\"1143\":4,\"1145\":2,\"1266\":5,\"1267\":8}}],[\"mqadminext\",{\"1\":{\"1248\":4}}],[\"mqadmin\",{\"0\":{\"1008\":1},\"1\":{\"1008\":1,\"1036\":1,\"1116\":2,\"1247\":1,\"1248\":1,\"1441\":1}}],[\"mqxxxxconsumer\",{\"1\":{\"1118\":1}}],[\"mqproducerinner\",{\"1\":{\"1471\":1}}],[\"mqproducerimpl\",{\"1\":{\"1038\":1}}],[\"mqpushconsumer\",{\"1\":{\"1117\":1}}],[\"mqpullconsumer\",{\"1\":{\"1117\":1}}],[\"mqconsumerinner\",{\"1\":{\"1118\":1}}],[\"mqconsumer\",{\"1\":{\"1116\":2}}],[\"mqclientmanager\",{\"1\":{\"1047\":1,\"1122\":1}}],[\"mqclientfactory\",{\"1\":{\"1047\":4,\"1051\":2,\"1053\":7,\"1118\":1,\"1122\":10,\"1140\":1,\"1143\":3,\"1171\":4,\"1197\":3,\"1200\":6,\"1226\":3,\"1460\":3,\"1471\":3,\"1472\":1}}],[\"mqclientapiipml\",{\"1\":{\"1040\":1}}],[\"mqclientapiimpl\",{\"0\":{\"1161\":1},\"1\":{\"1036\":1,\"1042\":2,\"1048\":3,\"1120\":1,\"1123\":2,\"1214\":1}}],[\"mqclientinstnace\",{\"1\":{\"1036\":1,\"1109\":1,\"1110\":1,\"1118\":1}}],[\"mqclientinstance\",{\"0\":{\"1123\":1,\"1172\":1},\"1\":{\"950\":2,\"956\":2,\"1036\":4,\"1037\":5,\"1042\":1,\"1047\":5,\"1048\":6,\"1053\":1,\"1111\":1,\"1112\":2,\"1118\":1,\"1120\":2,\"1123\":1,\"1191\":1,\"1235\":3}}],[\"mqclientexception\",{\"0\":{\"1048\":1},\"1\":{\"984\":1,\"985\":1,\"1047\":3,\"1048\":3,\"1050\":5,\"1053\":2,\"1122\":4,\"1123\":3,\"1170\":1,\"1171\":4,\"1197\":2,\"1200\":2,\"1443\":2,\"1444\":1,\"1458\":2,\"1459\":3}}],[\"mqbroker\",{\"1\":{\"1075\":3,\"1079\":4,\"1080\":3}}],[\"mqbrokerexception\",{\"1\":{\"1050\":2,\"1053\":1,\"1171\":2,\"1172\":1,\"1197\":2,\"1200\":1,\"1460\":1}}],[\"mqfaultstrategy\",{\"1\":{\"1041\":1,\"1052\":1}}],[\"mqnamesrv\",{\"1\":{\"960\":1,\"1075\":1,\"1079\":2}}],[\"mqversion\",{\"1\":{\"960\":1,\"1171\":1,\"1198\":1}}],[\"mq\",{\"1\":{\"0\":1,\"15\":1,\"95\":1,\"106\":1,\"136\":1,\"137\":1,\"167\":1,\"262\":1,\"274\":1,\"286\":1,\"290\":1,\"369\":1,\"381\":1,\"397\":1,\"492\":1,\"607\":1,\"628\":1,\"640\":1,\"646\":1,\"679\":1,\"691\":1,\"704\":1,\"717\":1,\"743\":1,\"774\":1,\"798\":1,\"829\":1,\"848\":1,\"861\":1,\"872\":1,\"884\":1,\"917\":1,\"938\":1,\"974\":1,\"1001\":1,\"1022\":1,\"1024\":1,\"1050\":7,\"1052\":10,\"1053\":10,\"1057\":1,\"1067\":1,\"1084\":1,\"1105\":1,\"1123\":1,\"1144\":25,\"1145\":1,\"1171\":12,\"1173\":5,\"1175\":1,\"1195\":2,\"1200\":17,\"1201\":1,\"1217\":1,\"1222\":9,\"1224\":21,\"1225\":7,\"1226\":7,\"1230\":3,\"1242\":1,\"1267\":3,\"1281\":1,\"1288\":3,\"1298\":1,\"1300\":1,\"1329\":3,\"1334\":1,\"1375\":1,\"1431\":8,\"1432\":3,\"1437\":1,\"1473\":1,\"1504\":1,\"1522\":1,\"1523\":1,\"1527\":1,\"1537\":1}}],[\"欢迎关注公众号\",{\"1\":{\"0\":1,\"15\":1,\"95\":1,\"106\":1,\"136\":1,\"137\":1,\"167\":1,\"262\":1,\"274\":1,\"286\":1,\"290\":1,\"369\":1,\"381\":1,\"397\":1,\"492\":1,\"607\":1,\"628\":1,\"640\":1,\"646\":1,\"679\":1,\"691\":1,\"704\":1,\"717\":1,\"743\":1,\"774\":1,\"798\":1,\"829\":1,\"848\":1,\"861\":1,\"872\":1,\"884\":1,\"917\":1,\"938\":1,\"974\":1,\"1001\":1,\"1022\":1,\"1057\":1,\"1067\":1,\"1084\":1,\"1105\":1,\"1123\":1,\"1145\":1,\"1175\":1,\"1201\":1,\"1230\":1,\"1242\":1,\"1281\":1,\"1298\":1,\"1300\":1,\"1334\":1,\"1375\":1,\"1437\":1,\"1473\":1,\"1504\":1,\"1522\":1,\"1523\":1,\"1527\":1,\"1537\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
