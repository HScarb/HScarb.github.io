import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as r,c as d,a as e,b as i,d as l,e as a}from"./app-d4e6481d.js";const s={},c={href:"http://hscarb.github.io/other/20260211-vibe-coding-best-practice.html",target:"_blank",rel:"noopener noreferrer"},u=a('<h1 id="使用-claude-code-进行-vibe-coding-编程最佳实践" tabindex="-1"><a class="header-anchor" href="#使用-claude-code-进行-vibe-coding-编程最佳实践" aria-hidden="true">#</a> 使用 Claude Code 进行 vibe coding 编程最佳实践</h1><h2 id="_1-概述" tabindex="-1"><a class="header-anchor" href="#_1-概述" aria-hidden="true">#</a> 1. 概述</h2><p>AI 辅助编程的演进大致经历了三个阶段。</p><ol><li>2022 年 GitHub Copilot 正式发布，开启了 AI 代码补全时代。</li><li>2023 年 Cursor 等 AI IDE 出现，将交互方式从行内补全升级为 Chatbox 对话式编程。</li><li>2025 年 2 月，Karpathy 用 &quot;Vibe Coding&quot; 一词概括了这种新的编程方式——对 AI 描述意图，看结果、跑一跑、改一改。</li></ol><p>同月，Anthropic 发布 Claude Code，CLI Coding Agent 开始崛起。Agent 能自主读文件、跑命令、执行测试、修 bug，人从&quot;写代码&quot;变成&quot;下指令、做决策、审结果&quot;。</p><p>但没有约束的 Agent 会跑偏。社区随之发展出 OpenSpec、Spec-Kit、Superpowers 等工作流框架，用 SDD 和 TDD 约束 Agent 行为，让 Vibe Coding 从随性编程进化为有纪律的人机协作模式。</p><p>我一直积极拥抱和使用这些新工具和方法。从最初使用 GitHub Copilot 进行 AI 代码补全，到使用 Cursor、Windsurf 进行 Chatbox 对话式编程。在过去几个月里，我用 Claude Code 和 SDD 的方法完成了多个中大型项目的需求设计和开发工作，积累了不少实践经验。</p><p>这篇文章记录了我在这个过程中积累的实践：工具选择与配置、基于 Superpowers 的开发工作流，以及各种提效技巧。</p><h2 id="_2-获取和使用-vibe-coding-工具" tabindex="-1"><a class="header-anchor" href="#_2-获取和使用-vibe-coding-工具" aria-hidden="true">#</a> 2. 获取和使用 vibe-coding 工具</h2><h3 id="_2-1-交互式编程的未来-cli-coding-agent" tabindex="-1"><a class="header-anchor" href="#_2-1-交互式编程的未来-cli-coding-agent" aria-hidden="true">#</a> 2.1 交互式编程的未来：Cli Coding Agent</h3><p>在我看来，Cli Coding Agent 正在成为比 IDE + chatbox 更进一步的编程交互方式。随着 LLM 能力的持续提升，Coding Agent 在智能深度和自主性上有了明显的进步。它们不再局限于写代码本身，而是可以自主地长时间执行复杂任务——调试、测试、甚至驱动一个 Agent 团队来完成完整的软件开发生命周期。</p><p>畅想一下再下一代的 Coding Agent 使用方式也许是一个看板，来展示当前 Agent 的任务执行状态，用户可以在看板上直接与 Agent 交互，调整任务优先级，或者查看日志来理解 Agent 的行为。</p><h3 id="_2-2-主流-coding-agent-选择" tabindex="-1"><a class="header-anchor" href="#_2-2-主流-coding-agent-选择" aria-hidden="true">#</a> 2.2 主流 Coding Agent 选择</h3><p>目前主流的 Cli Coding Agent 包括：</p>',14),h={href:"https://claude.ai/code",target:"_blank",rel:"noopener noreferrer"},p={href:"https://openai.com/blog/codex",target:"_blank",rel:"noopener noreferrer"},g={href:"https://github.com/google-gemini/gemini-cli",target:"_blank",rel:"noopener noreferrer"},_={href:"https://opencode.ai/",target:"_blank",rel:"noopener noreferrer"},b=e("hr",null,null,-1),m=e("p",null,"除了 OpenCode 以外，我都深度使用过。目前我的使用组合是：",-1),f=e("ul",null,[e("li",null,"主力：Claude Code，用它做任何事情，缺点是贵和上下文较小（200K）。"),e("li",null,"辅助：Codex，偶尔用来解决 Claude Code 无法解决的难题，或者对 Claude Code 的结果进行二次验证。它的优势是便宜且上下文长（1M），所以可以用它来处理一些需要大量上下文的任务。"),e("li",null,"验证：Gemini CLI，偶尔用来对前两个工具的结果进行快速评价，它的优势是速度快、上下文大（1M）、知识宽度广而且有免费的用量。")],-1),C=e("h3",{id:"_2-3-如何获取和使用-coding-agent",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-3-如何获取和使用-coding-agent","aria-hidden":"true"},"#"),i(" 2.3 如何获取和使用 Coding Agent")],-1),v=e("p",null,"我目前通过国内中转站的方式使用这些工具。国内中转站提供稳定和价格实惠的 API 中转，让使用顶尖模型变得容易。",-1),k=e("p",null,"我通过这些中转评测网站来找到性价比较高的中转站：",-1),x={href:"https://aio.helphelp.club/transit",target:"_blank",rel:"noopener noreferrer"},w={href:"https://relaypulse.top/?service=cc&period=7d",target:"_blank",rel:"noopener noreferrer"},A=e("p",null,"目前个人在使用的中转站：",-1),D={href:"https://www.openclaudecode.cn/register?aff=vVsG",target:"_blank",rel:"noopener noreferrer"},S={href:"https://mikucode.xyz/",target:"_blank",rel:"noopener noreferrer"},q=e("blockquote",null,[e("p",null,"注意，所有中转站都有跑路风险，请勿大额度充值。")],-1),y=e("h3",{id:"_2-4-使用-cc-switch-快速配置和切换中转站",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-4-使用-cc-switch-快速配置和切换中转站","aria-hidden":"true"},"#"),i(" 2.4 使用 cc-switch 快速配置和切换中转站")],-1),E=e("p",null,"配置这几种 Coding Agent 的变量比较麻烦，尤其是需要频繁切换中转站和模型的情况下。",-1),I={href:"https://github.com/farion1231/cc-switch",target:"_blank",rel:"noopener noreferrer"},P=e("code",null,"cc-switch",-1),T=e("p",null,[e("img",{src:"https://scarb-images.oss-cn-hangzhou.aliyuncs.com/knowledge/2026/02/1770983950816.png",alt:"alt text",loading:"lazy"}),e("br"),e("img",{src:"https://scarb-images.oss-cn-hangzhou.aliyuncs.com/knowledge/2026/02/1770983951021.png",alt:"alt text",loading:"lazy"})],-1),M=e("p",null,[i("启用某个配置之后，它会自动设置 claude 的 "),e("code",null,"~/.claude/settings.json"),i("，重新启动 claude 即可生效。")],-1),L=e("h3",{id:"_2-5-使用-ccstatusline-实时查看运行状态",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_2-5-使用-ccstatusline-实时查看运行状态","aria-hidden":"true"},"#"),i(" 2.5 使用 ccstatusline 实时查看运行状态")],-1),G={href:"https://github.com/sirmalloc/ccstatusline",target:"_blank",rel:"noopener noreferrer"},B=a('<figure><img src="https://scarb-images.oss-cn-hangzhou.aliyuncs.com/knowledge/2026/02/1770983951079.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h2 id="_3-需求开发最佳实践-使用-superpowers" tabindex="-1"><a class="header-anchor" href="#_3-需求开发最佳实践-使用-superpowers" aria-hidden="true">#</a> 3. 需求开发最佳实践（使用 Superpowers）</h2><h3 id="_3-1-了解-agent-能力的边界" tabindex="-1"><a class="header-anchor" href="#_3-1-了解-agent-能力的边界" aria-hidden="true">#</a> 3.1 了解 Agent 能力的边界</h3><p>Vibe Coding 前，了解 Agent 能力的边界非常重要，这决定了你把什么任务让 Agent 完成。</p><p>目前 Claude Code 的能力能做到：</p><ul><li>与用户进行讨论，实现架构设计</li><li>100% 代码编写</li><li>环境搭建、依赖安装</li><li>端到端测试（单元测试、集成测试、E2E 测试）</li><li>调试问题，分析日志，修复 bug</li></ul><p>可以说，只要有足够的上下文，它的能力超过领域专家。所以，放心地把任务交给 Agent 吧！Agent 能力的边界远比你想象的要宽广。只要你给它足够的信息和正确的指令，它就能完成很多你觉得不可能的任务。</p><p>我曾经给他指令，让它自己查看日志，然后定位问题并修复。它通过 tail -f 实时查看日志，发现问题并定位到具体代码行，最后成功修复了问题。完全不需要人类介入。</p><p>目前最大的约束在于它还无法高效进行除了文本以外的输入输出，以及上下文大小有限。相信在不久的将来 Agent 能够实现所有执行层面的内容，人类只需要下达指令，剩下的交给 Agent 就好。</p><h3 id="_3-2-superpowers-介绍和获取" tabindex="-1"><a class="header-anchor" href="#_3-2-superpowers-介绍和获取" aria-hidden="true">#</a> 3.2 Superpowers 介绍和获取</h3>',10),z={href:"https://github.com/obra/superpowers",target:"_blank",rel:"noopener noreferrer"},U=a(`<p>在 claude code 中直接使用下面命令安装，其他 Agent 的安装方式请参考其文档。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># Claude Code 安装</span>
/plugin marketplace <span class="token function">add</span> obra/superpowers-marketplace
/plugin <span class="token function">install</span> superpowers@superpowers-marketplace
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>安装之后可以使用斜杠命令来看到它提供的 command，也可以在 prompt 中直接让它使用相应的技能。</p><figure><img src="https://scarb-images.oss-cn-hangzhou.aliyuncs.com/knowledge/2026/02/1770983951099.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>/skills
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://scarb-images.oss-cn-hangzhou.aliyuncs.com/knowledge/2026/02/1770983951122.png" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><h4 id="关于-sdd-specification-driven-development" tabindex="-1"><a class="header-anchor" href="#关于-sdd-specification-driven-development" aria-hidden="true">#</a> 关于 SDD （Specification-Driven Development）</h4><p>Spec Driven Development (SDD) 是一种&quot;先写规格说明，再写代码&quot;的开发方法。核心思路：在动手实现之前，先用文档明确定义系统该做什么（API 契约、行为规格、接口定义等），然后所有实现、测试、审查都围绕这份 spec 展开。</p><p>我强烈建议在 Vibe Coding 场景下应该使用 SDD 来开发中大型的需求。而 Superpowers 就为 Coding Agent 实现这套方法论提供了工具。但是它的实现比较灵活，它是一系列 Skill，你可以自行选择使用哪些 Skill 来执行你的 SDD 工作流。</p><hr><p>我也使用过一些其他的 SDD 框架或者命令。他们各有各的特点和适用场景：</p>`,11),V={href:"https://github.com/anthropics/claude-code/tree/main/plugins/feature-dev",target:"_blank",rel:"noopener noreferrer"},H=e("ul",null,[e("li",null,"适合中小需求的快速开发。")],-1),O={href:"https://github.com/github/spec-kit",target:"_blank",rel:"noopener noreferrer"},j=e("ul",null,[e("li",null,"流程较重，而且与用户讨论不充分。适合从 0 到 1 开发一个完整项目。")],-1),Y=e("li",null,[i("对于更小的需求或者 BUG 修复，建议先用 "),e("code",null,"/plan"),i(" 模式编写一个计划，审查完计划再执行。")],-1),K=a('<p>superpowers 是我使用下来感觉比较灵活高效的 SDD 实现。它提供了很多实用的 Skill 来支持 SDD 工作流，同时又不会过于死板地限制开发流程，适合进行中大型需求的开发。</p><h4 id="关于-tdd-test-driven-development" tabindex="-1"><a class="header-anchor" href="#关于-tdd-test-driven-development" aria-hidden="true">#</a> 关于 TDD（Test-Driven Development）</h4><p>TDD 是&quot;先写测试，再写代码&quot;的开发方法，也是我觉得非常适合 Coding Agent 的开发方法。</p><p>在人写代码时，TDD 往往无法得到很好的执行，因为它需要耗费大量时间设计和编写高质量的测试用例，而人类开发者往往会因为时间压力或者缺乏动力而跳过这个步骤。但是在 Coding Agent 的世界里，Agent 本身就非常擅长编写测试用例，TDD 可以得到非常好的执行。</p><p>Superpowers 中的流程也天然按照 TDD 的方式来设置，在执行阶段它要求 Agent 先完成测试用例的编写，然后再编写实现代码，最后运行测试验证结果。这个流程非常适合 Agent 的能力特点，可以最大化地发挥 Agent 在测试编写方面的优势，同时也能保证代码质量。</p><h3 id="_3-3-使用-superpowers-进行需求开发" tabindex="-1"><a class="header-anchor" href="#_3-3-使用-superpowers-进行需求开发" aria-hidden="true">#</a> 3.3 使用 Superpowers 进行需求开发</h3><p>Superpowers 的核心工作流是一条从&quot;想法&quot;到&quot;交付&quot;的完整链路。每个环节对应一个 Skill，Skill 之间通过明确的衔接点串联。下面按实际执行顺序逐步介绍。</p><h4 id="_3-3-0-初始化-vibe-coding-环境" tabindex="-1"><a class="header-anchor" href="#_3-3-0-初始化-vibe-coding-环境" aria-hidden="true">#</a> 3.3.0 初始化 Vibe Coding 环境</h4><p>在开始 Vibe Coding 之前，建议先进行一些环境准备工作：</p>',9),N=a("<li><p>使用 <code>/init</code> 命令来初始化 <code>CLAUDE.md</code> 文件，Claude Code 会探索整个代码仓，记录项目约定。这个文件会作为作为上下文的一部分，让 Agent 在执行过程时刻都能参考到这些约定。</p><p>你还可以把一些你要求 Agent 遵守的规则写入 <code>CLAUDE.md</code>，比如&quot;每次修改代码都要运行测试验证&quot;、&quot;每次提交都要写清楚 commit message 的内容和目的&quot;等。</p></li><li><p>在本地准备集成测试需要的环境，比如数据库、中间件等。我会让 Agent 在项目目录中写一个 <code>docker-compose.yml</code> 来定义这些环境，然后让 Agent 在集成测试中使用这些环境，确保编写的代码能够在真实环境中运行。</p></li>",2),R=e("code",null,".claude/rules",-1),F={href:"https://github.com/affaan-m/everything-claude-code/tree/main/rules",target:"_blank",rel:"noopener noreferrer"},W=a('<h4 id="_3-3-1-头脑风暴-brainstorming" tabindex="-1"><a class="header-anchor" href="#_3-3-1-头脑风暴-brainstorming" aria-hidden="true">#</a> 3.3.1 头脑风暴（brainstorming）</h4><p>拿到一个需求之后，我们需要先进行方案设计。当脑中有一个方案框架时，我们用 <code>/brainstorming</code> 命令，与 LLM 讨论设计方案，直到达成一致。LLM 能识别出很多你没有考虑到的点，并且通过多轮提问的方式来确定最终的方案。</p><p>这是我认为 superpowers 工作流中非常好的一个点，其他的 SDD 框架往往在设计环节比较薄弱，直接让 Agent 拿到需求后写计划。而 superpowers 强制要求先进行设计讨论，确保需求和方案被充分理解和审视。</p><p>它做什么：</p><ul><li>先探索项目上下文（文件结构、文档、最近的 git 提交）</li><li>每次只问你一个问题，逐步理解你的意图、约束和成功标准</li><li>提出 2-3 种实现方案，附带权衡分析和推荐理由，你只要做选择题来选择期望的方案</li><li>分段展示最终设计方案，每段确认后再继续</li><li>最终将设计文档保存到 <code>docs/plans/YYYY-MM-DD-&lt;topic&gt;-design.md</code></li></ul><p>对于设计文档的格式，我个人根据我的实践总结了一个结构清晰、信息密度高的模板，已经写成了一个 Skill，可以参考。</p>',6),J={href:"https://github.com/HScarb/agent-configs/tree/main/.claude/skills/feature-designer",target:"_blank",rel:"noopener noreferrer"},X=a(`<p>所以最终的 prompt 可以类似这样：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>/brainstorming 帮我设计一个新的特性，功能是 xxx。设计文档请按照 feature-designer skill 的模板来写。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_3-3-2-创建-git-worktree-using-git-worktrees" tabindex="-1"><a class="header-anchor" href="#_3-3-2-创建-git-worktree-using-git-worktrees" aria-hidden="true">#</a> 3.3.2 创建 Git Worktree（using-git-worktrees）</h4><p>这步是可选的。当需要并行开发多个特性时，可以用 <code>/using-git-worktrees</code> 命令为每个特性创建一个隔离的 git worktree 工作区，避免分支冲突。</p><p>这个命令会为我们创建一个 git worktree，并且自动安装依赖，验证测试基线是干净的。然后我推荐需要 <code>cd</code> 进入新创建的 worktree 目录，重新启动一个新的 Claude Code 会话，在这个隔离的环境中进行开发。</p>`,5),Q={href:"https://x.com/bcherny/status/2017742741636321619",target:"_blank",rel:"noopener noreferrer"},Z=a(`<h4 id="_3-3-3-编写实施计划-writing-plans" tabindex="-1"><a class="header-anchor" href="#_3-3-3-编写实施计划-writing-plans" aria-hidden="true">#</a> 3.3.3 编写实施计划（writing-plans）</h4><p>有了批准的设计文档后，Agent 调用 writing-plans skill 将设计转化为可执行的实施计划。</p><p>这步也是可选的，对于小型任务，可以直接跳过，进入实施阶段。但对于中大型任务，编写详细的实施计划能显著提升开发效率和质量。</p><p>它做什么：</p><ul><li>将设计拆分为细粒度的任务（每个任务 2-5 分钟）</li><li>每个任务包含：精确的文件路径、完整的代码片段、测试命令及预期输出、git commit 命令</li><li>严格遵循 TDD 节奏：写失败测试 → 运行验证失败 → 写最少实现 → 运行验证通过 → 提交</li><li>计划保存到 <code>docs/plans/YYYY-MM-DD-&lt;feature-name&gt;.md</code></li></ul><p>计划编写完成后，Superpowers 提供两种执行方式供选择：</p><ol><li><code>/subagent-driven-development</code>：子代理驱动开发（当前会话内执行）</li><li><code>/executing-plans</code>：并行会话执行（在新会话中使用 executing-plans skill）</li></ol><h4 id="_3-3-4-执行计划" tabindex="-1"><a class="header-anchor" href="#_3-3-4-执行计划" aria-hidden="true">#</a> 3.3.4 执行计划</h4><p>根据用户选择，有两种执行模式：</p><p><strong>模式 A：子代理驱动开发（subagent-driven-development）</strong></p><p>适合在当前会话内执行，是推荐的默认模式，也是我个人使用最多的模式。它可以连续跑几个小时，直到完成所有任务，期间不需要人工介入。</p><p>它做什么：</p><ul><li>主 Agent 读取计划，提取所有任务，创建 TodoWrite 跟踪进度</li><li>为每个任务分派一个全新的子代理（subagent），附带完整的任务文本和上下文</li><li>子代理可以在开始前提问，主 Agent 回答后再继续</li><li>子代理按 TDD 流程实现、测试、自审查、提交</li><li>完成后进入两阶段审查： <ul><li>第一阶段：规格合规性审查（spec reviewer）——代码是否完整实现了规格要求，有没有多做或少做</li><li>第二阶段：代码质量审查（code quality reviewer）——代码是否写得好</li></ul></li><li>审查不通过则由同一个子代理修复，再次审查，循环直到通过</li><li>所有任务完成后，分派最终的全局代码审查子代理</li></ul><p><strong>模式 B：分批执行（executing-plans）</strong></p><p>适合在独立的并行会话中执行，带有人工检查点。</p><p>它做什么：</p><ul><li>加载计划文件，先批判性审查计划本身</li><li>默认每批执行 3 个任务</li><li>每批完成后停下来报告进展和验证结果，等待用户反馈</li><li>根据反馈调整后继续下一批</li></ul><h4 id="_3-3-5-完成开发分支-finishing-a-development-branch" tabindex="-1"><a class="header-anchor" href="#_3-3-5-完成开发分支-finishing-a-development-branch" aria-hidden="true">#</a> 3.3.5 完成开发分支（finishing-a-development-branch）</h4><p>所有任务完成后，可以调用此 skill 来收尾。他会确保测试通过，然后提供合并选项，最后清理工作区。</p><p>它做什么：</p><ul><li>先运行完整测试套件，测试不通过则停下来修复</li><li>确定基础分支（main/master）</li><li>提供 4 个选项： <ol><li>本地合并回基础分支</li><li>推送并创建 Pull Request</li><li>保留分支不动（稍后处理）</li><li>丢弃这次工作</li></ol></li><li>执行用户选择的操作</li><li>清理 worktree（选项 1 和 4 清理，选项 2 和 3 保留）</li></ul><h4 id="_3-3-6-完整工作流示意" tabindex="-1"><a class="header-anchor" href="#_3-3-6-完整工作流示意" aria-hidden="true">#</a> 3.3.6 完整工作流示意</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>用户提出需求
    │
    ▼
brainstorming（探索上下文 → 提问 → 提出方案 → 展示设计 → 用户批准）
    │
    ▼
using-git-worktrees（创建隔离工作区 → 安装依赖 → 验证测试基线）
    │
    ▼
writing-plans（设计 → 细粒度任务 → TDD 步骤 → 保存计划文件）
    │
    ├─→ subagent-driven-development（当前会话：子代理实现 → 两阶段审查 → 循环）
    │
    └─→ executing-plans（并行会话：分批执行 → 人工检查点 → 循环）
    │
    │   ↕ test-driven-development（贯穿实施全程）
    │   ↕ systematic-debugging（遇到问题时触发）
    │   ↕ requesting-code-review / receiving-code-review（任务间审查）
    │   ↕ verification-before-completion（声称完成前验证）
    │
    ▼
finishing-a-development-branch（验证测试 → 选择操作 → 清理 worktree）
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这套工作流的核心理念是：在写代码之前把需求和设计讨论清楚，在写代码的过程中用 TDD 和审查保证质量，在声称完成之前用证据验证结果。Agent 在每个环节都有明确的&quot;铁律&quot;约束，防止走捷径。</p><h4 id="_3-3-7-其他-skill" tabindex="-1"><a class="header-anchor" href="#_3-3-7-其他-skill" aria-hidden="true">#</a> 3.3.7 其他 Skill</h4><p>除了上述流程之外，Superpowers 还提供了很多其他实用的 Skill，可以自行探索。</p><h2 id="_4-其他技巧和工具推荐" tabindex="-1"><a class="header-anchor" href="#_4-其他技巧和工具推荐" aria-hidden="true">#</a> 4. 其他技巧和工具推荐</h2><h3 id="_4-1-并行会话与-git-worktree" tabindex="-1"><a class="header-anchor" href="#_4-1-并行会话与-git-worktree" aria-hidden="true">#</a> 4.1 并行会话与 Git Worktree</h3><ul><li>同时运行 3-5 个 Claude Code 终端会话，每个对应一个独立任务。</li><li>使用 <code>git worktree</code> 为每个会话创建隔离工作目录，避免分支冲突。给标签页编号/命名，开启系统通知以快速跳转到需要输入的会话。</li><li>也可混合使用终端 + Web UI（<code>claude.ai/code</code>）+ 移动端会话，用 <code>--teleport</code> 在不同环境间迁移上下文。</li></ul>`,29),$={id:"_4-2-claude-md-维护",tabindex:"-1"},ee=e("a",{class:"header-anchor",href:"#_4-2-claude-md-维护","aria-hidden":"true"},"#",-1),ie={href:"http://CLAUDE.md",target:"_blank",rel:"noopener noreferrer"},ne=a('<ul><li>在仓库根目录维护 <code>CLAUDE.md</code> 并提交到 git，团队共享。记录：项目约定（构建/lint/test 命令、代码风格）、Claude 反复犯的错误。</li><li>每次 Claude 犯错后立即更新此文件，让后续会话从更好的上下文起步。无情迭代直到错误率明显下降。</li><li>PR Review 时标记 <code>@.claude</code>，将审查反馈自动转化为 <code>CLAUDE.md</code> 更新（需配合 Claude Code GitHub Action）。</li></ul><h3 id="_4-3-plan-模式优先" tabindex="-1"><a class="header-anchor" href="#_4-3-plan-模式优先" aria-hidden="true">#</a> 4.3 Plan 模式优先</h3><ul><li>非简单任务一律先进入 Plan 模式（<code>Shift+Tab</code> 两次），与 Claude 反复迭代计划直到满意，再切换到执行模式。</li><li>进阶：让一个 Claude 起草计划，另一个 Claude 扮演 Staff Engineer 审查计划。如果执行跑偏，切回 Plan 模式重新规划而非硬推。</li><li>编码任务优先选择最强模型 + thinking 模式（如 Opus），虽然单 token 慢但总体更快——减少纠偏和修复工具调用错误的时间。</li></ul><h3 id="_4-4-slash-命令与-skills" tabindex="-1"><a class="header-anchor" href="#_4-4-slash-命令与-skills" aria-hidden="true">#</a> 4.4 Slash 命令与 Skills</h3><ul><li>高频工作流封装为 slash 命令，存放在 <code>.claude/commands/</code> 下并提交到仓库，团队共享。</li><li>命令中可内嵌 bash 预计算上下文（如 <code>git status</code>、<code>git diff</code>），减少交互轮次。</li><li>实际案例：<code>/techdebt</code>（会话结束时查找重复代码）、同步最近 7 天 Slack/GitHub 信息的命令、&quot;分析工程师&quot; agent 等。</li></ul><h3 id="_4-5-subagent-与并行任务" tabindex="-1"><a class="header-anchor" href="#_4-5-subagent-与并行任务" aria-hidden="true">#</a> 4.5 Subagent 与并行任务</h3><ul><li>将子任务分配给 subagent，保持主 agent 上下文干净聚焦。明确告诉 Claude &quot;使用 subagent&quot; 可投入更多算力。</li><li>定义可复用的 subagent 角色：精简最终 diff、端到端验证、安全扫描等。</li><li>Superpowers 的子代理驱动开发模式：为每个任务分派子代理，两阶段审查（规格合规性 + 代码质量），主代理只做调度和检查。</li></ul><h3 id="_4-6-hooks-自动化" tabindex="-1"><a class="header-anchor" href="#_4-6-hooks-自动化" aria-hidden="true">#</a> 4.6 Hooks 自动化</h3><ul><li><code>PostToolUse</code> hook：文件编辑后自动运行格式化工具（black、prettier 等），捕获边界情况，减少 CI 失败。</li><li><code>PreToolUse</code> hook：重大决策前自动重新读取计划文件，防止目标漂移。</li><li><code>Stop</code> hook：会话结束前验证任务完成情况。</li><li>进阶：通过 hook 将敏感权限检查路由到更强模型（如安全扫描用 Opus）。</li></ul><h3 id="_4-7-权限管理" tabindex="-1"><a class="header-anchor" href="#_4-7-权限管理" aria-hidden="true">#</a> 4.7 权限管理</h3><ul><li>通过 <code>/permissions</code> 预授权常用安全命令，配置写入 <code>.claude/settings.json</code> 并团队共享，减少交互中断同时保留安全护栏。</li><li><strong>Bypass Permissions 模式</strong>：<code>Shift+Tab</code> 循环切换权限模式时可进入，或通过 <code>--dangerously-skip-permissions</code> 启动。该模式下 Claude 自动批准所有工具调用（文件读写、bash 命令等），无需逐一确认。适合对计划已充分审查后的执行阶段——先在 Plan 模式下确认方案，再切换到 Bypass 模式让 Claude 全速执行，大幅减少人工干预次数。</li><li>注意：Bypass 模式会跳过所有安全检查，仅在你信任当前计划且工作在独立分支上时使用。生产环境或涉及敏感操作时应避免。</li></ul><h3 id="_4-8-上下文管理与文件持久化" tabindex="-1"><a class="header-anchor" href="#_4-8-上下文管理与文件持久化" aria-hidden="true">#</a> 4.8 上下文管理与文件持久化</h3><ul><li>核心原则：上下文窗口 = 内存（易失、有限），文件系统 = 磁盘（持久、无限）。重要信息写入文件而非依赖上下文。</li><li>Planning with Files 三文件模式：<code>task_plan.md</code>（阶段与进度）、<code>findings.md</code>（研究发现）、<code>progress.md</code>（会话日志与测试结果）。适用于 3 步以上的多步骤任务。</li><li>合理使用 <code>/compact</code> 压缩上下文、<code>/clear</code> 重置。禁用 <code>autoCompact</code> 可在清除前最大化上下文利用。</li></ul><h3 id="_4-9-规格驱动开发" tabindex="-1"><a class="header-anchor" href="#_4-9-规格驱动开发" aria-hidden="true">#</a> 4.9 规格驱动开发</h3><ul><li>在交付前写详细规格说明，消除歧义——越具体，Claude 的自主性越强。</li><li>工具选择： <ul><li><strong>OpenSpec</strong>：轻量迭代，无阶段门控，适合快速原型。命令：<code>/opsx:new</code> → <code>/opsx:ff</code> → <code>/opsx:apply</code> → <code>/opsx:archive</code>。</li><li><strong>Spec Kit</strong>（GitHub 出品）：六步流程（原则 → 规格 → 计划 → 任务 → 实施 → 验证），适合正式项目。</li></ul></li><li>两者均支持多种 AI 编码助手，核心理念一致：需求不应只存在于聊天历史中，规格文件带来可预测性。</li></ul><h3 id="_4-10-提示技巧" tabindex="-1"><a class="header-anchor" href="#_4-10-提示技巧" aria-hidden="true">#</a> 4.10 提示技巧</h3><ul><li>挑战 Claude：要求它证明变更有效（&quot;证明这能工作&quot;、对比 main 分支），扮演审查者角色。</li><li>修复质量不佳时，要求从头重写而非修补（&quot;推翻重来，实现优雅的方案&quot;）。</li><li>端到端委托 bug 修复：粘贴 Slack 讨论线程 / Docker 日志 / CI 失败信息，宽泛委托（&quot;修复失败的 CI 测试&quot;），避免微管理具体方法。</li><li>使用语音输入产出更长、更丰富的提示，提升交互效率。</li></ul><h3 id="_4-11-会话管理与恢复" tabindex="-1"><a class="header-anchor" href="#_4-11-会话管理与恢复" aria-hidden="true">#</a> 4.11 会话管理与恢复</h3><ul><li><code>claude --resume</code> / <code>claude -r</code>：恢复上一次会话，保留完整上下文。适合中断后继续、跨天接续同一任务。</li><li><code>claude --continue</code> / <code>claude -c</code>：继续最近的对话但不进入交互模式，适合追加一条指令后退出。</li><li>会话历史存储在 <code>~/.claude/projects/</code> 下，按项目路径组织。<code>/clear</code> 后 Planning with Files 插件可自动恢复之前的规划状态。</li></ul><h3 id="_4-12-非交互模式与自动化" tabindex="-1"><a class="header-anchor" href="#_4-12-非交互模式与自动化" aria-hidden="true">#</a> 4.12 非交互模式与自动化</h3><ul><li><code>claude -p &quot;指令&quot;</code>：单次执行模式（print mode），不进入交互，适合脚本和 CI/CD 集成。</li><li>支持管道输入：<code>git diff | claude -p &quot;review this&quot;</code> 或 <code>cat error.log | claude -p &quot;分析这个错误&quot;</code>。</li><li><code>--output-format json</code>：结构化输出，便于下游程序解析。</li><li>GitHub Action 集成：在 PR 中自动触发 Claude 进行代码审查、修复 CI 失败、响应 review 评论。通过 <code>/install-github-action</code> 快速配置。</li></ul><h3 id="_4-13-mcp-server-扩展" tabindex="-1"><a class="header-anchor" href="#_4-13-mcp-server-扩展" aria-hidden="true">#</a> 4.13 MCP Server 扩展</h3><ul><li>MCP（Model Context Protocol）让 Claude 接入外部数据源和工具：数据库查询、Slack 消息、Jira 工单、浏览器操作等。</li><li>配置在 <code>.claude/settings.json</code> 的 <code>mcpServers</code> 字段，支持 stdio 和 SSE 两种传输方式。</li><li>实用场景：接入 Slack MCP 粘贴 bug 讨论线程让 Claude 直接修复；接入数据库 MCP 做数据分析；接入浏览器 MCP 做 E2E 测试。</li></ul><h3 id="_4-14-自定义-agent" tabindex="-1"><a class="header-anchor" href="#_4-14-自定义-agent" aria-hidden="true">#</a> 4.14 自定义 Agent</h3><ul><li>在 <code>.claude/agents/</code> 目录下定义专用 agent（Markdown 文件），每个 agent 有独立的系统提示和工具权限。</li><li>适合固化团队角色：planner、code-reviewer、security-reviewer、tdd-guide 等。通过 <code>Task</code> 工具的 <code>subagent_type</code> 参数调用。</li><li>Agent 文件提交到仓库，团队共享统一的工作流标准。</li></ul><h3 id="_4-15-agent-teams-多代理协作" tabindex="-1"><a class="header-anchor" href="#_4-15-agent-teams-多代理协作" aria-hidden="true">#</a> 4.15 Agent Teams（多代理协作）</h3><blockquote><p>实验性功能，需在 <code>settings.json</code> 中设置 <code>&quot;env&quot;: {&quot;CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS&quot;: &quot;1&quot;}</code> 启用。</p></blockquote><ul><li>Agent Teams 让多个 Claude Code 实例组成团队协作：一个 lead 会话负责调度，多个 teammate 会话独立工作，各自拥有独立上下文窗口。</li><li>与 subagent 的区别：subagent 在单会话内运行、只能向主 agent 汇报结果；agent team 的 teammate 之间可以直接通信、共享任务列表、自主认领任务。</li><li>启动方式：用自然语言描述任务和团队结构即可，如 &quot;Create an agent team with 3 reviewers: security, performance, test coverage&quot;。</li><li>适用场景：并行代码审查（安全/性能/测试覆盖各一人）、竞争性假设调试（多人各持一个假设互相挑战）、跨层协作（前端/后端/测试各一人）。</li><li>注意事项：token 消耗随 teammate 数量线性增长；避免多人编辑同一文件；简单任务用 subagent 更经济。</li></ul><h3 id="_4-16-使用分析和优化" tabindex="-1"><a class="header-anchor" href="#_4-16-使用分析和优化" aria-hidden="true">#</a> 4.16 使用分析和优化</h3>',29),le=e("code",null,"/insights",-1),ae={href:"https://www.natemeyvis.com/claude-codes-insights/",target:"_blank",rel:"noopener noreferrer"},te=e("h3",{id:"_4-17-上下文窗口管理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_4-17-上下文窗口管理","aria-hidden":"true"},"#"),i(" 4.17 上下文窗口管理")],-1),oe=e("ul",null,[e("li",null,[i("使用 "),e("code",null,"/context"),i(" 窗口观察当前上下文使用情况。")]),e("li",null,"避免在上下文窗口最后 20% 区域执行大规模重构——此时模型表现下降，应先压缩或新开会话。")],-1),re=e("h2",{id:"参考资料",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考资料","aria-hidden":"true"},"#"),i(" 参考资料")],-1),de={href:"https://github.com/ykdojo/claude-code-tips",target:"_blank",rel:"noopener noreferrer"},se={href:"https://github.com/affaan-m/everything-claude-code/",target:"_blank",rel:"noopener noreferrer"},ce={href:"https://github.com/obra/superpowers",target:"_blank",rel:"noopener noreferrer"},ue={href:"https://github.com/OthmanAdi/planning-with-files",target:"_blank",rel:"noopener noreferrer"},he={href:"https://github.com/Fission-AI/OpenSpec",target:"_blank",rel:"noopener noreferrer"},pe={href:"https://github.com/github/spec-kit",target:"_blank",rel:"noopener noreferrer"},ge={href:"https://x.com/bcherny/status/2017742741636321619",target:"_blank",rel:"noopener noreferrer"},_e={href:"http://CLAUDE.md",target:"_blank",rel:"noopener noreferrer"},be=e("hr",null,null,-1),me=e("p",null,"欢迎关注公众号【消息中间件】（middleware-mq），更新消息中间件的源码解析和最新动态！",-1),fe=e("figure",null,[e("img",{src:"https://scarb-images.oss-cn-hangzhou.aliyuncs.com/img/202205170102971.jpg",alt:"",tabindex:"0",loading:"lazy"}),e("figcaption")],-1);function Ce(ve,ke){const n=o("ExternalLinkIcon");return r(),d("div",null,[e("p",null,[i("原文地址："),e("a",c,[i("http://hscarb.github.io/other/20260211-vibe-coding-best-practice.html"),l(n)])]),u,e("ul",null,[e("li",null,[e("a",h,[i("Claude Code"),l(n)]),i("：目前最强大的 Coding Agent，适合复杂任务和长期项目，skill 等概念的提出者，生态最丰富，模型能力和速度达到完美平衡。")]),e("li",null,[e("a",p,[i("Codex"),l(n)]),i("：模型能力大力出奇迹的典范，模型能力很强，但是工具生态和用户体验不如 Claude Code，速度也较慢。适合解决疑难的但是结果确定的问题。")]),e("li",null,[e("a",g,[i("Gemini CLI"),l(n)]),i("：谷歌推出的开源 Coding Agent，工具生态在快速追赶。硬伤是模型的编程能力不如前两者，优势是速度快和提供了免费的用量。适合前端编写和评价前面两个工具的结果。")]),e("li",null,[e("a",_,[i("OpenCode"),l(n)]),i("：开源的 Coding Agent，工具生态和模型能力都在快速追赶，社区活跃，支持各种模型的接入。")])]),b,m,f,C,v,k,e("ul",null,[e("li",null,[e("a",x,[i("https://aio.helphelp.club"),l(n)]),i("：提供多个中转站的评测和链接")]),e("li",null,[e("a",w,[i("https://relaypulse.top"),l(n)]),i("：中转站可用性监控，可以查看不同中转站的稳定性和响应速度")])]),A,e("ul",null,[e("li",null,[e("a",D,[i("Micu"),l(n)]),i("：Claude Code 价格 0.85x，特价分组 0.2x，稳定性佳。")]),e("li",null,[e("a",S,[i("MikuCode"),l(n)]),i("：纯 Claude Code Max 号池，小而美，价格 1.2x，稳定性中上。")])]),q,y,E,e("p",null,[e("a",I,[i("cc-switch"),l(n)]),i("是一个页面工具，可以快速切换不同 Coding Agent 的配置。它支持预设多个配置文件，每个文件包含不同的 API 密钥、模型选择和其他参数。使用 "),P,i(" 可以大大简化在不同工具之间切换的流程，提高工作效率。还支持 Skill 管理、MCP 管理等功能。")]),T,M,L,e("p",null,[e("a",G,[i("ccstatusline"),l(n)]),i(" 可以在 Claude Code 中实时显示当前使用的模型、上下文使用情况、费用消耗等信息。")]),B,e("p",null,[i("简单来说 "),e("a",z,[i("Superpowers"),l(n)]),i(" 就是一套开发工作流的 Skills。它通过工作流约束 Coding Agent 的行为，让 Agent 在执行任务前与用户讨论清楚需求和计划，然后再以 TDD 的形式执行任务。")]),U,e("ul",null,[e("li",null,[e("a",V,[i("feature-dev"),l(n)]),i("：Anthropic 官方 command，提供了一个简单的工作流，在开发特性前会先让 Agent 探索代码，然后与用户讨论并生成一个开发计划，然后执行，最后用多个 agent 进行审查。 "),H]),e("li",null,[e("a",O,[i("Spec Kit"),l(n)]),i("：严格规定了六步流程（原则 → 规格 → 计划 → 任务 → 实施 → 验证），适合正式项目和团队使用。它的特点是每一步都有明确的输入输出，且有专门的命令来管理整个流程。 "),j]),Y]),K,e("ol",null,[N,e("li",null,[e("p",null,[i("把项目的编码规范写到 "),R,i(" 目录下，Claude Code 会自动加载这些规则并在执行过程中遵守。"),e("a",F,[i("一些 Rules 参考"),l(n)])])])]),W,e("p",null,[e("a",J,[i("feature-designer"),l(n)])]),X,e("p",null,[i("这也是 Claude Code 作者 Boris Cherny 的一个最佳实践推荐 "),e("a",Q,[i("a few tips for using Claude Code - Boris Cherny"),l(n)]),i("。通过这种方式可以实现数倍的开发效率提升，并行开发多个需求，把 Claude Code 的提效能力最大化。我在看到 Boris Cherny 的文章之前，一直是只开启一个 Claude Code 会话来开发，要等待一个任务处理完之后才能开始下一个任务。后来我开始用多个窗口并行开发需求，显著提升了开发效率。")]),Z,e("h3",$,[ee,i(" 4.2 "),e("a",ie,[i("CLAUDE.md"),l(n)]),i(" 维护")]),ne,e("ul",null,[e("li",null,[le,i("：分析你的历史使用模式并生成个性化改进报告。报告内容包括：工作模式反馈（如是否频繁放弃对话）、针对你的使用习惯给出可直接复制粘贴的 skill/agent/hook 建议、具体改进示例。每次运行结果略有不同（侧重近期数据），建议定期执行以持续优化与 Claude 的协作方式。（"),e("a",ae,[i("参考"),l(n)]),i("）")])]),te,oe,re,e("ul",null,[e("li",null,[e("a",de,[i("45 Claude Code Tips: From Basics to Advanced"),l(n)]),i("：包含 45 个 Claude Code 使用技巧的合集，涵盖自定义状态栏、斜杠命令、语音输入、上下文管理和 Git 工作流等方面。")]),e("li",null,[e("a",se,[i("Everything Claude Code"),l(n)]),i("：包含 15+ 代理、30+ 技能、30+ 命令和多语言支持的 Claude Code 综合配置合集。")]),e("li",null,[e("a",ce,[i("Superpowers"),l(n)]),i("：为 Coding Agent 构建的完整软件开发工作流技能集，基于可组合的 Skill 系统，强调 TDD、系统化流程和子代理驱动开发。")]),e("li",null,[e("a",ue,[i("Planning with Files"),l(n)]),i("：通过持久化 Markdown 文件实现 AI 代理的规划、进度跟踪和知识存储的 Claude Code 插件，解决上下文易失和目标漂移问题。")]),e("li",null,[e("a",he,[i("OpenSpec"),l(n)]),i("：轻量级规格驱动开发框架，让开发者在写代码前与 AI 助手就规格达成一致，强调流动性和迭代性，无阶段门控。")]),e("li",null,[e("a",pe,[i("Spec Kit"),l(n)]),i("：GitHub 开源的规格驱动开发工具包，通过六步工作流（原则 → 规格 → 计划 → 任务 → 实施 → 验证）来构建高质量软件。")]),e("li",null,[e("a",ge,[i("a few tips for using Claude Code - Boris Cherny"),l(n)]),i("：Claude Code 创建者分享的使用技巧，包括并行会话、Plan 模式、"),e("a",_e,[i("CLAUDE.md"),l(n)]),i(" 维护、Slash 命令、Subagent 和 Hook 等最佳实践。")])]),be,me,fe])}const Ae=t(s,[["render",Ce],["__file","20260211-vibe-coding-best-practice.html.vue"]]);export{Ae as default};
